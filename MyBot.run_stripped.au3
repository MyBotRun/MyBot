#NoTrayIcon
#RequireAdmin
#pragma compile(ProductName, My Bot)
#pragma compile(Out, MyBot.run.exe) ; Required
#pragma compile(Icon, "Images\MyBot.ico")
#pragma compile(FileDescription, Clash of Clans Bot - A Free Clash of Clans bot - https://mybot.run)
#pragma compile(ProductVersion, 7.5.2)
#pragma compile(FileVersion, 7.5.2)
#pragma compile(LegalCopyright, © https://mybot.run)
#Au3Stripper_Off
#Au3Stripper_On
Global $g_sBotVersion = "v7.5.2"
Opt("MustDeclareVars", 1)
Global $g_sBotTitle = ""
Global $g_hFrmBot = 0
Global Const $WAIT_TIMEOUT = 258
Global Const $WS_OVERLAPPED = 0
Global Const $WS_MAXIMIZEBOX = 0x00010000
Global Const $WS_MINIMIZEBOX = 0x00020000
Global Const $WS_TABSTOP = 0x00010000
Global Const $WS_GROUP = 0x00020000
Global Const $WS_SIZEBOX = 0x00040000
Global Const $WS_THICKFRAME = $WS_SIZEBOX
Global Const $WS_SYSMENU = 0x00080000
Global Const $WS_HSCROLL = 0x00100000
Global Const $WS_VSCROLL = 0x00200000
Global Const $WS_DLGFRAME = 0x00400000
Global Const $WS_BORDER = 0x00800000
Global Const $WS_CAPTION = 0x00C00000
Global Const $WS_MAXIMIZE = 0x01000000
Global Const $WS_CLIPCHILDREN = 0x02000000
Global Const $WS_CLIPSIBLINGS = 0x04000000
Global Const $WS_DISABLED = 0x08000000
Global Const $WS_VISIBLE = 0x10000000
Global Const $WS_MINIMIZE = 0x20000000
Global Const $WS_CHILD = 0x40000000
Global Const $WS_POPUP = 0x80000000
Global Const $WS_POPUPWINDOW = 0x80880000
Global Const $DS_MODALFRAME = 0x0080
Global Const $WS_EX_APPWINDOW = 0x00040000
Global Const $WS_EX_CONTROLPARENT = 0x10000
Global Const $WS_EX_LAYERED = 0x00080000
Global Const $WS_EX_MDICHILD = 0x00000040
Global Const $WS_EX_NOACTIVATE = 0x08000000
Global Const $WS_EX_RIGHT = 0x00001000
Global Const $WS_EX_STATICEDGE = 0x00020000
Global Const $WS_EX_TOOLWINDOW = 0x00000080
Global Const $WS_EX_TOPMOST = 0x00000008
Global Const $WS_EX_TRANSPARENT = 0x00000020
Global Const $WS_EX_WINDOWEDGE = 0x00000100
Global Const $WM_MOVE = 0x0003
Global Const $WM_SETFOCUS = 0x0007
Global Const $WM_KILLFOCUS = 0x0008
Global Const $WM_SETREDRAW = 0x000B
Global Const $WM_CLOSE = 0x0010
Global Const $WM_ACTIVATEAPP = 0x001C
Global Const $WM_GETFONT = 0x0031
Global Const $WM_NOTIFY = 0x004E
Global Const $WM_SETICON = 0x0080
Global Const $WM_NCACTIVATE = 0x0086
Global Const $WM_KEYDOWN = 0x0100
Global Const $WM_KEYUP = 0x0101
Global Const $WM_SYSKEYDOWN = 0x0104
Global Const $WM_SYSKEYUP = 0x0105
Global Const $WM_COMMAND = 0x0111
Global Const $WM_SYSCOMMAND = 0x0112
Global Const $WM_MOUSEMOVE = 0x0200
Global Const $WM_LBUTTONDOWN = 0x0201
Global Const $WM_LBUTTONUP = 0x0202
Global Const $WM_RBUTTONDOWN = 0x0204
Global Const $WM_RBUTTONUP = 0x0205
Global Const $WM_MBUTTONDOWN = 0x0207
Global Const $WM_MOUSEWHEEL = 0x020A
Global Const $WM_MOUSEHWHEEL = 0x020E
Global Const $SM_CYCAPTION = 4
Global Const $SRCCOPY = 0x00CC0020
Global Const $RDW_ERASE = 0x0004
Global Const $RDW_INVALIDATE = 0x0001
Global Const $RDW_ALLCHILDREN = 0x0080
Global Const $STARTF_USESHOWWINDOW = 0x1
Global Const $STARTF_USESTDHANDLES = 0x100
Global Const $SD_SHUTDOWN = 1
Global Const $SD_REBOOT = 2
Global Const $SD_FORCE = 4
Global Const $SD_STANDBY = 32
Global Const $STDIN_CHILD = 1
Global Const $STDERR_MERGED = 8
Global Const $UBOUND_DIMENSIONS = 0
Global Const $UBOUND_ROWS = 1
Global Const $UBOUND_COLUMNS = 2
Global Const $HWND_BOTTOM = 1
Global Const $HWND_NOTOPMOST = -2
Global Const $HWND_TOP = 0
Global Const $HWND_TOPMOST = -1
Global Const $SWP_NOSIZE = 0x0001
Global Const $SWP_NOMOVE = 0x0002
Global Const $SWP_NOZORDER = 0x0004
Global Const $SWP_NOACTIVATE = 0x0010
Global Const $SWP_FRAMECHANGED = 0x0020
Global Const $SWP_SHOWWINDOW = 0x0040
Global Const $SWP_HIDEWINDOW = 0x0080
Global Const $SWP_NOOWNERZORDER = 0x0200
Global Const $SWP_NOREPOSITION = 0x0200
Global Const $SWP_NOSENDCHANGING = 0x0400
Global Const $ASSIGN_EXISTFAIL = 4
Global Const $DIR_REMOVE= 1
Global Const $FC_NOOVERWRITE = 0
Global Const $FC_OVERWRITE = 1
Global Const $FC_CREATEPATH = 8
Global Const $FT_MODIFIED = 0
Global Const $FT_CREATED = 1
Global Const $FT_STRING = 1
Global Const $FSF_NEWDIALOG = 2
Global Const $FO_READ = 0
Global Const $FO_APPEND = 1
Global Const $FO_OVERWRITE = 2
Global Const $FO_CREATEPATH = 8
Global Const $FO_BINARY = 16
Global Const $FO_UTF16_LE = 32
Global Const $FD_FILEMUSTEXIST = 1
Global Const $CREATE_NEW = 1
Global Const $CREATE_ALWAYS = 2
Global Const $OPEN_EXISTING = 3
Global Const $OPEN_ALWAYS = 4
Global Const $TRUNCATE_EXISTING = 5
Global Const $FILE_ATTRIBUTE_READONLY = 0x00000001
Global Const $FILE_ATTRIBUTE_HIDDEN = 0x00000002
Global Const $FILE_ATTRIBUTE_SYSTEM = 0x00000004
Global Const $FILE_ATTRIBUTE_ARCHIVE = 0x00000020
Global Const $FILE_SHARE_READ = 0x00000001
Global Const $FILE_SHARE_WRITE = 0x00000002
Global Const $FILE_SHARE_DELETE = 0x00000004
Global Const $GENERIC_EXECUTE = 0x20000000
Global Const $GENERIC_WRITE = 0x40000000
Global Const $GENERIC_READ = 0x80000000
Global Const $FV_FILEDESCRIPTION = "FileDescription"
Global Const $FLTA_FILESFOLDERS = 0
Global Const $FLTA_FILES = 1
Global Const $FLTA_FOLDERS = 2
Global Const $FLTAR_FILESFOLDERS = 0
Global Const $FLTAR_FILES = 1
Global Const $FLTAR_NORECUR = 0
Global Const $FLTAR_RECUR = 1
Global Const $FLTAR_NOSORT = 0
Global Const $FLTAR_SORT = 1
Global Const $FLTAR_NOPATH = 0
Global Const $FLTAR_RELPATH = 1
Global Const $MB_OK = 0
Global Const $MB_OKCANCEL = 1
Global Const $MB_ICONWARNING = 48
Global Const $MB_ICONINFORMATION = 64
Global Const $MB_APPLMODAL = 0
Global Const $MB_SYSTEMMODAL = 4096
Global Const $MB_TOPMOST = 0x00040000
Global Const $IDOK = 1
Global Const $SE_PRIVILEGE_ENABLED = 0x00000002
Global Enum $SECURITYANONYMOUS = 0, $SECURITYIDENTIFICATION, $SECURITYIMPERSONATION, $SECURITYDELEGATION
Global Const $TOKEN_QUERY = 0x00000008
Global Const $TOKEN_ADJUST_PRIVILEGES = 0x00000020
Func _WinAPI_GetLastError(Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
Local $aResult = DllCall("kernel32.dll", "dword", "GetLastError")
Return SetError($_iCurrentError, $_iCurrentExtended, $aResult[0])
EndFunc
Func _WinAPI_SetLastError($iErrorCode, Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
DllCall("kernel32.dll", "none", "SetLastError", "dword", $iErrorCode)
Return SetError($_iCurrentError, $_iCurrentExtended, Null)
EndFunc
Func _Security__AdjustTokenPrivileges($hToken, $bDisableAll, $tNewState, $iBufferLen, $tPrevState = 0, $pRequired = 0)
Local $aCall = DllCall("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $hToken, "bool", $bDisableAll, "struct*", $tNewState, "dword", $iBufferLen, "struct*", $tPrevState, "struct*", $pRequired)
If @error Then Return SetError(@error, @extended, False)
Return Not($aCall[0] = 0)
EndFunc
Func _Security__ImpersonateSelf($iLevel = $SECURITYIMPERSONATION)
Local $aCall = DllCall("advapi32.dll", "bool", "ImpersonateSelf", "int", $iLevel)
If @error Then Return SetError(@error, @extended, False)
Return Not($aCall[0] = 0)
EndFunc
Func _Security__LookupPrivilegeValue($sSystem, $sName)
Local $aCall = DllCall("advapi32.dll", "bool", "LookupPrivilegeValueW", "wstr", $sSystem, "wstr", $sName, "int64*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[3]
EndFunc
Func _Security__OpenThreadToken($iAccess, $hThread = 0, $bOpenAsSelf = False)
If $hThread = 0 Then
Local $aResult = DllCall("kernel32.dll", "handle", "GetCurrentThread")
If @error Then Return SetError(@error + 10, @extended, 0)
$hThread = $aResult[0]
EndIf
Local $aCall = DllCall("advapi32.dll", "bool", "OpenThreadToken", "handle", $hThread, "dword", $iAccess, "bool", $bOpenAsSelf, "handle*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[4]
EndFunc
Func _Security__OpenThreadTokenEx($iAccess, $hThread = 0, $bOpenAsSelf = False)
Local $hToken = _Security__OpenThreadToken($iAccess, $hThread, $bOpenAsSelf)
If $hToken = 0 Then
Local Const $ERROR_NO_TOKEN = 1008
If _WinAPI_GetLastError() <> $ERROR_NO_TOKEN Then Return SetError(20, _WinAPI_GetLastError(), 0)
If Not _Security__ImpersonateSelf() Then Return SetError(@error + 10, _WinAPI_GetLastError(), 0)
$hToken = _Security__OpenThreadToken($iAccess, $hThread, $bOpenAsSelf)
If $hToken = 0 Then Return SetError(@error, _WinAPI_GetLastError(), 0)
EndIf
Return $hToken
EndFunc
Func _Security__SetPrivilege($hToken, $sPrivilege, $bEnable)
Local $iLUID = _Security__LookupPrivilegeValue("", $sPrivilege)
If $iLUID = 0 Then Return SetError(@error + 10, @extended, False)
Local Const $tagTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
Local $tCurrState = DllStructCreate($tagTOKEN_PRIVILEGES)
Local $iCurrState = DllStructGetSize($tCurrState)
Local $tPrevState = DllStructCreate($tagTOKEN_PRIVILEGES)
Local $iPrevState = DllStructGetSize($tPrevState)
Local $tRequired = DllStructCreate("int Data")
DllStructSetData($tCurrState, "Count", 1)
DllStructSetData($tCurrState, "LUID", $iLUID)
If Not _Security__AdjustTokenPrivileges($hToken, False, $tCurrState, $iCurrState, $tPrevState, $tRequired) Then Return SetError(2, @error, False)
DllStructSetData($tPrevState, "Count", 1)
DllStructSetData($tPrevState, "LUID", $iLUID)
Local $iAttributes = DllStructGetData($tPrevState, "Attributes")
If $bEnable Then
$iAttributes = BitOR($iAttributes, $SE_PRIVILEGE_ENABLED)
Else
$iAttributes = BitAND($iAttributes, BitNOT($SE_PRIVILEGE_ENABLED))
EndIf
DllStructSetData($tPrevState, "Attributes", $iAttributes)
If Not _Security__AdjustTokenPrivileges($hToken, False, $tPrevState, $iPrevState, $tCurrState, $tRequired) Then Return SetError(3, @error, False)
Return True
EndFunc
Func _SendMessage($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iReturn = 0, $wParamType = "wparam", $lParamType = "lparam", $sReturnType = "lresult")
Local $aResult = DllCall("user32.dll", $sReturnType, "SendMessageW", "hwnd", $hWnd, "uint", $iMsg, $wParamType, $wParam, $lParamType, $lParam)
If @error Then Return SetError(@error, @extended, "")
If $iReturn >= 0 And $iReturn <= 4 Then Return $aResult[$iReturn]
Return $aResult
EndFunc
Global Const $STR_NOCASESENSE = 0
Global Const $STR_CASESENSE = 1
Global Const $STR_NOCASESENSEBASIC = 2
Global Const $STR_STRIPLEADING = 1
Global Const $STR_STRIPTRAILING = 2
Global Const $STR_STRIPSPACES = 4
Global Const $STR_STRIPALL = 8
Global Const $STR_CHRSPLIT = 0
Global Const $STR_ENTIRESPLIT = 1
Global Const $STR_NOCOUNT = 2
Global Const $STR_REGEXPMATCH = 0
Global Const $STR_REGEXPARRAYMATCH = 1
Global Const $STR_REGEXPARRAYGLOBALMATCH = 3
Global Const $STR_ENDISSTART = 0
Global Const $STR_ENDNOTSTART = 1
Global Const $tagPOINT = "struct;long X;long Y;endstruct"
Global Const $tagRECT = "struct;long Left;long Top;long Right;long Bottom;endstruct"
Global Const $tagSIZE = "struct;long X;long Y;endstruct"
Global Const $tagFILETIME = "struct;dword Lo;dword Hi;endstruct"
Global Const $tagSYSTEMTIME = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
Global Const $tagCOMBOBOXEXITEM = "uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;int SelectedImage;int OverlayImage;" & "int Indent;lparam Param"
Global Const $tagGDIPBITMAPDATA = "uint Width;uint Height;int Stride;int Format;ptr Scan0;uint_ptr Reserved"
Global Const $tagGDIPENCODERPARAM = "struct;byte GUID[16];ulong NumberOfValues;ulong Type;ptr Values;endstruct"
Global Const $tagGDIPENCODERPARAMS = "uint Count;" & $tagGDIPENCODERPARAM
Global Const $tagGDIPRECTF = "struct;float X;float Y;float Width;float Height;endstruct"
Global Const $tagGDIPSTARTUPINPUT = "uint Version;ptr Callback;bool NoThread;bool NoCodecs"
Global Const $tagGDIPIMAGECODECINFO = "byte CLSID[16];byte FormatID[16];ptr CodecName;ptr DllName;ptr FormatDesc;ptr FileExt;" & "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask"
Global Const $tagMENUITEMINFO = "uint Size;uint Mask;uint Type;uint State;uint ID;handle SubMenu;handle BmpChecked;handle BmpUnchecked;" & "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem"
Global Const $tagREBARBANDINFO = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" & "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" & "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" &((@OSVersion = "WIN_XP") ? "" : ";" & $tagRECT & ";uint uChevronState")
Global Const $tagBITMAPINFOHEADER = "struct;dword biSize;long biWidth;long biHeight;word biPlanes;word biBitCount;" & "dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;endstruct"
Global Const $tagBLENDFUNCTION = "byte Op;byte Flags;byte Alpha;byte Format"
Global Const $tagGUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
Global Const $tagWINDOWPOS = "hwnd hWnd;hwnd InsertAfter;int X;int Y;int CX;int CY;uint Flags"
Global Const $tagLOGFONT = "struct;long Height;long Width;long Escapement;long Orientation;long Weight;byte Italic;byte Underline;" & "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecision;byte Quality;byte PitchAndFamily;wchar FaceName[32];endstruct"
Global Const $tagPROCESS_INFORMATION = "handle hProcess;handle hThread;dword ProcessID;dword ThreadID"
Global Const $tagSTARTUPINFO = "dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;" & "dword YCountChars;dword FillAttribute;dword Flags;word ShowWindow;word Reserved2;ptr Reserved3;handle StdInput;" & "handle StdOutput;handle StdError"
Global Const $tagSECURITY_ATTRIBUTES = "dword Length;ptr Descriptor;bool InheritHandle"
Global Const $tagTEXTMETRIC = "long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;" & "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;" & "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;" & "byte tmPitchAndFamily;byte tmCharSet"
Global Const $HGDI_ERROR = Ptr(-1)
Global Const $INVALID_HANDLE_VALUE = Ptr(-1)
Global Const $DEFAULT_GUI_FONT = 17
Global Const $ULW_ALPHA = 0x02
Global Const $WH_CBT = 5
Global Const $KF_EXTENDED = 0x0100
Global Const $KF_ALTDOWN = 0x2000
Global Const $KF_UP = 0x8000
Global Const $LLKHF_EXTENDED = BitShift($KF_EXTENDED, 8)
Global Const $LLKHF_ALTDOWN = BitShift($KF_ALTDOWN, 8)
Global Const $LLKHF_UP = BitShift($KF_UP, 8)
Global Const $DI_MASK = 0x0001
Global Const $DI_IMAGE = 0x0002
Global Const $DI_NORMAL = 0x0003
Global Const $DI_COMPAT = 0x0004
Global Const $DI_DEFAULTSIZE = 0x0008
Global Const $DI_NOMIRROR = 0x0010
Global Const $GW_HWNDNEXT = 2
Global Const $GW_CHILD = 5
Global Const $GWL_WNDPROC = 0xFFFFFFFC
Global Const $GWL_HWNDPARENT = 0xFFFFFFF8
Global Const $GWL_STYLE = 0xFFFFFFF0
Global Const $GWL_EXSTYLE = 0xFFFFFFEC
Global Const $IMAGE_ICON = 1
Global Const $LOAD_LIBRARY_AS_DATAFILE = 0x02
Global Const $S_OK = 0x00000000
Global Const $LR_DEFAULTCOLOR = 0x0000
Global Const $LR_LOADFROMFILE = 0x0010
Global $__g_aInProcess_WinAPI[64][2] = [[0, 0]]
Global $__g_aWinList_WinAPI[64][2] = [[0, 0]]
Global Const $__WINAPICONSTANT_WM_SETFONT = 0x0030
Global Const $__WINAPICONSTANT_FW_NORMAL = 400
Global Const $__WINAPICONSTANT_DEFAULT_CHARSET = 1
Global Const $__WINAPICONSTANT_OUT_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_DEFAULT_QUALITY = 0
Global Const $tagCURSORINFO = "dword Size;dword Flags;handle hCursor;" & $tagPOINT
Global Const $tagICONINFO = "bool Icon;dword XHotSpot;dword YHotSpot;handle hMask;handle hColor"
Func _WinAPI_BitBlt($hDestDC, $iXDest, $iYDest, $iWidth, $iHeight, $hSrcDC, $iXSrc, $iYSrc, $iROP)
Local $aResult = DllCall("gdi32.dll", "bool", "BitBlt", "handle", $hDestDC, "int", $iXDest, "int", $iYDest, "int", $iWidth, "int", $iHeight, "handle", $hSrcDC, "int", $iXSrc, "int", $iYSrc, "dword", $iROP)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_CallNextHookEx($hHook, $iCode, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "lresult", "CallNextHookEx", "handle", $hHook, "int", $iCode, "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_CallWindowProc($pPrevWndFunc, $hWnd, $iMsg, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", $pPrevWndFunc, "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_ClientToScreen($hWnd, ByRef $tPoint)
Local $aRet = DllCall("user32.dll", "bool", "ClientToScreen", "hwnd", $hWnd, "struct*", $tPoint)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPoint
EndFunc
Func _WinAPI_CloseHandle($hObject)
Local $aResult = DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hObject)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_CopyIcon($hIcon)
Local $aResult = DllCall("user32.dll", "handle", "CopyIcon", "handle", $hIcon)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateCompatibleBitmap($hDC, $iWidth, $iHeight)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hDC, "int", $iWidth, "int", $iHeight)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateCompatibleDC($hDC)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateFile($sFileName, $iCreation, $iAccess = 4, $iShare = 0, $iAttributes = 0, $tSecurity = 0)
Local $iDA = 0, $iSM = 0, $iCD = 0, $iFA = 0
If BitAND($iAccess, 1) <> 0 Then $iDA = BitOR($iDA, $GENERIC_EXECUTE)
If BitAND($iAccess, 2) <> 0 Then $iDA = BitOR($iDA, $GENERIC_READ)
If BitAND($iAccess, 4) <> 0 Then $iDA = BitOR($iDA, $GENERIC_WRITE)
If BitAND($iShare, 1) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_DELETE)
If BitAND($iShare, 2) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_READ)
If BitAND($iShare, 4) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_WRITE)
Switch $iCreation
Case 0
$iCD = $CREATE_NEW
Case 1
$iCD = $CREATE_ALWAYS
Case 2
$iCD = $OPEN_EXISTING
Case 3
$iCD = $OPEN_ALWAYS
Case 4
$iCD = $TRUNCATE_EXISTING
EndSwitch
If BitAND($iAttributes, 1) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_ARCHIVE)
If BitAND($iAttributes, 2) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_HIDDEN)
If BitAND($iAttributes, 4) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_READONLY)
If BitAND($iAttributes, 8) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_SYSTEM)
Local $aResult = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sFileName, "dword", $iDA, "dword", $iSM, "struct*", $tSecurity, "dword", $iCD, "dword", $iFA, "ptr", 0)
If @error Or($aResult[0] = $INVALID_HANDLE_VALUE) Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateFont($iHeight, $iWidth, $iEscape = 0, $iOrientn = 0, $iWeight = $__WINAPICONSTANT_FW_NORMAL, $bItalic = False, $bUnderline = False, $bStrikeout = False, $iCharset = $__WINAPICONSTANT_DEFAULT_CHARSET, $iOutputPrec = $__WINAPICONSTANT_OUT_DEFAULT_PRECIS, $iClipPrec = $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS, $iQuality = $__WINAPICONSTANT_DEFAULT_QUALITY, $iPitch = 0, $sFace = 'Arial')
Local $aResult = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $iHeight, "int", $iWidth, "int", $iEscape, "int", $iOrientn, "int", $iWeight, "dword", $bItalic, "dword", $bUnderline, "dword", $bStrikeout, "dword", $iCharset, "dword", $iOutputPrec, "dword", $iClipPrec, "dword", $iQuality, "dword", $iPitch, "wstr", $sFace)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateFontIndirect($tLogFont)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateFontIndirectW", "struct*", $tLogFont)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateWindowEx($iExStyle, $sClass, $sName, $iStyle, $iX, $iY, $iWidth, $iHeight, $hParent, $hMenu = 0, $hInstance = 0, $pParam = 0)
If $hInstance = 0 Then $hInstance = _WinAPI_GetModuleHandle("")
Local $aResult = DllCall("user32.dll", "hwnd", "CreateWindowExW", "dword", $iExStyle, "wstr", $sClass, "wstr", $sName, "dword", $iStyle, "int", $iX, "int", $iY, "int", $iWidth, "int", $iHeight, "hwnd", $hParent, "handle", $hMenu, "handle", $hInstance, "struct*", $pParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_DeleteDC($hDC)
Local $aResult = DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DeleteObject($hObject)
Local $aResult = DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hObject)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DestroyIcon($hIcon)
Local $aResult = DllCall("user32.dll", "bool", "DestroyIcon", "handle", $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DestroyWindow($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "DestroyWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawIcon($hDC, $iX, $iY, $hIcon)
Local $aResult = DllCall("user32.dll", "bool", "DrawIcon", "handle", $hDC, "int", $iX, "int", $iY, "handle", $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawIconEx($hDC, $iX, $iY, $hIcon, $iWidth = 0, $iHeight = 0, $iStep = 0, $hBrush = 0, $iFlags = 3)
Local $iOptions
Switch $iFlags
Case 1
$iOptions = $DI_MASK
Case 2
$iOptions = $DI_IMAGE
Case 3
$iOptions = $DI_NORMAL
Case 4
$iOptions = $DI_COMPAT
Case 5
$iOptions = $DI_DEFAULTSIZE
Case Else
$iOptions = $DI_NOMIRROR
EndSwitch
Local $aResult = DllCall("user32.dll", "bool", "DrawIconEx", "handle", $hDC, "int", $iX, "int", $iY, "handle", $hIcon, "int", $iWidth, "int", $iHeight, "uint", $iStep, "handle", $hBrush, "uint", $iOptions)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_EnableWindow($hWnd, $bEnable = True)
Local $aResult = DllCall("user32.dll", "bool", "EnableWindow", "hwnd", $hWnd, "bool", $bEnable)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func __WinAPI_EnumWindowsAdd($hWnd, $sClass = "")
If $sClass = "" Then $sClass = _WinAPI_GetClassName($hWnd)
$__g_aWinList_WinAPI[0][0] += 1
Local $iCount = $__g_aWinList_WinAPI[0][0]
If $iCount >= $__g_aWinList_WinAPI[0][1] Then
ReDim $__g_aWinList_WinAPI[$iCount + 64][2]
$__g_aWinList_WinAPI[0][1] += 64
EndIf
$__g_aWinList_WinAPI[$iCount][0] = $hWnd
$__g_aWinList_WinAPI[$iCount][1] = $sClass
EndFunc
Func __WinAPI_EnumWindowsInit()
ReDim $__g_aWinList_WinAPI[64][2]
$__g_aWinList_WinAPI[0][0] = 0
$__g_aWinList_WinAPI[0][1] = 64
EndFunc
Func _WinAPI_EnumWindowsTop()
__WinAPI_EnumWindowsInit()
Local $hWnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $GW_CHILD)
While $hWnd <> 0
If _WinAPI_IsWindowVisible($hWnd) Then __WinAPI_EnumWindowsAdd($hWnd)
$hWnd = _WinAPI_GetWindow($hWnd, $GW_HWNDNEXT)
WEnd
Return $__g_aWinList_WinAPI
EndFunc
Func _WinAPI_ExtractIconEx($sFilePath, $iIndex, $paLarge, $paSmall, $iIcons)
Local $aResult = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sFilePath, "int", $iIndex, "struct*", $paLarge, "struct*", $paSmall, "uint", $iIcons)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_FatalAppExit($sMessage)
DllCall("kernel32.dll", "none", "FatalAppExitW", "uint", 0, "wstr", $sMessage)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _WinAPI_FindWindow($sClassName, $sWindowName)
Local $aResult = DllCall("user32.dll", "hwnd", "FindWindowW", "wstr", $sClassName, "wstr", $sWindowName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_FreeLibrary($hModule)
Local $aResult = DllCall("kernel32.dll", "bool", "FreeLibrary", "handle", $hModule)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_GetAncestor($hWnd, $iFlags = 1)
Local $aResult = DllCall("user32.dll", "hwnd", "GetAncestor", "hwnd", $hWnd, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetClassName($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aResult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hWnd, "wstr", "", "int", 4096)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, '')
Return SetExtended($aResult[0], $aResult[2])
EndFunc
Func _WinAPI_GetClientHeight($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top")
EndFunc
Func _WinAPI_GetClientWidth($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
EndFunc
Func _WinAPI_GetClientRect($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hWnd, "struct*", $tRECT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetCurrentProcess()
Local $aResult = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCurrentThreadId()
Local $aResult = DllCall("kernel32.dll", "dword", "GetCurrentThreadId")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCursorInfo()
Local $tCursor = DllStructCreate($tagCURSORINFO)
Local $iCursor = DllStructGetSize($tCursor)
DllStructSetData($tCursor, "Size", $iCursor)
Local $aRet = DllCall("user32.dll", "bool", "GetCursorInfo", "struct*", $tCursor)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aCursor[5]
$aCursor[0] = True
$aCursor[1] = DllStructGetData($tCursor, "Flags") <> 0
$aCursor[2] = DllStructGetData($tCursor, "hCursor")
$aCursor[3] = DllStructGetData($tCursor, "X")
$aCursor[4] = DllStructGetData($tCursor, "Y")
Return $aCursor
EndFunc
Func _WinAPI_GetDC($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDesktopWindow()
Local $aResult = DllCall("user32.dll", "hwnd", "GetDesktopWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDeviceCaps($hDC, $iIndex)
Local $aResult = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDlgCtrlID($hWnd)
Local $aResult = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetFileSizeEx($hFile)
Local $aResult = DllCall("kernel32.dll", "bool", "GetFileSizeEx", "handle", $hFile, "int64*", 0)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, -1)
Return $aResult[2]
EndFunc
Func _WinAPI_GetFocus()
Local $aResult = DllCall("user32.dll", "hwnd", "GetFocus")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetForegroundWindow()
Local $aResult = DllCall("user32.dll", "hwnd", "GetForegroundWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetGuiResources($iFlag = 0, $hProcess = -1)
If $hProcess = -1 Then $hProcess = _WinAPI_GetCurrentProcess()
Local $aResult = DllCall("user32.dll", "dword", "GetGuiResources", "handle", $hProcess, "dword", $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetIconInfo($hIcon)
Local $tInfo = DllStructCreate($tagICONINFO)
Local $aRet = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hIcon, "struct*", $tInfo)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aIcon[6]
$aIcon[0] = True
$aIcon[1] = DllStructGetData($tInfo, "Icon") <> 0
$aIcon[2] = DllStructGetData($tInfo, "XHotSpot")
$aIcon[3] = DllStructGetData($tInfo, "YHotSpot")
$aIcon[4] = DllStructGetData($tInfo, "hMask")
$aIcon[5] = DllStructGetData($tInfo, "hColor")
Return $aIcon
EndFunc
Func _WinAPI_GetModuleHandle($sModuleName)
Local $sModuleNameType = "wstr"
If $sModuleName = "" Then
$sModuleName = 0
$sModuleNameType = "ptr"
EndIf
Local $aResult = DllCall("kernel32.dll", "handle", "GetModuleHandleW", $sModuleNameType, $sModuleName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetObject($hObject, $iSize, $pObject)
Local $aResult = DllCall("gdi32.dll", "int", "GetObjectW", "handle", $hObject, "int", $iSize, "struct*", $pObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetParent($hWnd)
Local $aResult = DllCall("user32.dll", "hwnd", "GetParent", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetStockObject($iObject)
Local $aResult = DllCall("gdi32.dll", "handle", "GetStockObject", "int", $iObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetStdHandle($iStdHandle)
If $iStdHandle < 0 Or $iStdHandle > 2 Then Return SetError(2, 0, -1)
Local Const $aHandle[3] = [-10, -11, -12]
Local $aResult = DllCall("kernel32.dll", "handle", "GetStdHandle", "dword", $aHandle[$iStdHandle])
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_GetSystemMetrics($iIndex)
Local $aResult = DllCall("user32.dll", "int", "GetSystemMetrics", "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindow($hWnd, $iCmd)
Local $aResult = DllCall("user32.dll", "hwnd", "GetWindow", "hwnd", $hWnd, "uint", $iCmd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowDC($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetWindowDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowLong($hWnd, $iIndex)
Local $sFuncName = "GetWindowLongW"
If @AutoItX64 Then $sFuncName = "GetWindowLongPtrW"
Local $aResult = DllCall("user32.dll", "long_ptr", $sFuncName, "hwnd", $hWnd, "int", $iIndex)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowThreadProcessId($hWnd, ByRef $iPID)
Local $aResult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
If @error Then Return SetError(@error, @extended, 0)
$iPID = $aResult[2]
Return $aResult[0]
EndFunc
Func _WinAPI_GetXYFromPoint(ByRef $tPoint, ByRef $iX, ByRef $iY)
$iX = DllStructGetData($tPoint, "X")
$iY = DllStructGetData($tPoint, "Y")
EndFunc
Func _WinAPI_GUIDFromString($sGUID)
Local $tGUID = DllStructCreate($tagGUID)
_WinAPI_GUIDFromStringEx($sGUID, $tGUID)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $tGUID
EndFunc
Func _WinAPI_GUIDFromStringEx($sGUID, $tGUID)
Local $aResult = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sGUID, "struct*", $tGUID)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_HiWord($iLong)
Return BitShift($iLong, 16)
EndFunc
Func _WinAPI_InProcess($hWnd, ByRef $hLastWnd)
If $hWnd = $hLastWnd Then Return True
For $iI = $__g_aInProcess_WinAPI[0][0] To 1 Step -1
If $hWnd = $__g_aInProcess_WinAPI[$iI][0] Then
If $__g_aInProcess_WinAPI[$iI][1] Then
$hLastWnd = $hWnd
Return True
Else
Return False
EndIf
EndIf
Next
Local $iPID
_WinAPI_GetWindowThreadProcessId($hWnd, $iPID)
Local $iCount = $__g_aInProcess_WinAPI[0][0] + 1
If $iCount >= 64 Then $iCount = 1
$__g_aInProcess_WinAPI[0][0] = $iCount
$__g_aInProcess_WinAPI[$iCount][0] = $hWnd
$__g_aInProcess_WinAPI[$iCount][1] =($iPID = @AutoItPID)
Return $__g_aInProcess_WinAPI[$iCount][1]
EndFunc
Func _WinAPI_IsClassName($hWnd, $sClassName)
Local $sSeparator = Opt("GUIDataSeparatorChar")
Local $aClassName = StringSplit($sClassName, $sSeparator)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sClassCheck = _WinAPI_GetClassName($hWnd)
For $x = 1 To UBound($aClassName) - 1
If StringUpper(StringMid($sClassCheck, 1, StringLen($aClassName[$x]))) = StringUpper($aClassName[$x]) Then Return True
Next
Return False
EndFunc
Func _WinAPI_IsWindowVisible($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_InvalidateRect($hWnd, $tRECT = 0, $bErase = True)
Local $aResult = DllCall("user32.dll", "bool", "InvalidateRect", "hwnd", $hWnd, "struct*", $tRECT, "bool", $bErase)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadImage($hInstance, $sImage, $iType, $iXDesired, $iYDesired, $iLoad)
Local $aResult, $sImageType = "int"
If IsString($sImage) Then $sImageType = "wstr"
$aResult = DllCall("user32.dll", "handle", "LoadImageW", "handle", $hInstance, $sImageType, $sImage, "uint", $iType, "int", $iXDesired, "int", $iYDesired, "uint", $iLoad)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadLibraryEx($sFileName, $iFlags = 0)
Local $aResult = DllCall("kernel32.dll", "handle", "LoadLibraryExW", "wstr", $sFileName, "ptr", 0, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoWord($iLong)
Return BitAND($iLong, 0xFFFF)
EndFunc
Func _WinAPI_MakeLong($iLo, $iHi)
Return BitOR(BitShift($iHi, -16), BitAND($iLo, 0xFFFF))
EndFunc
Func _WinAPI_OpenProcess($iAccess, $bInherit, $iPID, $bDebugPriv = False)
Local $aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return $aResult[0]
If Not $bDebugPriv Then Return SetError(100, 0, 0)
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 10, @extended, 0)
_Security__SetPrivilege($hToken, "SeDebugPrivilege", True)
Local $iError = @error
Local $iExtended = @extended
Local $iRet = 0
If Not @error Then
$aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
$iError = @error
$iExtended = @extended
If $aResult[0] Then $iRet = $aResult[0]
_Security__SetPrivilege($hToken, "SeDebugPrivilege", False)
If @error Then
$iError = @error + 20
$iExtended = @extended
EndIf
Else
$iError = @error + 30
EndIf
_WinAPI_CloseHandle($hToken)
Return SetError($iError, $iExtended, $iRet)
EndFunc
Func _WinAPI_PointFromRect(ByRef $tRECT, $bCenter = True)
Local $iX1 = DllStructGetData($tRECT, "Left")
Local $iY1 = DllStructGetData($tRECT, "Top")
Local $iX2 = DllStructGetData($tRECT, "Right")
Local $iY2 = DllStructGetData($tRECT, "Bottom")
If $bCenter Then
$iX1 = $iX1 +(($iX2 - $iX1) / 2)
$iY1 = $iY1 +(($iY2 - $iY1) / 2)
EndIf
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $iX1)
DllStructSetData($tPoint, "Y", $iY1)
Return $tPoint
EndFunc
Func _WinAPI_PostMessage($hWnd, $iMsg, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "bool", "PostMessage", "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ReadFile($hFile, $pBuffer, $iToRead, ByRef $iRead, $tOverlapped = 0)
Local $aResult = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hFile, "struct*", $pBuffer, "dword", $iToRead, "dword*", 0, "struct*", $tOverlapped)
If @error Then Return SetError(@error, @extended, False)
$iRead = $aResult[4]
Return $aResult[0]
EndFunc
Func _WinAPI_RedrawWindow($hWnd, $tRECT = 0, $hRegion = 0, $iFlags = 5)
Local $aResult = DllCall("user32.dll", "bool", "RedrawWindow", "hwnd", $hWnd, "struct*", $tRECT, "handle", $hRegion, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_RegisterWindowMessage($sMessage)
Local $aResult = DllCall("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $sMessage)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_ReleaseDC($hWnd, $hDC)
Local $aResult = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SelectObject($hDC, $hGDIObj)
Local $aResult = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hGDIObj)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFilePointer($hFile, $iPos, $iMethod = 0)
Local $aResult = DllCall("kernel32.dll", "INT", "SetFilePointer", "handle", $hFile, "long", $iPos, "ptr", 0, "long", $iMethod)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFocus($hWnd)
Local $aResult = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFont($hWnd, $hFont, $bRedraw = True)
_SendMessage($hWnd, $__WINAPICONSTANT_WM_SETFONT, $hFont, $bRedraw, 0, "hwnd")
EndFunc
Func _WinAPI_SetHandleInformation($hObject, $iMask, $iFlags)
Local $aResult = DllCall("kernel32.dll", "bool", "SetHandleInformation", "handle", $hObject, "dword", $iMask, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetParent($hWndChild, $hWndParent)
Local $aResult = DllCall("user32.dll", "hwnd", "SetParent", "hwnd", $hWndChild, "hwnd", $hWndParent)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetProcessAffinityMask($hProcess, $iMask)
Local $aResult = DllCall("kernel32.dll", "bool", "SetProcessAffinityMask", "handle", $hProcess, "ulong_ptr", $iMask)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowLong($hWnd, $iIndex, $iValue)
_WinAPI_SetLastError(0)
Local $sFuncName = "SetWindowLongW"
If @AutoItX64 Then $sFuncName = "SetWindowLongPtrW"
Local $aResult = DllCall("user32.dll", "long_ptr", $sFuncName, "hwnd", $hWnd, "int", $iIndex, "long_ptr", $iValue)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowPos($hWnd, $hAfter, $iX, $iY, $iCX, $iCY, $iFlags)
Local $aResult = DllCall("user32.dll", "bool", "SetWindowPos", "hwnd", $hWnd, "hwnd", $hAfter, "int", $iX, "int", $iY, "int", $iCX, "int", $iCY, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowsHookEx($iHook, $pProc, $hDll, $iThreadId = 0)
Local $aResult = DllCall("user32.dll", "handle", "SetWindowsHookEx", "int", $iHook, "ptr", $pProc, "handle", $hDll, "dword", $iThreadId)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowText($hWnd, $sText)
Local $aResult = DllCall("user32.dll", "bool", "SetWindowTextW", "hwnd", $hWnd, "wstr", $sText)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ShowWindow($hWnd, $iCmdShow = 5)
Local $aResult = DllCall("user32.dll", "bool", "ShowWindow", "hwnd", $hWnd, "int", $iCmdShow)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_StringFromGUID($tGUID)
Local $aResult = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tGUID, "wstr", "", "int", 40)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, "")
Return SetExtended($aResult[0], $aResult[2])
EndFunc
Func _WinAPI_UnhookWindowsHookEx($hHook)
Local $aResult = DllCall("user32.dll", "bool", "UnhookWindowsHookEx", "handle", $hHook)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_UpdateLayeredWindow($hWnd, $hDestDC, $tPTDest, $tSize, $hSrcDC, $tPTSrce, $iRGB, $tBlend, $iFlags)
Local $aResult = DllCall("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $hWnd, "handle", $hDestDC, "struct*", $tPTDest, "struct*", $tSize, "handle", $hSrcDC, "struct*", $tPTSrce, "dword", $iRGB, "struct*", $tBlend, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_UpdateWindow($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "UpdateWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_WaitForSingleObject($hHandle, $iTimeout = -1)
Local $aResult = DllCall("kernel32.dll", "INT", "WaitForSingleObject", "handle", $hHandle, "dword", $iTimeout)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_WideCharToMultiByte($vUnicode, $iCodePage = 0, $bRetString = True)
Local $sUnicodeType = "wstr"
If Not IsString($vUnicode) Then $sUnicodeType = "struct*"
Local $aResult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $iCodePage, "dword", 0, $sUnicodeType, $vUnicode, "int", -1, "ptr", 0, "int", 0, "ptr", 0, "ptr", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 20, @extended, "")
Local $tMultiByte = DllStructCreate("char[" & $aResult[0] & "]")
$aResult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $iCodePage, "dword", 0, $sUnicodeType, $vUnicode, "int", -1, "struct*", $tMultiByte, "int", $aResult[0], "ptr", 0, "ptr", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, "")
If $bRetString Then Return DllStructGetData($tMultiByte, 1)
Return $tMultiByte
EndFunc
Func _WinAPI_WriteFile($hFile, $pBuffer, $iToWrite, ByRef $iWritten, $tOverlapped = 0)
Local $aResult = DllCall("kernel32.dll", "bool", "WriteFile", "handle", $hFile, "struct*", $pBuffer, "dword", $iToWrite, "dword*", 0, "struct*", $tOverlapped)
If @error Then Return SetError(@error, @extended, False)
$iWritten = $aResult[4]
Return $aResult[0]
EndFunc
Global Const $HANDLE_FLAG_INHERIT = 0x00000001
Global Const $MAPVK_VK_TO_CHAR = 2
Global Const $HSHELL_WINDOWACTIVATED = 4
Global $__g_vEnum, $__g_vExt = 0
Global $__g_hHeap = 0, $__g_iRGBMode = 1
Global Const $tagOSVERSIONINFO = 'struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct'
Global Const $__WINVER = __WINVER()
Func _WinAPI_CreatePoint($iX, $iY)
Local $tPOINT = DllStructCreate($tagPOINT)
DllStructSetData($tPOINT, 1, $iX)
DllStructSetData($tPOINT, 2, $iY)
Return $tPOINT
EndFunc
Func _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, $iLeft)
DllStructSetData($tRECT, 2, $iTop)
DllStructSetData($tRECT, 3, $iRight)
DllStructSetData($tRECT, 4, $iBottom)
Return $tRECT
EndFunc
Func _WinAPI_CreateRectEx($iX, $iY, $iWidth, $iHeight)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, $iX)
DllStructSetData($tRECT, 2, $iY)
DllStructSetData($tRECT, 3, $iX + $iWidth)
DllStructSetData($tRECT, 4, $iY + $iHeight)
Return $tRECT
EndFunc
Func _WinAPI_CreateSize($iWidth, $iHeight)
Local $tSIZE = DllStructCreate($tagSIZE)
DllStructSetData($tSIZE, 1, $iWidth)
DllStructSetData($tSIZE, 2, $iHeight)
Return $tSIZE
EndFunc
Func _WinAPI_FatalExit($iCode)
DllCall('kernel32.dll', 'none', 'FatalExit', 'int', $iCode)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _WinAPI_GetBitmapDimension($hBitmap)
Local Const $tagBITMAP = 'struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct'
Local $tObj = DllStructCreate($tagBITMAP)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return _WinAPI_CreateSize(DllStructGetData($tObj, 'bmWidth'), DllStructGetData($tObj, 'bmHeight'))
EndFunc
Func _WinAPI_IsBadReadPtr($pAddress, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadReadPtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsBadWritePtr($pAddress, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadWritePtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MoveMemory($pDestination, $pSource, $iLength)
If _WinAPI_IsBadReadPtr($pSource, $iLength) Then Return SetError(10, @extended, 0)
If _WinAPI_IsBadWritePtr($pDestination, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlMoveMemory', 'struct*', $pDestination, 'struct*', $pSource, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_StrLen($pString, $bUnicode = True)
Local $W = ''
If $bUnicode Then $W = 'W'
Local $aRet = DllCall('kernel32.dll', 'int', 'lstrlen' & $W, 'struct*', $pString)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SwitchColor($iColor)
If $iColor = -1 Then Return $iColor
Return BitOR(BitAND($iColor, 0x00FF00), BitShift(BitAND($iColor, 0x0000FF), -16), BitShift(BitAND($iColor, 0xFF0000), 16))
EndFunc
Func _WinAPI_ZeroMemory($pMemory, $iLength)
If _WinAPI_IsBadWritePtr($pMemory, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlZeroMemory', 'struct*', $pMemory, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func __CheckErrorArrayBounds(Const ByRef $aData, ByRef $iStart, ByRef $iEnd, $nDim = 1, $iDim = $UBOUND_DIMENSIONS)
If Not IsArray($aData) Then Return SetError(1, 0, 1)
If UBound($aData, $iDim) <> $nDim Then Return SetError(2, 0, 1)
If $iStart < 0 Then $iStart = 0
Local $iUBound = UBound($aData) - 1
If $iEnd < 1 Or $iEnd > $iUBound Then $iEnd = $iUBound
If $iStart > $iEnd Then Return SetError(4, 0, 1)
Return 0
EndFunc
Func __CheckErrorCloseHandle($aRet, $hFile, $bLastError = 0, $iCurErr = @error, $iCurExt = @extended)
If Not $iCurErr And Not $aRet[0] Then $iCurErr = 10
Local $iLastError = _WinAPI_GetLastError()
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
If $iCurErr Then _WinAPI_SetLastError($iLastError)
If $bLastError Then $iCurExt = $iLastError
Return SetError($iCurErr, $iCurExt, $iCurErr)
EndFunc
Func __EnumWindowsProc($hWnd, $bVisible)
Local $aResult
If $bVisible Then
$aResult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hWnd)
If Not $aResult[0] Then
Return 1
EndIf
EndIf
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = $hWnd
$aResult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hWnd, "wstr", "", "int", 4096)
$__g_vEnum[$__g_vEnum[0][0]][1] = $aResult[2]
Return 1
EndFunc
Func __FatalExit($iCode, $sText = '')
If $sText Then MsgBox($MB_SYSTEMMODAL, 'AutoIt', $sText)
_WinAPI_FatalExit($iCode)
EndFunc
Func __HeapAlloc($iSize, $bAbort = False)
Local $aRet
If Not $__g_hHeap Then
$aRet = DllCall('kernel32.dll', 'handle', 'HeapCreate', 'dword', 0, 'ulong_ptr', 0, 'ulong_ptr', 0)
If @error Or Not $aRet[0] Then __FatalExit(1, 'Error allocating memory.')
$__g_hHeap = $aRet[0]
EndIf
$aRet = DllCall('kernel32.dll', 'ptr', 'HeapAlloc', 'handle', $__g_hHeap, 'dword', 0x00000008, 'ulong_ptr', $iSize)
If @error Or Not $aRet[0] Then
If $bAbort Then __FatalExit(1, 'Error allocating memory.')
Return SetError(@error + 30, @extended, 0)
EndIf
Return $aRet[0]
EndFunc
Func __HeapReAlloc($pMemory, $iSize, $bAmount = False, $bAbort = False)
Local $aRet, $pRet
If __HeapValidate($pMemory) Then
If $bAmount And(__HeapSize($pMemory) >= $iSize) Then Return SetExtended(1, Ptr($pMemory))
$aRet = DllCall('kernel32.dll', 'ptr', 'HeapReAlloc', 'handle', $__g_hHeap, 'dword', 0x00000008, 'ptr', $pMemory, 'ulong_ptr', $iSize)
If @error Or Not $aRet[0] Then
If $bAbort Then __FatalExit(1, 'Error allocating memory.')
Return SetError(@error + 20, @extended, Ptr($pMemory))
EndIf
$pRet = $aRet[0]
Else
$pRet = __HeapAlloc($iSize, $bAbort)
If @error Then Return SetError(@error, @extended, 0)
EndIf
Return $pRet
EndFunc
Func __HeapSize($pMemory, $bCheck = False)
If $bCheck And(Not __HeapValidate($pMemory)) Then Return SetError(@error, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'ulong_ptr', 'HeapSize', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Or($aRet[0] = Ptr(-1)) Then Return SetError(@error + 50, @extended, 0)
Return $aRet[0]
EndFunc
Func __HeapValidate($pMemory)
If(Not $__g_hHeap) Or(Not Ptr($pMemory)) Then Return SetError(9, 0, False)
Local $aRet = DllCall('kernel32.dll', 'int', 'HeapValidate', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func __Inc(ByRef $aData, $iIncrement = 100)
Select
Case UBound($aData, $UBOUND_COLUMNS)
If $iIncrement < 0 Then
ReDim $aData[$aData[0][0] + 1][UBound($aData, $UBOUND_COLUMNS)]
Else
$aData[0][0] += 1
If $aData[0][0] > UBound($aData) - 1 Then
ReDim $aData[$aData[0][0] + $iIncrement][UBound($aData, $UBOUND_COLUMNS)]
EndIf
EndIf
Case UBound($aData, $UBOUND_ROWS)
If $iIncrement < 0 Then
ReDim $aData[$aData[0] + 1]
Else
$aData[0] += 1
If $aData[0] > UBound($aData) - 1 Then
ReDim $aData[$aData[0] + $iIncrement]
EndIf
EndIf
Case Else
Return 0
EndSelect
Return 1
EndFunc
Func __Iif($bTest, $vTrue, $vFalse)
Return $bTest ? $vTrue : $vFalse
EndFunc
Func __Init($dData)
Local $iLength = BinaryLen($dData)
Local $aRet = DllCall('kernel32.dll', 'ptr', 'VirtualAlloc', 'ptr', 0, 'ulong_ptr', $iLength, 'dword', 0x00001000, 'dword', 0x00000040)
If @error Or Not $aRet[0] Then __FatalExit(1, 'Error allocating memory.')
Local $tData = DllStructCreate('byte[' & $iLength & "]", $aRet[0])
DllStructSetData($tData, 1, $dData)
Return $aRet[0]
EndFunc
Func __RGB($iColor)
If $__g_iRGBMode Then
$iColor = _WinAPI_SwitchColor($iColor)
EndIf
Return $iColor
EndFunc
Func __WINVER()
Local $tOSVI = DllStructCreate($tagOSVERSIONINFO)
DllStructSetData($tOSVI, 1, DllStructGetSize($tOSVI))
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetVersionExW', 'struct*', $tOSVI)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return BitOR(BitShift(DllStructGetData($tOSVI, 2), -8), DllStructGetData($tOSVI, 3))
EndFunc
Func _WinAPI_DeregisterShellHookWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'DeregisterShellHookWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_GetActiveWindow()
Local $aRet = DllCall('user32.dll', 'hwnd', 'GetActiveWindow')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetVersion()
Return BitAND(BitShift($__WINVER, 8), 0xFF) & '.' & BitAND($__WINVER, 0xFF)
EndFunc
Func _WinAPI_IsIconic($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsIconic', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MapVirtualKey($iCode, $iType, $hLocale = 0)
Local $aRet = DllCall('user32.dll', 'INT', 'MapVirtualKeyExW', 'uint', $iCode, 'uint', $iType, 'uint_ptr', $hLocale)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_QueryPerformanceCounter()
Local $aRet = DllCall('kernel32.dll', 'bool', 'QueryPerformanceCounter', 'int64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[1]
EndFunc
Func _WinAPI_QueryPerformanceFrequency()
Local $aRet = DllCall('kernel32.dll', 'bool', 'QueryPerformanceFrequency', 'int64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[1]
EndFunc
Func _WinAPI_RegisterShellHookWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'RegisterShellHookWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func __EnumDefaultProc($pData, $lParam)
#forceref $lParam
Local $iLength = _WinAPI_StrLen($pData)
__Inc($__g_vEnum)
If $iLength Then
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' &($iLength + 1) & ']', $pData), 1)
Else
$__g_vEnum[$__g_vEnum[0]] = ''
EndIf
Return 1
EndFunc
Func __EnumPageFilesProc($iSize, $pInfo, $pFile)
Local $tEPFI = DllStructCreate('dword;dword;ulong_ptr;ulong_ptr;ulong_ptr', $pInfo)
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = DllStructGetData(DllStructCreate('wchar[' &(_WinAPI_StrLen($pFile) + 1) & ']', $pFile), 1)
For $i = 1 To 3
$__g_vEnum[$__g_vEnum[0][0]][$i] = DllStructGetData($tEPFI, $i + 2) * $iSize
Next
Return 1
EndFunc
Global Const $PROCESS_VM_OPERATION = 0x00000008
Global Const $PROCESS_VM_READ = 0x00000010
Global Const $PROCESS_VM_WRITE = 0x00000020
Global Const $PROCESS_QUERY_INFORMATION = 0x00000400
Global Const $PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
Global Const $PROCESS_ALL_ACCESS = 0x001F0FFF
Func _Max($iNum1, $iNum2)
If Not IsNumber($iNum1) Then Return SetError(1, 0, 0)
If Not IsNumber($iNum2) Then Return SetError(2, 0, 0)
Return($iNum1 > $iNum2) ? $iNum1 : $iNum2
EndFunc
Func _Min($iNum1, $iNum2)
If Not IsNumber($iNum1) Then Return SetError(1, 0, 0)
If Not IsNumber($iNum2) Then Return SetError(2, 0, 0)
Return($iNum1 > $iNum2) ? $iNum2 : $iNum1
EndFunc
Global Const $BS_DEFPUSHBUTTON = 0x0001
Global Const $BS_MULTILINE = 0x2000
Global Const $BS_PUSHLIKE = 0x1000
Global Const $BS_VCENTER = 0x0C00
Global Const $BS_ICON = 0x0040
Global Const $BCM_FIRST = 0x1600
Global Const $BCM_SETIMAGELIST =($BCM_FIRST + 0x0002)
Global Const $CB_ERR = -1
Global Const $CBS_AUTOHSCROLL = 0x40
Global Const $CBS_DROPDOWN = 0x2
Global Const $CBS_DROPDOWNLIST = 0x3
Global Const $CB_FINDSTRINGEXACT = 0x158
Global Const $CB_GETCOUNT = 0x146
Global Const $CB_GETCURSEL = 0x147
Global Const $CB_GETLBTEXT = 0x148
Global Const $CB_GETLBTEXTLEN = 0x149
Global Const $CB_RESETCONTENT = 0x14B
Global Const $CB_SELECTSTRING = 0x14D
Global Const $CB_SETCURSEL = 0x14E
Global Const $CBN_SELCHANGE = 1
Global Const $__COMBOBOXCONSTANT_WM_USER = 0X400
Global Const $CBEM_GETCOMBOCONTROL =($__COMBOBOXCONSTANT_WM_USER + 6)
Global Const $CBEM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $CBEM_INSERTITEMA =($__COMBOBOXCONSTANT_WM_USER + 1)
Global Const $CBEM_INSERTITEMW =($__COMBOBOXCONSTANT_WM_USER + 11)
Global Const $CBEM_SETIMAGELIST =($__COMBOBOXCONSTANT_WM_USER + 2)
Global Const $CBEIF_DI_SETITEM = 0x10000000
Global Const $CBEIF_IMAGE = 0x2
Global Const $CBEIF_INDENT = 0x10
Global Const $CBEIF_LPARAM = 0x20
Global Const $CBEIF_OVERLAY = 0x8
Global Const $CBEIF_SELECTEDIMAGE = 0x4
Global Const $CBEIF_TEXT = 0x1
Global Const $ES_LEFT = 0
Global Const $ES_CENTER = 1
Global Const $ES_MULTILINE = 4
Global Const $ES_UPPERCASE = 8
Global Const $ES_AUTOVSCROLL = 64
Global Const $ES_AUTOHSCROLL = 128
Global Const $ES_READONLY = 2048
Global Const $ES_WANTRETURN = 4096
Global Const $ES_NUMBER = 8192
Global Const $EM_REPLACESEL = 0xC2
Global Const $EM_SETREADONLY = 0xCF
Global Const $EM_SETSEL = 0xB1
Global Const $GUI_SS_DEFAULT_EDIT = 0x003010c0
Global Const $GUI_SS_DEFAULT_INPUT = 0x00000080
Global Const $GUI_EVENT_CLOSE = -3
Global Const $GUI_EVENT_MINIMIZE = -4
Global Const $GUI_EVENT_RESTORE = -5
Global Const $GUI_EVENT_PRIMARYDOWN = -7
Global Const $GUI_RUNDEFMSG = 'GUI_RUNDEFMSG'
Global Const $GUI_CHECKED = 1
Global Const $GUI_UNCHECKED = 4
Global Const $GUI_SHOW = 16
Global Const $GUI_HIDE = 32
Global Const $GUI_ENABLE = 64
Global Const $GUI_DISABLE = 128
Global Const $GUI_FOCUS = 256
Global Const $GUI_FONTNORMAL = 0
Global Const $GUI_FONTUNDER = 4
Global Const $GUI_DOCKLEFT = 0x0002
Global Const $GUI_DOCKBOTTOM = 0x0040
Global Const $GUI_DOCKWIDTH = 0x0100
Global Const $GUI_DOCKHEIGHT = 0x0200
Global Const $GUI_DOCKALL = 0x0322
Global Const $GUI_DOCKBORDERS = 0x0066
Global Const $GUI_BKCOLOR_TRANSPARENT = -2
Global Const $_UDF_GlobalIDs_OFFSET = 2
Global Const $_UDF_GlobalID_MAX_WIN = 16
Global Const $_UDF_STARTID = 10000
Global Const $_UDF_GlobalID_MAX_IDS = 55535
Global Const $__UDFGUICONSTANT_WS_TABSTOP = 0x00010000
Global Const $__UDFGUICONSTANT_WS_VISIBLE = 0x10000000
Global Const $__UDFGUICONSTANT_WS_CHILD = 0x40000000
Global $__g_aUDF_GlobalIDs_Used[$_UDF_GlobalID_MAX_WIN][$_UDF_GlobalID_MAX_IDS + $_UDF_GlobalIDs_OFFSET + 1]
Func __UDF_GetNextGlobalID($hWnd)
Local $nCtrlID, $iUsedIndex = -1, $bAllUsed = True
If Not WinExists($hWnd) Then Return SetError(-1, -1, 0)
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] <> 0 Then
If Not WinExists($__g_aUDF_GlobalIDs_Used[$iIndex][0]) Then
For $x = 0 To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
$__g_aUDF_GlobalIDs_Used[$iIndex][$x] = 0
Next
$__g_aUDF_GlobalIDs_Used[$iIndex][1] = $_UDF_STARTID
$bAllUsed = False
EndIf
EndIf
Next
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd Then
$iUsedIndex = $iIndex
ExitLoop
EndIf
Next
If $iUsedIndex = -1 Then
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = 0 Then
$__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd
$__g_aUDF_GlobalIDs_Used[$iIndex][1] = $_UDF_STARTID
$bAllUsed = False
$iUsedIndex = $iIndex
ExitLoop
EndIf
Next
EndIf
If $iUsedIndex = -1 And $bAllUsed Then Return SetError(16, 0, 0)
If $__g_aUDF_GlobalIDs_Used[$iUsedIndex][1] = $_UDF_STARTID + $_UDF_GlobalID_MAX_IDS Then
For $iIDIndex = $_UDF_GlobalIDs_OFFSET To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
If $__g_aUDF_GlobalIDs_Used[$iUsedIndex][$iIDIndex] = 0 Then
$nCtrlID =($iIDIndex - $_UDF_GlobalIDs_OFFSET) + 10000
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][$iIDIndex] = $nCtrlID
Return $nCtrlID
EndIf
Next
Return SetError(-1, $_UDF_GlobalID_MAX_IDS, 0)
EndIf
$nCtrlID = $__g_aUDF_GlobalIDs_Used[$iUsedIndex][1]
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][1] += 1
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][($nCtrlID - 10000) + $_UDF_GlobalIDs_OFFSET] = $nCtrlID
Return $nCtrlID
EndFunc
Func __UDF_FreeGlobalID($hWnd, $iGlobalID)
If $iGlobalID - $_UDF_STARTID < 0 Or $iGlobalID - $_UDF_STARTID > $_UDF_GlobalID_MAX_IDS Then Return SetError(-1, 0, False)
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd Then
For $x = $_UDF_GlobalIDs_OFFSET To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][$x] = $iGlobalID Then
$__g_aUDF_GlobalIDs_Used[$iIndex][$x] = 0
Return True
EndIf
Next
Return SetError(-3, 0, False)
EndIf
Next
Return SetError(-2, 0, False)
EndFunc
Global Const $tagBUTTON_IMAGELIST = "ptr ImageList;" & $tagRECT & ";uint Align"
Global Const $__BUTTONCONSTANT_ClassName = "Button"
Func _GUICtrlButton_Enable($hWnd, $bEnable = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then Return _WinAPI_EnableWindow($hWnd, $bEnable) = $bEnable
EndFunc
Func _GUICtrlButton_SetImageList($hWnd, $hImage, $iAlign = 0, $iLeft = 1, $iTop = 1, $iRight = 1, $iBottom = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If $iAlign < 0 Or $iAlign > 4 Then $iAlign = 0
Local $tBUTTON_IMAGELIST = DllStructCreate($tagBUTTON_IMAGELIST)
DllStructSetData($tBUTTON_IMAGELIST, "ImageList", $hImage)
DllStructSetData($tBUTTON_IMAGELIST, "Left", $iLeft)
DllStructSetData($tBUTTON_IMAGELIST, "Top", $iTop)
DllStructSetData($tBUTTON_IMAGELIST, "Right", $iRight)
DllStructSetData($tBUTTON_IMAGELIST, "Bottom", $iBottom)
DllStructSetData($tBUTTON_IMAGELIST, "Align", $iAlign)
Local $bEnabled = _GUICtrlButton_Enable($hWnd, False)
Local $iRet = _SendMessage($hWnd, $BCM_SETIMAGELIST, 0, $tBUTTON_IMAGELIST, 0, "wparam", "struct*") <> 0
_GUICtrlButton_Enable($hWnd)
If Not $bEnabled Then _GUICtrlButton_Enable($hWnd, False)
Return $iRet
EndFunc
Global Const $COLOR_AQUA = 0x00FFFF
Global Const $COLOR_BLACK = 0x000000
Global Const $COLOR_BLUE = 0x0000FF
Global Const $COLOR_FUCHSIA = 0xFF00FF
Global Const $COLOR_GRAY = 0x808080
Global Const $COLOR_GREEN = 0x008000
Global Const $COLOR_MAROON = 0x8B1C62
Global Const $COLOR_MEDGRAY = 0xA0A0A4
Global Const $COLOR_MONEYGREEN = 0xC0DCC0
Global Const $COLOR_NAVY = 0x000080
Global Const $COLOR_PURPLE = 0x800080
Global Const $COLOR_RED = 0xFF0000
Global Const $COLOR_WHITE = 0xFFFFFF
Global Const $COLOR_YELLOW = 0xFFFF00
Global Const $ILC_MASK = 0x00000001
Global Const $ILC_COLOR = 0x00000000
Global Const $ILC_COLORDDB = 0x000000FE
Global Const $ILC_COLOR4 = 0x00000004
Global Const $ILC_COLOR8 = 0x00000008
Global Const $ILC_COLOR16 = 0x00000010
Global Const $ILC_COLOR24 = 0x00000018
Global Const $ILC_COLOR32 = 0x00000020
Global Const $ILC_MIRROR = 0x00002000
Global Const $ILC_PERITEMMIRROR = 0x00008000
Global Const $__IMAGELISTCONSTANT_IMAGE_BITMAP = 0
Func _GUIImageList_Add($hWnd, $hImage, $hMask = 0)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_Add", "handle", $hWnd, "handle", $hImage, "handle", $hMask)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUIImageList_AddBitmap($hWnd, $sImage, $sMask = "")
Local $aSize = _GUIImageList_GetIconSize($hWnd)
Local $hImage = _WinAPI_LoadImage(0, $sImage, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $aSize[0], $aSize[1], $LR_LOADFROMFILE)
If $hImage = 0 Then Return SetError(_WinAPI_GetLastError(), 1, -1)
Local $hMask = 0
If $sMask <> "" Then
$hMask = _WinAPI_LoadImage(0, $sMask, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $aSize[0], $aSize[1], $LR_LOADFROMFILE)
If $hMask = 0 Then Return SetError(_WinAPI_GetLastError(), 2, -1)
EndIf
Local $iRet = _GUIImageList_Add($hWnd, $hImage, $hMask)
_WinAPI_DeleteObject($hImage)
If $hMask <> 0 Then _WinAPI_DeleteObject($hMask)
Return $iRet
EndFunc
Func _GUIImageList_AddIcon($hWnd, $sFilePath, $iIndex = 0, $bLarge = False)
Local $iRet, $tIcon = DllStructCreate("handle Handle")
If $bLarge Then
$iRet = _WinAPI_ExtractIconEx($sFilePath, $iIndex, $tIcon, 0, 1)
Else
$iRet = _WinAPI_ExtractIconEx($sFilePath, $iIndex, 0, $tIcon, 1)
EndIf
If $iRet <= 0 Then Return SetError(-1, $iRet, -1)
Local $hIcon = DllStructGetData($tIcon, "Handle")
$iRet = _GUIImageList_ReplaceIcon($hWnd, -1, $hIcon)
_WinAPI_DestroyIcon($hIcon)
If $iRet = -1 Then Return SetError(-2, $iRet, -1)
Return $iRet
EndFunc
Func _GUIImageList_Create($iCX = 16, $iCY = 16, $iColor = 4, $iOptions = 0, $iInitial = 4, $iGrow = 4)
Local Const $aColor[7] = [$ILC_COLOR, $ILC_COLOR4, $ILC_COLOR8, $ILC_COLOR16, $ILC_COLOR24, $ILC_COLOR32, $ILC_COLORDDB]
Local $iFlags = 0
If BitAND($iOptions, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILC_MASK)
If BitAND($iOptions, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILC_MIRROR)
If BitAND($iOptions, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILC_PERITEMMIRROR)
$iFlags = BitOR($iFlags, $aColor[$iColor])
Local $aResult = DllCall("comctl32.dll", "handle", "ImageList_Create", "int", $iCX, "int", $iCY, "uint", $iFlags, "int", $iInitial, "int", $iGrow)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_Destroy($hWnd)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Destroy", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_GetIconSize($hWnd)
Local $aSize[2]
Local $tPoint = _GUIImageList_GetIconSizeEx($hWnd)
$aSize[0] = DllStructGetData($tPoint, "X")
$aSize[1] = DllStructGetData($tPoint, "Y")
Return $aSize
EndFunc
Func _GUIImageList_GetIconSizeEx($hWnd)
Local $tPoint = DllStructCreate($tagPOINT)
Local $pPointX = DllStructGetPtr($tPoint, "X")
Local $pPointY = DllStructGetPtr($tPoint, "Y")
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_GetIconSize", "hwnd", $hWnd, "struct*", $pPointX, "struct*", $pPointY)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tPoint)
EndFunc
Func _GUIImageList_ReplaceIcon($hWnd, $iIndex, $hIcon)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hWnd, "int", $iIndex, "handle", $hIcon)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Global Const $GMEM_MOVEABLE = 0x0002
Global Const $MEM_COMMIT = 0x00001000
Global Const $MEM_RESERVE = 0x00002000
Global Const $PAGE_READWRITE = 0x00000004
Global Const $PAGE_EXECUTE_READWRITE = 0x00000040
Global Const $MEM_RELEASE = 0x00008000
Global Const $tagMEMMAP = "handle hProc;ulong_ptr Size;ptr Mem"
Func _MemFree(ByRef $tMemMap)
Local $pMemory = DllStructGetData($tMemMap, "Mem")
Local $hProcess = DllStructGetData($tMemMap, "hProc")
Local $bResult = _MemVirtualFreeEx($hProcess, $pMemory, 0, $MEM_RELEASE)
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess)
If @error Then Return SetError(@error, @extended, False)
Return $bResult
EndFunc
Func _MemGlobalAlloc($iBytes, $iFlags = 0)
Local $aResult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $iFlags, "ulong_ptr", $iBytes)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalLock($hMemory)
Local $aResult = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalUnlock($hMemory)
Local $aResult = DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemInit($hWnd, $iSize, ByRef $tMemMap)
Local $aResult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
If @error Then Return SetError(@error + 10, @extended, 0)
Local $iProcessID = $aResult[2]
If $iProcessID = 0 Then Return SetError(1, 0, 0)
Local $iAccess = BitOR($PROCESS_VM_OPERATION, $PROCESS_VM_READ, $PROCESS_VM_WRITE)
Local $hProcess = __Mem_OpenProcess($iAccess, False, $iProcessID, True)
Local $iAlloc = BitOR($MEM_RESERVE, $MEM_COMMIT)
Local $pMemory = _MemVirtualAllocEx($hProcess, 0, $iSize, $iAlloc, $PAGE_READWRITE)
If $pMemory = 0 Then Return SetError(2, 0, 0)
$tMemMap = DllStructCreate($tagMEMMAP)
DllStructSetData($tMemMap, "hProc", $hProcess)
DllStructSetData($tMemMap, "Size", $iSize)
DllStructSetData($tMemMap, "Mem", $pMemory)
Return $pMemory
EndFunc
Func _MemRead(ByRef $tMemMap, $pSrce, $pDest, $iSize)
Local $aResult = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", DllStructGetData($tMemMap, "hProc"), "ptr", $pSrce, "struct*", $pDest, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemWrite(ByRef $tMemMap, $pSrce, $pDest = 0, $iSize = 0, $sSrce = "struct*")
If $pDest = 0 Then $pDest = DllStructGetData($tMemMap, "Mem")
If $iSize = 0 Then $iSize = DllStructGetData($tMemMap, "Size")
Local $aResult = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", DllStructGetData($tMemMap, "hProc"), "ptr", $pDest, $sSrce, $pSrce, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemVirtualAlloc($pAddress, $iSize, $iAllocation, $iProtect)
Local $aResult = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iAllocation, "dword", $iProtect)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemVirtualAllocEx($hProcess, $pAddress, $iSize, $iAllocation, $iProtect)
Local $aResult = DllCall("kernel32.dll", "ptr", "VirtualAllocEx", "handle", $hProcess, "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iAllocation, "dword", $iProtect)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemVirtualFree($pAddress, $iSize, $iFreeType)
Local $aResult = DllCall("kernel32.dll", "bool", "VirtualFree", "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iFreeType)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemVirtualFreeEx($hProcess, $pAddress, $iSize, $iFreeType)
Local $aResult = DllCall("kernel32.dll", "bool", "VirtualFreeEx", "handle", $hProcess, "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iFreeType)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func __Mem_OpenProcess($iAccess, $bInherit, $iProcessID, $bDebugPriv = False)
Local $aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iProcessID)
If @error Then Return SetError(@error + 10, @extended, 0)
If $aResult[0] Then Return $aResult[0]
If Not $bDebugPriv Then Return 0
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 20, @extended, 0)
_Security__SetPrivilege($hToken, "SeDebugPrivilege", True)
Local $iError = @error
Local $iLastError = @extended
Local $iRet = 0
If Not @error Then
$aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iProcessID)
$iError = @error
$iLastError = @extended
If $aResult[0] Then $iRet = $aResult[0]
_Security__SetPrivilege($hToken, "SeDebugPrivilege", False)
If @error Then
$iError = @error + 30
$iLastError = @extended
EndIf
Else
$iError = @error + 40
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
Return SetError($iError, $iLastError, $iRet)
EndFunc
Global Const $__STATUSBARCONSTANT_WM_USER = 0X400
Global Const $SB_GETUNICODEFORMAT = 0x2000 + 6
Global Const $SB_ISSIMPLE =($__STATUSBARCONSTANT_WM_USER + 14)
Global Const $SB_SETPARTS =($__STATUSBARCONSTANT_WM_USER + 4)
Global Const $SB_SETTEXTA =($__STATUSBARCONSTANT_WM_USER + 1)
Global Const $SB_SETTEXTW =($__STATUSBARCONSTANT_WM_USER + 11)
Global Const $SB_SETTEXT = $SB_SETTEXTA
Global Const $SB_SIMPLE =($__STATUSBARCONSTANT_WM_USER + 9)
Global Const $SB_SIMPLEID = 0xff
Global $__g_hSBLastWnd
Global Const $__STATUSBARCONSTANT_ClassName = "msctls_statusbar32"
Global Const $__STATUSBARCONSTANT_WM_SIZE = 0x05
Func _GUICtrlStatusBar_Create($hWnd, $vPartEdge = -1, $vPartText = "", $iStyles = -1, $iExStyles = 0x00000000)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
Local $iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
If $iStyles = -1 Then $iStyles = 0x00000000
If $iExStyles = -1 Then $iExStyles = 0x00000000
Local $aPartWidth[1], $aPartText[1]
If @NumParams > 1 Then
If IsArray($vPartEdge) Then
$aPartWidth = $vPartEdge
Else
$aPartWidth[0] = $vPartEdge
EndIf
If @NumParams = 2 Then
ReDim $aPartText[UBound($aPartWidth)]
Else
If IsArray($vPartText) Then
$aPartText = $vPartText
Else
$aPartText[0] = $vPartText
EndIf
If UBound($aPartWidth) <> UBound($aPartText) Then
Local $iLast
If UBound($aPartWidth) > UBound($aPartText) Then
$iLast = UBound($aPartText)
ReDim $aPartText[UBound($aPartWidth)]
Else
$iLast = UBound($aPartWidth)
ReDim $aPartWidth[UBound($aPartText)]
For $x = $iLast To UBound($aPartWidth) - 1
$aPartWidth[$x] = $aPartWidth[$x - 1] + 75
Next
$aPartWidth[UBound($aPartText) - 1] = -1
EndIf
EndIf
EndIf
If Not IsHWnd($hWnd) Then $hWnd = HWnd($hWnd)
If @NumParams > 3 Then $iStyle = BitOR($iStyle, $iStyles)
EndIf
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hWndSBar = _WinAPI_CreateWindowEx($iExStyles, $__STATUSBARCONSTANT_ClassName, "", $iStyle, 0, 0, 0, 0, $hWnd, $nCtrlID)
If @error Then Return SetError(@error, @extended, 0)
If @NumParams > 1 Then
_GUICtrlStatusBar_SetParts($hWndSBar, UBound($aPartWidth), $aPartWidth)
For $x = 0 To UBound($aPartText) - 1
_GUICtrlStatusBar_SetText($hWndSBar, $aPartText[$x], $x)
Next
EndIf
Return $hWndSBar
EndFunc
Func _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Return _SendMessage($hWnd, $SB_GETUNICODEFORMAT) <> 0
EndFunc
Func _GUICtrlStatusBar_IsSimple($hWnd)
Return _SendMessage($hWnd, $SB_ISSIMPLE) <> 0
EndFunc
Func _GUICtrlStatusBar_Resize($hWnd)
_SendMessage($hWnd, $__STATUSBARCONSTANT_WM_SIZE)
EndFunc
Func _GUICtrlStatusBar_SetParts($hWnd, $aParts = -1, $aPartWidth = 25)
Local $tParts, $iParts = 1
If IsArray($aParts) <> 0 Then
$aParts[UBound($aParts) - 1] = -1
$iParts = UBound($aParts)
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 0 To $iParts - 2
DllStructSetData($tParts, 1, $aParts[$x], $x + 1)
Next
DllStructSetData($tParts, 1, -1, $iParts)
ElseIf IsArray($aPartWidth) <> 0 Then
$iParts = UBound($aPartWidth)
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 0 To $iParts - 2
DllStructSetData($tParts, 1, $aPartWidth[$x], $x + 1)
Next
DllStructSetData($tParts, 1, -1, $iParts)
ElseIf $aParts > 1 Then
$iParts = $aParts
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 1 To $iParts - 1
DllStructSetData($tParts, 1, $aPartWidth * $x, $x)
Next
DllStructSetData($tParts, 1, -1, $iParts)
Else
$tParts = DllStructCreate("int")
DllStructSetData($tParts, $iParts, -1)
EndIf
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
_SendMessage($hWnd, $SB_SETPARTS, $iParts, $tParts, 0, "wparam", "struct*")
Else
Local $iSize = DllStructGetSize($tParts)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iSize, $tMemMap)
_MemWrite($tMemMap, $tParts)
_SendMessage($hWnd, $SB_SETPARTS, $iParts, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
_GUICtrlStatusBar_Resize($hWnd)
Return True
EndFunc
Func _GUICtrlStatusBar_SetSimple($hWnd, $bSimple = True)
_SendMessage($hWnd, $SB_SIMPLE, $bSimple)
EndFunc
Func _GUICtrlStatusBar_SetText($hWnd, $sText = "", $iPart = 0, $iUFlag = 0)
Local $bUnicode = _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tText
If $bUnicode Then
$tText = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tText = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tText, "Text", $sText)
If _GUICtrlStatusBar_IsSimple($hWnd) Then $iPart = $SB_SIMPLEID
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
$iRet = _SendMessage($hWnd, $SB_SETTEXTW, BitOR($iPart, $iUFlag), $tText, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tText)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $SB_SETTEXTW, BitOR($iPart, $iUFlag), $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $SB_SETTEXT, BitOR($iPart, $iUFlag), $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Global Const $TTF_IDISHWND = 0x00000001
Global Const $TTF_SUBCLASS = 0x00000010
Global Const $__TOOLTIPCONSTANTS_WM_USER = 0X400
Global Const $TTM_SETMAXTIPWIDTH = $__TOOLTIPCONSTANTS_WM_USER + 24
Global Const $TTM_ADDTOOLW = $__TOOLTIPCONSTANTS_WM_USER + 50
Global Const $TTM_GETTEXTW = $__TOOLTIPCONSTANTS_WM_USER + 56
Global Const $TTS_ALWAYSTIP = 0x00000001
Global Const $TTS_NOPREFIX = 0x00000002
Global Const $__EDITCONSTANT_WM_GETTEXTLENGTH = 0x000E
Global Const $__EDITCONSTANT_WM_SETTEXT = 0x000C
Func _GUICtrlEdit_AppendText($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iLength = _GUICtrlEdit_GetTextLen($hWnd)
_GUICtrlEdit_SetSel($hWnd, $iLength, $iLength)
_SendMessage($hWnd, $EM_REPLACESEL, True, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlEdit_GetTextLen($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__EDITCONSTANT_WM_GETTEXTLENGTH)
EndFunc
Func _GUICtrlEdit_SetReadOnly($hWnd, $bReadOnly)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_SETREADONLY, $bReadOnly) <> 0
EndFunc
Func _GUICtrlEdit_SetSel($hWnd, $iStart, $iEnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETSEL, $iStart, $iEnd)
EndFunc
Func _GUICtrlEdit_SetText($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $__EDITCONSTANT_WM_SETTEXT, 0, $sText, 0, "wparam", "wstr")
EndFunc
Global Const $__COMBOBOXCONSTANT_DEFAULT_GUI_FONT = 17
Func _GUICtrlComboBox_FindStringExact($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_FINDSTRINGEXACT, $iIndex, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBox_GetCount($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETCOUNT)
EndFunc
Func _GUICtrlComboBox_GetCurSel($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETCURSEL)
EndFunc
Func _GUICtrlComboBox_GetLBText($hWnd, $iIndex, ByRef $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iLen = _GUICtrlComboBox_GetLBTextLen($hWnd, $iIndex)
Local $tBuffer = DllStructCreate("wchar Text[" & $iLen + 1 & "]")
Local $iRet = _SendMessage($hWnd, $CB_GETLBTEXT, $iIndex, $tBuffer, 0, "wparam", "struct*")
If($iRet == $CB_ERR) Then Return SetError($CB_ERR, $CB_ERR, $CB_ERR)
$sText = DllStructGetData($tBuffer, "Text")
Return $iRet
EndFunc
Func _GUICtrlComboBox_GetLBTextLen($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETLBTEXTLEN, $iIndex)
EndFunc
Func _GUICtrlComboBox_GetList($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sDelimiter = Opt("GUIDataSeparatorChar")
Local $sResult = "", $sItem
For $i = 0 To _GUICtrlComboBox_GetCount($hWnd) - 1
_GUICtrlComboBox_GetLBText($hWnd, $i, $sItem)
$sResult &= $sItem & $sDelimiter
Next
Return StringTrimRight($sResult, StringLen($sDelimiter))
EndFunc
Func _GUICtrlComboBox_GetListArray($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sDelimiter = Opt("GUIDataSeparatorChar")
Return StringSplit(_GUICtrlComboBox_GetList($hWnd), $sDelimiter)
EndFunc
Func _GUICtrlComboBox_ResetContent($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $CB_RESETCONTENT)
EndFunc
Func _GUICtrlComboBox_SelectString($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SELECTSTRING, $iIndex, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBox_SetCurSel($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETCURSEL, $iIndex)
EndFunc
Global $__g_hCBExLastWnd
Global Const $__COMBOBOXEXCONSTANT_ClassName = "ComboBoxEx32"
Global Const $__COMBOBOXEXCONSTANT_WM_SIZE = 0x05
Func _GUICtrlComboBoxEx_AddString($hWnd, $sText, $iImage = -1, $iSelectedImage = -1, $iOverlayImage = -1, $iIndent = -1, $iParam = -1)
Return _GUICtrlComboBoxEx_InsertString($hWnd, $sText, -1, $iImage, $iSelectedImage, $iOverlayImage, $iIndent, $iParam)
EndFunc
Func _GUICtrlComboBoxEx_Create($hWnd, $sText, $iX, $iY, $iWidth = 100, $iHeight = 200, $iStyle = 0x00200002, $iExStyle = 0x00000000)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sText) Then Return SetError(2, 0, 0)
Local $sDelimiter = Opt("GUIDataSeparatorChar")
If $iWidth = -1 Then $iWidth = 100
If $iHeight = -1 Then $iHeight = 200
Local Const $WS_VSCROLL = 0x00200000
If $iStyle = -1 Then $iStyle = BitOR($WS_VSCROLL, $CBS_DROPDOWN)
If $iExStyle = -1 Then $iExStyle = 0x00000000
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_TABSTOP, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hCombo = _WinAPI_CreateWindowEx($iExStyle, $__COMBOBOXEXCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_WinAPI_SetFont($hCombo, _WinAPI_GetStockObject($__COMBOBOXCONSTANT_DEFAULT_GUI_FONT))
If StringLen($sText) Then
Local $aText = StringSplit($sText, $sDelimiter)
For $x = 1 To $aText[0]
_GUICtrlComboBoxEx_AddString($hCombo, $aText[$x])
Next
EndIf
Return $hCombo
EndFunc
Func _GUICtrlComboBoxEx_FindStringExact($hWnd, $sText, $iIndex = -1)
Return _SendMessage($hWnd, $CB_FINDSTRINGEXACT, $iIndex, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBoxEx_GetComboControl($hWnd)
Return HWnd(_SendMessage($hWnd, $CBEM_GETCOMBOCONTROL))
EndFunc
Func _GUICtrlComboBoxEx_GetCount($hWnd)
Return _SendMessage($hWnd, $CB_GETCOUNT)
EndFunc
Func _GUICtrlComboBoxEx_GetUnicode($hWnd)
Return _SendMessage($hWnd, $CBEM_GETUNICODEFORMAT) <> 0
EndFunc
Func _GUICtrlComboBoxEx_InsertString($hWnd, $sText, $iIndex = -1, $iImage = -1, $iSelectedImage = -1, $iOverlayImage = -1, $iIndent = -1, $iParam = -1)
Local $iBuffer = 0, $iMask, $iRet
Local $bUnicode = _GUICtrlComboBoxEx_GetUnicode($hWnd)
Local $tItem = DllStructCreate($tagCOMBOBOXEXITEM)
If $sText <> -1 Then
$iMask = BitOR($CBEIF_TEXT, $CBEIF_LPARAM)
$iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
DllStructSetData($tItem, "TextMax", $iBuffer)
Else
$iMask = BitOR($CBEIF_DI_SETITEM, $CBEIF_LPARAM)
EndIf
If $iImage >= 0 Then $iMask = BitOR($iMask, $CBEIF_IMAGE)
If $iSelectedImage >= 0 Then $iMask = BitOR($iMask, $CBEIF_SELECTEDIMAGE)
If $iOverlayImage >= 0 Then $iMask = BitOR($iMask, $CBEIF_OVERLAY)
If $iIndent >= 1 Then $iMask = BitOR($iMask, $CBEIF_INDENT)
If $iParam = -1 Then $iParam = _GUICtrlComboBoxEx_GetCount($hWnd)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "Image", $iImage)
DllStructSetData($tItem, "SelectedImage", $iSelectedImage)
DllStructSetData($tItem, "OverlayImage", $iOverlayImage)
DllStructSetData($tItem, "Indent", $iIndent)
DllStructSetData($tItem, "Param", $iParam)
If _WinAPI_InProcess($hWnd, $__g_hCBExLastWnd) Or($sText = -1) Then
$iRet = _SendMessage($hWnd, $CBEM_INSERTITEMW, 0, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $CBEM_INSERTITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $CBEM_INSERTITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet
EndFunc
Func _GUICtrlComboBoxEx_SetCurSel($hWnd, $iIndex = -1)
Return _SendMessage($hWnd, $CB_SETCURSEL, $iIndex)
EndFunc
Func _GUICtrlComboBoxEx_SetImageList($hWnd, $hHandle)
Local $hResult = _SendMessage($hWnd, $CBEM_SETIMAGELIST, 0, $hHandle, 0, "wparam", "handle", "handle")
_SendMessage($hWnd, $__COMBOBOXEXCONSTANT_WM_SIZE)
Return $hResult
EndFunc
Global Const $__SLIDERCONSTANT_WM_USER = 0x400
Global Const $TBM_SETTICFREQ = $__SLIDERCONSTANT_WM_USER + 20
Global Const $TBM_SETTIPSIDE = $__SLIDERCONSTANT_WM_USER + 31
Global Const $TBTS_BOTTOM = 2
Global Const $TBS_AUTOTICKS = 0x0001
Global Const $TBS_TOOLTIPS = 0x100
Func _GUICtrlSlider_SetTicFreq($hWnd, $iFreg)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETTICFREQ, $iFreg)
EndFunc
Func _GUICtrlSlider_SetTipSide($hWnd, $iLocation)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETTIPSIDE, $iLocation)
EndFunc
Global Const $PBS_SMOOTH = 1
Global Const $SS_LEFT = 0x0
Global Const $SS_CENTER = 0x1
Global Const $SS_RIGHT = 0x2
Global Const $SS_BLACKRECT = 0x4
Global Const $SS_GRAYRECT = 0x5
Global Const $SS_WHITERECT = 0x6
Global Const $SS_BITMAP = 0xE
Global Const $SS_SUNKEN = 0x1000
Global Const $STM_SETIMAGE = 0x0172
Global Const $TCS_MULTILINE = 0x00000200
Global Const $TCS_RIGHTJUSTIFY = 0x00000000
Global Const $TCM_FIRST = 0x1300
Global Const $TCCM_FIRST = 0X2000
Global Const $TCM_GETITEMRECT =($TCM_FIRST + 10)
Global Const $TCM_SETCURFOCUS =($TCM_FIRST + 48)
Global Const $TCM_SETIMAGELIST = $TCM_FIRST + 3
Func _WinAPI_CreateStreamOnHGlobal($hGlobal = 0, $bDeleteOnRelease = True)
Local $aReturn = DllCall('ole32.dll', 'long', 'CreateStreamOnHGlobal', 'handle', $hGlobal, 'bool', $bDeleteOnRelease, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return $aReturn[3]
EndFunc
Func _WinAPI_ReleaseStream($pStream)
Local $aReturn = DllCall('oleaut32.dll', 'long', 'DispCallFunc', 'ptr', $pStream, 'ulong_ptr', 8 *(1 + @AutoItX64), 'uint', 4, 'ushort', 23, 'uint', 0, 'ptr', 0, 'ptr', 0, 'str', '')
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return 1
EndFunc
Func _WinAPI_CreateMutex($sMutex, $bInitial = True, $tSecurity = 0)
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateMutexW', 'struct*', $tSecurity, 'bool', $bInitial, 'wstr', $sMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateSemaphore($sSemaphore, $iInitial, $iMaximum, $tSecurity = 0)
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateSemaphoreW', 'struct*', $tSecurity, 'long', $iInitial, 'long', $iMaximum, 'wstr', $sSemaphore)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_EmptyWorkingSet($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000500, 0x00001100), 'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EmptyWorkingSet', 'handle', $hProcess[0])
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_EnumProcessThreads($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000004, 'dword', 0)
If @error Or Not $hSnapshot[0] Then Return SetError(@error + 10, @extended, 0)
Local Const $tagTHREADENTRY32 = 'dword Size;dword Usage;dword ThreadID;dword OwnerProcessID;long BasePri;long DeltaPri;dword Flags'
Local $tTHREADENTRY32 = DllStructCreate($tagTHREADENTRY32)
Local $aResult[101] = [0]
$hSnapshot = $hSnapshot[0]
DllStructSetData($tTHREADENTRY32, 'Size', DllStructGetSize($tTHREADENTRY32))
Local $aRet = DllCall('kernel32.dll', 'bool', 'Thread32First', 'handle', $hSnapshot, 'struct*', $tTHREADENTRY32)
While Not @error And $aRet[0]
If DllStructGetData($tTHREADENTRY32, 'OwnerProcessID') = $iPID Then
__Inc($aResult)
$aResult[$aResult[0]] = DllStructGetData($tTHREADENTRY32, 'ThreadID')
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'Thread32Next', 'handle', $hSnapshot, 'struct*', $tTHREADENTRY32)
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If Not $aResult[0] Then Return SetError(1, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_EnumProcessWindows($iPID = 0, $bVisible = True)
Local $aThreads = _WinAPI_EnumProcessThreads($iPID)
If @error Then Return SetError(@error, @extended, 0)
Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'bool', 'hwnd;lparam')
Dim $__g_vEnum[101][2] = [[0]]
For $i = 1 To $aThreads[0]
DllCall('user32.dll', 'bool', 'EnumThreadWindows', 'dword', $aThreads[$i], 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $bVisible)
If @error Then
ExitLoop
EndIf
Next
DllCallbackFree($hEnumProc)
If Not $__g_vEnum[0][0] Then Return SetError(11, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_GetExitCodeProcess($hProcess)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetExitCodeProcess', 'handle', $hProcess, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_ReleaseMutex($hMutex)
Local $aRet = DllCall('kernel32.dll', 'bool', 'ReleaseMutex', 'handle', $hMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ReleaseSemaphore($hSemaphore, $iIncrease = 1)
Local $aRet = DllCall('kernel32.dll', 'bool', 'ReleaseSemaphore', 'handle', $hSemaphore, 'long', $iIncrease, 'long*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[3]
EndFunc
Global Const $LOCALE_SDATE = 0x001D
Global Const $LOCALE_STIME = 0x001E
Global Const $LOCALE_SSHORTDATE = 0x001F
Global Const $LOCALE_SLONGDATE = 0x0020
Global Const $LOCALE_STIMEFORMAT = 0x1003
Global Const $LOCALE_S1159 = 0x0028
Global Const $LOCALE_S2359 = 0x0029
Global Const $LOCALE_INVARIANT = 0x007F
Global Const $LOCALE_USER_DEFAULT = 0x0400
Global Const $DIB_RGB_COLORS = 0
Global Const $BI_RGB = 0
Global Const $tagBITMAP = 'struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct'
Global Const $tagBITMAPV5HEADER = 'struct;dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPelsPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[9];dword bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;endstruct'
Global Const $tagDIBSECTION = $tagBITMAP & ';' & $tagBITMAPINFOHEADER & ';dword dsBitfields[3];ptr dshSection;dword dsOffset'
Func _WinAPI_CopyBitmap($hBitmap)
$hBitmap = _WinAPI_CopyImage($hBitmap, 0, 0, 0, 0x2000)
Return SetError(@error, @extended, $hBitmap)
EndFunc
Func _WinAPI_CopyImage($hImage, $iType = 0, $iXDesiredPixels = 0, $iYDesiredPixels = 0, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'CopyImage', 'handle', $hImage, 'uint', $iType, 'int', $iXDesiredPixels, 'int', $iYDesiredPixels, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_Create32BitHBITMAP($hIcon, $bDib = False, $bDelete = False)
Local $hBitmap = 0
Local $aDIB[2] = [0, 0]
Local $hTemp = _WinAPI_Create32BitHICON($hIcon)
If @error Then Return SetError(@error, @extended, 0)
Local $iError = 0
Do
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hTemp, 'struct*', $tICONINFO)
If @error Or Not $aRet[0] Then
$iError = @error + 10
ExitLoop
EndIf
For $i = 0 To 1
$aDIB[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
Local $tBITMAP = DllStructCreate($tagBITMAP)
If Not _WinAPI_GetObject($aDIB[0], DllStructGetSize($tBITMAP), $tBITMAP) Then
$iError = @error + 20
ExitLoop
EndIf
If $bDib Then
$hBitmap = _WinAPI_CreateDIB(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'))
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hBitmap)
_WinAPI_DrawIconEx($hDC, 0, 0, $hTemp)
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
Else
$hBitmap = $aDIB[1]
$aDIB[1] = 0
EndIf
Until 1
For $i = 0 To 1
If $aDIB[$i] Then
_WinAPI_DeleteObject($aDIB[$i])
EndIf
Next
_WinAPI_DestroyIcon($hTemp)
If $iError Then Return SetError($iError, 0, 0)
If Not $hBitmap Then Return SetError(12, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hBitmap
EndFunc
Func _WinAPI_Create32BitHICON($hIcon, $bDelete = False)
Local $ahBitmap[2], $hResult = 0
Local $aDIB[2][2] = [[0, 0], [0, 0]]
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hIcon, 'struct*', $tICONINFO)
If @error Then Return SetError(@error, @extended, 0)
If Not $aRet[0] Then Return SetError(10, 0, 0)
For $i = 0 To 1
$ahBitmap[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
If _WinAPI_IsAlphaBitmap($ahBitmap[1]) Then
$aDIB[0][0] = _WinAPI_CreateANDBitmap($ahBitmap[1])
If Not @error Then
$hResult = _WinAPI_CreateIconIndirect($ahBitmap[1], $aDIB[0][0])
EndIf
Else
Local $tSIZE = _WinAPI_GetBitmapDimension($ahBitmap[1])
Local $aSize[2]
For $i = 0 To 1
$aSize[$i] = DllStructGetData($tSIZE, $i + 1)
Next
Local $hSrcDC = _WinAPI_CreateCompatibleDC(0)
Local $hDstDC = _WinAPI_CreateCompatibleDC(0)
Local $hSrcSv, $hDstSv
For $i = 0 To 1
$aDIB[$i][0] = _WinAPI_CreateDIB($aSize[0], $aSize[1])
$aDIB[$i][1] = $__g_vExt
$hSrcSv = _WinAPI_SelectObject($hSrcDC, $ahBitmap[$i])
$hDstSv = _WinAPI_SelectObject($hDstDC, $aDIB[$i][0])
_WinAPI_BitBlt($hDstDC, 0, 0, $aSize[0], $aSize[1], $hSrcDC, 0, 0, 0x00C000CA)
_WinAPI_SelectObject($hSrcDC, $hSrcSv)
_WinAPI_SelectObject($hDstDC, $hDstSv)
Next
_WinAPI_DeleteDC($hSrcDC)
_WinAPI_DeleteDC($hDstDC)
$aRet = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'ptr', __XORProc(), 'ptr', 0, 'uint', $aSize[0] * $aSize[1] * 4, 'wparam', $aDIB[0][1], 'lparam', $aDIB[1][1])
If Not @error And $aRet[0] Then
$hResult = _WinAPI_CreateIconIndirect($aDIB[1][0], $ahBitmap[0])
EndIf
EndIf
For $i = 0 To 1
_WinAPI_DeleteObject($ahBitmap[$i])
If $aDIB[$i][0] Then
_WinAPI_DeleteObject($aDIB[$i][0])
EndIf
Next
If Not $hResult Then Return SetError(11, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hResult
EndFunc
Func _WinAPI_CreateANDBitmap($hBitmap)
Local $iError = 0, $hDib = 0
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
If Not $hBitmap Then Return SetError(@error + 20, @extended, 0)
Do
Local $atDIB[2]
$atDIB[0] = DllStructCreate($tagDIBSECTION)
If(Not _WinAPI_GetObject($hBitmap, DllStructGetSize($atDIB[0]), $atDIB[0])) Or(DllStructGetData($atDIB[0], 'bmBitsPixel') <> 32) Or(DllStructGetData($atDIB[0], 'biCompression')) Then
$iError = 10
ExitLoop
EndIf
$atDIB[1] = DllStructCreate($tagBITMAP)
$hDib = _WinAPI_CreateDIB(DllStructGetData($atDIB[0], 'bmWidth'), DllStructGetData($atDIB[0], 'bmHeight'), 1)
If Not _WinAPI_GetObject($hDib, DllStructGetSize($atDIB[1]), $atDIB[1]) Then
$iError = 11
ExitLoop
EndIf
Local $aRet = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'ptr', __ANDProc(), 'ptr', 0, 'uint', 0, 'wparam', DllStructGetPtr($atDIB[0]), 'lparam', DllStructGetPtr($atDIB[1]))
If @error Then
$iError = @error
ExitLoop
EndIf
If Not $aRet[0] Then
$iError = 12
ExitLoop
EndIf
$iError = 0
Until 1
_WinAPI_DeleteObject($hBitmap)
If $iError Then
If $hDib Then
_WinAPI_DeleteObject($hDib)
EndIf
$hDib = 0
EndIf
Return SetError($iError, 0, $hDib)
EndFunc
Func _WinAPI_CreateDIB($iWidth, $iHeight, $iBitsPerPel = 32, $tColorTable = 0, $iColorCount = 0)
Local $aRGBQ[2], $iColors, $tagRGBQ
Switch $iBitsPerPel
Case 1
$iColors = 2
Case 4
$iColors = 16
Case 8
$iColors = 256
Case Else
$iColors = 0
EndSwitch
If $iColors Then
If Not IsDllStruct($tColorTable) Then
Switch $iBitsPerPel
Case 1
$aRGBQ[0] = 0
$aRGBQ[1] = 0xFFFFFF
$tColorTable = _WinAPI_CreateDIBColorTable($aRGBQ)
Case Else
EndSwitch
Else
If $iColors > $iColorCount Then
$iColors = $iColorCount
EndIf
If(Not $iColors) Or((4 * $iColors) > DllStructGetSize($tColorTable)) Then
Return SetError(20, 0, 0)
EndIf
EndIf
$tagRGBQ = ';dword aRGBQuad[' & $iColors & ']'
Else
$tagRGBQ = ''
EndIf
Local $tBITMAPINFO = DllStructCreate($tagBITMAPINFOHEADER & $tagRGBQ)
DllStructSetData($tBITMAPINFO, 'biSize', 40)
DllStructSetData($tBITMAPINFO, 'biWidth', $iWidth)
DllStructSetData($tBITMAPINFO, 'biHeight', $iHeight)
DllStructSetData($tBITMAPINFO, 'biPlanes', 1)
DllStructSetData($tBITMAPINFO, 'biBitCount', $iBitsPerPel)
DllStructSetData($tBITMAPINFO, 'biCompression', 0)
DllStructSetData($tBITMAPINFO, 'biSizeImage', 0)
DllStructSetData($tBITMAPINFO, 'biXPelsPerMeter', 0)
DllStructSetData($tBITMAPINFO, 'biYPelsPerMeter', 0)
DllStructSetData($tBITMAPINFO, 'biClrUsed', $iColors)
DllStructSetData($tBITMAPINFO, 'biClrImportant', 0)
If $iColors Then
If IsDllStruct($tColorTable) Then
_WinAPI_MoveMemory(DllStructGetPtr($tBITMAPINFO, 'aRGBQuad'), $tColorTable, 4 * $iColors)
Else
_WinAPI_ZeroMemory(DllStructGetPtr($tBITMAPINFO, 'aRGBQuad'), 4 * $iColors)
EndIf
EndIf
Local $hBitmap = _WinAPI_CreateDIBSection(0, $tBITMAPINFO, 0, $__g_vExt)
If Not $hBitmap Then Return SetError(@error, @extended, 0)
Return $hBitmap
EndFunc
Func _WinAPI_CreateDIBColorTable(Const ByRef $aColorTable, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aColorTable, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $tColorTable = DllStructCreate('dword[' &($iEnd - $iStart + 1) & ']')
Local $iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tColorTable, 1, _WinAPI_SwitchColor(__RGB($aColorTable[$i])), $iCount)
$iCount += 1
Next
Return $tColorTable
EndFunc
Func _WinAPI_CreateDIBSection($hDC, $tBITMAPINFO, $iUsage, ByRef $pBits, $hSection = 0, $iOffset = 0)
$pBits = 0
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateDIBSection', 'handle', $hDC, 'struct*', $tBITMAPINFO, 'uint', $iUsage, 'ptr*', 0, 'handle', $hSection, 'dword', $iOffset)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
$pBits = $aRet[4]
Return $aRet[0]
EndFunc
Func _WinAPI_CreateIconIndirect($hBitmap, $hMask, $iXHotspot = 0, $iYHotspot = 0, $bIcon = True)
Local $tICONINFO = DllStructCreate($tagICONINFO)
DllStructSetData($tICONINFO, 1, $bIcon)
DllStructSetData($tICONINFO, 2, $iXHotspot)
DllStructSetData($tICONINFO, 3, $iYHotspot)
DllStructSetData($tICONINFO, 4, $hMask)
DllStructSetData($tICONINFO, 5, $hBitmap)
Local $aRet = DllCall('user32.dll', 'handle', 'CreateIconIndirect', 'struct*', $tICONINFO)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DwmEnableComposition($bEnable)
If $bEnable Then $bEnable = 1
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmEnableComposition', 'uint', $bEnable)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmIsCompositionEnabled()
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmIsCompositionEnabled', 'bool*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[1]
EndFunc
Func _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
Local $tSIZE = DllStructCreate($tagSIZE)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmQueryThumbnailSourceSize', 'handle', $hThumbnail, 'struct*', $tSIZE)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $tSIZE
EndFunc
Func _WinAPI_DwmRegisterThumbnail($hDestination, $hSource)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmRegisterThumbnail', 'hwnd', $hDestination, 'hwnd', $hSource, 'handle*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[3]
EndFunc
Func _WinAPI_DwmUnregisterThumbnail($hThumbnail)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmUnregisterThumbnail', 'handle', $hThumbnail)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmUpdateThumbnailProperties($hThumbnail, $bVisible = True, $bClientAreaOnly = False, $iOpacity = 255, $tRectDest = 0, $tRectSrc = 0)
Local Const $tagDWM_THUMBNAIL_PROPERTIES = 'struct;dword dwFlags;int rcDestination[4];int rcSource[4];byte opacity;bool opacity;bool fSourceClientAreaOnly;endstruct'
Local $tTHUMBNAILPROPERTIES = DllStructCreate($tagDWM_THUMBNAIL_PROPERTIES)
Local $tSIZE, $iFlags = 0
If Not IsDllStruct($tRectDest) Then
$tSIZE = _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
If @error Then
Return SetError(@error + 10, @extended, 0)
EndIf
$tRectDest = _WinAPI_CreateRectEx(0, 0, DllStructGetData($tSIZE, 1), DllStructGetData($tSIZE, 2))
EndIf
For $i = 1 To 4
DllStructSetData($tTHUMBNAILPROPERTIES, 2, DllStructGetData($tRectDest, $i), $i)
Next
If IsDllStruct($tRectSrc) Then
$iFlags += 2
For $i = 1 To 4
DllStructSetData($tTHUMBNAILPROPERTIES, 3, DllStructGetData($tRectSrc, $i), $i)
Next
EndIf
DllStructSetData($tTHUMBNAILPROPERTIES, 1, BitOR($iFlags, 0x1D))
DllStructSetData($tTHUMBNAILPROPERTIES, 4, $iOpacity)
DllStructSetData($tTHUMBNAILPROPERTIES, 5, $bVisible)
DllStructSetData($tTHUMBNAILPROPERTIES, 6, $bClientAreaOnly)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmUpdateThumbnailProperties', 'handle', $hThumbnail, 'struct*', $tTHUMBNAILPROPERTIES)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_GetPixel($hDC, $iX, $iY)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetPixel', 'handle', $hDC, 'int', $iX, 'int', $iY)
If @error Or($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_IsAlphaBitmap($hBitmap)
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
If Not $hBitmap Then Return SetError(@error + 20, @extended, 0)
Local $aRet, $iError = 0
Do
Local $tDIB = DllStructCreate($tagDIBSECTION)
If(Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), $tDIB)) Or(DllStructGetData($tDIB, 'bmBitsPixel') <> 32) Or(DllStructGetData($tDIB, 'biCompression')) Then
$iError = 1
ExitLoop
EndIf
$aRet = DllCall('user32.dll', 'int', 'CallWindowProc', 'ptr', __AlphaProc(), 'ptr', 0, 'uint', 0, 'struct*', $tDIB, 'ptr', 0)
If @error Or($aRet[0] = -1) Then
$iError = @error + 10
ExitLoop
EndIf
Until 1
_WinAPI_DeleteObject($hBitmap)
If $iError Then Return SetError($iError, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_PtInRectEx($iX, $iY, $iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)
Local $tPOINT = _WinAPI_CreatePoint($iX, $iY)
Local $aRet = DllCall('user32.dll', 'bool', 'PtInRect', 'struct*', $tRECT, 'struct', $tPOINT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func __AlphaProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary( '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' & '48837C24600074054831C0EB0748C7C0010000004821C0751F488B6C24604883' & '7D180074054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB' & '034831C04821C0740C48C7C0FFFFFFFF4863C0EB6F48C744242800000000488B' & '6C24604C637D04488B6C2460486345084C0FAFF849C1E7024983C7FC4C3B7C24' & '287C36488B6C24604C8B7D184C037C24284983C7034C897C2430488B6C243080' & '7D0000740C48C7C0010000004863C0EB1348834424280471A54831C04863C0EB' & '034831C04883C438415F5DC3'))
Else
$pProc = __Init(Binary( '0x555331C05050837C241C00740431C0EB05B80100000021C075198B6C241C837D' & '1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021C07407' & 'B8FFFFFFFFEB4FC70424000000008B6C241C8B5D048B6C241C0FAF5D08C1E302' & '83C3FC3B1C247C288B6C241C8B5D14031C2483C303895C24048B6C2404807D00' & '007407B801000000EB0C8304240471BE31C0EB0231C083C4085B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
Func __ANDProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary( '0x48894C240848895424104C894424184C894C2420554157415648C7C009000000' & '4883EC0848C704240000000048FFC875EF4883EC284883BC24A0000000007405' & '4831C0EB0748C7C0010000004821C00F85840000004883BC24A8000000007405' & '4831C0EB0748C7C0010000004821C07555488BAC24A000000048837D18007405' & '4831C0EB0748C7C0010000004821C07522488BAC24A800000048837D18007405' & '4831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C048' & '21C07502EB0948C7C001000000EB034831C04821C07502EB0948C7C001000000' & 'EB034831C04821C0740B4831C04863C0E9D701000048C74424280000000048C7' & '44243000000000488BAC24A00000004C637D0849FFCF4C3B7C24300F8C9C0100' & '0048C74424380000000048C74424400000000048C744244800000000488BAC24' & 'A00000004C637D0449FFCF4C3B7C24480F8CDB000000488BAC24A00000004C8B' & '7D184C037C24284983C7034C897C2450488B6C2450807D000074264C8B7C2440' & '4C8B74243849F7DE4983C61F4C89F148C7C00100000048D3E04909C74C897C24' & '4048FF4424384C8B7C24384983FF1F7E6F4C8B7C244049F7D74C897C244048C7' & '442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D184C037C' & '24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C2458588845' & '0048FF4424604883442458F871B948C74424380000000048C744244000000000' & '48834424280448FF4424480F810BFFFFFF48837C24380074794C8B7C244049F7' & 'D74C8B74243849F7DE4983C6204C89F148C7C0FFFFFFFF48D3E04921C74C897C' & '244048C7442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D' & '184C037C24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C24' & '585888450048FF4424604883442458F871B948FF4424300F814AFEFFFF48C7C0' & '010000004863C0EB034831C04883C470415E415F5DC3'))
Else
$pProc = __Init(Binary( '0x555357BA0800000083EC04C70424000000004A75F3837C243800740431C0EB05' & 'B80100000021C07562837C243C00740431C0EB05B80100000021C0753F8B6C24' & '38837D1400740431C0EB05B80100000021C075198B6C243C837D1400740431C0' & 'EB05B80100000021C07502EB07B801000000EB0231C021C07502EB07B8010000' & '00EB0231C021C07502EB07B801000000EB0231C021C0740731C0E969010000C7' & '042400000000C7442404000000008B6C24388B5D084B3B5C24040F8C3F010000' & 'C744240800000000C744240C00000000C7442410000000008B6C24388B5D044B' & '3B5C24100F8CA90000008B6C24388B5D14031C2483C303895C24148B6C241480' & '7D0000741C8B5C240C8B7C2408F7DF83C71F89F9B801000000D3E009C3895C24' & '0CFF4424088B5C240883FB1F7E578B5C240CF7D3895C240CC744241818000000' & '31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' & 'FB538B6C241858884500FF44241C83442418F871CBC744240800000000C74424' & '0C0000000083042404FF4424100F8145FFFFFF837C240800745B8B5C240CF7D3' & '8B7C2408F7DF83C72089F9B8FFFFFFFFD3E021C3895C240CC744241818000000' & '31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' & 'FB538B6C241858884500FF44241C83442418F871CBFF4424040F81AFFEFFFFB8' & '01000000EB0231C083C4205F5B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
Func __XORProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary( '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' & '48837C24600074054831C0EB0748C7C0010000004821C0751B48837C24680074' & '054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C0' & '4821C074084831C04863C0EB7748C7442428000000004C637C24584983C7FC4C' & '3B7C24287C4F4C8B7C24604C037C24284C897C2430488B6C2430807D00007405' & '4831C0EB0748C7C0010000004821C0741C4C8B7C24684C037C24284983C7034C' & '897C2430488B6C2430C64500FF48834424280471A148C7C0010000004863C0EB' & '034831C04883C438415F5DC3'))
Else
$pProc = __Init(Binary( '0x555331C05050837C241C00740431C0EB05B80100000021C07516837C24200074' & '0431C0EB05B80100000021C07502EB07B801000000EB0231C021C0740431C0EB' & '5AC70424000000008B5C241883C3FC3B1C247C3E8B5C241C031C24895C24048B' & '6C2404807D0000740431C0EB05B80100000021C074168B5C2420031C2483C303' & '895C24048B6C2404C64500FF8304240471B6B801000000EB0231C083C4085B5D' & 'C21000'))
EndIf
EndIf
Return $pProc
EndFunc
Func _WinAPI_GetFileVersionInfo($sFilePath, ByRef $pBuffer, $iFlags = 0)
Local $aRet
If $__WINVER >= 0x0600 Then
$aRet = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeExW', 'dword', BitAND($iFlags, 0x03), 'wstr', $sFilePath, 'ptr', 0)
Else
$aRet = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeW', 'wstr', $sFilePath, 'ptr', 0)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
$pBuffer = __HeapReAlloc($pBuffer, $aRet[0], 1)
If @error Then Return SetError(@error + 100, @extended, 0)
Local $iNbByte = $aRet[0]
If $__WINVER >= 0x0600 Then
$aRet = DllCall('version.dll', 'bool', 'GetFileVersionInfoExW', 'dword', BitAND($iFlags, 0x07), 'wstr', $sFilePath, 'dword', 0, 'dword', $iNbByte, 'ptr', $pBuffer)
Else
$aRet = DllCall('version.dll', 'bool', 'GetFileVersionInfoW', 'wstr', $sFilePath, 'dword', 0, 'dword', $iNbByte, 'ptr', $pBuffer)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $iNbByte
EndFunc
Func _WinAPI_VerQueryValue($pData, $sValues = '')
$sValues = StringRegExpReplace($sValues, '\A[\s\|]*|[\s\|]*\Z', '')
If Not $sValues Then
$sValues = 'Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild'
EndIf
$sValues = StringSplit($sValues, '|', $STR_NOCOUNT)
Local $aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\VarFileInfo\Translation', 'ptr*', 0, 'uint*', 0)
If @error Or Not $aRet[0] Or Not $aRet[4] Then Return SetError(@error + 10, 0, 0)
Local $iLength = Floor($aRet[4] / 4)
Local $tLang = DllStructCreate('dword[' & $iLength & ']', $aRet[3])
If @error Then Return SetError(@error + 20, 0, 0)
Local $sCP, $aInfo[101][UBound($sValues) + 1] = [[0]]
For $i = 1 To $iLength
__Inc($aInfo)
$aInfo[$aInfo[0][0]][0] = _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))
$sCP = Hex(_WinAPI_MakeLong(_WinAPI_HiWord(DllStructGetData($tLang, 1, $i)), _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))), 8)
For $j = 0 To UBound($sValues) - 1
$aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\StringFileInfo\' & $sCP & '\' & $sValues[$j], 'ptr*', 0, 'uint*', 0)
If Not @error And $aRet[0] And $aRet[4] Then
$aInfo[$aInfo[0][0]][$j + 1] = DllStructGetData(DllStructCreate('wchar[' & $aRet[4] & ']', $aRet[3]), 1)
Else
$aInfo[$aInfo[0][0]][$j + 1] = ''
EndIf
Next
Next
__Inc($aInfo, -1)
Return $aInfo
EndFunc
Global Const $GDIP_EPGCOLORDEPTH = '{66087055-AD66-4C7C-9A18-38A2310B8337}'
Global Const $GDIP_EPGCOMPRESSION = '{E09D739D-CCD4-44EE-8EBA-3FBF8BE4FC58}'
Global Const $GDIP_EPGQUALITY = '{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}'
Global Const $GDIP_EPTLONG = 4
Global Const $GDIP_EVTCOMPRESSIONLZW = 2
Global Const $GDIP_ILMREAD = 0x0001
Global Const $GDIP_PXF24RGB = 0x00021808
Global Const $GDIP_PXF32RGB = 0x00022009
Global Const $GDIP_PXF32ARGB = 0x0026200A
Global Const $GDIP_SMOOTHINGMODE_DEFAULT = 0
Global Const $GDIP_SMOOTHINGMODE_HIGHQUALITY = 2
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 = 5
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC = 7
Global $__g_hGDIPBrush = 0
Global $__g_hGDIPDll = 0
Global $__g_hGDIPPen = 0
Global $__g_iGDIPRef = 0
Global $__g_iGDIPToken = 0
Global $__g_bGDIP_V1_0 = True
Func _GDIPlus_BitmapCloneArea($hBitmap, $nLeft, $nTop, $nWidth, $nHeight, $iFormat = 0x00021808)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCloneBitmapArea", "float", $nLeft, "float", $nTop, "float", $nWidth, "float", $nHeight, "int", $iFormat, "handle", $hBitmap, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[7]
EndFunc
Func _GDIPlus_BitmapCreateDIBFromBitmap($hBitmap)
Local $aRet = DllCall($__g_hGDIPDll, "uint", "GdipGetImageDimension", "handle", $hBitmap, "float*", 0, "float*", 0)
If @error Or $aRet[0] Then Return SetError(@error + 10, $aRet[0], 0)
Local $tData = _GDIPlus_BitmapLockBits($hBitmap, 0, 0, $aRet[2], $aRet[3], $GDIP_ILMREAD, $GDIP_PXF32ARGB)
Local $pBits = DllStructGetData($tData, "Scan0")
If Not $pBits Then Return 0
Local $tBIHDR = DllStructCreate($tagBITMAPV5HEADER)
DllStructSetData($tBIHDR, "bV5Size", DllStructGetSize($tBIHDR))
DllStructSetData($tBIHDR, "bV5Width", $aRet[2])
DllStructSetData($tBIHDR, "bV5Height", $aRet[3])
DllStructSetData($tBIHDR, "bV5Planes", 1)
DllStructSetData($tBIHDR, "bV5BitCount", 32)
DllStructSetData($tBIHDR, "bV5Compression", 0)
DllStructSetData($tBIHDR, "bV5SizeImage", $aRet[3] * DllStructGetData($tData, "Stride"))
DllStructSetData($tBIHDR, "bV5AlphaMask", 0xFF000000)
DllStructSetData($tBIHDR, "bV5RedMask", 0x00FF0000)
DllStructSetData($tBIHDR, "bV5GreenMask", 0x0000FF00)
DllStructSetData($tBIHDR, "bV5BlueMask", 0x000000FF)
DllStructSetData($tBIHDR, "bV5CSType", 2)
DllStructSetData($tBIHDR, "bV5Intent", 4)
Local $hHBitmapv5 = DllCall("gdi32.dll", "ptr", "CreateDIBSection", "hwnd", 0, "struct*", $tBIHDR, "uint", 0, "ptr*", 0, "ptr", 0, "dword", 0)
If Not @error And $hHBitmapv5[0] Then
DllCall("gdi32.dll", "dword", "SetBitmapBits", "ptr", $hHBitmapv5[0], "dword", $aRet[2] * $aRet[3] * 4, "ptr", DllStructGetData($tData, "Scan0"))
$hHBitmapv5 = $hHBitmapv5[0]
Else
$hHBitmapv5 = 0
EndIf
_GDIPlus_BitmapUnlockBits($hBitmap, $tData)
$tData = 0
$tBIHDR = 0
Return $hHBitmapv5
EndFunc
Func _GDIPlus_BitmapCreateFromFile($sFileName)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromFile", "wstr", $sFileName, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BitmapCreateFromHBITMAP($hBitmap, $hPal = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromHBITMAP", "handle", $hBitmap, "handle", $hPal, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight, $iPixelFormat = $GDIP_PXF32ARGB, $iStride = 0, $pScan0 = 0)
Local $aResult = DllCall($__g_hGDIPDll, "uint", "GdipCreateBitmapFromScan0", "int", $iWidth, "int", $iHeight, "int", $iStride, "int", $iPixelFormat, "struct*", $pScan0, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[6]
EndFunc
Func _GDIPlus_BitmapCreateFromStream($pStream)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromStream", "ptr", $pStream, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BitmapDispose($hBitmap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDisposeImage", "handle", $hBitmap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapGetPixel($hBitmap, $iX, $iY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapGetPixel", "handle", $hBitmap, "int", $iX, "int", $iY, "uint*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_BitmapLockBits($hBitmap, $iLeft, $iTop, $iWidth, $iHeight, $iFlags = $GDIP_ILMREAD, $iFormat = $GDIP_PXF32RGB)
Local $tData = DllStructCreate($tagGDIPBITMAPDATA)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iWidth)
DllStructSetData($tRECT, "Bottom", $iHeight)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapLockBits", "handle", $hBitmap, "struct*", $tRECT, "uint", $iFlags, "int", $iFormat, "struct*", $tData)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $tData
EndFunc
Func _GDIPlus_BitmapUnlockBits($hBitmap, $tBitmapData)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapUnlockBits", "handle", $hBitmap, "struct*", $tBitmapData)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BrushCreateSolid($iARGB = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateSolidFill", "int", $iARGB, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BrushDispose($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteBrush", "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_Encoders()
Local $iCount = _GDIPlus_EncodersGetCount()
Local $iSize = _GDIPlus_EncodersGetSize()
Local $tBuffer = DllStructCreate("byte[" & $iSize & "]")
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncoders", "uint", $iCount, "uint", $iSize, "struct*", $tBuffer)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tCodec, $aInfo[$iCount + 1][14]
$aInfo[0][0] = $iCount
For $iI = 1 To $iCount
$tCodec = DllStructCreate($tagGDIPIMAGECODECINFO, $pBuffer)
$aInfo[$iI][1] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "CLSID"))
$aInfo[$iI][2] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "FormatID"))
$aInfo[$iI][3] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "CodecName"))
$aInfo[$iI][4] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "DllName"))
$aInfo[$iI][5] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "FormatDesc"))
$aInfo[$iI][6] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "FileExt"))
$aInfo[$iI][7] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "MimeType"))
$aInfo[$iI][8] = DllStructGetData($tCodec, "Flags")
$aInfo[$iI][9] = DllStructGetData($tCodec, "Version")
$aInfo[$iI][10] = DllStructGetData($tCodec, "SigCount")
$aInfo[$iI][11] = DllStructGetData($tCodec, "SigSize")
$aInfo[$iI][12] = DllStructGetData($tCodec, "SigPattern")
$aInfo[$iI][13] = DllStructGetData($tCodec, "SigMask")
$pBuffer += DllStructGetSize($tCodec)
Next
Return $aInfo
EndFunc
Func _GDIPlus_EncodersGetCLSID($sFileExtension)
Local $aEncoders = _GDIPlus_Encoders()
If @error Then Return SetError(@error, 0, "")
For $iI = 1 To $aEncoders[0][0]
If StringInStr($aEncoders[$iI][6], "*." & $sFileExtension) > 0 Then Return $aEncoders[$iI][1]
Next
Return SetError(-1, -1, "")
EndFunc
Func _GDIPlus_EncodersGetCount()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[1]
EndFunc
Func _GDIPlus_EncodersGetSize()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_FontCreate($hFamily, $fSize, $iStyle = 0, $iUnit = 3)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFont", "handle", $hFamily, "float", $fSize, "int", $iStyle, "int", $iUnit, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[5]
EndFunc
Func _GDIPlus_FontDispose($hFont)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteFont", "handle", $hFont)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_FontFamilyCreate($sFamily, $pCollection = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFontFamilyFromName", "wstr", $sFamily, "ptr", $pCollection, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_FontFamilyDispose($hFamily)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteFontFamily", "handle", $hFamily)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsClear($hGraphics, $iARGB = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGraphicsClear", "handle", $hGraphics, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsCreateFromHDC($hDC)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFromHDC", "handle", $hDC, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsDispose($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteGraphics", "handle", $hGraphics)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawEllipse($hGraphics, $nX, $nY, $nWidth, $nHeight, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawEllipse", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawImageRect($hGraphics, $hImage, $nX, $nY, $nW, $nH)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawImageRect", "handle", $hGraphics, "handle", $hImage, "float", $nX, "float", $nY, "float", $nW, "float", $nH)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawLine($hGraphics, $nX1, $nY1, $nX2, $nY2, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawLine", "handle", $hGraphics, "handle", $hPen, "float", $nX1, "float", $nY1, "float", $nX2, "float", $nY2)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawRect($hGraphics, $nX, $nY, $nWidth, $nHeight, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawRectangle", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawString($hGraphics, $sString, $nX, $nY, $sFont = "Arial", $fSize = 10, $iFormat = 0)
Local $hBrush = _GDIPlus_BrushCreateSolid()
Local $hFormat = _GDIPlus_StringFormatCreate($iFormat)
Local $hFamily = _GDIPlus_FontFamilyCreate($sFont)
Local $hFont = _GDIPlus_FontCreate($hFamily, $fSize)
Local $tLayout = _GDIPlus_RectFCreate($nX, $nY, 0.0, 0.0)
Local $aInfo = _GDIPlus_GraphicsMeasureString($hGraphics, $sString, $hFont, $tLayout, $hFormat)
If @error Then Return SetError(@error, @extended, 0)
Local $aResult = _GDIPlus_GraphicsDrawStringEx($hGraphics, $sString, $hFont, $aInfo[0], $hFormat, $hBrush)
Local $iError = @error, $iExtended = @extended
_GDIPlus_FontDispose($hFont)
_GDIPlus_FontFamilyDispose($hFamily)
_GDIPlus_StringFormatDispose($hFormat)
_GDIPlus_BrushDispose($hBrush)
Return SetError($iError, $iExtended, $aResult)
EndFunc
Func _GDIPlus_GraphicsDrawStringEx($hGraphics, $sString, $hFont, $tLayout, $hFormat, $hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawString", "handle", $hGraphics, "wstr", $sString, "int", -1, "handle", $hFont, "struct*", $tLayout, "handle", $hFormat, "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillRect($hGraphics, $nX, $nY, $nWidth, $nHeight, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillRectangle", "handle", $hGraphics, "handle", $hBrush, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsMeasureString($hGraphics, $sString, $hFont, $tLayout, $hFormat)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipMeasureString", "handle", $hGraphics, "wstr", $sString, "int", -1, "handle", $hFont, "struct*", $tLayout, "handle", $hFormat, "struct*", $tRECTF, "int*", 0, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Local $aInfo[3]
$aInfo[0] = $tRECTF
$aInfo[1] = $aResult[8]
$aInfo[2] = $aResult[9]
Return $aInfo
EndFunc
Func _GDIPlus_GraphicsSetInterpolationMode($hGraphics, $iInterpolationMode)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetInterpolationMode", "handle", $hGraphics, "int", $iInterpolationMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetSmoothingMode($hGraphics, $iSmooth)
If $iSmooth < $GDIP_SMOOTHINGMODE_DEFAULT Or $iSmooth > $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 Then $iSmooth = $GDIP_SMOOTHINGMODE_DEFAULT
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetSmoothingMode", "handle", $hGraphics, "int", $iSmooth)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageDispose($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDisposeImage", "handle", $hImage)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageGetGraphicsContext($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageGraphicsContext", "handle", $hImage, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageGetHeight($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageHeight", "handle", $hImage, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageGetWidth($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageWidth", "handle", $hImage, "uint*", -1)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageSaveToFile($hImage, $sFileName)
Local $sExt = __GDIPlus_ExtractFileExt($sFileName)
Local $sCLSID = _GDIPlus_EncodersGetCLSID($sExt)
If $sCLSID = "" Then Return SetError(-1, 0, False)
Local $bRet = _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sCLSID, 0)
Return SetError(@error, @extended, $bRet)
EndFunc
Func _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sEncoder, $tParams = 0)
Local $tGUID = _WinAPI_GUIDFromString($sEncoder)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSaveImageToFile", "handle", $hImage, "wstr", $sFileName, "struct*", $tGUID, "struct*", $tParams)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageResize($hImage, $iNewWidth, $iNewHeight, $iInterpolationMode = $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
Local $hBitmap = _GDIPlus_BitmapCreateFromScan0($iNewWidth, $iNewHeight)
If @error Then Return SetError(1, 0, 0)
Local $hBmpCtxt = _GDIPlus_ImageGetGraphicsContext($hBitmap)
If @error Then
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(2, @extended, 0)
EndIf
_GDIPlus_GraphicsSetInterpolationMode($hBmpCtxt, $iInterpolationMode)
If @error Then
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(3, @extended, 0)
EndIf
_GDIPlus_GraphicsDrawImageRect($hBmpCtxt, $hImage, 0, 0, $iNewWidth, $iNewHeight)
If @error Then
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(4, @extended, 0)
EndIf
_GDIPlus_GraphicsDispose($hBmpCtxt)
Return $hBitmap
EndFunc
Func _GDIPlus_ParamAdd(ByRef $tParams, $sGUID, $iNbOfValues, $iType, $pValues)
Local $iCount = DllStructGetData($tParams, "Count")
Local $pGUID = DllStructGetPtr($tParams, "GUID") +($iCount * _GDIPlus_ParamSize())
Local $tParam = DllStructCreate($tagGDIPENCODERPARAM, $pGUID)
_WinAPI_GUIDFromStringEx($sGUID, $pGUID)
DllStructSetData($tParam, "Type", $iType)
DllStructSetData($tParam, "NumberOfValues", $iNbOfValues)
DllStructSetData($tParam, "Values", $pValues)
DllStructSetData($tParams, "Count", $iCount + 1)
EndFunc
Func _GDIPlus_ParamInit($iCount)
Local $sStruct = $tagGDIPENCODERPARAMS
For $i = 2 To $iCount
$sStruct &= ";struct;byte[16];ulong;ulong;ptr;endstruct"
Next
Return DllStructCreate($sStruct)
EndFunc
Func _GDIPlus_ParamSize()
Local $tParam = DllStructCreate($tagGDIPENCODERPARAM)
Return DllStructGetSize($tParam)
EndFunc
Func _GDIPlus_PenCreate($iARGB = 0xFF000000, $nWidth = 1, $iUnit = 2)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePen1", "dword", $iARGB, "float", $nWidth, "int", $iUnit, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_PenDispose($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeletePen", "handle", $hPen)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RectFCreate($nX = 0, $nY = 0, $nWidth = 0, $nHeight = 0)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
DllStructSetData($tRECTF, "X", $nX)
DllStructSetData($tRECTF, "Y", $nY)
DllStructSetData($tRECTF, "Width", $nWidth)
DllStructSetData($tRECTF, "Height", $nHeight)
Return $tRECTF
EndFunc
Func _GDIPlus_Shutdown()
If $__g_hGDIPDll = 0 Then Return SetError(-1, -1, False)
$__g_iGDIPRef -= 1
If $__g_iGDIPRef = 0 Then
DllCall($__g_hGDIPDll, "none", "GdiplusShutdown", "ulong_ptr", $__g_iGDIPToken)
DllClose($__g_hGDIPDll)
$__g_hGDIPDll = 0
EndIf
Return True
EndFunc
Func _GDIPlus_Startup($sGDIPDLL = Default, $bRetDllHandle = False)
$__g_iGDIPRef += 1
If $__g_iGDIPRef > 1 Then Return True
If $sGDIPDLL = Default Then $sGDIPDLL = "gdiplus.dll"
$__g_hGDIPDll = DllOpen($sGDIPDLL)
If $__g_hGDIPDll = -1 Then
$__g_iGDIPRef = 0
Return SetError(1, 2, False)
EndIf
Local $sVer = FileGetVersion($sGDIPDLL)
$sVer = StringSplit($sVer, ".")
If $sVer[1] > 5 Then $__g_bGDIP_V1_0 = False
Local $tInput = DllStructCreate($tagGDIPSTARTUPINPUT)
Local $tToken = DllStructCreate("ulong_ptr Data")
DllStructSetData($tInput, "Version", 1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdiplusStartup", "struct*", $tToken, "struct*", $tInput, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
$__g_iGDIPToken = DllStructGetData($tToken, "Data")
If $bRetDllHandle Then Return $__g_hGDIPDll
Return SetExtended($sVer[1], True)
EndFunc
Func _GDIPlus_StringFormatCreate($iFormat = 0, $iLangID = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateStringFormat", "int", $iFormat, "word", $iLangID, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_StringFormatDispose($hFormat)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteStringFormat", "handle", $hFormat)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func __GDIPlus_BrushDefCreate(ByRef $hBrush)
If $hBrush = 0 Then
$__g_hGDIPBrush = _GDIPlus_BrushCreateSolid()
$hBrush = $__g_hGDIPBrush
EndIf
EndFunc
Func __GDIPlus_BrushDefDispose($iCurError = @error, $iCurExtended = @extended)
If $__g_hGDIPBrush <> 0 Then
_GDIPlus_BrushDispose($__g_hGDIPBrush)
$__g_hGDIPBrush = 0
EndIf
Return SetError($iCurError, $iCurExtended)
EndFunc
Func __GDIPlus_ExtractFileExt($sFileName, $bNoDot = True)
Local $iIndex = __GDIPlus_LastDelimiter(".\:", $sFileName)
If($iIndex > 0) And(StringMid($sFileName, $iIndex, 1) = '.') Then
If $bNoDot Then
Return StringMid($sFileName, $iIndex + 1)
Else
Return StringMid($sFileName, $iIndex)
EndIf
Else
Return ""
EndIf
EndFunc
Func __GDIPlus_LastDelimiter($sDelimiters, $sString)
Local $sDelimiter, $iN
For $iI = 1 To StringLen($sDelimiters)
$sDelimiter = StringMid($sDelimiters, $iI, 1)
$iN = StringInStr($sString, $sDelimiter, 0, -1)
If $iN > 0 Then Return $iN
Next
EndFunc
Func __GDIPlus_PenDefCreate(ByRef $hPen)
If $hPen = 0 Then
$__g_hGDIPPen = _GDIPlus_PenCreate()
$hPen = $__g_hGDIPPen
EndIf
EndFunc
Func __GDIPlus_PenDefDispose($iCurError = @error, $iCurExtended = @extended)
If $__g_hGDIPPen <> 0 Then
_GDIPlus_PenDispose($__g_hGDIPPen)
$__g_hGDIPPen = 0
EndIf
Return SetError($iCurError, $iCurExtended)
EndFunc
Global $__g_iBMPFormat = $GDIP_PXF24RGB
Global $__g_iJPGQuality = 100
Global $__g_iTIFColorDepth = 24
Global $__g_iTIFCompression = $GDIP_EVTCOMPRESSIONLZW
Global Const $__SCREENCAPTURECONSTANT_SM_CXSCREEN = 0
Global Const $__SCREENCAPTURECONSTANT_SM_CYSCREEN = 1
Global Const $__SCREENCAPTURECONSTANT_SRCCOPY = 0x00CC0020
Func _ScreenCapture_Capture($sFileName = "", $iLeft = 0, $iTop = 0, $iRight = -1, $iBottom = -1, $bCursor = True)
Local $bRet = False
If $iRight = -1 Then $iRight = _WinAPI_GetSystemMetrics($__SCREENCAPTURECONSTANT_SM_CXSCREEN) - 1
If $iBottom = -1 Then $iBottom = _WinAPI_GetSystemMetrics($__SCREENCAPTURECONSTANT_SM_CYSCREEN) - 1
If $iRight < $iLeft Then Return SetError(-1, 0, $bRet)
If $iBottom < $iTop Then Return SetError(-2, 0, $bRet)
Local $iW =($iRight - $iLeft) + 1
Local $iH =($iBottom - $iTop) + 1
Local $hWnd = _WinAPI_GetDesktopWindow()
Local $hDDC = _WinAPI_GetDC($hWnd)
Local $hCDC = _WinAPI_CreateCompatibleDC($hDDC)
Local $hBMP = _WinAPI_CreateCompatibleBitmap($hDDC, $iW, $iH)
_WinAPI_SelectObject($hCDC, $hBMP)
_WinAPI_BitBlt($hCDC, 0, 0, $iW, $iH, $hDDC, $iLeft, $iTop, $__SCREENCAPTURECONSTANT_SRCCOPY)
If $bCursor Then
Local $aCursor = _WinAPI_GetCursorInfo()
If Not @error And $aCursor[1] Then
$bCursor = True
Local $hIcon = _WinAPI_CopyIcon($aCursor[2])
Local $aIcon = _WinAPI_GetIconInfo($hIcon)
If Not @error Then
_WinAPI_DeleteObject($aIcon[4])
If $aIcon[5] <> 0 Then _WinAPI_DeleteObject($aIcon[5])
_WinAPI_DrawIcon($hCDC, $aCursor[3] - $aIcon[2] - $iLeft, $aCursor[4] - $aIcon[3] - $iTop, $hIcon)
EndIf
_WinAPI_DestroyIcon($hIcon)
EndIf
EndIf
_WinAPI_ReleaseDC($hWnd, $hDDC)
_WinAPI_DeleteDC($hCDC)
If $sFileName = "" Then Return $hBMP
$bRet = _ScreenCapture_SaveImage($sFileName, $hBMP, True)
Return SetError(@error, @extended, $bRet)
EndFunc
Func _ScreenCapture_SaveImage($sFileName, $hBitmap, $bFreeBmp = True)
_GDIPlus_Startup()
If @error Then Return SetError(-1, -1, False)
Local $sExt = StringUpper(__GDIPlus_ExtractFileExt($sFileName))
Local $sCLSID = _GDIPlus_EncodersGetCLSID($sExt)
If $sCLSID = "" Then Return SetError(-2, -2, False)
Local $hImage = _GDIPlus_BitmapCreateFromHBITMAP($hBitmap)
If @error Then Return SetError(-3, -3, False)
Local $tData, $tParams
Switch $sExt
Case "BMP"
Local $iX = _GDIPlus_ImageGetWidth($hImage)
Local $iY = _GDIPlus_ImageGetHeight($hImage)
Local $hClone = _GDIPlus_BitmapCloneArea($hImage, 0, 0, $iX, $iY, $__g_iBMPFormat)
_GDIPlus_ImageDispose($hImage)
$hImage = $hClone
Case "JPG", "JPEG"
$tParams = _GDIPlus_ParamInit(1)
$tData = DllStructCreate("int Quality")
DllStructSetData($tData, "Quality", $__g_iJPGQuality)
_GDIPlus_ParamAdd($tParams, $GDIP_EPGQUALITY, 1, $GDIP_EPTLONG, DllStructGetPtr($tData))
Case "TIF", "TIFF"
$tParams = _GDIPlus_ParamInit(2)
$tData = DllStructCreate("int ColorDepth;int Compression")
DllStructSetData($tData, "ColorDepth", $__g_iTIFColorDepth)
DllStructSetData($tData, "Compression", $__g_iTIFCompression)
_GDIPlus_ParamAdd($tParams, $GDIP_EPGCOLORDEPTH, 1, $GDIP_EPTLONG, DllStructGetPtr($tData, "ColorDepth"))
_GDIPlus_ParamAdd($tParams, $GDIP_EPGCOMPRESSION, 1, $GDIP_EPTLONG, DllStructGetPtr($tData, "Compression"))
EndSwitch
Local $pParams = 0
If IsDllStruct($tParams) Then $pParams = $tParams
Local $bRet = _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sCLSID, $pParams)
_GDIPlus_ImageDispose($hImage)
If $bFreeBmp Then _WinAPI_DeleteObject($hBitmap)
_GDIPlus_Shutdown()
Return SetError($bRet = False, 0, $bRet)
EndFunc
Global Enum $ARRAYFILL_FORCE_DEFAULT, $ARRAYFILL_FORCE_SINGLEITEM, $ARRAYFILL_FORCE_INT, $ARRAYFILL_FORCE_NUMBER, $ARRAYFILL_FORCE_PTR, $ARRAYFILL_FORCE_HWND, $ARRAYFILL_FORCE_STRING
Func _ArrayAdd(ByRef $aArray, $vValue, $iStart = 0, $sDelim_Item = "|", $sDelim_Row = @CRLF, $iForce = $ARRAYFILL_FORCE_DEFAULT)
If $iStart = Default Then $iStart = 0
If $sDelim_Item = Default Then $sDelim_Item = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iForce = Default Then $iForce = $ARRAYFILL_FORCE_DEFAULT
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
Local $hDataType = 0
Switch $iForce
Case $ARRAYFILL_FORCE_INT
$hDataType = Int
Case $ARRAYFILL_FORCE_NUMBER
$hDataType = Number
Case $ARRAYFILL_FORCE_PTR
$hDataType = Ptr
Case $ARRAYFILL_FORCE_HWND
$hDataType = Hwnd
Case $ARRAYFILL_FORCE_STRING
$hDataType = String
EndSwitch
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iForce = $ARRAYFILL_FORCE_SINGLEITEM Then
ReDim $aArray[$iDim_1 + 1]
$aArray[$iDim_1] = $vValue
Return $iDim_1
EndIf
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(5, 0, -1)
$hDataType = 0
Else
Local $aTmp = StringSplit($vValue, $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
If UBound($aTmp, $UBOUND_ROWS) = 1 Then
$aTmp[0] = $vValue
EndIf
$vValue = $aTmp
EndIf
Local $iAdd = UBound($vValue, $UBOUND_ROWS)
ReDim $aArray[$iDim_1 + $iAdd]
For $i = 0 To $iAdd - 1
If IsFunc($hDataType) Then
$aArray[$iDim_1 + $i] = $hDataType($vValue[$i])
Else
$aArray[$iDim_1 + $i] = $vValue[$i]
EndIf
Next
Return $iDim_1 + $iAdd - 1
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iStart < 0 Or $iStart > $iDim_2 - 1 Then Return SetError(4, 0, -1)
Local $iValDim_1, $iValDim_2 = 0, $iColCount
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 2 Then Return SetError(5, 0, -1)
$iValDim_1 = UBound($vValue, $UBOUND_ROWS)
$iValDim_2 = UBound($vValue, $UBOUND_COLUMNS)
$hDataType = 0
Else
Local $aSplit_1 = StringSplit($vValue, $sDelim_Row, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iValDim_1 = UBound($aSplit_1, $UBOUND_ROWS)
Local $aTmp[$iValDim_1][0], $aSplit_2
For $i = 0 To $iValDim_1 - 1
$aSplit_2 = StringSplit($aSplit_1[$i], $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iColCount = UBound($aSplit_2)
If $iColCount > $iValDim_2 Then
$iValDim_2 = $iColCount
ReDim $aTmp[$iValDim_1][$iValDim_2]
EndIf
For $j = 0 To $iColCount - 1
$aTmp[$i][$j] = $aSplit_2[$j]
Next
Next
$vValue = $aTmp
EndIf
If UBound($vValue, $UBOUND_COLUMNS) + $iStart > UBound($aArray, $UBOUND_COLUMNS) Then Return SetError(3, 0, -1)
ReDim $aArray[$iDim_1 + $iValDim_1][$iDim_2]
For $iWriteTo_Index = 0 To $iValDim_1 - 1
For $j = 0 To $iDim_2 - 1
If $j < $iStart Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = ""
ElseIf $j - $iStart > $iValDim_2 - 1 Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = ""
Else
If IsFunc($hDataType) Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = $hDataType($vValue[$iWriteTo_Index][$j - $iStart])
Else
$aArray[$iWriteTo_Index + $iDim_1][$j] = $vValue[$iWriteTo_Index][$j - $iStart]
EndIf
EndIf
Next
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS) - 1
EndFunc
Func _ArrayColInsert(ByRef $aArray, $iColumn)
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
Local $aTempArray[$iDim_1][2]
Switch $iColumn
Case 0, 1
For $i = 0 To $iDim_1 - 1
$aTempArray[$i][(Not $iColumn)] = $aArray[$i]
Next
Case Else
Return SetError(3, 0, -1)
EndSwitch
$aArray = $aTempArray
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iColumn < 0 Or $iColumn > $iDim_2 Then Return SetError(3, 0, -1)
ReDim $aArray[$iDim_1][$iDim_2 + 1]
For $i = 0 To $iDim_1 - 1
For $j = $iDim_2 To $iColumn + 1 Step -1
$aArray[$i][$j] = $aArray[$i][$j - 1]
Next
$aArray[$i][$iColumn] = ""
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_COLUMNS)
EndFunc
Func _ArrayConcatenate(ByRef $aArrayTarget, Const ByRef $aArraySource, $iStart = 0)
If $iStart = Default Then $iStart = 0
If Not IsArray($aArrayTarget) Then Return SetError(1, 0, -1)
If Not IsArray($aArraySource) Then Return SetError(2, 0, -1)
Local $iDim_Total_Tgt = UBound($aArrayTarget, $UBOUND_DIMENSIONS)
Local $iDim_Total_Src = UBound($aArraySource, $UBOUND_DIMENSIONS)
Local $iDim_1_Tgt = UBound($aArrayTarget, $UBOUND_ROWS)
Local $iDim_1_Src = UBound($aArraySource, $UBOUND_ROWS)
If $iStart < 0 Or $iStart > $iDim_1_Src - 1 Then Return SetError(6, 0, -1)
Switch $iDim_Total_Tgt
Case 1
If $iDim_Total_Src <> 1 Then Return SetError(4, 0, -1)
ReDim $aArrayTarget[$iDim_1_Tgt + $iDim_1_Src - $iStart]
For $i = $iStart To $iDim_1_Src - 1
$aArrayTarget[$iDim_1_Tgt + $i - $iStart] = $aArraySource[$i]
Next
Case 2
If $iDim_Total_Src <> 2 Then Return SetError(4, 0, -1)
Local $iDim_2_Tgt = UBound($aArrayTarget, $UBOUND_COLUMNS)
If UBound($aArraySource, $UBOUND_COLUMNS) <> $iDim_2_Tgt Then Return SetError(5, 0, -1)
ReDim $aArrayTarget[$iDim_1_Tgt + $iDim_1_Src - $iStart][$iDim_2_Tgt]
For $i = $iStart To $iDim_1_Src - 1
For $j = 0 To $iDim_2_Tgt - 1
$aArrayTarget[$iDim_1_Tgt + $i - $iStart][$j] = $aArraySource[$i][$j]
Next
Next
Case Else
Return SetError(3, 0, -1)
EndSwitch
Return UBound($aArrayTarget, $UBOUND_ROWS)
EndFunc
Func _ArrayDelete(ByRef $aArray, $vRange)
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If IsArray($vRange) Then
If UBound($vRange, $UBOUND_DIMENSIONS) <> 1 Or UBound($vRange, $UBOUND_ROWS) < 2 Then Return SetError(4, 0, -1)
Else
Local $iNumber, $aSplit_1, $aSplit_2
$vRange = StringStripWS($vRange, 8)
$aSplit_1 = StringSplit($vRange, ";")
$vRange = ""
For $i = 1 To $aSplit_1[0]
If Not StringRegExp($aSplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(3, 0, -1)
$aSplit_2 = StringSplit($aSplit_1[$i], "-")
Switch $aSplit_2[0]
Case 1
$vRange &= $aSplit_2[1] & ";"
Case 2
If Number($aSplit_2[2]) >= Number($aSplit_2[1]) Then
$iNumber = $aSplit_2[1] - 1
Do
$iNumber += 1
$vRange &= $iNumber & ";"
Until $iNumber = $aSplit_2[2]
EndIf
EndSwitch
Next
$vRange = StringSplit(StringTrimRight($vRange, 1), ";")
EndIf
If $vRange[1] < 0 Or $vRange[$vRange[0]] > $iDim_1 Then Return SetError(5, 0, -1)
Local $iCopyTo_Index = 0
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = 1 To $vRange[0]
$aArray[$vRange[$i]] = ChrW(0xFAB1)
Next
For $iReadFrom_Index = 0 To $iDim_1
If $aArray[$iReadFrom_Index] == ChrW(0xFAB1) Then
ContinueLoop
Else
If $iReadFrom_Index <> $iCopyTo_Index Then
$aArray[$iCopyTo_Index] = $aArray[$iReadFrom_Index]
EndIf
$iCopyTo_Index += 1
EndIf
Next
ReDim $aArray[$iDim_1 - $vRange[0] + 1]
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
For $i = 1 To $vRange[0]
$aArray[$vRange[$i]][0] = ChrW(0xFAB1)
Next
For $iReadFrom_Index = 0 To $iDim_1
If $aArray[$iReadFrom_Index][0] == ChrW(0xFAB1) Then
ContinueLoop
Else
If $iReadFrom_Index <> $iCopyTo_Index Then
For $j = 0 To $iDim_2
$aArray[$iCopyTo_Index][$j] = $aArray[$iReadFrom_Index][$j]
Next
EndIf
$iCopyTo_Index += 1
EndIf
Next
ReDim $aArray[$iDim_1 - $vRange[0] + 1][$iDim_2 + 1]
Case Else
Return SetError(2, 0, False)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS)
EndFunc
Func _ArrayFindAll(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iCase = 0, $iCompare = 0, $iSubItem = 0, $bRow = False)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iCase = Default Then $iCase = 0
If $iCompare = Default Then $iCompare = 0
If $iSubItem = Default Then $iSubItem = 0
If $bRow = Default Then $bRow = False
$iStart = _ArraySearch($aArray, $vValue, $iStart, $iEnd, $iCase, $iCompare, 1, $iSubItem, $bRow)
If @error Then Return SetError(@error, 0, -1)
Local $iIndex = 0, $avResult[UBound($aArray,($bRow ? $UBOUND_COLUMNS : $UBOUND_ROWS))]
Do
$avResult[$iIndex] = $iStart
$iIndex += 1
$iStart = _ArraySearch($aArray, $vValue, $iStart + 1, $iEnd, $iCase, $iCompare, 1, $iSubItem, $bRow)
Until @error
ReDim $avResult[$iIndex]
Return $avResult
EndFunc
Func _ArrayMax(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
Local $iResult = _ArrayMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem)
If @error Then Return SetError(@error, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then
Return $aArray[$iResult]
Else
Return $aArray[$iResult][$iSubItem]
EndIf
EndFunc
Func _ArrayMaxIndex(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If $iSubItem = Default Then $iSubItem = 0
Local $iRet = __Array_MinMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, __Array_GreaterThan)
Return SetError(@error, 0, $iRet)
EndFunc
Func _ArrayPop(ByRef $aArray)
If(Not IsArray($aArray)) Then Return SetError(1, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(2, 0, "")
Local $iUBound = UBound($aArray) - 1
If $iUBound = -1 Then Return SetError(3, 0, "")
Local $sLastVal = $aArray[$iUBound]
If $iUBound > -1 Then
ReDim $aArray[$iUBound]
EndIf
Return $sLastVal
EndFunc
Func _ArrayReverse(ByRef $aArray, $iStart = 0, $iEnd = 0)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(3, 0, 0)
If Not UBound($aArray) Then Return SetError(4, 0, 0)
Local $vTmp, $iUBound = UBound($aArray) - 1
If $iEnd < 1 Or $iEnd > $iUBound Then $iEnd = $iUBound
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(2, 0, 0)
For $i = $iStart To Int(($iStart + $iEnd - 1) / 2)
$vTmp = $aArray[$i]
$aArray[$i] = $aArray[$iEnd]
$aArray[$iEnd] = $vTmp
$iEnd -= 1
Next
Return 1
EndFunc
Func _ArraySearch(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iCase = 0, $iCompare = 0, $iForward = 1, $iSubItem = -1, $bRow = False)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iCase = Default Then $iCase = 0
If $iCompare = Default Then $iCompare = 0
If $iForward = Default Then $iForward = 1
If $iSubItem = Default Then $iSubItem = -1
If $bRow = Default Then $bRow = False
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray) - 1
If $iDim_1 = -1 Then Return SetError(3, 0, -1)
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
Local $bCompType = False
If $iCompare = 2 Then
$iCompare = 0
$bCompType = True
EndIf
If $bRow Then
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then Return SetError(5, 0, -1)
If $iEnd < 1 Or $iEnd > $iDim_2 Then $iEnd = $iDim_2
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Else
If $iEnd < 1 Or $iEnd > $iDim_1 Then $iEnd = $iDim_1
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
EndIf
Local $iStep = 1
If Not $iForward Then
Local $iTmp = $iStart
$iStart = $iEnd
$iEnd = $iTmp
$iStep = -1
EndIf
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If Not $iCompare Then
If Not $iCase Then
For $i = $iStart To $iEnd Step $iStep
If $bCompType And VarGetType($aArray[$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i] = $vValue Then Return $i
Next
Else
For $i = $iStart To $iEnd Step $iStep
If $bCompType And VarGetType($aArray[$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i] == $vValue Then Return $i
Next
EndIf
Else
For $i = $iStart To $iEnd Step $iStep
If $iCompare = 3 Then
If StringRegExp($aArray[$i], $vValue) Then Return $i
Else
If StringInStr($aArray[$i], $vValue, $iCase) > 0 Then Return $i
EndIf
Next
EndIf
Case 2
Local $iDim_Sub
If $bRow Then
$iDim_Sub = $iDim_1
If $iSubItem > $iDim_Sub Then $iSubItem = $iDim_Sub
If $iSubItem < 0 Then
$iSubItem = 0
Else
$iDim_Sub = $iSubItem
EndIf
Else
$iDim_Sub = $iDim_2
If $iSubItem > $iDim_Sub Then $iSubItem = $iDim_Sub
If $iSubItem < 0 Then
$iSubItem = 0
Else
$iDim_Sub = $iSubItem
EndIf
EndIf
For $j = $iSubItem To $iDim_Sub
If Not $iCompare Then
If Not $iCase Then
For $i = $iStart To $iEnd Step $iStep
If $bRow Then
If $bCompType And VarGetType($aArray[$j][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$j][$i] = $vValue Then Return $i
Else
If $bCompType And VarGetType($aArray[$i][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i][$j] = $vValue Then Return $i
EndIf
Next
Else
For $i = $iStart To $iEnd Step $iStep
If $bRow Then
If $bCompType And VarGetType($aArray[$j][$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$j][$i] == $vValue Then Return $i
Else
If $bCompType And VarGetType($aArray[$i][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i][$j] == $vValue Then Return $i
EndIf
Next
EndIf
Else
For $i = $iStart To $iEnd Step $iStep
If $iCompare = 3 Then
If $bRow Then
If StringRegExp($aArray[$j][$i], $vValue) Then Return $i
Else
If StringRegExp($aArray[$i][$j], $vValue) Then Return $i
EndIf
Else
If $bRow Then
If StringInStr($aArray[$j][$i], $vValue, $iCase) > 0 Then Return $i
Else
If StringInStr($aArray[$i][$j], $vValue, $iCase) > 0 Then Return $i
EndIf
EndIf
Next
EndIf
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return SetError(6, 0, -1)
EndFunc
Func _ArrayShuffle(ByRef $aArray, $iStart_Row = 0, $iEnd_Row = 0, $iCol = -1)
If $iStart_Row = Default Then $iStart_Row = 0
If $iEnd_Row = Default Then $iEnd_Row = 0
If $iCol = Default Then $iCol = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
If $iEnd_Row = 0 Then $iEnd_Row = $iDim_1 - 1
If $iStart_Row < 0 Or $iStart_Row > $iDim_1 - 1 Then Return SetError(3, 0, -1)
If $iEnd_Row < 1 Or $iEnd_Row > $iDim_1 - 1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Local $vTmp, $iRand
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = $iEnd_Row To $iStart_Row + 1 Step -1
$iRand = Random($iStart_Row, $i, 1)
$vTmp = $aArray[$i]
$aArray[$i] = $aArray[$iRand]
$aArray[$iRand] = $vTmp
Next
Return 1
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iCol < -1 Or $iCol > $iDim_2 - 1 Then Return SetError(5, 0, -1)
Local $iCol_Start, $iCol_End
If $iCol = -1 Then
$iCol_Start = 0
$iCol_End = $iDim_2 - 1
Else
$iCol_Start = $iCol
$iCol_End = $iCol
EndIf
For $i = $iEnd_Row To $iStart_Row + 1 Step -1
$iRand = Random($iStart_Row, $i, 1)
For $j = $iCol_Start To $iCol_End
$vTmp = $aArray[$i][$j]
$aArray[$i][$j] = $aArray[$iRand][$j]
$aArray[$iRand][$j] = $vTmp
Next
Next
Return 1
Case Else
Return SetError(2, 0, -1)
EndSwitch
EndFunc
Func _ArraySort(ByRef $aArray, $iDescending = 0, $iStart = 0, $iEnd = 0, $iSubItem = 0, $iPivot = 0)
If $iDescending = Default Then $iDescending = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If $iPivot = Default Then $iPivot = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
Local $iUBound = UBound($aArray) - 1
If $iUBound = -1 Then Return SetError(5, 0, 0)
If $iEnd = Default Then $iEnd = 0
If $iEnd < 1 Or $iEnd > $iUBound Or $iEnd = Default Then $iEnd = $iUBound
If $iStart < 0 Or $iStart = Default Then $iStart = 0
If $iStart > $iEnd Then Return SetError(2, 0, 0)
If $iDescending = Default Then $iDescending = 0
If $iPivot = Default Then $iPivot = 0
If $iSubItem = Default Then $iSubItem = 0
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iPivot Then
__ArrayDualPivotSort($aArray, $iStart, $iEnd)
Else
__ArrayQuickSort1D($aArray, $iStart, $iEnd)
EndIf
If $iDescending Then _ArrayReverse($aArray, $iStart, $iEnd)
Case 2
If $iPivot Then Return SetError(6, 0, 0)
Local $iSubMax = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iSubItem > $iSubMax Then Return SetError(3, 0, 0)
If $iDescending Then
$iDescending = -1
Else
$iDescending = 1
EndIf
__ArrayQuickSort2D($aArray, $iDescending, $iStart, $iEnd, $iSubItem, $iSubMax)
Case Else
Return SetError(4, 0, 0)
EndSwitch
Return 1
EndFunc
Func __ArrayQuickSort1D(ByRef $aArray, Const ByRef $iStart, Const ByRef $iEnd)
If $iEnd <= $iStart Then Return
Local $vTmp
If($iEnd - $iStart) < 15 Then
Local $vCur
For $i = $iStart + 1 To $iEnd
$vTmp = $aArray[$i]
If IsNumber($vTmp) Then
For $j = $i - 1 To $iStart Step -1
$vCur = $aArray[$j]
If($vTmp >= $vCur And IsNumber($vCur)) Or(Not IsNumber($vCur) And StringCompare($vTmp, $vCur) >= 0) Then ExitLoop
$aArray[$j + 1] = $vCur
Next
Else
For $j = $i - 1 To $iStart Step -1
If(StringCompare($vTmp, $aArray[$j]) >= 0) Then ExitLoop
$aArray[$j + 1] = $aArray[$j]
Next
EndIf
$aArray[$j + 1] = $vTmp
Next
Return
EndIf
Local $L = $iStart, $R = $iEnd, $vPivot = $aArray[Int(($iStart + $iEnd) / 2)], $bNum = IsNumber($vPivot)
Do
If $bNum Then
While($aArray[$L] < $vPivot And IsNumber($aArray[$L])) Or(Not IsNumber($aArray[$L]) And StringCompare($aArray[$L], $vPivot) < 0)
$L += 1
WEnd
While($aArray[$R] > $vPivot And IsNumber($aArray[$R])) Or(Not IsNumber($aArray[$R]) And StringCompare($aArray[$R], $vPivot) > 0)
$R -= 1
WEnd
Else
While(StringCompare($aArray[$L], $vPivot) < 0)
$L += 1
WEnd
While(StringCompare($aArray[$R], $vPivot) > 0)
$R -= 1
WEnd
EndIf
If $L <= $R Then
$vTmp = $aArray[$L]
$aArray[$L] = $aArray[$R]
$aArray[$R] = $vTmp
$L += 1
$R -= 1
EndIf
Until $L > $R
__ArrayQuickSort1D($aArray, $iStart, $R)
__ArrayQuickSort1D($aArray, $L, $iEnd)
EndFunc
Func __ArrayQuickSort2D(ByRef $aArray, Const ByRef $iStep, Const ByRef $iStart, Const ByRef $iEnd, Const ByRef $iSubItem, Const ByRef $iSubMax)
If $iEnd <= $iStart Then Return
Local $vTmp, $L = $iStart, $R = $iEnd, $vPivot = $aArray[Int(($iStart + $iEnd) / 2)][$iSubItem], $bNum = IsNumber($vPivot)
Do
If $bNum Then
While($iStep *($aArray[$L][$iSubItem] - $vPivot) < 0 And IsNumber($aArray[$L][$iSubItem])) Or(Not IsNumber($aArray[$L][$iSubItem]) And $iStep * StringCompare($aArray[$L][$iSubItem], $vPivot) < 0)
$L += 1
WEnd
While($iStep *($aArray[$R][$iSubItem] - $vPivot) > 0 And IsNumber($aArray[$R][$iSubItem])) Or(Not IsNumber($aArray[$R][$iSubItem]) And $iStep * StringCompare($aArray[$R][$iSubItem], $vPivot) > 0)
$R -= 1
WEnd
Else
While($iStep * StringCompare($aArray[$L][$iSubItem], $vPivot) < 0)
$L += 1
WEnd
While($iStep * StringCompare($aArray[$R][$iSubItem], $vPivot) > 0)
$R -= 1
WEnd
EndIf
If $L <= $R Then
For $i = 0 To $iSubMax
$vTmp = $aArray[$L][$i]
$aArray[$L][$i] = $aArray[$R][$i]
$aArray[$R][$i] = $vTmp
Next
$L += 1
$R -= 1
EndIf
Until $L > $R
__ArrayQuickSort2D($aArray, $iStep, $iStart, $R, $iSubItem, $iSubMax)
__ArrayQuickSort2D($aArray, $iStep, $L, $iEnd, $iSubItem, $iSubMax)
EndFunc
Func __ArrayDualPivotSort(ByRef $aArray, $iPivot_Left, $iPivot_Right, $bLeftMost = True)
If $iPivot_Left > $iPivot_Right Then Return
Local $iLength = $iPivot_Right - $iPivot_Left + 1
Local $i, $j, $k, $iAi, $iAk, $iA1, $iA2, $iLast
If $iLength < 45 Then
If $bLeftMost Then
$i = $iPivot_Left
While $i < $iPivot_Right
$j = $i
$iAi = $aArray[$i + 1]
While $iAi < $aArray[$j]
$aArray[$j + 1] = $aArray[$j]
$j -= 1
If $j + 1 = $iPivot_Left Then ExitLoop
WEnd
$aArray[$j + 1] = $iAi
$i += 1
WEnd
Else
While 1
If $iPivot_Left >= $iPivot_Right Then Return 1
$iPivot_Left += 1
If $aArray[$iPivot_Left] < $aArray[$iPivot_Left - 1] Then ExitLoop
WEnd
While 1
$k = $iPivot_Left
$iPivot_Left += 1
If $iPivot_Left > $iPivot_Right Then ExitLoop
$iA1 = $aArray[$k]
$iA2 = $aArray[$iPivot_Left]
If $iA1 < $iA2 Then
$iA2 = $iA1
$iA1 = $aArray[$iPivot_Left]
EndIf
$k -= 1
While $iA1 < $aArray[$k]
$aArray[$k + 2] = $aArray[$k]
$k -= 1
WEnd
$aArray[$k + 2] = $iA1
While $iA2 < $aArray[$k]
$aArray[$k + 1] = $aArray[$k]
$k -= 1
WEnd
$aArray[$k + 1] = $iA2
$iPivot_Left += 1
WEnd
$iLast = $aArray[$iPivot_Right]
$iPivot_Right -= 1
While $iLast < $aArray[$iPivot_Right]
$aArray[$iPivot_Right + 1] = $aArray[$iPivot_Right]
$iPivot_Right -= 1
WEnd
$aArray[$iPivot_Right + 1] = $iLast
EndIf
Return 1
EndIf
Local $iSeventh = BitShift($iLength, 3) + BitShift($iLength, 6) + 1
Local $iE1, $iE2, $iE3, $iE4, $iE5, $t
$iE3 = Ceiling(($iPivot_Left + $iPivot_Right) / 2)
$iE2 = $iE3 - $iSeventh
$iE1 = $iE2 - $iSeventh
$iE4 = $iE3 + $iSeventh
$iE5 = $iE4 + $iSeventh
If $aArray[$iE2] < $aArray[$iE1] Then
$t = $aArray[$iE2]
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
If $aArray[$iE3] < $aArray[$iE2] Then
$t = $aArray[$iE3]
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
If $aArray[$iE4] < $aArray[$iE3] Then
$t = $aArray[$iE4]
$aArray[$iE4] = $aArray[$iE3]
$aArray[$iE3] = $t
If $t < $aArray[$iE2] Then
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
EndIf
If $aArray[$iE5] < $aArray[$iE4] Then
$t = $aArray[$iE5]
$aArray[$iE5] = $aArray[$iE4]
$aArray[$iE4] = $t
If $t < $aArray[$iE3] Then
$aArray[$iE4] = $aArray[$iE3]
$aArray[$iE3] = $t
If $t < $aArray[$iE2] Then
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
EndIf
EndIf
Local $iLess = $iPivot_Left
Local $iGreater = $iPivot_Right
If(($aArray[$iE1] <> $aArray[$iE2]) And($aArray[$iE2] <> $aArray[$iE3]) And($aArray[$iE3] <> $aArray[$iE4]) And($aArray[$iE4] <> $aArray[$iE5])) Then
Local $iPivot_1 = $aArray[$iE2]
Local $iPivot_2 = $aArray[$iE4]
$aArray[$iE2] = $aArray[$iPivot_Left]
$aArray[$iE4] = $aArray[$iPivot_Right]
Do
$iLess += 1
Until $aArray[$iLess] >= $iPivot_1
Do
$iGreater -= 1
Until $aArray[$iGreater] <= $iPivot_2
$k = $iLess
While $k <= $iGreater
$iAk = $aArray[$k]
If $iAk < $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
ElseIf $iAk > $iPivot_2 Then
While $aArray[$iGreater] > $iPivot_2
$iGreater -= 1
If $iGreater + 1 = $k Then ExitLoop 2
WEnd
If $aArray[$iGreater] < $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $aArray[$iGreater]
$iLess += 1
Else
$aArray[$k] = $aArray[$iGreater]
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
$aArray[$iPivot_Left] = $aArray[$iLess - 1]
$aArray[$iLess - 1] = $iPivot_1
$aArray[$iPivot_Right] = $aArray[$iGreater + 1]
$aArray[$iGreater + 1] = $iPivot_2
__ArrayDualPivotSort($aArray, $iPivot_Left, $iLess - 2, True)
__ArrayDualPivotSort($aArray, $iGreater + 2, $iPivot_Right, False)
If($iLess < $iE1) And($iE5 < $iGreater) Then
While $aArray[$iLess] = $iPivot_1
$iLess += 1
WEnd
While $aArray[$iGreater] = $iPivot_2
$iGreater -= 1
WEnd
$k = $iLess
While $k <= $iGreater
$iAk = $aArray[$k]
If $iAk = $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
ElseIf $iAk = $iPivot_2 Then
While $aArray[$iGreater] = $iPivot_2
$iGreater -= 1
If $iGreater + 1 = $k Then ExitLoop 2
WEnd
If $aArray[$iGreater] = $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iPivot_1
$iLess += 1
Else
$aArray[$k] = $aArray[$iGreater]
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
EndIf
__ArrayDualPivotSort($aArray, $iLess, $iGreater, False)
Else
Local $iPivot = $aArray[$iE3]
$k = $iLess
While $k <= $iGreater
If $aArray[$k] = $iPivot Then
$k += 1
ContinueLoop
EndIf
$iAk = $aArray[$k]
If $iAk < $iPivot Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
Else
While $aArray[$iGreater] > $iPivot
$iGreater -= 1
WEnd
If $aArray[$iGreater] < $iPivot Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $aArray[$iGreater]
$iLess += 1
Else
$aArray[$k] = $iPivot
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
__ArrayDualPivotSort($aArray, $iPivot_Left, $iLess - 1, True)
__ArrayDualPivotSort($aArray, $iGreater + 1, $iPivot_Right, False)
EndIf
EndFunc
Func _ArrayToString(Const ByRef $aArray, $sDelim_Col = "|", $iStart_Row = -1, $iEnd_Row = -1, $sDelim_Row = @CRLF, $iStart_Col = -1, $iEnd_Col = -1)
If $sDelim_Col = Default Then $sDelim_Col = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iStart_Row = Default Then $iStart_Row = -1
If $iEnd_Row = Default Then $iEnd_Row = -1
If $iStart_Col = Default Then $iStart_Col = -1
If $iEnd_Col = Default Then $iEnd_Col = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iStart_Row = -1 Then $iStart_Row = 0
If $iEnd_Row = -1 Then $iEnd_Row = $iDim_1
If $iStart_Row < -1 Or $iEnd_Row < -1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iDim_1 Or $iEnd_Row > $iDim_1 Then Return SetError(3, 0, "")
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Local $sRet = ""
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = $iStart_Row To $iEnd_Row
$sRet &= $aArray[$i] & $sDelim_Col
Next
Return StringTrimRight($sRet, StringLen($sDelim_Col))
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iStart_Col = -1 Then $iStart_Col = 0
If $iEnd_Col = -1 Then $iEnd_Col = $iDim_2
If $iStart_Col < -1 Or $iEnd_Col < -1 Then Return SetError(5, 0, -1)
If $iStart_Col > $iDim_2 Or $iEnd_Col > $iDim_2 Then Return SetError(5, 0, -1)
If $iStart_Col > $iEnd_Col Then Return SetError(6, 0, -1)
For $i = $iStart_Row To $iEnd_Row
For $j = $iStart_Col To $iEnd_Col
$sRet &= $aArray[$i][$j] & $sDelim_Col
Next
$sRet = StringTrimRight($sRet, StringLen($sDelim_Col)) & $sDelim_Row
Next
Return StringTrimRight($sRet, StringLen($sDelim_Row))
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func __Array_MinMaxIndex(Const ByRef $aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, $fuComparison)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iCompNumeric <> 1 Then $iCompNumeric = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iDim_1 < 0 Then Return SetError(1, 0, -1)
If $iEnd = -1 Then $iEnd = $iDim_1
If $iStart = -1 Then $iStart = 0
If $iStart < -1 Or $iEnd < -1 Then Return SetError(3, 0, -1)
If $iStart > $iDim_1 Or $iEnd > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart > $iEnd Then Return SetError(4, 0, -1)
If $iDim_1 < 0 Then Return SetError(5, 0, -1)
Local $iMaxMinIndex = $iStart
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iCompNumeric Then
For $i = $iStart To $iEnd
If $fuComparison(Number($aArray[$i]), Number($aArray[$iMaxMinIndex])) Then $iMaxMinIndex = $i
Next
Else
For $i = $iStart To $iEnd
If $fuComparison($aArray[$i], $aArray[$iMaxMinIndex]) Then $iMaxMinIndex = $i
Next
EndIf
Case 2
If $iSubItem < 0 Or $iSubItem > UBound($aArray, $UBOUND_COLUMNS) - 1 Then Return SetError(6, 0, -1)
If $iCompNumeric Then
For $i = $iStart To $iEnd
If $fuComparison(Number($aArray[$i][$iSubItem]), Number($aArray[$iMaxMinIndex][$iSubItem])) Then $iMaxMinIndex = $i
Next
Else
For $i = $iStart To $iEnd
If $fuComparison($aArray[$i][$iSubItem], $aArray[$iMaxMinIndex][$iSubItem]) Then $iMaxMinIndex = $i
Next
EndIf
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return $iMaxMinIndex
EndFunc
Func __Array_GreaterThan($vValue1, $vValue2)
Return $vValue1 > $vValue2
EndFunc
Global Const $DMW_SHORTNAME = 1
Global Const $DMW_LOCALE_LONGNAME = 2
Func _WinAPI_GetDateFormat($iLCID = 0, $tSYSTEMTIME = 0, $iFlags = 0, $sFormat = '')
If Not $iLCID Then $iLCID = 0x0400
Local $sTypeOfFormat = 'wstr'
If Not StringStripWS($sFormat, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfFormat = 'ptr'
$sFormat = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'int', 'GetDateFormatW', 'dword', $iLCID, 'dword', $iFlags, 'struct*', $tSYSTEMTIME, $sTypeOfFormat, $sFormat, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[5]
EndFunc
Func _WinAPI_GetLocaleInfo($iLCID, $iType)
Local $aRet = DllCall('kernel32.dll', 'int', 'GetLocaleInfoW', 'dword', $iLCID, 'dword', $iType, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[3]
EndFunc
Func _DateAdd($sType, $iNumber, $sDate)
Local $asTimePart[4]
Local $asDatePart[4]
Local $iJulianDate
$sType = StringLeft($sType, 1)
If StringInStr("D,M,Y,w,h,n,s", $sType) = 0 Or $sType = "" Then
Return SetError(1, 0, 0)
EndIf
If Not StringIsInt($iNumber) Then
Return SetError(2, 0, 0)
EndIf
If Not _DateIsValid($sDate) Then
Return SetError(3, 0, 0)
EndIf
_DateTimeSplit($sDate, $asDatePart, $asTimePart)
If $sType = "d" Or $sType = "w" Then
If $sType = "w" Then $iNumber = $iNumber * 7
$iJulianDate = _DateToDayValue($asDatePart[1], $asDatePart[2], $asDatePart[3]) + $iNumber
_DayValueToDate($iJulianDate, $asDatePart[1], $asDatePart[2], $asDatePart[3])
EndIf
If $sType = "m" Then
$asDatePart[2] = $asDatePart[2] + $iNumber
While $asDatePart[2] > 12
$asDatePart[2] = $asDatePart[2] - 12
$asDatePart[1] = $asDatePart[1] + 1
WEnd
While $asDatePart[2] < 1
$asDatePart[2] = $asDatePart[2] + 12
$asDatePart[1] = $asDatePart[1] - 1
WEnd
EndIf
If $sType = "y" Then
$asDatePart[1] = $asDatePart[1] + $iNumber
EndIf
If $sType = "h" Or $sType = "n" Or $sType = "s" Then
Local $iTimeVal = _TimeToTicks($asTimePart[1], $asTimePart[2], $asTimePart[3]) / 1000
If $sType = "h" Then $iTimeVal = $iTimeVal + $iNumber * 3600
If $sType = "n" Then $iTimeVal = $iTimeVal + $iNumber * 60
If $sType = "s" Then $iTimeVal = $iTimeVal + $iNumber
Local $iDay2Add = Int($iTimeVal /(24 * 60 * 60))
$iTimeVal = $iTimeVal - $iDay2Add * 24 * 60 * 60
If $iTimeVal < 0 Then
$iDay2Add = $iDay2Add - 1
$iTimeVal = $iTimeVal + 24 * 60 * 60
EndIf
$iJulianDate = _DateToDayValue($asDatePart[1], $asDatePart[2], $asDatePart[3]) + $iDay2Add
_DayValueToDate($iJulianDate, $asDatePart[1], $asDatePart[2], $asDatePart[3])
_TicksToTime($iTimeVal * 1000, $asTimePart[1], $asTimePart[2], $asTimePart[3])
EndIf
Local $iNumDays = _DaysInMonth($asDatePart[1])
If $iNumDays[$asDatePart[2]] < $asDatePart[3] Then $asDatePart[3] = $iNumDays[$asDatePart[2]]
$sDate = $asDatePart[1] & '/' & StringRight("0" & $asDatePart[2], 2) & '/' & StringRight("0" & $asDatePart[3], 2)
If $asTimePart[0] > 0 Then
If $asTimePart[0] > 2 Then
$sDate = $sDate & " " & StringRight("0" & $asTimePart[1], 2) & ':' & StringRight("0" & $asTimePart[2], 2) & ':' & StringRight("0" & $asTimePart[3], 2)
Else
$sDate = $sDate & " " & StringRight("0" & $asTimePart[1], 2) & ':' & StringRight("0" & $asTimePart[2], 2)
EndIf
EndIf
Return $sDate
EndFunc
Func _DateDayOfWeek($iDayNum, $iFormat = Default)
Local Const $MONDAY_IS_NO1 = 128
If $iFormat = Default Then $iFormat = 0
$iDayNum = Int($iDayNum)
If $iDayNum < 1 Or $iDayNum > 7 Then Return SetError(1, 0, "")
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSYSTEMTIME, "Year", BitAND($iFormat, $MONDAY_IS_NO1) ? 2007 : 2006)
DllStructSetData($tSYSTEMTIME, "Month", 1)
DllStructSetData($tSYSTEMTIME, "Day", $iDayNum)
Return _WinAPI_GetDateFormat(BitAND($iFormat, $DMW_LOCALE_LONGNAME) ? $LOCALE_USER_DEFAULT : $LOCALE_INVARIANT, $tSYSTEMTIME, 0, BitAND($iFormat, $DMW_SHORTNAME) ? "ddd" : "dddd")
EndFunc
Func _DateDiff($sType, $sStartDate, $sEndDate)
$sType = StringLeft($sType, 1)
If StringInStr("d,m,y,w,h,n,s", $sType) = 0 Or $sType = "" Then
Return SetError(1, 0, 0)
EndIf
If Not _DateIsValid($sStartDate) Then
Return SetError(2, 0, 0)
EndIf
If Not _DateIsValid($sEndDate) Then
Return SetError(3, 0, 0)
EndIf
Local $asStartDatePart[4], $asStartTimePart[4], $asEndDatePart[4], $asEndTimePart[4]
_DateTimeSplit($sStartDate, $asStartDatePart, $asStartTimePart)
_DateTimeSplit($sEndDate, $asEndDatePart, $asEndTimePart)
Local $aDaysDiff = _DateToDayValue($asEndDatePart[1], $asEndDatePart[2], $asEndDatePart[3]) - _DateToDayValue($asStartDatePart[1], $asStartDatePart[2], $asStartDatePart[3])
Local $iTimeDiff, $iYearDiff, $iStartTimeInSecs, $iEndTimeInSecs
If $asStartTimePart[0] > 1 And $asEndTimePart[0] > 1 Then
$iStartTimeInSecs = $asStartTimePart[1] * 3600 + $asStartTimePart[2] * 60 + $asStartTimePart[3]
$iEndTimeInSecs = $asEndTimePart[1] * 3600 + $asEndTimePart[2] * 60 + $asEndTimePart[3]
$iTimeDiff = $iEndTimeInSecs - $iStartTimeInSecs
If $iTimeDiff < 0 Then
$aDaysDiff = $aDaysDiff - 1
$iTimeDiff = $iTimeDiff + 24 * 60 * 60
EndIf
Else
$iTimeDiff = 0
EndIf
Select
Case $sType = "d"
Return $aDaysDiff
Case $sType = "m"
$iYearDiff = $asEndDatePart[1] - $asStartDatePart[1]
Local $iMonthDiff = $asEndDatePart[2] - $asStartDatePart[2] + $iYearDiff * 12
If $asEndDatePart[3] < $asStartDatePart[3] Then $iMonthDiff = $iMonthDiff - 1
$iStartTimeInSecs = $asStartTimePart[1] * 3600 + $asStartTimePart[2] * 60 + $asStartTimePart[3]
$iEndTimeInSecs = $asEndTimePart[1] * 3600 + $asEndTimePart[2] * 60 + $asEndTimePart[3]
$iTimeDiff = $iEndTimeInSecs - $iStartTimeInSecs
If $asEndDatePart[3] = $asStartDatePart[3] And $iTimeDiff < 0 Then $iMonthDiff = $iMonthDiff - 1
Return $iMonthDiff
Case $sType = "y"
$iYearDiff = $asEndDatePart[1] - $asStartDatePart[1]
If $asEndDatePart[2] < $asStartDatePart[2] Then $iYearDiff = $iYearDiff - 1
If $asEndDatePart[2] = $asStartDatePart[2] And $asEndDatePart[3] < $asStartDatePart[3] Then $iYearDiff = $iYearDiff - 1
$iStartTimeInSecs = $asStartTimePart[1] * 3600 + $asStartTimePart[2] * 60 + $asStartTimePart[3]
$iEndTimeInSecs = $asEndTimePart[1] * 3600 + $asEndTimePart[2] * 60 + $asEndTimePart[3]
$iTimeDiff = $iEndTimeInSecs - $iStartTimeInSecs
If $asEndDatePart[2] = $asStartDatePart[2] And $asEndDatePart[3] = $asStartDatePart[3] And $iTimeDiff < 0 Then $iYearDiff = $iYearDiff - 1
Return $iYearDiff
Case $sType = "w"
Return Int($aDaysDiff / 7)
Case $sType = "h"
Return $aDaysDiff * 24 + Int($iTimeDiff / 3600)
Case $sType = "n"
Return $aDaysDiff * 24 * 60 + Int($iTimeDiff / 60)
Case $sType = "s"
Return $aDaysDiff * 24 * 60 * 60 + $iTimeDiff
EndSelect
EndFunc
Func _DateIsLeapYear($iYear)
If StringIsInt($iYear) Then
Select
Case Mod($iYear, 4) = 0 And Mod($iYear, 100) <> 0
Return 1
Case Mod($iYear, 400) = 0
Return 1
Case Else
Return 0
EndSelect
EndIf
Return SetError(1, 0, 0)
EndFunc
Func __DateIsMonth($iNumber)
$iNumber = Int($iNumber)
Return $iNumber >= 1 And $iNumber <= 12
EndFunc
Func _DateIsValid($sDate)
Local $asDatePart[4], $asTimePart[4]
_DateTimeSplit($sDate, $asDatePart, $asTimePart)
If Not StringIsInt($asDatePart[1]) Then Return 0
If Not StringIsInt($asDatePart[2]) Then Return 0
If Not StringIsInt($asDatePart[3]) Then Return 0
$asDatePart[1] = Int($asDatePart[1])
$asDatePart[2] = Int($asDatePart[2])
$asDatePart[3] = Int($asDatePart[3])
Local $iNumDays = _DaysInMonth($asDatePart[1])
If $asDatePart[1] < 1000 Or $asDatePart[1] > 2999 Then Return 0
If $asDatePart[2] < 1 Or $asDatePart[2] > 12 Then Return 0
If $asDatePart[3] < 1 Or $asDatePart[3] > $iNumDays[$asDatePart[2]] Then Return 0
If $asTimePart[0] < 1 Then Return 1
If $asTimePart[0] < 2 Then Return 0
If $asTimePart[0] = 2 Then $asTimePart[3] = "00"
If Not StringIsInt($asTimePart[1]) Then Return 0
If Not StringIsInt($asTimePart[2]) Then Return 0
If Not StringIsInt($asTimePart[3]) Then Return 0
$asTimePart[1] = Int($asTimePart[1])
$asTimePart[2] = Int($asTimePart[2])
$asTimePart[3] = Int($asTimePart[3])
If $asTimePart[1] < 0 Or $asTimePart[1] > 23 Then Return 0
If $asTimePart[2] < 0 Or $asTimePart[2] > 59 Then Return 0
If $asTimePart[3] < 0 Or $asTimePart[3] > 59 Then Return 0
Return 1
EndFunc
Func _DateTimeFormat($sDate, $sType)
Local $asDatePart[4], $asTimePart[4]
Local $sTempDate = "", $sTempTime = ""
Local $sAM, $sPM, $sTempString = ""
If Not _DateIsValid($sDate) Then
Return SetError(1, 0, "")
EndIf
If $sType < 0 Or $sType > 5 Or Not IsInt($sType) Then
Return SetError(2, 0, "")
EndIf
_DateTimeSplit($sDate, $asDatePart, $asTimePart)
Switch $sType
Case 0
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SSHORTDATE)
If Not @error And Not($sTempString = '') Then
$sTempDate = $sTempString
Else
$sTempDate = "M/d/yyyy"
EndIf
If $asTimePart[0] > 1 Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIMEFORMAT)
If Not @error And Not($sTempString = '') Then
$sTempTime = $sTempString
Else
$sTempTime = "h:mm:ss tt"
EndIf
EndIf
Case 1
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SLONGDATE)
If Not @error And Not($sTempString = '') Then
$sTempDate = $sTempString
Else
$sTempDate = "dddd, MMMM dd, yyyy"
EndIf
Case 2
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SSHORTDATE)
If Not @error And Not($sTempString = '') Then
$sTempDate = $sTempString
Else
$sTempDate = "M/d/yyyy"
EndIf
Case 3
If $asTimePart[0] > 1 Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIMEFORMAT)
If Not @error And Not($sTempString = '') Then
$sTempTime = $sTempString
Else
$sTempTime = "h:mm:ss tt"
EndIf
EndIf
Case 4
If $asTimePart[0] > 1 Then
$sTempTime = "hh:mm"
EndIf
Case 5
If $asTimePart[0] > 1 Then
$sTempTime = "hh:mm:ss"
EndIf
EndSwitch
If $sTempDate <> "" Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SDATE)
If Not @error And Not($sTempString = '') Then
$sTempDate = StringReplace($sTempDate, "/", $sTempString)
EndIf
Local $iWday = _DateToDayOfWeek($asDatePart[1], $asDatePart[2], $asDatePart[3])
$asDatePart[3] = StringRight("0" & $asDatePart[3], 2)
$asDatePart[2] = StringRight("0" & $asDatePart[2], 2)
$sTempDate = StringReplace($sTempDate, "d", "@")
$sTempDate = StringReplace($sTempDate, "m", "#")
$sTempDate = StringReplace($sTempDate, "y", "&")
$sTempDate = StringReplace($sTempDate, "@@@@", _DateDayOfWeek($iWday, 0))
$sTempDate = StringReplace($sTempDate, "@@@", _DateDayOfWeek($iWday, 1))
$sTempDate = StringReplace($sTempDate, "@@", $asDatePart[3])
$sTempDate = StringReplace($sTempDate, "@", StringReplace(StringLeft($asDatePart[3], 1), "0", "") & StringRight($asDatePart[3], 1))
$sTempDate = StringReplace($sTempDate, "####", _DateToMonth($asDatePart[2], 0))
$sTempDate = StringReplace($sTempDate, "###", _DateToMonth($asDatePart[2], 1))
$sTempDate = StringReplace($sTempDate, "##", $asDatePart[2])
$sTempDate = StringReplace($sTempDate, "#", StringReplace(StringLeft($asDatePart[2], 1), "0", "") & StringRight($asDatePart[2], 1))
$sTempDate = StringReplace($sTempDate, "&&&&", $asDatePart[1])
$sTempDate = StringReplace($sTempDate, "&&", StringRight($asDatePart[1], 2))
EndIf
If $sTempTime <> "" Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_S1159)
If Not @error And Not($sTempString = '') Then
$sAM = $sTempString
Else
$sAM = "AM"
EndIf
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_S2359)
If Not @error And Not($sTempString = '') Then
$sPM = $sTempString
Else
$sPM = "PM"
EndIf
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIME)
If Not @error And Not($sTempString = '') Then
$sTempTime = StringReplace($sTempTime, ":", $sTempString)
EndIf
If StringInStr($sTempTime, "tt") Then
If $asTimePart[1] < 12 Then
$sTempTime = StringReplace($sTempTime, "tt", $sAM)
If $asTimePart[1] = 0 Then $asTimePart[1] = 12
Else
$sTempTime = StringReplace($sTempTime, "tt", $sPM)
If $asTimePart[1] > 12 Then $asTimePart[1] = $asTimePart[1] - 12
EndIf
EndIf
$asTimePart[1] = StringRight("0" & $asTimePart[1], 2)
$asTimePart[2] = StringRight("0" & $asTimePart[2], 2)
$asTimePart[3] = StringRight("0" & $asTimePart[3], 2)
$sTempTime = StringReplace($sTempTime, "hh", StringFormat("%02d", $asTimePart[1]))
$sTempTime = StringReplace($sTempTime, "h", StringReplace(StringLeft($asTimePart[1], 1), "0", "") & StringRight($asTimePart[1], 1))
$sTempTime = StringReplace($sTempTime, "mm", StringFormat("%02d", $asTimePart[2]))
$sTempTime = StringReplace($sTempTime, "ss", StringFormat("%02d", $asTimePart[3]))
$sTempDate = StringStripWS($sTempDate & " " & $sTempTime, $STR_STRIPLEADING + $STR_STRIPTRAILING)
EndIf
Return $sTempDate
EndFunc
Func _DateTimeSplit($sDate, ByRef $aDatePart, ByRef $iTimePart)
Local $sDateTime = StringSplit($sDate, " T")
If $sDateTime[0] > 0 Then $aDatePart = StringSplit($sDateTime[1], "/-.")
If $sDateTime[0] > 1 Then
$iTimePart = StringSplit($sDateTime[2], ":")
If UBound($iTimePart) < 4 Then ReDim $iTimePart[4]
Else
Dim $iTimePart[4]
EndIf
If UBound($aDatePart) < 4 Then ReDim $aDatePart[4]
For $x = 1 To 3
If StringIsInt($aDatePart[$x]) Then
$aDatePart[$x] = Int($aDatePart[$x])
Else
$aDatePart[$x] = -1
EndIf
If StringIsInt($iTimePart[$x]) Then
$iTimePart[$x] = Int($iTimePart[$x])
Else
$iTimePart[$x] = 0
EndIf
Next
Return 1
EndFunc
Func _DateToDayOfWeek($iYear, $iMonth, $iDay)
If Not _DateIsValid($iYear & "/" & $iMonth & "/" & $iDay) Then
Return SetError(1, 0, "")
EndIf
Local $i_FactorA = Int((14 - $iMonth) / 12)
Local $i_FactorY = $iYear - $i_FactorA
Local $i_FactorM = $iMonth +(12 * $i_FactorA) - 2
Local $i_FactorD = Mod($iDay + $i_FactorY + Int($i_FactorY / 4) - Int($i_FactorY / 100) + Int($i_FactorY / 400) + Int((31 * $i_FactorM) / 12), 7)
Return $i_FactorD + 1
EndFunc
Func _DateToDayValue($iYear, $iMonth, $iDay)
If Not _DateIsValid(StringFormat("%04d/%02d/%02d", $iYear, $iMonth, $iDay)) Then
Return SetError(1, 0, "")
EndIf
If $iMonth < 3 Then
$iMonth = $iMonth + 12
$iYear = $iYear - 1
EndIf
Local $i_FactorA = Int($iYear / 100)
Local $i_FactorB = Int($i_FactorA / 4)
Local $i_FactorC = 2 - $i_FactorA + $i_FactorB
Local $i_FactorE = Int(1461 *($iYear + 4716) / 4)
Local $i_FactorF = Int(153 *($iMonth + 1) / 5)
Local $iJulianDate = $i_FactorC + $iDay + $i_FactorE + $i_FactorF - 1524.5
Return $iJulianDate
EndFunc
Func _DateToMonth($iMonNum, $iFormat = Default)
If $iFormat = Default Then $iFormat = 0
$iMonNum = Int($iMonNum)
If Not __DateIsMonth($iMonNum) Then Return SetError(1, 0, "")
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSYSTEMTIME, "Year", @YEAR)
DllStructSetData($tSYSTEMTIME, "Month", $iMonNum)
DllStructSetData($tSYSTEMTIME, "Day", 1)
Return _WinAPI_GetDateFormat(BitAND($iFormat, $DMW_LOCALE_LONGNAME) ? $LOCALE_USER_DEFAULT : $LOCALE_INVARIANT, $tSYSTEMTIME, 0, BitAND($iFormat, $DMW_SHORTNAME) ? "MMM" : "MMMM")
EndFunc
Func _DayValueToDate($iJulianDate, ByRef $iYear, ByRef $iMonth, ByRef $iDay)
If $iJulianDate < 0 Or Not IsNumber($iJulianDate) Then
Return SetError(1, 0, 0)
EndIf
Local $i_FactorZ = Int($iJulianDate + 0.5)
Local $i_FactorW = Int(($i_FactorZ - 1867216.25) / 36524.25)
Local $i_FactorX = Int($i_FactorW / 4)
Local $i_FactorA = $i_FactorZ + 1 + $i_FactorW - $i_FactorX
Local $i_FactorB = $i_FactorA + 1524
Local $i_FactorC = Int(($i_FactorB - 122.1) / 365.25)
Local $i_FactorD = Int(365.25 * $i_FactorC)
Local $i_FactorE = Int(($i_FactorB - $i_FactorD) / 30.6001)
Local $i_FactorF = Int(30.6001 * $i_FactorE)
$iDay = $i_FactorB - $i_FactorD - $i_FactorF
If $i_FactorE - 1 < 13 Then
$iMonth = $i_FactorE - 1
Else
$iMonth = $i_FactorE - 13
EndIf
If $iMonth < 3 Then
$iYear = $i_FactorC - 4715
Else
$iYear = $i_FactorC - 4716
EndIf
$iYear = StringFormat("%04d", $iYear)
$iMonth = StringFormat("%02d", $iMonth)
$iDay = StringFormat("%02d", $iDay)
Return $iYear & "/" & $iMonth & "/" & $iDay
EndFunc
Func _Now()
Return _DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC, 0)
EndFunc
Func _NowCalc()
Return @YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC
EndFunc
Func _NowCalcDate()
Return @YEAR & "/" & @MON & "/" & @MDAY
EndFunc
Func _NowDate()
Return _DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY, 0)
EndFunc
Func _NowTime($sType = 3)
If $sType < 3 Or $sType > 5 Then $sType = 3
Return _DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC, $sType)
EndFunc
Func _TicksToTime($iTicks, ByRef $iHours, ByRef $iMins, ByRef $iSecs)
If Number($iTicks) > 0 Then
$iTicks = Int($iTicks / 1000)
$iHours = Int($iTicks / 3600)
$iTicks = Mod($iTicks, 3600)
$iMins = Int($iTicks / 60)
$iSecs = Mod($iTicks, 60)
Return 1
ElseIf Number($iTicks) = 0 Then
$iHours = 0
$iTicks = 0
$iMins = 0
$iSecs = 0
Return 1
Else
Return SetError(1, 0, 0)
EndIf
EndFunc
Func _TimeToTicks($iHours = @HOUR, $iMins = @MIN, $iSecs = @SEC)
If StringIsInt($iHours) And StringIsInt($iMins) And StringIsInt($iSecs) Then
Local $iTicks = 1000 *((3600 * $iHours) +(60 * $iMins) + $iSecs)
Return $iTicks
Else
Return SetError(1, 0, 0)
EndIf
EndFunc
Func _DaysInMonth($iYear)
Local $aDays = [12, 31,(_DateIsLeapYear($iYear) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
Return $aDays
EndFunc
Func _Date_Time_EncodeFileTime($iMonth, $iDay, $iYear, $iHour = 0, $iMinute = 0, $iSecond = 0, $iMSeconds = 0)
Local $tSYSTEMTIME = _Date_Time_EncodeSystemTime($iMonth, $iDay, $iYear, $iHour, $iMinute, $iSecond, $iMSeconds)
Return _Date_Time_SystemTimeToFileTime($tSYSTEMTIME)
EndFunc
Func _Date_Time_EncodeSystemTime($iMonth, $iDay, $iYear, $iHour = 0, $iMinute = 0, $iSecond = 0, $iMSeconds = 0)
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSYSTEMTIME, "Month", $iMonth)
DllStructSetData($tSYSTEMTIME, "Day", $iDay)
DllStructSetData($tSYSTEMTIME, "Year", $iYear)
DllStructSetData($tSYSTEMTIME, "Hour", $iHour)
DllStructSetData($tSYSTEMTIME, "Minute", $iMinute)
DllStructSetData($tSYSTEMTIME, "Second", $iSecond)
DllStructSetData($tSYSTEMTIME, "MSeconds", $iMSeconds)
Return $tSYSTEMTIME
EndFunc
Func _Date_Time_GetLocalTime()
Local $tSystTime = DllStructCreate($tagSYSTEMTIME)
DllCall("kernel32.dll", "none", "GetLocalTime", "struct*", $tSystTime)
If @error Then Return SetError(@error, @extended, 0)
Return $tSystTime
EndFunc
Func _Date_Time_GetTickCount()
Local $aResult = DllCall("kernel32.dll", "dword", "GetTickCount")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _Date_Time_LocalFileTimeToFileTime($tLocalTime)
Local $tFileTime = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "LocalFileTimeToFileTime", "struct*", $tLocalTime, "struct*", $tFileTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tFileTime)
EndFunc
Func _Date_Time_SystemTimeToArray(ByRef $tSYSTEMTIME)
Local $aInfo[8]
$aInfo[0] = DllStructGetData($tSYSTEMTIME, "Month")
$aInfo[1] = DllStructGetData($tSYSTEMTIME, "Day")
$aInfo[2] = DllStructGetData($tSYSTEMTIME, "Year")
$aInfo[3] = DllStructGetData($tSYSTEMTIME, "Hour")
$aInfo[4] = DllStructGetData($tSYSTEMTIME, "Minute")
$aInfo[5] = DllStructGetData($tSYSTEMTIME, "Second")
$aInfo[6] = DllStructGetData($tSYSTEMTIME, "MSeconds")
$aInfo[7] = DllStructGetData($tSYSTEMTIME, "DOW")
Return $aInfo
EndFunc
Func _Date_Time_SystemTimeToDateTimeStr(ByRef $tSYSTEMTIME, $iFmt = 0)
Local $aInfo = _Date_Time_SystemTimeToArray($tSYSTEMTIME)
If @error Then Return SetError(@error, @extended, "")
If $iFmt Then
Return StringFormat("%04d/%02d/%02d %02d:%02d:%02d", $aInfo[2], $aInfo[0], $aInfo[1], $aInfo[3], $aInfo[4], $aInfo[5])
Else
Return StringFormat("%02d/%02d/%04d %02d:%02d:%02d", $aInfo[0], $aInfo[1], $aInfo[2], $aInfo[3], $aInfo[4], $aInfo[5])
EndIf
EndFunc
Func _Date_Time_SystemTimeToFileTime($tSYSTEMTIME)
Local $tFileTime = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "SystemTimeToFileTime", "struct*", $tSYSTEMTIME, "struct*", $tFileTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tFileTime)
EndFunc
Func _Date_Time_TzSpecificLocalTimeToSystemTime($tLocalTime, $tTimeZone = 0)
Local $tUTC = DllStructCreate($tagSYSTEMTIME)
Local $aResult = DllCall("kernel32.dll", "bool", "TzSpecificLocalTimeToSystemTime", "struct*", $tTimeZone, "struct*", $tLocalTime, "struct*", $tUTC)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tUTC)
EndFunc
Global Const $FW_MEDIUM = 500
Global Const $FW_BOLD = 700
Global Const $CLEARTYPE_QUALITY = 5
Func _IsPressed($sHexKey, $vDLL = 'user32.dll')
Local $a_R = DllCall($vDLL, "short", "GetAsyncKeyState", "int", '0x' & $sHexKey)
If @error Then Return SetError(@error, @extended, False)
Return BitAND($a_R[0], 0x8000) <> 0
EndFunc
Func _VersionCompare($sVersion1, $sVersion2)
If $sVersion1 = $sVersion2 Then Return 0
Local $sSubVersion1 = "", $sSubVersion2 = ""
If StringIsAlpha(StringRight($sVersion1, 1)) Then
$sSubVersion1 = StringRight($sVersion1, 1)
$sVersion1 = StringTrimRight($sVersion1, 1)
EndIf
If StringIsAlpha(StringRight($sVersion2, 1)) Then
$sSubVersion2 = StringRight($sVersion2, 1)
$sVersion2 = StringTrimRight($sVersion2, 1)
EndIf
Local $aVersion1 = StringSplit($sVersion1, ".,"), $aVersion2 = StringSplit($sVersion2, ".,")
Local $iPartDifference =($aVersion1[0] - $aVersion2[0])
If $iPartDifference < 0 Then
ReDim $aVersion1[UBound($aVersion2)]
$aVersion1[0] = UBound($aVersion1) - 1
For $i =(UBound($aVersion1) - Abs($iPartDifference)) To $aVersion1[0]
$aVersion1[$i] = "0"
Next
ElseIf $iPartDifference > 0 Then
ReDim $aVersion2[UBound($aVersion1)]
$aVersion2[0] = UBound($aVersion2) - 1
For $i =(UBound($aVersion2) - Abs($iPartDifference)) To $aVersion2[0]
$aVersion2[$i] = "0"
Next
EndIf
For $i = 1 To $aVersion1[0]
If StringIsDigit($aVersion1[$i]) And StringIsDigit($aVersion2[$i]) Then
If Number($aVersion1[$i]) > Number($aVersion2[$i]) Then
Return SetExtended(2, 1)
ElseIf Number($aVersion1[$i]) < Number($aVersion2[$i]) Then
Return SetExtended(2, -1)
ElseIf $i = $aVersion1[0] Then
If $sSubVersion1 > $sSubVersion2 Then
Return SetExtended(3, 1)
ElseIf $sSubVersion1 < $sSubVersion2 Then
Return SetExtended(3, -1)
EndIf
EndIf
Else
If $aVersion1[$i] > $aVersion2[$i] Then
Return SetExtended(1, 1)
ElseIf $aVersion1[$i] < $aVersion2[$i] Then
Return SetExtended(1, -1)
EndIf
EndIf
Next
Return SetExtended(Abs($iPartDifference), 0)
EndFunc
Func _FileCreate($sFilePath)
Local $hFileOpen = FileOpen($sFilePath, BitOR($FO_OVERWRITE, $FO_CREATEPATH))
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $iFileWrite = FileWrite($hFileOpen, "")
FileClose($hFileOpen)
If Not $iFileWrite Then Return SetError(2, 0, 0)
Return 1
EndFunc
Func _FileListToArray($sFilePath, $sFilter = "*", $iFlag = $FLTA_FILESFOLDERS, $bReturnPath = False)
Local $sDelimiter = "|", $sFileList = "", $sFileName = "", $sFullPath = ""
$sFilePath = StringRegExpReplace($sFilePath, "[\\/]+$", "") & "\"
If $iFlag = Default Then $iFlag = $FLTA_FILESFOLDERS
If $bReturnPath Then $sFullPath = $sFilePath
If $sFilter = Default Then $sFilter = "*"
If Not FileExists($sFilePath) Then Return SetError(1, 0, 0)
If StringRegExp($sFilter, "[\\/:><\|]|(?s)^\s*$") Then Return SetError(2, 0, 0)
If Not($iFlag = 0 Or $iFlag = 1 Or $iFlag = 2) Then Return SetError(3, 0, 0)
Local $hSearch = FileFindFirstFile($sFilePath & $sFilter)
If @error Then Return SetError(4, 0, 0)
While 1
$sFileName = FileFindNextFile($hSearch)
If @error Then ExitLoop
If($iFlag + @extended = 2) Then ContinueLoop
$sFileList &= $sDelimiter & $sFullPath & $sFileName
WEnd
FileClose($hSearch)
If $sFileList = "" Then Return SetError(4, 0, 0)
Return StringSplit(StringTrimLeft($sFileList, 1), $sDelimiter)
EndFunc
Func _FileListToArrayRec($sFilePath, $sMask = "*", $iReturn = $FLTAR_FILESFOLDERS, $iRecur = $FLTAR_NORECUR, $iSort = $FLTAR_NOSORT, $iReturnPath = $FLTAR_RELPATH)
If Not FileExists($sFilePath) Then Return SetError(1, 1, "")
If $sMask = Default Then $sMask = "*"
If $iReturn = Default Then $iReturn = $FLTAR_FILESFOLDERS
If $iRecur = Default Then $iRecur = $FLTAR_NORECUR
If $iSort = Default Then $iSort = $FLTAR_NOSORT
If $iReturnPath = Default Then $iReturnPath = $FLTAR_RELPATH
If $iRecur > 1 Or Not IsInt($iRecur) Then Return SetError(1, 6, "")
Local $bLongPath = False
If StringLeft($sFilePath, 4) == "\\?\" Then
$bLongPath = True
EndIf
Local $sFolderSlash = ""
If StringRight($sFilePath, 1) = "\" Then
$sFolderSlash = "\"
Else
$sFilePath = $sFilePath & "\"
EndIf
Local $asFolderSearchList[100] = [1]
$asFolderSearchList[1] = $sFilePath
Local $iHide_HS = 0, $sHide_HS = ""
If BitAND($iReturn, 4) Then
$iHide_HS += 2
$sHide_HS &= "H"
$iReturn -= 4
EndIf
If BitAND($iReturn, 8) Then
$iHide_HS += 4
$sHide_HS &= "S"
$iReturn -= 8
EndIf
Local $iHide_Link = 0
If BitAND($iReturn, 16) Then
$iHide_Link = 0x400
$iReturn -= 16
EndIf
Local $iMaxLevel = 0
If $iRecur < 0 Then
StringReplace($sFilePath, "\", "", 0, $STR_NOCASESENSEBASIC)
$iMaxLevel = @extended - $iRecur
EndIf
Local $sExclude_List = "", $sExclude_List_Folder = "", $sInclude_List = "*"
Local $aMaskSplit = StringSplit($sMask, "|")
Switch $aMaskSplit[0]
Case 3
$sExclude_List_Folder = $aMaskSplit[3]
ContinueCase
Case 2
$sExclude_List = $aMaskSplit[2]
ContinueCase
Case 1
$sInclude_List = $aMaskSplit[1]
EndSwitch
Local $sInclude_File_Mask = ".+"
If $sInclude_List <> "*" Then
If Not __FLTAR_ListToMask($sInclude_File_Mask, $sInclude_List) Then Return SetError(1, 2, "")
EndIf
Local $sInclude_Folder_Mask = ".+"
Switch $iReturn
Case 0
Switch $iRecur
Case 0
$sInclude_Folder_Mask = $sInclude_File_Mask
EndSwitch
Case 2
$sInclude_Folder_Mask = $sInclude_File_Mask
EndSwitch
Local $sExclude_File_Mask = ":"
If $sExclude_List <> "" Then
If Not __FLTAR_ListToMask($sExclude_File_Mask, $sExclude_List) Then Return SetError(1, 3, "")
EndIf
Local $sExclude_Folder_Mask = ":"
If $iRecur Then
If $sExclude_List_Folder Then
If Not __FLTAR_ListToMask($sExclude_Folder_Mask, $sExclude_List_Folder) Then Return SetError(1, 4, "")
EndIf
If $iReturn = 2 Then
$sExclude_Folder_Mask = $sExclude_File_Mask
EndIf
Else
$sExclude_Folder_Mask = $sExclude_File_Mask
EndIf
If Not($iReturn = 0 Or $iReturn = 1 Or $iReturn = 2) Then Return SetError(1, 5, "")
If Not($iSort = 0 Or $iSort = 1 Or $iSort = 2) Then Return SetError(1, 7, "")
If Not($iReturnPath = 0 Or $iReturnPath = 1 Or $iReturnPath = 2) Then Return SetError(1, 8, "")
If $iHide_Link Then
Local $tFile_Data = DllStructCreate("struct;align 4;dword FileAttributes;uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;" & "dword FileSizeHigh;dword FileSizeLow;dword Reserved0;dword Reserved1;wchar FileName[260];wchar AlternateFileName[14];endstruct")
Local $hDLL = DllOpen('kernel32.dll'), $aDLL_Ret
EndIf
Local $asReturnList[100] = [0]
Local $asFileMatchList = $asReturnList, $asRootFileMatchList = $asReturnList, $asFolderMatchList = $asReturnList
Local $bFolder = False, $hSearch = 0, $sCurrentPath = "", $sName = "", $sRetPath = ""
Local $iAttribs = 0, $sAttribs = ''
Local $asFolderFileSectionList[100][2] = [[0, 0]]
While $asFolderSearchList[0] > 0
$sCurrentPath = $asFolderSearchList[$asFolderSearchList[0]]
$asFolderSearchList[0] -= 1
Switch $iReturnPath
Case 1
$sRetPath = StringReplace($sCurrentPath, $sFilePath, "")
Case 2
If $bLongPath Then
$sRetPath = StringTrimLeft($sCurrentPath, 4)
Else
$sRetPath = $sCurrentPath
EndIf
EndSwitch
If $iHide_Link Then
$aDLL_Ret = DllCall($hDLL, 'handle', 'FindFirstFileW', 'wstr', $sCurrentPath & "*", 'struct*', $tFile_Data)
If @error Or Not $aDLL_Ret[0] Then
ContinueLoop
EndIf
$hSearch = $aDLL_Ret[0]
Else
$hSearch = FileFindFirstFile($sCurrentPath & "*")
If $hSearch = -1 Then
ContinueLoop
EndIf
EndIf
If $iReturn = 0 And $iSort And $iReturnPath Then
__FLTAR_AddToList($asFolderFileSectionList, $sRetPath, $asFileMatchList[0] + 1)
EndIf
$sAttribs = ''
While 1
If $iHide_Link Then
$aDLL_Ret = DllCall($hDLL, 'int', 'FindNextFileW', 'handle', $hSearch, 'struct*', $tFile_Data)
If @error Or Not $aDLL_Ret[0] Then
ExitLoop
EndIf
$sName = DllStructGetData($tFile_Data, "FileName")
If $sName = ".." Then
ContinueLoop
EndIf
$iAttribs = DllStructGetData($tFile_Data, "FileAttributes")
If $iHide_HS And BitAND($iAttribs, $iHide_HS) Then
ContinueLoop
EndIf
If BitAND($iAttribs, $iHide_Link) Then
ContinueLoop
EndIf
$bFolder = False
If BitAND($iAttribs, 16) Then
$bFolder = True
EndIf
Else
$bFolder = False
$sName = FileFindNextFile($hSearch, 1)
If @error Then
ExitLoop
EndIf
$sAttribs = @extended
If StringInStr($sAttribs, "D") Then
$bFolder = True
EndIf
If StringRegExp($sAttribs, "[" & $sHide_HS & "]") Then
ContinueLoop
EndIf
EndIf
If $bFolder Then
Select
Case $iRecur < 0
StringReplace($sCurrentPath, "\", "", 0, $STR_NOCASESENSEBASIC)
If @extended < $iMaxLevel Then
ContinueCase
EndIf
Case $iRecur = 1
If Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asFolderSearchList, $sCurrentPath & $sName & "\")
EndIf
EndSelect
EndIf
If $iSort Then
If $bFolder Then
If StringRegExp($sName, $sInclude_Folder_Mask) And Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asFolderMatchList, $sRetPath & $sName & $sFolderSlash)
EndIf
Else
If StringRegExp($sName, $sInclude_File_Mask) And Not StringRegExp($sName, $sExclude_File_Mask) Then
If $sCurrentPath = $sFilePath Then
__FLTAR_AddToList($asRootFileMatchList, $sRetPath & $sName)
Else
__FLTAR_AddToList($asFileMatchList, $sRetPath & $sName)
EndIf
EndIf
EndIf
Else
If $bFolder Then
If $iReturn <> 1 And StringRegExp($sName, $sInclude_Folder_Mask) And Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asReturnList, $sRetPath & $sName & $sFolderSlash)
EndIf
Else
If $iReturn <> 2 And StringRegExp($sName, $sInclude_File_Mask) And Not StringRegExp($sName, $sExclude_File_Mask) Then
__FLTAR_AddToList($asReturnList, $sRetPath & $sName)
EndIf
EndIf
EndIf
WEnd
If $iHide_Link Then
DllCall($hDLL, 'int', 'FindClose', 'ptr', $hSearch)
Else
FileClose($hSearch)
EndIf
WEnd
If $iHide_Link Then
DllClose($hDLL)
EndIf
If $iSort Then
Switch $iReturn
Case 2
If $asFolderMatchList[0] = 0 Then Return SetError(1, 9, "")
ReDim $asFolderMatchList[$asFolderMatchList[0] + 1]
$asReturnList = $asFolderMatchList
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Case 1
If $asRootFileMatchList[0] = 0 And $asFileMatchList[0] = 0 Then Return SetError(1, 9, "")
If $iReturnPath = 0 Then
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList)
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Else
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList, 1)
EndIf
Case 0
If $asRootFileMatchList[0] = 0 And $asFolderMatchList[0] = 0 Then Return SetError(1, 9, "")
If $iReturnPath = 0 Then
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList)
$asReturnList[0] += $asFolderMatchList[0]
ReDim $asFolderMatchList[$asFolderMatchList[0] + 1]
_ArrayConcatenate($asReturnList, $asFolderMatchList, 1)
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Else
Local $asReturnList[$asFileMatchList[0] + $asRootFileMatchList[0] + $asFolderMatchList[0] + 1]
$asReturnList[0] = $asFileMatchList[0] + $asRootFileMatchList[0] + $asFolderMatchList[0]
__ArrayDualPivotSort($asRootFileMatchList, 1, $asRootFileMatchList[0])
For $i = 1 To $asRootFileMatchList[0]
$asReturnList[$i] = $asRootFileMatchList[$i]
Next
Local $iNextInsertionIndex = $asRootFileMatchList[0] + 1
__ArrayDualPivotSort($asFolderMatchList, 1, $asFolderMatchList[0])
Local $sFolderToFind = ""
For $i = 1 To $asFolderMatchList[0]
$asReturnList[$iNextInsertionIndex] = $asFolderMatchList[$i]
$iNextInsertionIndex += 1
If $sFolderSlash Then
$sFolderToFind = $asFolderMatchList[$i]
Else
$sFolderToFind = $asFolderMatchList[$i] & "\"
EndIf
Local $iFileSectionEndIndex = 0, $iFileSectionStartIndex = 0
For $j = 1 To $asFolderFileSectionList[0][0]
If $sFolderToFind = $asFolderFileSectionList[$j][0] Then
$iFileSectionStartIndex = $asFolderFileSectionList[$j][1]
If $j = $asFolderFileSectionList[0][0] Then
$iFileSectionEndIndex = $asFileMatchList[0]
Else
$iFileSectionEndIndex = $asFolderFileSectionList[$j + 1][1] - 1
EndIf
If $iSort = 1 Then
__ArrayDualPivotSort($asFileMatchList, $iFileSectionStartIndex, $iFileSectionEndIndex)
EndIf
For $k = $iFileSectionStartIndex To $iFileSectionEndIndex
$asReturnList[$iNextInsertionIndex] = $asFileMatchList[$k]
$iNextInsertionIndex += 1
Next
ExitLoop
EndIf
Next
Next
EndIf
EndSwitch
Else
If $asReturnList[0] = 0 Then Return SetError(1, 9, "")
ReDim $asReturnList[$asReturnList[0] + 1]
EndIf
Return $asReturnList
EndFunc
Func __FLTAR_AddFileLists(ByRef $asTarget, $asSource_1, $asSource_2, $iSort = 0)
ReDim $asSource_1[$asSource_1[0] + 1]
If $iSort = 1 Then __ArrayDualPivotSort($asSource_1, 1, $asSource_1[0])
$asTarget = $asSource_1
$asTarget[0] += $asSource_2[0]
ReDim $asSource_2[$asSource_2[0] + 1]
If $iSort = 1 Then __ArrayDualPivotSort($asSource_2, 1, $asSource_2[0])
_ArrayConcatenate($asTarget, $asSource_2, 1)
EndFunc
Func __FLTAR_AddToList(ByRef $aList, $vValue_0, $vValue_1 = -1)
If $vValue_1 = -1 Then
$aList[0] += 1
If UBound($aList) <= $aList[0] Then ReDim $aList[UBound($aList) * 2]
$aList[$aList[0]] = $vValue_0
Else
$aList[0][0] += 1
If UBound($aList) <= $aList[0][0] Then ReDim $aList[UBound($aList) * 2][2]
$aList[$aList[0][0]][0] = $vValue_0
$aList[$aList[0][0]][1] = $vValue_1
EndIf
EndFunc
Func __FLTAR_ListToMask(ByRef $sMask, $sList)
If StringRegExp($sList, "\\|/|:|\<|\>|\|") Then Return 0
$sList = StringReplace(StringStripWS(StringRegExpReplace($sList, "\s*;\s*", ";"), $STR_STRIPLEADING + $STR_STRIPTRAILING), ";", "|")
$sList = StringReplace(StringReplace(StringRegExpReplace($sList, "[][$^.{}()+\-]", "\\$0"), "?", "."), "*", ".*?")
$sMask = "(?i)^(" & $sList & ")\z"
Return 1
EndFunc
Func _FileWriteLog($sLogPath, $sLogMsg, $iFlag = -1)
Local $iOpenMode = $FO_APPEND
Local $sDateNow = @YEAR & "-" & @MON & "-" & @MDAY
Local $sTimeNow = @HOUR & ":" & @MIN & ":" & @SEC
Local $sMsg = $sDateNow & " " & $sTimeNow & " : " & $sLogMsg
If $iFlag = Default Then $iFlag = -1
If $iFlag <> -1 Then
$iOpenMode = $FO_OVERWRITE
$sMsg &= @CRLF & FileRead($sLogPath)
EndIf
Local $hFileOpen = $sLogPath
If IsString($sLogPath) Then
$hFileOpen = FileOpen($sLogPath, $iOpenMode)
EndIf
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $iReturn = FileWriteLine($hFileOpen, $sMsg)
If IsString($sLogPath) Then $iReturn = FileClose($hFileOpen)
If $iReturn <= 0 Then Return SetError(2, $iReturn, 0)
Return $iReturn
EndFunc
Global Const $TRAY_CHECKED = 1
Global Const $TRAY_UNCHECKED = 4
Global Const $TRAY_ENABLE = 64
Global Const $TRAY_DISABLE = 128
Global Const $TIP_ICONASTERISK = 1
Global Const $TIP_ICONEXCLAMATION = 2
Global Const $TIP_NOSOUND = 16
Global Const $MF_BYPOSITION = 0x00000400
Global Const $MIIM_DATAMASK = 0x0000003F
Global Const $SC_MINIMIZE = 0xF020
Global Const $SC_MAXIMIZE = 0xF030
Global Const $SC_CLOSE = 0xF060
Global Const $SC_RESTORE = 0xF120
Func _GUICtrlMenu_DrawMenuBar($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "DrawMenuBar", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_FindParent($hMenu)
Local $hList = _WinAPI_EnumWindowsTop()
For $iI = 1 To $hList[0][0]
If _GUICtrlMenu_GetMenu($hList[$iI][0]) = $hMenu Then Return $hList[$iI][0]
Next
EndFunc
Func _GUICtrlMenu_GetItemCount($hMenu)
Local $aResult = DllCall("user32.dll", "int", "GetMenuItemCount", "handle", $hMenu)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_GetItemID($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "ID")
EndFunc
Func _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos = True)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_DATAMASK)
Local $aResult = DllCall("user32.dll", "bool", "GetMenuItemInfo", "handle", $hMenu, "uint", $iItem, "bool", $bByPos, "struct*", $tInfo)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tInfo)
EndFunc
Func _GUICtrlMenu_GetMenu($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetMenu", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_GetSystemMenu($hWnd, $bRevert = False)
Local $aResult = DllCall("user32.dll", "hwnd", "GetSystemMenu", "hwnd", $hWnd, "int", $bRevert)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_RemoveMenu($hMenu, $iItem, $bByPos = True)
Local $iByPos = 0
If $bByPos Then $iByPos = $MF_BYPOSITION
Local $aResult = DllCall("user32.dll", "bool", "RemoveMenu", "handle", $hMenu, "uint", $iItem, "uint", $iByPos)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] = 0 Then Return SetError(10, 0, False)
_GUICtrlMenu_DrawMenuBar(_GUICtrlMenu_FindParent($hMenu))
Return True
EndFunc
Func _ClipBoard_RegisterFormat($sFormat)
Local $aResult = DllCall("user32.dll", "uint", "RegisterClipboardFormatW", "wstr", $sFormat)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Global Const $__RICHEDITCONSTANT_WM_USER = 0x400
Global Const $EM_EXGETSEL = $__RICHEDITCONSTANT_WM_USER + 52
Global Const $EM_GETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 94
Global Const $EM_GETTEXTLENGTHEX = $__RICHEDITCONSTANT_WM_USER + 95
Global Const $EM_HIDESELECTION = $__RICHEDITCONSTANT_WM_USER + 63
Global Const $EM_SETCHARFORMAT = $__RICHEDITCONSTANT_WM_USER + 68
Global Const $EM_SETSCROLLPOS = $__RICHEDITCONSTANT_WM_USER + 222
Global Const $EM_SETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 97
Global Const $EM_STREAMIN = $__RICHEDITCONSTANT_WM_USER + 73
Global Const $ST_DEFAULT = 0
Global Const $ST_SELECTION = 2
Global Const $GT_USECRLF = 1
Global Const $GTL_CLOSE = 4
Global Const $GTL_DEFAULT = 0
Global Const $GTL_NUMBYTES = 16
Global Const $GTL_PRECISE = 2
Global Const $GTL_USECRLF = 1
Global Const $CP_ACP = 0
Global Const $CP_UNICODE = 1200
Global Const $CFE_SUBSCRIPT = 0x00010000
Global Const $CFE_SUPERSCRIPT = 0x00020000
Global Const $CFM_CHARSET = 0x8000000
Global Const $CFM_COLOR = 0x40000000
Global Const $CFM_FACE = 0x20000000
Global Const $CFM_LCID = 0x2000000
Global Const $CFM_SIZE = 0x80000000
Global Const $CFE_AUTOCOLOR = $CFM_COLOR
Global Const $SCF_SELECTION = 0x1
Global Const $LF_FACESIZE = 32
Global Const $SF_TEXT = 0x1
Global Const $SF_RTF = 0x2
Global Const $SFF_SELECTION = 0x8000
Global $__g_sRTFClassName, $__g_sRTFVersion, $__g_iRTFTwipsPeSpaceUnit = 1440
Global $__g_sGRE_CF_RTF, $__g_sGRE_CF_RETEXTOBJ
Global $__g_pGRC_StreamFromFileCallback = DllCallbackRegister("__GCR_StreamFromFileCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamFromVarCallback = DllCallbackRegister("__GCR_StreamFromVarCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamToFileCallback = DllCallbackRegister("__GCR_StreamToFileCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamToVarCallback = DllCallbackRegister("__GCR_StreamToVarCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_sStreamVar
Global $__g_hRELastWnd
Global $__g_tObj_RichComObject = DllStructCreate("ptr pIntf; dword  Refcount")
Global $__g_tCall_RichCom, $__g_pObj_RichCom
Global $__g_hLib_RichCom_OLE32 = DllOpen("OLE32.DLL")
Global $__g_pRichCom_Object_QueryInterface = DllCallbackRegister("__RichCom_Object_QueryInterface", "long", "ptr;dword;dword")
Global $__g_pRichCom_Object_AddRef = DllCallbackRegister("__RichCom_Object_AddRef", "long", "ptr")
Global $__g_pRichCom_Object_Release = DllCallbackRegister("__RichCom_Object_Release", "long", "ptr")
Global $__g_pRichCom_Object_GetNewStorage = DllCallbackRegister("__RichCom_Object_GetNewStorage", "long", "ptr;ptr")
Global $__g_pRichCom_Object_GetInPlaceContext = DllCallbackRegister("__RichCom_Object_GetInPlaceContext", "long", "ptr;dword;dword;dword")
Global $__g_pRichCom_Object_ShowContainerUI = DllCallbackRegister("__RichCom_Object_ShowContainerUI", "long", "ptr;long")
Global $__g_pRichCom_Object_QueryInsertObject = DllCallbackRegister("__RichCom_Object_QueryInsertObject", "long", "ptr;dword;ptr;long")
Global $__g_pRichCom_Object_DeleteObject = DllCallbackRegister("__RichCom_Object_DeleteObject", "long", "ptr;ptr")
Global $__g_pRichCom_Object_QueryAcceptData = DllCallbackRegister("__RichCom_Object_QueryAcceptData", "long", "ptr;ptr;dword;dword;dword;ptr")
Global $__g_pRichCom_Object_ContextSensitiveHelp = DllCallbackRegister("__RichCom_Object_ContextSensitiveHelp", "long", "ptr;long")
Global $__g_pRichCom_Object_GetClipboardData = DllCallbackRegister("__RichCom_Object_GetClipboardData", "long", "ptr;ptr;dword;ptr")
Global $__g_pRichCom_Object_GetDragDropEffect = DllCallbackRegister("__RichCom_Object_GetDragDropEffect", "long", "ptr;dword;dword;dword")
Global $__g_pRichCom_Object_GetContextMenu = DllCallbackRegister("__RichCom_Object_GetContextMenu", "long", "ptr;short;ptr;ptr;ptr")
Global Const $__RICHEDITCONSTANT_WM_SETFONT = 0x0030
Global Const $_GCR_S_OK = 0
Global Const $_GCR_E_NOTIMPL = 0x80004001
Global Const $tagEDITSTREAM = "align 4;dword_ptr dwCookie;dword dwError;ptr pfnCallback"
Global Const $tagCHARFORMAT = "struct;uint cbSize;dword dwMask;dword dwEffects;long yHeight;long yOffset;INT crCharColor;" & "byte bCharSet;byte bPitchAndFamily;wchar szFaceName[32];endstruct"
Global Const $tagCHARFORMAT2 = $tagCHARFORMAT & ";word wWeight;short sSpacing;INT crBackColor;dword lcid;dword dwReserved;" & "short sStyle;word wKerning;byte bUnderlineType;byte bAnimation;byte bRevAuthor;byte bReserved1"
Global Const $tagCHARRANGE = "struct;long cpMin;long cpMax;endstruct"
Global Const $tagGETTEXTEX = "align 4;dword cb;dword flags;uint codepage;ptr lpDefaultChar;ptr lpbUsedDefChar"
Global Const $tagGETTEXTLENGTHEX = "dword flags;uint codepage"
Global Const $tagSETTEXTEX = "dword flags;uint codepage"
Func _GUICtrlRichEdit_AppendText($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iLength = _GUICtrlRichEdit_GetTextLength($hWnd)
_GUICtrlRichEdit_SetSel($hWnd, $iLength, $iLength)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_SELECTION)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
DllStructSetData($tSetText, 2, $CP_ACP)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_Create($hWnd, $sText, $iLeft, $iTop, $iWidth = 150, $iHeight = 150, $iStyle = -1, $iExStyle = -1)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sText) Then Return SetError(2, 0, 0)
If Not __GCR_IsNumeric($iWidth, ">0,-1") Then Return SetError(105, 0, 0)
If Not __GCR_IsNumeric($iHeight, ">0,-1") Then Return SetError(106, 0, 0)
If Not __GCR_IsNumeric($iStyle, ">=0,-1") Then Return SetError(107, 0, 0)
If Not __GCR_IsNumeric($iExStyle, ">=0,-1") Then Return SetError(108, 0, 0)
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = BitOR($ES_WANTRETURN, $ES_MULTILINE)
If BitAND($iStyle, $ES_MULTILINE) <> 0 Then $iStyle = BitOR($iStyle, $ES_WANTRETURN)
If $iExStyle = -1 Then $iExStyle = 0x200
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
If BitAND($iStyle, $ES_READONLY) = 0 Then $iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_TABSTOP)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
__GCR_Init()
Local $hRichEdit = _WinAPI_CreateWindowEx($iExStyle, $__g_sRTFClassName, "", $iStyle, $iLeft, $iTop, $iWidth, $iHeight, $hWnd, $nCtrlID)
If $hRichEdit = 0 Then Return SetError(700, 0, False)
__GCR_SetOLECallback($hRichEdit)
_SendMessage($hRichEdit, $__RICHEDITCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($DEFAULT_GUI_FONT), True)
_GUICtrlRichEdit_AppendText($hRichEdit, $sText)
Return $hRichEdit
EndFunc
Func _GUICtrlRichEdit_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hRELastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlRichEdit_GetText($hWnd, $bCrToCrLf = False, $iCodePage = 0, $sReplChar = "")
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not IsBool($bCrToCrLf) Then Return SetError(102, 0, "")
If Not __GCR_IsNumeric($iCodePage) Then Return SetError(103, 0, "")
Local $iLen = _GUICtrlRichEdit_GetTextLength($hWnd, False, True) + 1
Local $sUni = ''
If $iCodePage = $CP_UNICODE Or Not $iCodePage Then $sUni = "w"
Local $tText = DllStructCreate($sUni & "char[" & $iLen & "]")
Local $tGetTextEx = DllStructCreate($tagGETTEXTEX)
DllStructSetData($tGetTextEx, "cb", DllStructGetSize($tText))
Local $iFlags = 0
If $bCrToCrLf Then $iFlags = $GT_USECRLF
DllStructSetData($tGetTextEx, "flags", $iFlags)
If $iCodePage = 0 Then $iCodePage = $CP_UNICODE
DllStructSetData($tGetTextEx, "codepage", $iCodePage)
Local $pUsedDefChar = 0, $pDefaultChar = 0
If $sReplChar <> "" Then
Local $tDefaultChar = DllStructCreate("char")
$pDefaultChar = DllStructGetPtr($tDefaultChar, 1)
DllStructSetData($tDefaultChar, 1, $sReplChar)
Local $tUsedDefChar = DllStructCreate("bool")
$pUsedDefChar = DllStructGetPtr($tUsedDefChar, 1)
EndIf
DllStructSetData($tGetTextEx, "lpDefaultChar", $pDefaultChar)
DllStructSetData($tGetTextEx, "lpbUsedDefChar", $pUsedDefChar)
Local $iRet = _SendMessage($hWnd, $EM_GETTEXTEX, $tGetTextEx, $tText, 0, "struct*", "struct*")
If $iRet = 0 Then Return SetError(700, 0, "")
If $sReplChar <> "" Then SetExtended(DllStructGetData($tUsedDefChar, 1) <> 0)
Return DllStructGetData($tText, 1)
EndFunc
Func _GUICtrlRichEdit_GetTextLength($hWnd, $bExact = True, $bChars = False)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not IsBool($bExact) Then Return SetError(102, 0, 0)
If Not IsBool($bChars) Then Return SetError(103, 0, 0)
Local $tGetTextLen = DllStructCreate($tagGETTEXTLENGTHEX)
Local $iFlags = BitOR($GTL_USECRLF,($bExact ? $GTL_PRECISE : $GTL_CLOSE))
$iFlags = BitOR($iFlags,($bChars ? $GTL_DEFAULT : $GTL_NUMBYTES))
DllStructSetData($tGetTextLen, 1, $iFlags)
DllStructSetData($tGetTextLen, 2,($bChars ? $CP_ACP : $CP_UNICODE))
Local $iRet = _SendMessage($hWnd, $EM_GETTEXTLENGTHEX, $tGetTextLen, 0, 0, "struct*")
Return $iRet
EndFunc
Func _GUICtrlRichEdit_IsTextSelected($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tCharRange = DllStructCreate($tagCHARRANGE)
_SendMessage($hWnd, $EM_EXGETSEL, 0, $tCharRange, 0, "wparam", "struct*")
Return DllStructGetData($tCharRange, 2) <> DllStructGetData($tCharRange, 1)
EndFunc
Func _GUICtrlRichEdit_SetCharColor($hWnd, $iColor = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
If $iColor = Default Then
DllStructSetData($tCharFormat, 3, $CFE_AUTOCOLOR)
$iColor = 0
Else
If BitAND($iColor, 0xff000000) Then Return SetError(1022, 0, False)
EndIf
DllStructSetData($tCharFormat, 2, $CFM_COLOR)
DllStructSetData($tCharFormat, 6, $iColor)
Return _SendMessage($hWnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetFont($hWnd, $iPoints = Default, $sName = Default, $iCharset = Default, $iLcid = Default)
Local $iDwMask = 0
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not($iPoints = Default Or __GCR_IsNumeric($iPoints, ">0")) Then Return SetError(102, 0, False)
If $sName <> Default Then
Local $aS = StringSplit($sName, " ")
For $i = 1 To UBound($aS) - 1
If Not StringIsAlpha($aS[$i]) Then Return SetError(103, 0, False)
Next
EndIf
If Not($iCharset = Default Or __GCR_IsNumeric($iCharset)) Then Return SetError(104, 0, False)
If Not($iLcid = Default Or __GCR_IsNumeric($iLcid)) Then Return SetError(105, 0, False)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT2)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
If $iPoints <> Default Then
$iDwMask = $CFM_SIZE
DllStructSetData($tCharFormat, 4, Int($iPoints * 20))
EndIf
If $sName <> Default Then
If StringLen($sName) > $LF_FACESIZE - 1 Then SetError(-1, 0, False)
$iDwMask = BitOR($iDwMask, $CFM_FACE)
DllStructSetData($tCharFormat, 9, $sName)
EndIf
If $iCharset <> Default Then
$iDwMask = BitOR($iDwMask, $CFM_CHARSET)
DllStructSetData($tCharFormat, 7, $iCharset)
EndIf
If $iLcid <> Default Then
$iDwMask = BitOR($iDwMask, $CFM_LCID)
DllStructSetData($tCharFormat, 13, $iLcid)
EndIf
DllStructSetData($tCharFormat, 2, $iDwMask)
Local $iRet = _SendMessage($hWnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(@error + 200, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetReadOnly($hWnd, $bState = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bState) Then Return SetError(102, 0, False)
Local $iRet = _SendMessage($hWnd, $EM_SETREADONLY, $bState)
If $iRet = 0 Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetScrollPos($hWnd, $iX, $iY)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iX, ">=0") Then Return SetError(102, 0, False)
If Not __GCR_IsNumeric($iY, ">=0") Then Return SetError(103, 0, False)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, 1, $iX)
DllStructSetData($tPoint, 2, $iY)
Return _SendMessage($hWnd, $EM_SETSCROLLPOS, 0, $tPoint, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetSel($hWnd, $iAnchor, $iActive, $bHideSel = False)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iAnchor, ">=0,-1") Then Return SetError(102, 0, False)
If Not __GCR_IsNumeric($iActive, ">=0,-1") Then Return SetError(103, 0, False)
If Not IsBool($bHideSel) Then Return SetError(104, 0, False)
_SendMessage($hWnd, $EM_SETSEL, $iAnchor, $iActive)
If $bHideSel Then _SendMessage($hWnd, $EM_HIDESELECTION, $bHideSel)
_WinAPI_SetFocus($hWnd)
Return True
EndFunc
Func _GUICtrlRichEdit_SetText($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_DEFAULT)
DllStructSetData($tSetText, 2, $CP_ACP)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_StreamFromFile($hWnd, $sFileSpec)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tEditStream = DllStructCreate($tagEDITSTREAM)
DllStructSetData($tEditStream, "pfnCallback", DllCallbackGetPtr($__g_pGRC_StreamFromFileCallback))
Local $hFile = FileOpen($sFileSpec, $FO_READ)
If $hFile = -1 Then Return SetError(1021, 0, False)
Local $sBuf = FileRead($hFile, 5)
FileClose($hFile)
$hFile = FileOpen($sFileSpec, $FO_READ)
DllStructSetData($tEditStream, "dwCookie", $hFile)
Local $wParam =($sBuf == "{\rtf" Or $sBuf == "{urtf") ? $SF_RTF : $SF_TEXT
$wParam = BitOR($wParam, $SFF_SELECTION)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then
_GUICtrlRichEdit_SetText($hWnd, "")
EndIf
Local $iQchs = _SendMessage($hWnd, $EM_STREAMIN, $wParam, $tEditStream, 0, "wparam", "struct*")
FileClose($hFile)
Local $iError = DllStructGetData($tEditStream, "dwError")
If $iError <> 1 Then SetError(700, $iError, False)
If $iQchs = 0 Then
If FileGetSize($sFileSpec) = 0 Then Return SetError(1022, 0, False)
Return SetError(700, $iError, False)
EndIf
Return True
EndFunc
Func __GCR_Init()
Local $ah_GUICtrlRTF_lib = DllCall("kernel32.dll", "ptr", "LoadLibraryW", "wstr", "MSFTEDIT.DLL")
If $ah_GUICtrlRTF_lib[0] <> 0 Then
$__g_sRTFClassName = "RichEdit50W"
$__g_sRTFVersion = 4.1
Else
$ah_GUICtrlRTF_lib = DllCall("kernel32.dll", "ptr", "LoadLibraryW", "wstr", "RICHED20.DLL")
$__g_sRTFVersion = FileGetVersion(@SystemDir & "\riched20.dll", "ProductVersion")
Switch $__g_sRTFVersion
Case 3.0
$__g_sRTFClassName = "RichEdit20W"
Case 5.0
$__g_sRTFClassName = "RichEdit50W"
Case 6.0
$__g_sRTFClassName = "RichEdit60W"
EndSwitch
EndIf
$__g_sGRE_CF_RTF = _ClipBoard_RegisterFormat("Rich Text Format")
$__g_sGRE_CF_RETEXTOBJ = _ClipBoard_RegisterFormat("Rich Text Format with Objects")
EndFunc
Func __GCR_StreamFromFileCallback($hFile, $pBuf, $iBuflen, $pQbytes)
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $sBuf = FileRead($hFile, $iBuflen - 1)
If @error Then Return 1
DllStructSetData($tBuf, 1, $sBuf)
DllStructSetData($tQbytes, 1, StringLen($sBuf))
Return 0
EndFunc
Func __GCR_StreamFromVarCallback($iCookie, $pBuf, $iBuflen, $pQbytes)
#forceref $iCookie
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tCtl = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $sCtl = StringLeft($__g_pGRC_sStreamVar, $iBuflen - 1)
If $sCtl = "" Then Return 1
DllStructSetData($tCtl, 1, $sCtl)
Local $iLen = StringLen($sCtl)
DllStructSetData($tQbytes, 1, $iLen)
$__g_pGRC_sStreamVar = StringMid($__g_pGRC_sStreamVar, $iLen + 1)
Return 0
EndFunc
Func __GCR_StreamToFileCallback($hFile, $pBuf, $iBuflen, $pQbytes)
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $s = DllStructGetData($tBuf, 1)
FileWrite($hFile, $s)
DllStructSetData($tQbytes, 1, StringLen($s))
Return 0
EndFunc
Func __GCR_StreamToVarCallback($iCookie, $pBuf, $iBuflen, $pQbytes)
#forceref $iCookie
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $s = DllStructGetData($tBuf, 1)
$__g_pGRC_sStreamVar &= $s
Return 0
EndFunc
Func __GCR_IsNumeric($vN, $sRange = "")
If Not(IsNumber($vN) Or StringIsInt($vN) Or StringIsFloat($vN)) Then Return False
Switch $sRange
Case ">0"
If $vN <= 0 Then Return False
Case ">=0"
If $vN < 0 Then Return False
Case ">0,-1"
If Not($vN > 0 Or $vN = -1) Then Return False
Case ">=0,-1"
If Not($vN >= 0 Or $vN = -1) Then Return False
EndSwitch
Return True
EndFunc
Func __GCR_SetOLECallback($hWnd)
If Not IsHWnd($hWnd) Then Return SetError(101, 0, False)
If Not $__g_pObj_RichCom Then
$__g_tCall_RichCom = DllStructCreate("ptr[20]")
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryInterface), 1)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_AddRef), 2)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_Release), 3)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetNewStorage), 4)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetInPlaceContext), 5)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_ShowContainerUI), 6)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryInsertObject), 7)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_DeleteObject), 8)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryAcceptData), 9)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_ContextSensitiveHelp), 10)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetClipboardData), 11)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetDragDropEffect), 12)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetContextMenu), 13)
DllStructSetData($__g_tObj_RichComObject, 1, DllStructGetPtr($__g_tCall_RichCom))
DllStructSetData($__g_tObj_RichComObject, 2, 1)
$__g_pObj_RichCom = DllStructGetPtr($__g_tObj_RichComObject)
EndIf
Local Const $EM_SETOLECALLBACK = 0x400 + 70
If _SendMessage($hWnd, $EM_SETOLECALLBACK, 0, $__g_pObj_RichCom) = 0 Then Return SetError(700, 0, False)
Return True
EndFunc
Func __RichCom_Object_QueryInterface($pObject, $iREFIID, $pPvObj)
#forceref $pObject, $iREFIID, $pPvObj
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_AddRef($pObject)
Local $tData = DllStructCreate("ptr;dword", $pObject)
DllStructSetData($tData, 2, DllStructGetData($tData, 2) + 1)
Return DllStructGetData($tData, 2)
EndFunc
Func __RichCom_Object_Release($pObject)
Local $tData = DllStructCreate("ptr;dword", $pObject)
If DllStructGetData($tData, 2) > 0 Then
DllStructSetData($tData, 2, DllStructGetData($tData, 2) - 1)
Return DllStructGetData($tData, 2)
EndIf
EndFunc
Func __RichCom_Object_GetInPlaceContext($pObject, $pPFrame, $pPDoc, $pFrameInfo)
#forceref $pObject, $pPFrame, $pPDoc, $pFrameInfo
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_ShowContainerUI($pObject, $bShow)
#forceref $pObject, $bShow
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_QueryInsertObject($pObject, $pClsid, $tStg, $vCp)
#forceref $pObject, $pClsid, $tStg, $vCp
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_DeleteObject($pObject, $pOleobj)
#forceref $pObject, $pOleobj
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_QueryAcceptData($pObject, $pDataobj, $pCfFormat, $vReco, $bReally, $hMetaPict)
#forceref $pObject, $pDataobj, $pCfFormat, $vReco, $bReally, $hMetaPict
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_ContextSensitiveHelp($pObject, $bEnterMode)
#forceref $pObject, $bEnterMode
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetClipboardData($pObject, $pChrg, $vReco, $pPdataobj)
#forceref $pObject, $pChrg, $vReco, $pPdataobj
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetDragDropEffect($pObject, $bDrag, $iGrfKeyState, $piEffect)
#forceref $pObject, $bDrag, $iGrfKeyState, $piEffect
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetContextMenu($pObject, $iSeltype, $pOleobj, $pChrg, $pHmenu)
#forceref $pObject, $iSeltype, $pOleobj, $pChrg, $pHmenu
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetNewStorage($pObject, $pPstg)
#forceref $pObject
Local $aSc = DllCall($__g_hLib_RichCom_OLE32, "dword", "CreateILockBytesOnHGlobal", "hwnd", 0, "int", 1, "ptr*", 0)
Local $pLockBytes = $aSc[3]
$aSc = $aSc[0]
If $aSc Then Return $aSc
$aSc = DllCall($__g_hLib_RichCom_OLE32, "dword", "StgCreateDocfileOnILockBytes", "ptr", $pLockBytes, "dword", BitOR(0x10, 2, 0x1000), "dword", 0, "ptr*", 0)
Local $tStg = DllStructCreate("ptr", $pPstg)
DllStructSetData($tStg, 1, $aSc[4])
$aSc = $aSc[0]
If $aSc Then
Local $tObj = DllStructCreate("ptr", $pLockBytes)
Local $tUnknownFuncTable = DllStructCreate("ptr[3]", DllStructGetData($tObj, 1))
Local $pReleaseFunc = DllStructGetData($tUnknownFuncTable, 3)
DllCallAddress("long", $pReleaseFunc, "ptr", $pLockBytes)
EndIf
Return $aSc
EndFunc
Global Const $INET_DOWNLOADCOMPLETE = 2
Global $__g_hTabLastWnd
Func _GUICtrlTab_ClickTab($hWnd, $iIndex, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iX, $iY
If Not $bMove Then
Local $hWinParent = _WinAPI_GetParent($hWnd)
Local $avTabPos = _GUICtrlTab_GetItemRect($hWnd, $iIndex)
$iX = $avTabPos[0] +(($avTabPos[2] - $avTabPos[0]) / 2)
$iY = $avTabPos[1] +(($avTabPos[3] - $avTabPos[1]) / 2)
ControlClick($hWinParent, "", $hWnd, $sButton, $iClicks, $iX, $iY)
Else
Local $tRECT = _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
Local $tPoint = _WinAPI_PointFromRect($tRECT, True)
$tPoint = _WinAPI_ClientToScreen($hWnd, $tPoint)
_WinAPI_GetXYFromPoint($tPoint, $iX, $iY)
Local $iMode = Opt("MouseCoordMode", 1)
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
Opt("MouseCoordMode", $iMode)
EndIf
EndFunc
Func _GUICtrlTab_GetItemRect($hWnd, $iIndex)
Local $aRect[4]
Local $tRECT = _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
Local $tRECT = DllStructCreate($tagRECT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
_SendMessage($hWnd, $TCM_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_SendMessage($hWnd, $TCM_GETITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $TCM_GETITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Return $tRECT
EndFunc
Func _GUICtrlTab_SetCurFocus($hWnd, $iIndex)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_SETCURFOCUS, $iIndex)
Else
GUICtrlSendMsg($hWnd, $TCM_SETCURFOCUS, $iIndex, 0)
EndIf
EndFunc
Func _StringBetween($sString, $sStart, $sEnd, $iMode = $STR_ENDISSTART, $bCase = False)
$sStart = $sStart ? "\Q" & $sStart & "\E" : "\A"
If $iMode <> $STR_ENDNOTSTART Then $iMode = $STR_ENDISSTART
If $iMode = $STR_ENDISSTART Then
$sEnd = $sEnd ? "(?=\Q" & $sEnd & "\E)" : "\z"
Else
$sEnd = $sEnd ? "\Q" & $sEnd & "\E" : "\z"
EndIf
If $bCase = Default Then
$bCase = False
EndIf
Local $aReturn = StringRegExp($sString, "(?s" &(Not $bCase ? "i" : "") & ")" & $sStart & "(.*?)" & $sEnd, $STR_REGEXPARRAYGLOBALMATCH)
If @error Then Return SetError(1, 0, 0)
Return $aReturn
EndFunc
Func _StringRepeat($sString, $iRepeatCount)
$iRepeatCount = Int($iRepeatCount)
If $iRepeatCount = 0 Then Return ""
If StringLen($sString) < 1 Or $iRepeatCount < 0 Then Return SetError(1, 0, "")
Local $sResult = ""
While $iRepeatCount > 1
If BitAND($iRepeatCount, 1) Then $sResult &= $sString
$sString &= $sString
$iRepeatCount = BitShift($iRepeatCount, 1)
WEnd
Return $sString & $sResult
EndFunc
Global Const $HDM_FIRST = 0x1200
Global Const $HDM_LAYOUT = $HDM_FIRST + 5
Global $__g_hHDRLastWnd
Global Const $tagHDLAYOUT = "ptr Rect;ptr WindowPos"
Func _GUICtrlHeader_Layout($hWnd, ByRef $tRECT)
Local $tLayout = DllStructCreate($tagHDLAYOUT)
Local $tWindowPos = DllStructCreate($tagWINDOWPOS)
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
DllStructSetData($tLayout, "Rect", DllStructGetPtr($tRECT))
DllStructSetData($tLayout, "WindowPos", DllStructGetPtr($tWindowPos))
_SendMessage($hWnd, $HDM_LAYOUT, 0, $tLayout, 0, "wparam", "struct*")
Else
Local $iLayout = DllStructGetSize($tLayout)
Local $iRect = DllStructGetSize($tRECT)
Local $iWindowPos = DllStructGetSize($tWindowPos)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iLayout + $iRect + $iWindowPos, $tMemMap)
DllStructSetData($tLayout, "Rect", $pMemory + $iLayout)
DllStructSetData($tLayout, "WindowPos", $pMemory + $iLayout + $iRect)
_MemWrite($tMemMap, $tLayout, $pMemory, $iLayout)
_MemWrite($tMemMap, $tRECT, $pMemory + $iLayout, $iRect)
_SendMessage($hWnd, $HDM_LAYOUT, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory + $iLayout + $iRect, $tWindowPos, $iWindowPos)
_MemFree($tMemMap)
EndIf
Return $tWindowPos
EndFunc
Global Const $LVM_FIRST = 0x1000
Global Const $LVM_GETHEADER =($LVM_FIRST + 31)
Global Const $LVM_GETITEMRECT =($LVM_FIRST + 14)
Global Const $LVN_FIRST = -100
Global $__g_hLVLastWnd
Func _GUICtrlListView_GetHeader($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $LVM_GETHEADER))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_GETHEADER, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetItemRect($hWnd, $iIndex, $iPart = 3)
Local $tRECT = _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $iPart)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $iPart = 3)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iPart)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT, $pMemory, $iRect)
_SendMessage($hWnd, $LVM_GETITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Return $tRECT
EndFunc
Global $__g_hTTLastWnd
Global Const $_TOOLTIPCONSTANTS_ClassName = "tooltips_class32"
Global Const $_TT_ghTTDefaultStyle = BitOR($TTS_ALWAYSTIP, $TTS_NOPREFIX)
Global Const $tagTOOLINFO = "uint Size;uint Flags;hwnd hWnd;uint_ptr ID;" & $tagRECT & ";handle hInst;ptr Text;lparam Param;ptr Reserved"
Func _GUIToolTip_AddTool($hTool, $hWnd, $sText, $iID = 0, $iLeft = 0, $iTop = 0, $iRight = 0, $iBottom = 0, $iFlags = Default, $iParam = 0)
Local $iBuffer, $tBuffer, $pBuffer
If $iFlags = Default Then $iFlags = BitOR($TTF_SUBCLASS, $TTF_IDISHWND)
If $sText <> -1 Then
$iBuffer = StringLen($sText) + 1
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
$pBuffer = DllStructGetPtr($tBuffer)
DllStructSetData($tBuffer, "Text", $sText)
Else
$iBuffer = 0
$pBuffer = -1
EndIf
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
DllStructSetData($tToolInfo, "Flags", $iFlags)
DllStructSetData($tToolInfo, "hWnd", $hWnd)
DllStructSetData($tToolInfo, "ID", $iID)
DllStructSetData($tToolInfo, "Left", $iLeft)
DllStructSetData($tToolInfo, "Top", $iTop)
DllStructSetData($tToolInfo, "Right", $iRight)
DllStructSetData($tToolInfo, "Bottom", $iBottom)
DllStructSetData($tToolInfo, "Param", $iParam)
Local $iRet
If _WinAPI_InProcess($hTool, $__g_hTTLastWnd) Then
DllStructSetData($tToolInfo, "Text", $pBuffer)
$iRet = _SendMessage($hTool, $TTM_ADDTOOLW, 0, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hTool, $iToolInfo + $iBuffer, $tMemMap)
If $sText <> -1 Then
Local $pText = $pMemory + $iToolInfo
DllStructSetData($tToolInfo, "Text", $pText)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
Else
DllStructSetData($tToolInfo, "Text", -1)
EndIf
_MemWrite($tMemMap, $tToolInfo, $pMemory, $iToolInfo)
$iRet = _SendMessage($hTool, $TTM_ADDTOOLW, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUIToolTip_Create($hWnd, $iStyle = $_TT_ghTTDefaultStyle)
Return _WinAPI_CreateWindowEx(0, $_TOOLTIPCONSTANTS_ClassName, "", $iStyle, 0, 0, 0, 0, $hWnd)
EndFunc
Func _GUIToolTip_GetText($hWnd, $hTool, $iID)
Local $tBuffer = DllStructCreate("wchar Text[4096]")
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
DllStructSetData($tToolInfo, "hWnd", $hTool)
DllStructSetData($tToolInfo, "ID", $iID)
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
DllStructSetData($tToolInfo, "Text", DllStructGetPtr($tBuffer))
_SendMessage($hWnd, $TTM_GETTEXTW, 0, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iToolInfo + 4096, $tMemMap)
Local $pText = $pMemory + $iToolInfo
DllStructSetData($tToolInfo, "Text", $pText)
_MemWrite($tMemMap, $tToolInfo, $pMemory, $iToolInfo)
_SendMessage($hWnd, $TTM_GETTEXTW, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pText, $tBuffer, 81)
_MemFree($tMemMap)
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUIToolTip_SetMaxTipWidth($hWnd, $iWidth)
Return _SendMessage($hWnd, $TTM_SETMAXTIPWIDTH, 0, $iWidth)
EndFunc
Global Const $PROV_RSA_AES = 24
Global Const $CRYPT_VERIFYCONTEXT = 0xF0000000
Global Const $HP_HASHSIZE = 0x0004
Global Const $HP_HASHVAL = 0x0002
Global Const $CRYPT_USERDATA = 1
Global Const $CALG_SHA1 = 0x00008004
Global $__g_aCryptInternalData[3]
Func _Crypt_Startup()
If __Crypt_RefCount() = 0 Then
Local $hAdvapi32 = DllOpen("Advapi32.dll")
If $hAdvapi32 = -1 Then Return SetError(1, 0, False)
__Crypt_DllHandleSet($hAdvapi32)
Local $iProviderID = $PROV_RSA_AES
Local $aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptAcquireContext", "handle*", 0, "ptr", 0, "ptr", 0, "dword", $iProviderID, "dword", $CRYPT_VERIFYCONTEXT)
If @error Or Not $aRet[0] Then
Local $iError = @error + 10, $iExtended = @extended
DllClose(__Crypt_DllHandle())
Return SetError($iError, $iExtended, False)
Else
__Crypt_ContextSet($aRet[1])
EndIf
EndIf
__Crypt_RefCountInc()
Return True
EndFunc
Func _Crypt_Shutdown()
__Crypt_RefCountDec()
If __Crypt_RefCount() = 0 Then
DllCall(__Crypt_DllHandle(), "bool", "CryptReleaseContext", "handle", __Crypt_Context(), "dword", 0)
DllClose(__Crypt_DllHandle())
EndIf
EndFunc
Func _Crypt_HashData($vData, $iAlgID, $bFinal = True, $hCryptHash = 0)
Local $aRet = 0, $hBuff = 0, $iError = 0, $iExtended = 0, $iHashSize = 0, $vReturn = 0
_Crypt_Startup()
Do
If $hCryptHash = 0 Then
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptCreateHash", "handle", __Crypt_Context(), "uint", $iAlgID, "ptr", 0, "dword", 0, "handle*", 0)
If @error Or Not $aRet[0] Then
$iError = @error + 10
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$hCryptHash = $aRet[5]
EndIf
$hBuff = DllStructCreate("byte[" & BinaryLen($vData) & "]")
DllStructSetData($hBuff, 1, $vData)
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptHashData", "handle", $hCryptHash, "struct*", $hBuff, "dword", DllStructGetSize($hBuff), "dword", $CRYPT_USERDATA)
If @error Or Not $aRet[0] Then
$iError = @error + 20
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
If $bFinal Then
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptGetHashParam", "handle", $hCryptHash, "dword", $HP_HASHSIZE, "dword*", 0, "dword*", 4, "dword", 0)
If @error Or Not $aRet[0] Then
$iError = @error + 30
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$iHashSize = $aRet[3]
$hBuff = DllStructCreate("byte[" & $iHashSize & "]")
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptGetHashParam", "handle", $hCryptHash, "dword", $HP_HASHVAL, "struct*", $hBuff, "dword*", DllStructGetSize($hBuff), "dword", 0)
If @error Or Not $aRet[0] Then
$iError = @error + 40
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$vReturn = DllStructGetData($hBuff, 1)
Else
$vReturn = $hCryptHash
EndIf
Until True
If $hCryptHash <> 0 And $bFinal Then DllCall(__Crypt_DllHandle(), "bool", "CryptDestroyHash", "handle", $hCryptHash)
_Crypt_Shutdown()
Return SetError($iError, $iExtended, $vReturn)
EndFunc
Func __Crypt_RefCount()
Return $__g_aCryptInternalData[0]
EndFunc
Func __Crypt_RefCountInc()
$__g_aCryptInternalData[0] += 1
EndFunc
Func __Crypt_RefCountDec()
If $__g_aCryptInternalData[0] > 0 Then $__g_aCryptInternalData[0] -= 1
EndFunc
Func __Crypt_DllHandle()
Return $__g_aCryptInternalData[1]
EndFunc
Func __Crypt_DllHandleSet($hAdvapi32)
$__g_aCryptInternalData[1] = $hAdvapi32
EndFunc
Func __Crypt_Context()
Return $__g_aCryptInternalData[2]
EndFunc
Func __Crypt_ContextSet($hCryptContext)
$__g_aCryptInternalData[2] = $hCryptContext
EndFunc
Global Const $g_sLogoPath = @ScriptDir & "\Images\Logo.png"
Global Const $g_sLogoUrlPath = @ScriptDir & "\Images\LogoURL.png"
Global Const $g_sLogoUrlSmallPath = @ScriptDir & "\Images\LogoURLsmall.png"
Global Const $g_iGAME_WIDTH = 860
Global Const $g_iGAME_HEIGHT = 732
Global Const $g_iDEFAULT_HEIGHT = 780
Global Const $g_iDEFAULT_WIDTH = 860
Global Const $g_iMidOffsetY = Int(($g_iDEFAULT_HEIGHT - 720) / 2)
Global Const $g_iBottomOffsetY = $g_iDEFAULT_HEIGHT - 720
Global $g_hBotLaunchTime = __TimerInit()
Global $g_iBotLaunchTime = 0
Global $g_iVILLAGE_OFFSET[3] = [0, 0, 1]
Global $g_bDebugSetlog = False
Global $g_bDebugAndroid = False
Global $g_bDebugClick = False
Global $g_bDebugFuncTime = False
Global $g_bDebugFuncCall = False
Global $g_bDebugOcr = False
Global $g_bDebugImageSave = False
Global $g_bDebugBuildingPos = False
Global $g_bDebugSetlogTrain = False
Global $g_iDebugWindowMessages = 0
Global $g_bDebugAndroidEmbedded = False
Global $g_bDebugGetLocation = False
Global $g_bDebugRedArea = False
Global $g_hDebugAlwaysSaveFullScreenTimer = 0
Global $g_bDebugSmartZap = False
Global $g_bDebugAttackCSV = False
Global $g_bDebugMakeIMGCSV = False
Global $g_bDebugBetaVersion = StringInStr($g_sBotVersion, " b") > 0
Global $g_bDebugVillageSearchImages = False
Global $g_bDebugDeadBaseImage = False
Global $g_aiSearchEnableDebugDeadBaseImage = 200
Global $g_bDebugResourcesOffset = False
Global $g_bDebugMilkingIMGmake = False
Global $g_bDebugContinueSearchElixir = False
Global $g_bDebugOCRdonate = False
Global $g_bDebugDisableZoomout = False
Global $g_bDebugDisableVillageCentering = False
Global $g_iDebugGDICount = 0
Global $g_aZombie = ["" , 0 , 0 , 0 , 0 , "" , "" , 30 , 300 , 600 , 150 ]
Global $g_iDebugGDICountMax = 0
Global $g_oDebugGDIHandles = ObjCreate("Scripting.Dictionary")
Global $g_oCOMErrorHandler = 0
Global Const $COLOR_ORANGE = 0xFF7700
Global Const $COLOR_ERROR = $COLOR_RED
Global Const $COLOR_WARNING = $COLOR_MAROON
Global Const $COLOR_INFO = $COLOR_BLUE
Global Const $COLOR_SUCCESS = 0x006600
Global Const $COLOR_SUCCESS1 = 0x009900
Global Const $COLOR_DEBUG = $COLOR_PURPLE
Global Const $COLOR_DEBUG1 = 0x7A00CC
Global Const $COLOR_DEBUG2 = 0xAA80FF
Global Const $COLOR_DEBUGS = $COLOR_MEDGRAY
Global Const $COLOR_ACTION = 0xFF8000
Global Const $COLOR_ACTION1 = 0xCC80FF
Global Const $g_bCapturePixel = True, $g_bNoCapturePixel = False
Global $g_bWinMove2_Compatible = True
Global $g_sControlGetHandle2_Classname = ""
Global $g_bCriticalMessageProcessing = False
Global $g_hHBitmapTest = 0
Global $g_hBitmap
Global $g_hHBitmap
Global $g_hHBitmap2
Global $g_bOcrForceCaptureRegion = True
Global $g_iGuiMode = 1
Global $g_bGuiControlsEnabled = True
Global $g_bGuiRemote = False
Global $g_iGuiPID = @AutoItPID
Global $g_iDpiAwarenessMode = 1
Global Const $g_b64Bit = StringInStr(@OSArch, "64") > 0
Global Const $g_sHKLM = "HKLM" &($g_b64Bit ? "64" : "")
Global Const $g_sWow6432Node =($g_b64Bit ? "\Wow6432Node" : "")
Global Const $g_sGoogle = "Google"
Global $g_sAndroidGameDistributor = "Google"
Global $g_sAndroidGamePackage = "com.supercell.clashofclans"
Global $g_sAndroidGameClass = ".GameApp"
Global $g_sUserGameDistributor = "Google"
Global $g_sUserGamePackage = "com.supercell.clashofclans"
Global $g_sUserGameClass = ".GameApp"
Global $g_hAndroidLaunchTime = 0
Global $g_iAndroidRebootHours = 24
Global Const $g_bAndroidShieldPreWin8 =(_WinAPI_GetVersion() < 6.2)
Global $g_avAndroidShieldDelay[4] = [0, 0, Default, Default]
Global $g_bAndroidShieldForceDown = False
Global $g_iAndroidShieldColor = $COLOR_WHITE
Global $g_iAndroidShieldTransparency = 48
Global $g_iAndroidActiveColor = $COLOR_BLACK
Global $g_iAndroidActiveTransparency = 1
Global $g_iAndroidInactiveColor = $COLOR_WHITE
Global $g_iAndroidInactiveTransparency = 24
Global $g_bAndroidShieldEnabled = True
Global $g_bAndroidEmbedEnabled = True
Global $g_bAndroidEmbedded = False
Global $g_aiAndroidEmbeddedCtrlTarget[10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_avAndroidShieldStatus[5] = [Default, 0, 0, Default, Default]
Global $g_bPoliteCloseCoC = False
Global Const $g_bAndroidBackgroundLaunchEnabled = False
Global $g_bAndroidCheckTimeLagEnabled = True
Global $g_iAndroidAdbAutoTerminate = 0
Global $g_bAndroidAdbScreencapEnabled = True
Global $g_bAndroidAdbScreencapPngEnabled = False
Global $g_bAndroidAdbZoomoutEnabled = True
Global $g_bAndroidAdbClickDragEnabled = True
Global $g_bAndroidAdbInputEnabled = True
Global $g_iAndroidAdbInputWordsCharLimit = 10
Global $g_bAndroidAdbClickEnabled = False
Global $g_bAndroidAdbClicksEnabled = False
Global $g_iAndroidAdbClicksTroopDeploySize = 0
Global $g_bAndroidAdbInstanceEnabled = True
Global $g_bAndroidSuspendedEnabled = True
Global $g_iAndroidSuspendModeFlags = 1
Global $g_bNoFocusTampering = False
Global $g_iAndroidRecoverStrategy = 1
Global $__BlueStacks2Version_2_5_or_later = False
Global $__MEmu_ToolBar_Width = 45
Global $__MEmu_SystemBar = 36
Global $__MEmu_PhoneLayout = "2"
Global $__MEmu_Window[4][5] = [ ["3.0.8", $g_iDEFAULT_WIDTH + 40, $g_iDEFAULT_HEIGHT - 14, 36, "-1"], ["2.6.2", $g_iDEFAULT_WIDTH + 48, $g_iDEFAULT_HEIGHT - 10, 40, "2"], ["2.5.0", $g_iDEFAULT_WIDTH + 51, $g_iDEFAULT_HEIGHT - 12, 45, "0"], ["2.2.1", $g_iDEFAULT_WIDTH + 51, $g_iDEFAULT_HEIGHT - 12, 45, "0"] ]
Global $__Droid4X_Window[3][3] = [ ["0.10.0", $g_iDEFAULT_WIDTH + 6, $g_iDEFAULT_HEIGHT + 53], ["0.8.6", $g_iDEFAULT_WIDTH + 10, $g_iDEFAULT_HEIGHT + 50] ]
Global $__Nox_Config[1][2] = [ ["3.3.0", "[CLASS:subWin; INSTANCE:1]|[TEXT:QWidgetClassWindow; CLASS:Qt5QWindowIcon]"] ]
Global $g_avAndroidAppConfig[8][16] = [ ["Nox", "nox", "No", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH + 4, $g_iDEFAULT_HEIGHT - 10,0, "127.0.0.1:62001", 1 + 2 + 4 + 8 + 16 + 32 + 256,'# ', '(nox Virtual Input|Android Input|Android_Input)', 0, 2], ["MEmu", "MEmu", "MEmu ", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH + 51,$g_iDEFAULT_HEIGHT - 12,0, "127.0.0.1:21503", 2 + 4 + 8 + 16 + 32, '# ', '(Microvirt Virtual Input|User Input)', 0, 2], ["BlueStacks2","Android", "BlueStacks ", "[CLASS:BlueStacksApp; INSTANCE:1]","_ctl.Window", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,0, "127.0.0.1:5555", 1 + 2 + 8 + 16 + 32 + 128,'$ ', 'BlueStacks Virtual Touch', 0, 1], ["BlueStacks", "Android", "BlueStacks App Player","[CLASS:BlueStacksApp; INSTANCE:1]","_ctl.Window", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,0, "127.0.0.1:5555", 1 + 8 + 16 + 32 + 128,'$ ', 'BlueStacks Virtual Touch', 0, 1], ["iTools", "iToolsVM","iTools ", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH + 2, $g_iDEFAULT_HEIGHT - 13,0, "127.0.0.1:54001", 1 + 2 + 8 + 16 + 32 + 64, '# ', 'iTools Virtual PassThrough Input', 0, 1], ["KOPLAYER", "KOPLAYER","KOPLAYER", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH + 64,$g_iDEFAULT_HEIGHT - 8, 0, "127.0.0.1:6555", 1 + 2 + 4 + 8 + 16 + 32, '# ', 'ttVM Virtual Input', 0, 2], ["Droid4X", "droid4x", "Droid4X ", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH + 10,$g_iDEFAULT_HEIGHT + 50,0, "127.0.0.1:26944", 2 + 4 + 8 + 16 + 32, '# ', 'droid4x Virtual Input', 0, 2], ["LeapDroid", "vm1", "Leapd", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,0, "emulator-5554", 1 + 8 + 16 + 32, '# ', 'qwerty2', 1, 1] ]
Global $__MEmu_Idx = _ArraySearch($g_avAndroidAppConfig, "MEmu", 0, 0, 0, 0, 1, 0)
Global $__BS2_Idx = _ArraySearch($g_avAndroidAppConfig, "BlueStacks2", 0, 0, 0, 0, 1, 0)
Global $__BS_Idx = _ArraySearch($g_avAndroidAppConfig, "BlueStacks", 0, 0, 0, 0, 1, 0)
Global $__KOPLAYER_Idx = _ArraySearch($g_avAndroidAppConfig, "KOPLAYER", 0, 0, 0, 0, 1, 0)
Global $__LeapDroid_Idx = _ArraySearch($g_avAndroidAppConfig, "LeapDroid", 0, 0, 0, 0, 1, 0)
Global $__iTools_Idx = _ArraySearch($g_avAndroidAppConfig, "iTools", 0, 0, 0, 0, 1, 0)
Global $__Droid4X_Idx = _ArraySearch($g_avAndroidAppConfig, "Droid4X", 0, 0, 0, 0, 1, 0)
Global $__Nox_Idx = _ArraySearch($g_avAndroidAppConfig, "Nox", 0, 0, 0, 0, 1, 0)
Global $g_bOnlyInstance = True
Global $g_bFoundRunningAndroid = False
Global $g_bFoundInstalledAndroid = False
Global Const $g_iOpenAndroidActiveMaxTry = 3
Global Const $g_iAndroidBackgroundModeDirectX = 1
Global Const $g_iAndroidBackgroundModeOpenGL = 2
Global $g_iAndroidBackgroundMode = 0
Global $g_iAndroidBackgroundModeDefault = 1
Global $g_iAndroidConfig = 0
Global $g_sAndroidVersion
Global $g_sAndroidEmulator
Global $g_sAndroidInstance
Global $g_sAndroidTitle
Global $g_bUpdateAndroidWindowTitle = False
Global $g_sAppClassInstance
Global $g_sAppPaneName
Global $g_iAndroidClientWidth
Global $g_iAndroidClientHeight
Global $g_iAndroidWindowWidth
Global $g_iAndroidWindowHeight
Global $g_sAndroidAdbPath
Global $g_sAndroidAdbDevice
Global $g_iAndroidSupportFeature
Global $g_sAndroidShellPrompt
Global $g_sAndroidMouseDevice
Global $g_iAndroidAdbSuCommand
Global $g_bAndroidAdbScreencap
Global $g_bAndroidAdbClick
Global $g_bAndroidAdbInput
Global $g_bAndroidAdbInstance
Global $g_bAndroidAdbClickDrag
Global $g_bAndroidAdbClickDragScript = True
Global $g_bAndroidEmbed
Global $g_iAndroidEmbedMode
Global $g_bAndroidBackgroundLaunch
Global $g_bAndroidBackgroundLaunched
Global $g_iAndroidControlClickDelay = 10
Global $g_iAndroidControlClickDownDelay = 2
Global $g_iAndroidControlClickWindow = 0
Global $g_iAndroidControlClickMode = 0
Global $g_bAndroidCloseWithBot = False
Global $g_bAndroidInitialized = False
Global $g_iAndroidProcessAffinityMask = 0
Global Const $g_iAndroidJellyBean = 17
Global Const $g_iAndroidLollipop = 21
Global Const $g_iAndroidNougat = 24
Global $g_iAndroidVersionAPI = $g_iAndroidJellyBean
Global $g_bInitAndroidActive = False
Global $g_sAndroidPath = ""
Global $g_sAndroidProgramPath = ""
Global $b_sAndroidProgramWerFaultExcluded = True
Global $g_avAndroidProgramFileVersionInfo = 0
Global $g_bAndroidHasSystemBar = False
Global $g_iAndroidLaunchWaitSec = 240
Global $g_sAndroidPicturesPath = ""
Global $g_sAndroidPicturesHostPath = ""
Global $g_bAndroidSharedFolderAvailable = True
Global Const $g_iAndroidSecureFlags = 3
Global $g_sAndroidPicturesHostFolder = ""
Global $g_bAndroidPicturesPathAutoConfig = True
Global $g_iAndroidAdbAutoTerminateCount = 0
Global $g_aiAndroidAdbScreencapBuffer = DllStructCreate("byte[" &($g_iDEFAULT_WIDTH * $g_iDEFAULT_HEIGHT * 4) & "]")
Global $g_hAndroidAdbScreencapBufferPngHandle = 0
Global Const $g_iAndroidAdbScreencapWaitAdbTimeout = 10000
Global Const $g_iAndroidAdbScreencapWaitFileTimeout = 10000
Global $g_iAndroidAdbScreencapTimer = 0
Global $g_iAndroidAdbScreencapTimeoutMin = 200
Global $g_iAndroidAdbScreencapTimeoutMax = 1000
Global $g_iAndroidAdbScreencapTimeout = $g_iAndroidAdbScreencapTimeoutMax
Global $g_iAndroidAdbScreencapTimeoutDynamic = 3
Global $g_iAndroidAdbScreencapWidth = 0
Global $g_iAndroidAdbScreencapHeight = 0
Global $g_iAndroidAdbClickGroup = 10
Global Const $g_iAndroidAdbClickGroupDelay = 50
Global $g_bAndroidAdbKeepClicksActive = False
Global $g_aiAndroidTimeLag[6] = [0, 0, 0, 0, 0, 0]
Global Const $g_iAndroidTimeLagThreshold = 5
Global Const $g_iAndroidTimeLagRebootThreshold = 2
Global Const $g_iAndroidTimeLagResetProblemCountMinutes = 5
Global Const $g_iAndroidRebootPageErrorCount = 5
Global Const $g_iAndroidRebootAdbCommandErrorCount = 10
Global Const $g_iAndroidRebootPageErrorPerMinutes = 10
Global $g_hProcShieldInput[5] = [0, 0, False, False, 0]
Global $g_bSkipFirstZoomout = False
Global $g_bForceCapture = False
Global $g_hAndroidWindow = 0
Global $g_hAndroidWindowDpiAware = 0
Global $g_hAndroidControl = 0
Global $g_bInitAndroid = True
Global Const $g_iCoCReconnectingTimeout = 60000
Global $__BlueStacks_Version
Global $__BlueStacks_Path
Global $__Droid4X_Version
Global $__Droid4X_Path
Global $__MEmu_Path
Global $__LeapDroid_Path
Global $__Nox_Path
Global $__KOPLAYER_Path
Global $__iTools_Path
Global $__VBoxManage_Path
Global $__VBoxVMinfo
Global $__VBoxGuestProperties
Global $__VBoxExtraData
Global $g_iGlobalActiveBotsAllowed = EnvGet("NUMBER_OF_PROCESSORS")
If IsNumber($g_iGlobalActiveBotsAllowed) = 0 Or $g_iGlobalActiveBotsAllowed < 1 Then $g_iGlobalActiveBotsAllowed = 2
Global $g_hMutextOrSemaphoreGlobalActiveBots = 0
Global $g_iGlobalThreads = 0
Global $g_iThreads = 0
Global $g_sProfilePath = @ScriptDir & "\Profiles"
Global $g_sPrivateProfilePath = @MyDocumentsDir & "\MyBot.run-Profiles"
Global Const $g_sProfilePresetPath = @ScriptDir & "\Strategies"
Global $g_sProfileCurrentName = ""
Global $g_sProfileConfigPath = ""
Global $g_sProfileBuildingStatsPath = ""
Global $g_sProfileBuildingPath = ""
Global $g_sProfileLogsPath = "", $g_sProfileLootsPath = "", $g_sProfileTempPath = "", $g_sProfileTempDebugPath = ""
Global $g_sProfileDonateCapturePath = "", $g_sProfileDonateCaptureWhitelistPath = "", $g_sProfileDonateCaptureBlacklistPath = ""
Global $g_sProfileSecondaryInputFileName = ""
Global $g_sProfileSecondaryOutputFileName = ""
Global $g_asProfiles[0]
Global $g_bReadConfigIsActive = False
Global $g_bSaveConfigIsActive = False
Global $g_bApplyConfigIsActive = False
Global $g_hTxtLogTimer = __TimerInit()
Global Const $g_iTxtLogTimerTimeout = 500
Global $g_bMoveDivider = False
Global $g_bSilentSetLog = False
Global $g_sLogFileName = ""
Global $g_hLogFile = 0
Global $g_hAttackLogFile = 0
Global $g_hSwitchLogFile = 0
Global $g_bFlushGuiLogActive = False
Global $g_iLogCheckFreeSpaceMB = 100
Global $g_hStruct_SleepMicro = DllStructCreate("int64 time;")
Global $g_pStruct_SleepMicro = DllStructGetPtr($g_hStruct_SleepMicro)
Global Const $g_iEmptyWorkingSetAndroid = 0
Global Const $g_iEmptyWorkingSetBot = 300
Global Const $g_bMoveMouseOutBS = False
Global $g_bDevMode = False
Global $g_bBotLaunchOption_HideAndroid = False
Global $g_bBotLaunchOption_Restart = False
Global $g_bBotLaunchOption_Autostart = False
Global $g_bBotLaunchOption_NoWatchdog = False
Global $g_bBotLaunchOption_ForceDpiAware = False
Global $g_iBotLaunchOption_Dock = 0
Global $g_bBotLaunchOption_NoBotSlot = False
Global $g_iBotLaunchOption_Console = False
Global $g_iBotLaunchOption_Help = False
Global $g_asCmdLine[1] = [0]
Global Const $g_sWorkingDir = @WorkingDir
Global $g_hMutex_BotTitle = 0
Global $g_ahMutex_Profile[0][2]
Global $g_ahMutex_SwitchAccountsGroup = [0, 0]
Global $g_hMutex_MyBot = 0
Global $g_BotInstanceCount = 0
Global $g_aiWeakBaseStats
Global Const $g_sLibPath = @ScriptDir & "\lib"
Global Const $g_sLibImageSearchPath = $g_sLibPath & "\ImageSearchDLL.dll"
Global Const $g_sMBRLib = "MyBot.run.dll"
Global $g_bLibMyBotActive = False
Global Const $g_sLibMyBotPath = $g_sLibPath & "\" & $g_sMBRLib
Global $g_hLibMyBot = -1
Global $g_hLibNTDLL = DllOpen("ntdll.dll")
Global $g_hLibUser32DLL = DllOpen("user32.dll")
Global Const $g_sLibIconPath = $g_sLibPath & "\MBRBOT.dll"
Global Const $g_sTHSnipeAttacksPath = @ScriptDir & "\CSV\THSnipe"
Global Const $g_sCSVAttacksPath = @ScriptDir & "\CSV\Attack"
Global Const $g_sIcnMBisland = @ScriptDir & "\Images\bbico.png"
Global Const $g_sIcnBldGold = @ScriptDir & "\Images\gold.png"
Global Const $g_sIcnBldElixir = @ScriptDir & "\Images\elixir.png"
Global Const $g_sIcnBldTrophy = @ScriptDir & "\Images\trophy.png"
Global $g_iRedrawBotWindowMode = 2
Global Enum $eIcnArcher = 1, $eIcnDonArcher, $eIcnBalloon, $eIcnDonBalloon, $eIcnBarbarian, $eIcnDonBarbarian, $eBtnTest, $eIcnBuilder, $eIcnCC, $eIcnGUI, $eIcnDark, $eIcnDragon, $eIcnDonDragon, $eIcnDrill, $eIcnElixir, $eIcnCollector, $eIcnFreezeSpell, $eIcnGem, $eIcnGiant, $eIcnDonGiant, $eIcnTrap, $eIcnGoblin, $eIcnDonGoblin, $eIcnGold, $eIcnGolem, $eIcnDonGolem, $eIcnHealer, $eIcnDonHealer, $eIcnHogRider, $eIcnDonHogRider, $eIcnHealSpell, $eIcnInferno, $eIcnJumpSpell, $eIcnLavaHound, $eIcnDonLavaHound, $eIcnLightSpell, $eIcnMinion, $eIcnDonMinion, $eIcnPekka, $eIcnDonPekka, $eIcnTreasury, $eIcnRageSpell, $eIcnTroops, $eIcnHourGlass, $eIcnTH1, $eIcnTH10, $eIcnTrophy, $eIcnValkyrie, $eIcnDonValkyrie, $eIcnWall, $eIcnWallBreaker, $eIcnDonWallBreaker, $eIcnWitch, $eIcnDonWitch, $eIcnWizard, $eIcnDonWizard, $eIcnXbow, $eIcnBarrackBoost, $eIcnMine, $eIcnCamp, $eIcnBarrack, $eIcnSpellFactory, $eIcnDonBlacklist, $eIcnSpellFactoryBoost, $eIcnMortar, $eIcnWizTower, $eIcnPayPal, $eIcnNotify, $eIcnGreenLight, $eIcnLaboratory, $eIcnRedLight, $eIcnBlank, $eIcnYellowLight, $eIcnDonCustom, $eIcnTombstone, $eIcnSilverStar, $eIcnGoldStar, $eIcnDarkBarrack, $eIcnCollectorLocate, $eIcnDrillLocate, $eIcnMineLocate, $eIcnBarrackLocate, $eIcnDarkBarrackLocate, $eIcnDarkSpellFactoryLocate, $eIcnDarkSpellFactory, $eIcnEarthQuakeSpell, $eIcnHasteSpell, $eIcnPoisonSpell, $eIcnBldgTarget, $eIcnBldgX, $eIcnRecycle, $eIcnHeroes, $eIcnBldgElixir, $eIcnBldgGold, $eIcnMagnifier, $eIcnWallElixir, $eIcnWallGold, $eIcnKing, $eIcnQueen, $eIcnDarkSpellBoost, $eIcnQueenBoostLocate, $eIcnKingBoostLocate, $eIcnKingUpgr, $eIcnQueenUpgr, $eIcnWardenUpgr, $eIcnWarden, $eIcnWardenBoostLocate, $eIcnKingBoost, $eIcnQueenBoost, $eIcnWardenBoost, $eEmpty3, $eIcnReload, $eIcnCopy, $eIcnAddcvs, $eIcnEdit, $eIcnTreeSnow, $eIcnSleepingQueen, $eIcnSleepingKing, $eIcnGoldElixir, $eIcnBowler, $eIcnDonBowler, $eIcnCCDonate, $eIcnEagleArt, $eIcnGembox, $eIcnInferno4, $eIcnInfo, $eIcnMain, $eIcnTree, $eIcnProfile, $eIcnCCRequest, $eIcnTelegram, $eIcnTiles, $eIcnXbow3, $eIcnBark, $eIcnDailyProgram, $eIcnLootCart, $eIcnSleepMode, $eIcnTH11, $eIcnTrainMode, $eIcnSleepingWarden, $eIcnCloneSpell, $eIcnSkeletonSpell, $eIcnBabyDragon, $eIcnDonBabyDragon, $eIcnMiner, $eIcnDonMiner, $eIcnNoShield, $eIcnDonCustomB, $eIcnAirdefense, $eIcnDarkBarrackBoost, $eIcnDarkElixirStorage, $eIcnSpellsCost, $eIcnTroopsCost, $eIcnResetButton, $eIcnNewSmartZap, $eIcnTrain, $eIcnAttack, $eIcnDelay, $eIcnReOrder, $eIcn2Arrow, $eIcnArrowLeft, $eIcnArrowRight, $eIcnAndroid, $eHdV04, $eHdV05, $eHdV06, $eHdV07, $eHdV08, $eHdV09, $eHdV10, $eHdV11, $eUnranked, $eBronze, $eSilver, $eGold, $eCrystal, $eMaster, $eChampion, $eTitan, $eLegend, $eWall04, $eWall05, $eWall06, $eWall07, $eWall08, $eWall09, $eWall10, $eWall11, $eIcnPBNotify, $eIcnCCTroops, $eIcnCCSpells, $eIcnSpellsGroup, $eBahasaIND, $eChinese_S, $eChinese_T, $eEnglish, $eFrench, $eGerman, $eItalian, $ePersian, $eRussian, $eSpanish, $eTurkish, $eMissingLangIcon, $eWall12, $ePortuguese, $eIcnDonPoisonSpell, $eIcnDonEarthQuakeSpell, $eIcnDonHasteSpell, $eIcnDonSkeletonSpell, $eVietnamese, $eKorean, $eAzerbaijani, $eArabic, $eIcnBuilderHall, $eIcnClockTower, $eIcnElixirCollectorL5, $eIcnGemMine, $eIcnGoldMineL5, $eIcnElectroDragon, $eIcnTH12, $eHdV12, $eWall13, $eIcnGrayShield, $eIcnBlueShield, $eIcnGreenShield, $eIcnRedShield
Global $eIcnDonBlank = $eIcnDonBlacklist
Global $eIcnOptions = $eIcnDonBlacklist
Global $eIcnAchievements = $eIcnMain
Global $eIcnStrategies = $eIcnBlank
Global Const $g_iCollectAtCount = 10
Global Enum $eBotNoAction, $eBotStart, $eBotStop, $eBotSearchMode, $eBotClose
Global $g_iBotAction = $eBotNoAction
Global $g_bBotMoveRequested = False
Global $g_bBotShrinkExpandToggleRequested = False
Global $g_bBotGuiModeToggleRequested = False
Global $g_bRestart = False
Global $g_bRunState = False
Global $g_bIdleState = False
Global $g_bBtnAttackNowPressed = False
Global $g_iCommandStop = -1
Global $g_bMeetCondStop = False
Global $g_bRestarted =($g_bBotLaunchOption_Autostart ? True : False)
Global $g_bFirstStart = True
Global $g_iFirstRun = 1
Global $g_iFirstAttack = 0
Global $g_hTimerSinceStarted = 0
Global $g_iTimePassed = 0
Global $g_bBotPaused = False
Global $g_bTogglePauseUpdateState = False
Global $g_bTogglePauseAllowed = True
Global $g_bWaitShield = False
Global $g_bGForcePBTUpdate = False
Global $g_bQuicklyFirstStart = True
Global $g_bQuickAttack = False
Global $g_sTimeBeforeTrain = ""
Global $g_hAttackTimer = 0
Global $g_iAttackTimerOffset = Default
Global Const $REDLINE_IMGLOC_RAW = 0
Global Const $REDLINE_IMGLOC = 1
Global Const $REDLINE_ORIGINAL = 2
Global Const $REDLINE_NONE = 3
Global Const $DROPLINE_EDGE_FIXED = 0
Global Const $DROPLINE_EDGE_FIRST = 1
Global Const $DROPLINE_FULL_EDGE_FIXED = 2
Global Const $DROPLINE_FULL_EDGE_FIRST = 3
Global Const $DROPLINE_DROPPOINTS_ONLY = 4
Global Enum $eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine, $eEDrag, $eMini, $eHogs, $eValk, $eGole, $eWitc, $eLava, $eBowl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell, $eArmyCount
Global Enum $DB, $LB, $TS, $MA, $TB, $DT
Global Const $g_iModeCount = 3
Global $g_iMatchMode = 0
Global Const $g_asModeText[6] = ["Dead Base", "Live Base", "TH Snipe", "Milking Attack", "TH Bully", "Drop Trophy"]
Global Enum $eTroopBarbarian, $eTroopArcher, $eTroopGiant, $eTroopGoblin, $eTroopWallBreaker, $eTroopBalloon, $eTroopWizard, $eTroopHealer, $eTroopDragon, $eTroopPekka, $eTroopBabyDragon, $eTroopMiner, $eTroopElectroDragon, $eTroopMinion, $eTroopHogRider, $eTroopValkyrie, $eTroopGolem, $eTroopWitch, $eTroopLavaHound, $eTroopBowler, $eTroopCount
Global Const $g_asTroopNames[$eTroopCount] = [ "Barbarian", "Archer", "Giant", "Goblin", "Wall Breaker", "Balloon", "Wizard", "Healer", "Dragon", "Pekka", "Baby Dragon", "Miner", "Electro Dragon", "Minion", "Hog Rider", "Valkyrie", "Golem", "Witch", "Lava Hound", "Bowler"]
Global Const $g_asTroopNamesPlural[$eTroopCount] = [ "Barbarians", "Archers", "Giants", "Goblins", "Wall Breakers", "Balloons", "Wizards", "Healers", "Dragons", "Pekkas", "Baby Dragons", "Miners", "Electro Dragons", "Minions", "Hog Riders", "Valkyries", "Golems", "Witches", "Lava Hounds", "Bowlers"]
Global Const $g_asTroopShortNames[$eTroopCount] = [ "Barb", "Arch", "Giant", "Gobl", "Wall", "Ball", "Wiza", "Heal", "Drag", "Pekk", "BabyD", "Mine", "EDrag", "Mini", "Hogs", "Valk", "Gole", "Witc", "Lava", "Bowl"]
Global Const $g_aiTroopSpace[$eTroopCount] = [ 1, 1, 5, 1, 2, 5, 4, 14, 20, 25, 10, 6, 30, 2, 5, 8, 30, 12, 30, 6]
Global Const $g_aiTroopTrainTime[$eTroopCount] = [ 20, 24, 120, 28, 60, 120, 120, 480, 720, 720, 360, 120, 1440, 36, 90, 180, 600, 360, 600, 120]
Global Const $g_aiTroopCostPerLevel[$eTroopCount][10] = [ [8, 25, 40, 60, 100, 150, 200, 250, 300], [8, 50, 80, 120, 200, 300, 400, 500, 600], [9, 250, 750, 1250, 1750, 2250, 3000, 3500, 4000, 4500], [7, 25, 40, 60, 80, 100, 150, 200], [8, 1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500], [8, 2000, 2500, 3000, 3500, 4000, 4500, 5000, 5500], [9, 1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000, 5500], [5, 5000, 6000, 8000, 10000, 15000], [7, 18000, 20000, 22000, 24000, 26000, 28000, 30000], [8, 21000, 24000, 27000, 30000, 33000, 35000, 37000, 39000], [6, 15000, 16000, 17000, 18000, 19000, 20000], [6, 4200, 4800, 5200, 5600, 6000, 6400], [3, 36000, 40000, 44000], [8, 6, 7, 8, 9, 10, 11, 12, 13], [8, 40, 45, 52, 58, 65, 90, 115, 140], [7, 70, 100, 130, 160, 190, 220, 250], [8, 450, 525, 600, 675, 750, 825, 900, 975], [4, 250, 350, 450, 550], [5, 390, 450, 510, 570, 630], [4, 130, 150, 170, 190]]
Global Const $g_aiTroopDonateXP[$eTroopCount] = [1, 1, 5, 1, 2, 5, 4, 14, 20, 25, 10, 5, 30, 2, 5, 8, 30, 12, 30, 6]
Global Enum $eSpellLightning, $eSpellHeal, $eSpellRage, $eSpellJump, $eSpellFreeze, $eSpellClone, $eSpellPoison, $eSpellEarthquake, $eSpellHaste, $eSpellSkeleton, $eSpellCount
Global Const $g_asSpellNames[$eSpellCount] = ["Lightning", "Heal", "Rage", "Jump", "Freeze", "Clone", "Poison", "Earthquake", "Haste", "Skeleton"]
Global Const $g_asSpellShortNames[$eSpellCount] = ["LSpell", "HSpell", "RSpell", "JSpell", "FSpell", "CSpell", "PSpell", "ESpell", "HaSpell", "SkSpell"]
Global Const $g_aiSpellSpace[$eSpellCount] = [2, 2, 2, 2, 1, 3, 1, 1, 1, 1]
Global Const $g_aiSpellTrainTime[$eSpellCount] = [360, 360, 360, 360, 360, 720, 180, 180, 180, 180]
Global Const $g_aiSpellCostPerLevel[$eSpellCount][8] = [ [7, 15000, 16500, 18000, 20000, 22000, 24000, 26000], [7, 15000, 16500, 18000, 19000, 21000, 23000, 25000], [5, 23000, 25000, 27000, 30000, 33000], [3, 23000, 27000, 31000], [7, 12000, 13000, 14000, 15000, 16000, 17000, 18000], [5, 38000, 39000, 41000, 43000, 45000], [5, 95, 110, 125, 140, 155], [4, 125, 140, 160, 180], [4, 80, 85, 90, 95], [5, 110, 120, 130, 140, 150]]
Global Const $g_aiSpellDonateXP[$eSpellCount] = [10, 10, 10, 10, 10, 0, 5, 5, 5, 5]
Global Enum $eHeroNone = 0, $eHeroKing = 1, $eHeroQueen = 2, $eHeroWarden = 4
Global Enum $eHeroBarbarianKing, $eHeroArcherQueen, $eHeroGrandWarden, $eHeroCount
Global Const $g_asHeroNames[$eHeroCount] = ["Barbarian King", "Archer Queen", "Grand Warden"]
Global Const $g_asHeroShortNames[$eHeroCount] = ["King", "Queen", "Warden"]
Global $g_aiHeroBoost[$eHeroCount] = ["1970/01/01 00:00:00", "1970/01/01 00:00:00", "1970/01/01 00:00:00"]
Global Enum $eLeagueUnranked, $eLeagueBronze, $eLeagueSilver, $eLeagueGold, $eLeagueCrystal, $eLeagueMaster, $eLeagueChampion, $eLeagueTitan, $eLeagueLegend, $eLeagueCount
Global Const $g_asLeagueDetails[22][5] = [ ["0", "Bronze III", "0", "B3", "400"], ["1000", "Bronze II", "0", "B2", "500"], ["1300", "Bronze I", "0", "B1", "600"], ["2600", "Silver III", "0", "S3", "800"], ["3700", "Silver II", "0", "S2", "1000"], ["4800", "Silver I", "0", "S1", "1200"], ["10000", "Gold III", "0", "G3", "1400"], ["13500", "Gold II", "0", "G2", "1600"], ["17000", "Gold I", "0", "G1", "1800"], ["40000", "Crystal III", "120", "c3", "2000"], ["55000", "Crystal II", "220", "c2", "2200"], ["70000", "Crystal I", "320", "c1", "2400"], ["110000", "Master III", "560", "M3", "2600"], ["135000", "Master II", "740", "M2", "2800"], ["160000", "Master I", "920", "M1", "3000"], ["200000", "Champion III", "1220", "C3", "3200"], ["225000", "Champion II", "1400", "C2", "3500"], ["250000", "Champion I", "1580", "C1", "3800"], ["280000", "Titan III", "1880", "T3", "4100"], ["300000", "Titan II", "2060", "T2", "4400"], ["320000", "Titan I", "2240", "T1", "4700"], ["340000", "Legend", "2400", "LE", "5000"]]
Global Enum $eLootGold, $eLootElixir, $eLootDarkElixir, $eLootTrophy, $eLootCount
Global Enum $eLootGoldBB, $eLootElixirBB, $eLootTrophyBB, $eLootCountBB
Func TroopIndexLookup(Const $sName, Const $sSource = "")
For $i = 0 To UBound($g_asTroopShortNames) - 1
If $sName = $g_asTroopShortNames[$i] Then
Return $i
EndIf
Next
For $i = 0 To UBound($g_asSpellShortNames) - 1
If $sName = $g_asSpellShortNames[$i] Then
Return $i + $eLSpell
EndIf
Next
For $i = 0 To UBound($g_asHeroShortNames) - 1
If $sName = $g_asHeroShortNames[$i] Then
Return $i + $eKing
EndIf
Next
If $sName = "castle" Then Return $eCastle
SetDebugLog("TroopIndexLookup() Error: Index for troop name '" & $sName & "' not found" &(($sSource) ?(" (" & $sSource & ").") :(".")))
Return -1
EndFunc
Func GetTroopName(Const $iIndex)
If $iIndex >= $eBarb And $iIndex <= $eBowl Then
Return $g_asTroopNames[$iIndex]
ElseIf $iIndex >= $eLSpell And $iIndex <= $eSkSpell Then
Return $g_asSpellNames[$iIndex - $eLSpell]
ElseIf $iIndex >= $eKing And $iIndex <= $eWarden Then
Return $g_asHeroNames[$iIndex - $eKing]
ElseIf $iIndex = $eCastle Then
Return "Clan Castle"
EndIf
EndFunc
Global $g_iLogDividerY = 385
Global Const $g_iLogDividerHeight = 4
Global $g_iCmbLogDividerOption = 0
Global $g_bChkBackgroundMode
Global $g_bMakeScreenshotNow = False
Global $g_bChkBotStop = False, $g_iCmbBotCommand = 0, $g_iCmbBotCond = 0, $g_iCmbHoursStop = 0
Global $g_iTxtRestartGold = 10000
Global $g_iTxtRestartElixir = 25000
Global $g_iTxtRestartDark = 500
Global $g_bChkTrap = True, $g_bChkCollect = True, $g_bChkTombstones = True, $g_bChkCleanYard = False, $g_bChkGemsBox = False
Global $g_bChkTreasuryCollect = False
Global $g_iTxtTreasuryGold = 0
Global $g_iTxtTreasuryElixir = 0
Global $g_iTxtTreasuryDark = 0
Global $g_bChkCollectBuilderBase = False, $g_bChkStartClockTowerBoost = False, $g_bChkCTBoostBlderBz = False
Global $g_bRequestTroopsEnable = False
Global $g_sRequestTroopsText = ""
Global $g_abRequestCCHours[24] = [False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
Global $g_bChkDonate = True
Global Enum $eCustomA = $eTroopCount, $eCustomB = $eTroopCount + 1
Global Enum $eCustomC = $eTroopCount + 2, $eCustomD = $eTroopCount + 3
Global Const $g_iCustomDonateConfigs = 4
Global $g_abChkDonateTroop[$eTroopCount + $g_iCustomDonateConfigs] = [False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
Global $g_abChkDonateAllTroop[$eTroopCount + $g_iCustomDonateConfigs] = [False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
Global $g_asTxtDonateTroop[$eTroopCount + $g_iCustomDonateConfigs] = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]
Global $g_asTxtBlacklistTroop[$eTroopCount + $g_iCustomDonateConfigs] = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]
Global $g_abChkDonateSpell[$eSpellCount] = [False, False, False, False, False, False, False, False, False, False]
Global $g_abChkDonateAllSpell[$eSpellCount] = [False, False, False, False, False, False, False, False, False, False]
Global $g_asTxtDonateSpell[$eSpellCount] = ["", "", "", "", "", "", "", "", "", ""]
Global $g_asTxtBlacklistSpell[$eSpellCount] = ["", "", "", "", "", "", "", "", "", ""]
Global $g_aiDonateCustomTrpNumA[3][2] = [[0, 0], [0, 0], [0, 0]], $g_aiDonateCustomTrpNumB[3][2] = [[0, 0], [0, 0], [0, 0]]
Global $g_aiDonateCustomTrpNumC[3][2] = [[0, 0], [0, 0], [0, 0]], $g_aiDonateCustomTrpNumD[3][2] = [[0, 0], [0, 0], [0, 0]]
Global $g_bChkExtraAlphabets = False
Global $g_bChkExtraChinese = False
Global $g_bChkExtraKorean = False
Global $g_bChkExtraPersian = False
Global $g_sTxtGeneralBlacklist = ""
Global $g_bDonateHoursEnable = False
Global $g_abDonateHours[24] = [False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
Global $g_iCmbDonateFilter = 0
Global $g_bDonateSkipNearFullEnable = 1
Global $g_iDonateSkipNearFullPercent = 90
Global $g_bAutoLabUpgradeEnable = False, $g_iCmbLaboratory = 0
Global $g_bUpgradeKingEnable = False, $g_bUpgradeQueenEnable = False, $g_bUpgradeWardenEnable = False
Global Const $g_iUpgradeSlots = 14
Global $g_aiPicUpgradeStatus[$g_iUpgradeSlots] = [$eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops]
Global $g_abBuildingUpgradeEnable[$g_iUpgradeSlots] = [False, False, False, False, False, False, False, False, False, False, False, False, False, False]
Global $g_avBuildingUpgrades[$g_iUpgradeSlots][8]
For $i = 0 To $g_iUpgradeSlots - 1
$g_avBuildingUpgrades[$i][0] = -1
$g_avBuildingUpgrades[$i][1] = -1
$g_avBuildingUpgrades[$i][2] = -1
$g_avBuildingUpgrades[$i][3] = ""
$g_avBuildingUpgrades[$i][4] = ""
$g_avBuildingUpgrades[$i][5] = ""
$g_avBuildingUpgrades[$i][6] = ""
$g_avBuildingUpgrades[$i][7] = ""
Next
Global $g_iUpgradeMinGold = 100000, $g_iUpgradeMinElixir = 100000, $g_iUpgradeMinDark = 3000
Global $g_abUpgradeRepeatEnable[$g_iUpgradeSlots] = [False, False, False, False, False, False, False, False, False, False, False, False, False, False]
Global $g_bAutoUpgradeWallsEnable = 0
Global $g_iUpgradeWallMinGold = 0, $g_iUpgradeWallMinElixir = 0
Global $g_iUpgradeWallLootType = 0, $g_bUpgradeWallSaveBuilder = False
Global $g_iCmbUpgradeWallsLevel = 6
Global $g_aiWallsCurrentCount[14] = [-1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_aiLastGoodWallPos[2] = [-1, -1]
Global $g_iChkAutoUpgrade = 0
Global $g_iTxtSmartMinGold = 150000, $g_iTxtSmartMinElixir = 150000, $g_iTxtSmartMinDark = 1500
Global $g_iChkUpgradesToIgnore[13] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_iChkResourcesToIgnore[3] = [0, 0, 0]
Global $g_iCurrentLineOffset = 0, $g_iNextLineOffset = 0
Global $g_aUpgradeNameLevel
Global $g_aUpgradeResourceCostDuration[3] = ["", "", ""]
Global $g_iChkBBSuggestedUpgrades = 0, $g_iChkBBSuggestedUpgradesIgnoreGold = 0, $g_iChkBBSuggestedUpgradesIgnoreElixir = 0, $g_iChkBBSuggestedUpgradesIgnoreHall = 0
Global $g_iChkPlacingNewBuildings = 0
Global $g_iQuickMISX = 0, $g_iQuickMISY = 0
Global $g_iUnbrkMode = 0, $g_iUnbrkWait = 5
Global $g_iUnbrkMinGold = 50000, $g_iUnbrkMinElixir = 50000, $g_iUnbrkMaxGold = 600000, $g_iUnbrkMaxElixir = 600000, $g_iUnbrkMinDark = 5000, $g_iUnbrkMaxDark = 6000
Global Const $g_sCurlPath = $g_sLibPath & "\curl\curl.exe"
Global $g_bNotifyForced = False
Global $g_sTGChatID = ""
Global $g_bPBRequestScreenshot = False
Global $g_bPBRequestScreenshotHD = False
Global $g_bPBRequestBuilderInfo = False
Global $g_bPBRequestShieldInfo = False
Global $g_bTGRequestScreenshot = False
Global $g_bTGRequestScreenshotHD = False
Global $g_bTGRequestBuilderInfo = False
Global $g_bTGRequestShieldInfo = False
Global $g_iTGLastRemote = 0
Global $g_sTGLast_UID = ""
Global $g_sTGLastMessage = ""
Global $g_sAttackFile = ""
Global $g_bNotifyPBEnable = False, $g_sNotifyPBToken = ""
Global $g_bNotifyTGEnable = False, $g_sNotifyTGToken = ""
Global $g_bNotifyRemoteEnable = False, $g_sNotifyOrigin = "", $g_bNotifyDeleteAllPushesOnStart = False, $g_bNotifyDeletePushesOlderThan = False, $g_iNotifyDeletePushesOlderThanHours = 4
Global $g_bNotifyAlertMatchFound = False, $g_bNotifyAlerLastRaidIMG = False, $g_bNotifyAlerLastRaidTXT = False, $g_bNotifyAlertCampFull = False, $g_bNotifyAlertUpgradeWalls = False, $g_bNotifyAlertOutOfSync = False, $g_bNotifyAlertTakeBreak = False, $g_bNotifyAlertBulderIdle = False, $g_bNotifyAlertVillageReport = False, $g_bNotifyAlertLastAttack = False, $g_bNotifyAlertAnotherDevice = False, $g_bNotifyAlertMaintenance = False, $g_bNotifyAlertBAN = False, $g_bNotifyAlertBOTUpdate = False, $g_bNotifyAlertSmartWaitTime = False
Global $g_bNotifyScheduleHoursEnable = False, $g_bNotifyScheduleWeekDaysEnable = False
Global $g_abNotifyScheduleHours[24] = [False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
Global $g_abNotifyScheduleWeekDays[7] = [False, False, False, False, False, False, False]
Global $g_bQuickTrainEnable = False
Global $g_bQuickTrainArmy[3] = [True, False, False]
Global $g_aiArmyCompTroops[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_aiArmyCompSpells[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_aiTrainArmyTroopLevel[$eTroopCount] = [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_aiTrainArmySpellLevel[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_iTrainArmyFullTroopPct = 100
Global $g_bTotalCampForced = False, $g_iTotalCampForcedValue = 200
Global $g_bForceBrewSpells = False
Global $g_iTotalSpellValue = 0
Global $g_iCmbBoostBarracks = 0, $g_iCmbBoostSpellFactory = 0, $g_iCmbBoostBarbarianKing = 0, $g_iCmbBoostArcherQueen = 0, $g_iCmbBoostWarden = 0
Global $g_abBoostBarracksHours[24] = [True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]
Global Const $g_aiTroopOrderIcon[22] = [ $eIcnOptions, $eIcnBarbarian, $eIcnArcher, $eIcnGiant, $eIcnGoblin, $eIcnWallBreaker, $eIcnBalloon, $eIcnWizard, $eIcnHealer, $eIcnDragon, $eIcnPekka, $eIcnBabyDragon, $eIcnMiner, $eIcnElectroDragon, $eIcnMinion, $eIcnHogRider, $eIcnValkyrie, $eIcnGolem, $eIcnWitch, $eIcnLavaHound, $eIcnBowler]
Global $g_bCustomTrainOrderEnable = False, $g_aiCmbCustomTrainOrder[$eTroopCount] = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
Global $g_aiTrainOrder[$eTroopCount] = [ $eTroopArcher, $eTroopGiant, $eTroopWallBreaker, $eTroopBarbarian, $eTroopGoblin, $eTroopHealer, $eTroopPekka, $eTroopBalloon, $eTroopWizard, $eTroopDragon, $eTroopBabyDragon, $eTroopMiner, $eTroopElectroDragon, $eTroopMinion, $eTroopHogRider, $eTroopValkyrie, $eTroopGolem, $eTroopWitch, $eTroopLavaHound, $eTroopBowler]
Global Const $g_aiSpellsOrderIcon[12] = [ $eIcnOptions, $eIcnLightSpell, $eIcnHealSpell,$eIcnRageSpell, $eIcnJumpSpell, $eIcnFreezeSpell, $eIcnCloneSpell, $eIcnPoisonSpell, $eIcnEarthQuakeSpell, $eIcnHasteSpell, $eIcnSkeletonSpell]
Global $g_bCustomBrewOrderEnable = False, $g_aiCmbCustomBrewOrder[$eSpellCount] = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
Global $g_aiBrewOrder[$eSpellCount] = [ $eSpellLightning, $eSpellHeal, $eSpellRage, $eSpellJump, $eSpellFreeze, $eSpellClone, $eSpellPoison, $eSpellEarthquake, $eSpellHaste, $eSpellSkeleton]
Global Enum $eTroopBarbarianS, $eTroopArcherS, $eTroopGiantS, $eTroopGoblinS, $eTroopWallBreakerS, $eTroopBalloonS, $eTroopWizardS, $eTroopHealerS, $eTroopDragonS, $eTroopPekkaS, $eTroopBabyDragonS, $eTroopMinerS, $eTroopElectroDragons, $eTroopMinionS, $eTroopHogRiderS, $eTroopValkyrieS, $eTroopGolemS, $eTroopWitchS, $eTroopLavaHoundS, $eTroopBowlerS, $eHeroeS, $eCCS, $eDropOrderCount
Global Const $g_asDropOrderNames[$eDropOrderCount] = [ "Barbarians", "Archers", "Giants", "Goblins", "Wall Breakers", "Balloons", "Wizards", "Healers", "Dragons", "Pekkas", "Baby Dragons", "Miners", "Electro Dragons", "Minions", "Hog Riders", "Valkyries", "Golems", "Witches", "Lava Hounds", "Bowlers", "Clan Castle", "Heroes"]
Global Const $g_aiDropOrderIcon[24] = [ $eIcnOptions, $eIcnBarbarian, $eIcnArcher, $eIcnGiant, $eIcnGoblin, $eIcnWallBreaker, $eIcnBalloon, $eIcnWizard, $eIcnHealer, $eIcnDragon, $eIcnPekka, $eIcnBabyDragon, $eIcnMiner, $eIcnElectroDragon, $eIcnMinion, $eIcnHogRider, $eIcnValkyrie, $eIcnGolem, $eIcnWitch, $eIcnLavaHound, $eIcnBowler, $eIcnCC, $eIcnHeroes]
Global $g_bCustomDropOrderEnable = False, $g_aiCmbCustomDropOrder[$eDropOrderCount] = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
Global $g_aiDropOrder[$eDropOrderCount] = [ $eTroopBarbarianS, $eTroopArcherS, $eTroopGiantS, $eTroopGoblinS, $eTroopWallBreakerS, $eTroopBalloonS, $eTroopWizardS, $eTroopHealerS, $eTroopDragonS, $eTroopPekkaS, $eTroopBabyDragonS, $eTroopMinerS, $eTroopElectroDragonS, $eTroopMinionS, $eTroopHogRiderS, $eTroopValkyrieS, $eTroopGolemS, $eTroopWitchS, $eTroopLavaHoundS, $eTroopBowlerS, $eHeroeS, $eCCS]
Global $g_bCloseWhileTrainingEnable = True, $g_bCloseWithoutShield = False, $g_bCloseEmulator = False, $g_bSuspendComputer = False, $g_bCloseRandom = False, $g_bCloseExactTime = False, $g_bCloseRandomTime = True, $g_iCloseRandomTimePercent = 10, $g_iCloseMinimumTime = 2
Global $g_iTrainClickDelay = 40
Global $g_bTrainAddRandomDelayEnable = False, $g_iTrainAddRandomDelayMin = 5, $g_iTrainAddRandomDelayMax = 60
Global $g_abAttackTypeEnable[$g_iModeCount + 3] = [True, False, False, -1, False, -1]
Global $g_abSearchSearchesEnable[$g_iModeCount] = [True, False, False], $g_aiSearchSearchesMin[$g_iModeCount] = [0, 0, 0], $g_aiSearchSearchesMax[$g_iModeCount] = [0, 0, 0]
Global $g_abSearchTropiesEnable[$g_iModeCount] = [False, False, False], $g_aiSearchTrophiesMin[$g_iModeCount] = [0, 0, 0], $g_aiSearchTrophiesMax[$g_iModeCount] = [0, 0, 0]
Global $g_abSearchCampsEnable[$g_iModeCount] = [False, False, False], $g_aiSearchCampsPct[$g_iModeCount] = [0, 0, 0]
Global $g_aiSearchHeroWaitEnable[$g_iModeCount] = [0, 0, 0]
Global $g_abSearchSpellsWaitEnable[$g_iModeCount] = [False, False, False]
Global $g_abSearchCastleSpellsWaitEnable[$g_iModeCount] = [False, False, False], $g_aiSearchCastleSpellsWaitRegular[$g_iModeCount] = [0, 0, 0], $g_aiSearchCastleSpellsWaitDark[$g_iModeCount] = [0, 0, 0]
Global $g_abSearchCastleTroopsWaitEnable[$g_iModeCount] = [False, False, False]
Global $g_aiSearchNotWaitHeroesEnable[$g_iModeCount] = [0, 0, 0]
Global $g_iSearchNotWaitHeroesEnable = -1
Global $g_aiFilterMeetGE[$g_iModeCount] = [0, 0, 0], $g_aiFilterMinGold[$g_iModeCount] = [0, 0, 0], $g_aiFilterMinElixir[$g_iModeCount] = [0, 0, 0], $g_aiFilterMinGoldPlusElixir[$g_iModeCount] = [0, 0, 0]
Global $g_abFilterMeetDEEnable[$g_iModeCount] = [False, False, False], $g_aiFilterMeetDEMin[$g_iModeCount] = [0, 0, 0]
Global $g_abFilterMeetTrophyEnable[$g_iModeCount] = [False, False, False], $g_aiFilterMeetTrophyMin[$g_iModeCount] = [0, 0, 0], $g_aiFilterMeetTrophyMax[$g_iModeCount] = [99, 99, 99]
Global $g_abFilterMeetTH[$g_iModeCount] = [False, False, False], $g_aiFilterMeetTHMin[$g_iModeCount] = [0, 0, 0]
Global $g_abFilterMeetTHOutsideEnable[$g_iModeCount] = [False, False, False]
Global $g_abFilterMaxMortarEnable[$g_iModeCount] = [False, False, False], $g_abFilterMaxWizTowerEnable[$g_iModeCount] = [False, False, False], $g_abFilterMaxAirDefenseEnable[$g_iModeCount] = [False, False, False], $g_abFilterMaxXBowEnable[$g_iModeCount] = [False, False, False], $g_abFilterMaxInfernoEnable[$g_iModeCount] = [False, False, False], $g_abFilterMaxEagleEnable[$g_iModeCount] = [False, False, False]
Global $g_aiFilterMaxMortarLevel[$g_iModeCount] = [5, 5, 0], $g_aiFilterMaxWizTowerLevel[$g_iModeCount] = [4, 4, 0], $g_aiFilterMaxAirDefenseLevel[$g_iModeCount] = [0, 0, 0], $g_aiFilterMaxXBowLevel[$g_iModeCount] = [0, 0, 0], $g_aiFilterMaxInfernoLevel[$g_iModeCount] = [0, 0, 0], $g_aiFilterMaxEagleLevel[$g_iModeCount] = [0, 0, 0]
Global $g_abFilterMeetOneConditionEnable[$g_iModeCount] = [False, False, False]
Global $g_iSlotsGiants = 1
Global $g_aiAttackAlgorithm[$g_iModeCount] = [0, 0, 0], $g_aiAttackTroopSelection[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_aiAttackUseHeroes[$g_iModeCount] = [0, 0, 0], $g_abAttackDropCC[$g_iModeCount] = [0, 0, 0]
Global $g_abAttackUseLightSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseHealSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseRageSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseJumpSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseFreezeSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseCloneSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUsePoisonSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseEarthquakeSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseHasteSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseSkeletonSpell[$g_iModeCount] = [0, 0, 0]
Global $g_bTHSnipeBeforeEnable[$g_iModeCount] = [False, False, False], $g_iTHSnipeBeforeTiles[$g_iModeCount] = [0, 0, 0], $g_iTHSnipeBeforeScript[$g_iModeCount] = [0, 0, 0]
Global $g_aiAttackStdDropOrder[$g_iModeCount + 1] = [0, 0, 0, 0], $g_aiAttackStdDropSides[$g_iModeCount + 1] = [3, 3, 0, 1], $g_aiAttackStdUnitDelay[$g_iModeCount + 1] = [4, 4, 0, 4], $g_aiAttackStdWaveDelay[$g_iModeCount + 1] = [4, 4, 0, 4], $g_abAttackStdRandomizeDelay[$g_iModeCount + 1] = [True, True, False, True], $g_abAttackStdSmartAttack[$g_iModeCount + 3] = [True, True, False, True, False, False], $g_aiAttackStdSmartDeploy[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0]
Global $g_abAttackStdSmartNearCollectors[$g_iModeCount + 3][3] = [[False, False, False], [False, False, False], [False, False, False], [False, False, False], [False, False, False], [False, False, False]]
Global $g_aiAttackScrRedlineRoutine[$g_iModeCount + 3] = [$REDLINE_IMGLOC_RAW, $REDLINE_IMGLOC_RAW, 0, 0, 0, 0]
Global $g_aiAttackScrDroplineEdge[$g_iModeCount + 3] = [$DROPLINE_EDGE_FIRST, $DROPLINE_EDGE_FIRST, 0, 0, 0, 0]
Global $g_sAttackScrScriptName[$g_iModeCount] = ["Barch four fingers", "Barch four fingers", ""]
Global $g_abStopAtkNoLoot1Enable[$g_iModeCount] = [True, True, False], $g_aiStopAtkNoLoot1Time[$g_iModeCount] = [0, 0, 0], $g_abStopAtkNoLoot2Enable[$g_iModeCount] = [False, False, False], $g_aiStopAtkNoLoot2Time[$g_iModeCount] = [0, 0, 0]
Global $g_aiStopAtkNoLoot2MinGold[$g_iModeCount] = [0, 0, 0], $g_aiStopAtkNoLoot2MinElixir[$g_iModeCount] = [0, 0, 0], $g_aiStopAtkNoLoot2MinDark[$g_iModeCount] = [0, 0, 0]
Global $g_abStopAtkNoResources[$g_iModeCount] = [False, False, False], $g_abStopAtkOneStar[$g_iModeCount] = [False, False, False], $g_abStopAtkTwoStars[$g_iModeCount] = [False, False, False]
Global $g_abStopAtkPctHigherEnable[$g_iModeCount] = [False, False, False], $g_aiStopAtkPctHigherAmt[$g_iModeCount] = [0, 0, 0]
Global $g_abStopAtkPctNoChangeEnable[$g_iModeCount] = [False, False, False], $g_aiStopAtkPctNoChangeTime[$g_iModeCount] = [0, 0, 0]
Global $g_iMilkAttackType = 1, $g_aiMilkFarmElixirParam[9] = [-1, -1, -1, -1, -1, -1, 2, 2, 2]
Global $g_bMilkFarmLocateElixir = True, $g_bMilkFarmLocateMine = True, $g_bMilkFarmLocateDrill = True
Global $g_iMilkFarmMineParam = 5
Global $g_iMilkFarmDrillParam = 1
Global $g_iMilkFarmResMaxTilesFromBorder = 0, $g_bMilkFarmAttackGoldMines = True, $g_bMilkFarmAttackElixirExtractors = True, $g_bMilkFarmAttackDarkDrills = True, $g_iMilkFarmLimitGold = 9995000, $g_iMilkFarmLimitElixir = 9995000, $g_iMilkFarmLimitDark = 200000
Global $g_iMilkFarmTroopForWaveMin = 4, $g_iMilkFarmTroopForWaveMax = 6, $g_iMilkFarmTroopMaxWaves = 3, $g_iMilkFarmDelayFromWavesMin = 3000, $g_iMilkFarmDelayFromWavesMax = 5000
Global $g_iMilkingAttackDropGoblinAlgorithm = 1
Global $g_iMilkingAttackStructureOrder = 1, $g_bMilkingAttackCheckStructureDestroyedBeforeAttack = False, $g_bMilkingAttackCheckStructureDestroyedAfterAttack = False
Global $g_bMilkAttackAfterTHSnipeEnable = False, $g_iMilkFarmTHMaxTilesFromBorder = 1, $g_sMilkFarmAlgorithmTh = "Queen&GobTakeTH", $g_bMilkFarmSnipeEvenIfNoExtractorsFound = False, $g_bMilkAttackAfterScriptedAtkEnable = False, $g_sMilkAttackCSVscript = "Barch four fingers"
Global $g_bMilkFarmForceToleranceEnable = False, $g_iMilkFarmForceToleranceNormal = 31, $g_iMilkFarmForceToleranceBoosted = 31, $g_iMilkFarmForceToleranceDestroyed = 31
Global $g_abCollectorLevelEnabled[13] = [-1, -1, -1, -1, -1, -1, True, True, True, True, True, True, True]
Global $g_aiCollectorLevelFill[13] = [-1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1]
Global $g_bCollectorFilterDisable = False
Global $g_iCollectorMatchesMin = 3
Global $g_iCollectorToleranceOffset = 0
Global $g_bDESideEndEnable = False, $g_iDESideEndMin = 25, $g_bDESideDisableOther = False, $g_bDESideEndAQWeak = False, $g_bDESideEndBKWeak = False, $g_bDESideEndOneStar = False
Global $g_iAtkTSAddTilesWhileTrain = 1, $g_iAtkTSAddTilesFullTroops = 0
Global $g_sAtkTSType = "Bam"
Global $g_bEndTSCampsEnable = False, $g_iEndTSCampsPct = 0
Global $g_iAtkTBEnableCount = 150, $g_iAtkTBMaxTHLevel = 0, $g_iAtkTBMode = 0
Global $g_bSearchReductionEnable = False, $g_iSearchReductionCount = 20, $g_iSearchReductionGold = 2000, $g_iSearchReductionElixir = 2000, $g_iSearchReductionGoldPlusElixir = 4000, $g_iSearchReductionDark = 100, $g_iSearchReductionTrophy = 2
Global $g_iSearchDelayMin = 0, $g_iSearchDelayMax = 0
Global $g_bSearchAttackNowEnable = False, $g_iSearchAttackNowDelay = 0, $g_bSearchRestartEnable = False, $g_iSearchRestartLimit = 25, $g_bSearchAlertMe = True
Global $g_iActivateQueen = 0, $g_iActivateKing = 0, $g_iActivateWarden = 0
Global $g_iDelayActivateQueen = 9000, $g_iDelayActivateKing = 9000, $g_iDelayActivateWarden = 10000
Global $g_aHeroesTimerActivation[$eHeroCount] = [0, 0, 0]
Global $g_bAttackPlannerEnable = False, $g_bAttackPlannerCloseCoC = False, $g_bAttackPlannerCloseAll = False, $g_bAttackPlannerSuspendComputer = False, $g_bAttackPlannerRandomEnable = False, $g_iAttackPlannerRandomTime = 0, $g_iAttackPlannerRandomTime = 0, $g_bAttackPlannerDayLimit = False, $g_iAttackPlannerDayMin = 12, $g_iAttackPlannerDayMax = 15
Global $g_abPlannedAttackWeekDays[7] = [True, True, True, True, True, True, True]
Global $g_abPlannedattackHours[24] = [True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]
Global $g_bPlannedDropCCHoursEnable = False, $g_bUseCCBalanced = False, $g_iCCDonated = 0, $g_iCCReceived = 0
Global $g_abPlannedDropCCHours[24] = [True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]
Global $g_bSmartZapEnable = False, $g_bEarthQuakeZap = False, $g_bNoobZap = False, $g_bSmartZapDB = True, $g_bSmartZapSaveHeroes = True, $g_bSmartZapFTW = False, $g_iSmartZapMinDE = 350, $g_iSmartZapExpectedDE = 320, $g_bDebugSmartZap = False
Global $g_bShareAttackEnable = 0, $g_iShareMinGold = 300000, $g_iShareMinElixir = 300000, $g_iShareMinDark = 0, $g_sShareMessage = "Nice|Good|Thanks|Wowwww", $g_bTakeLootSnapShot = True, $g_bScreenshotLootInfo = False, $g_bShareAttackEnableNow = False
Global $g_bDropTrophyEnable = False, $g_iDropTrophyMax = 1200, $g_iDropTrophyMin = 800, $g_bDropTrophyUseHeroes = False, $g_iDropTrophyHeroesPriority = 0, $g_bDropTrophyAtkDead = 0, $g_iDropTrophyArmyMinPct = 70
Global $g_sLanguage = "English"
Global $g_bDisableSplash = False
Global $g_bMyBotDance = False
Global $g_bCheckVersion = True
Global $g_bDeleteLogs = True, $g_iDeleteLogsDays = 2, $g_bDeleteTemp = True, $g_iDeleteTempDays = 2, $g_bDeleteLoots = True, $g_iDeleteLootsDays = 2
Global $g_bAutoStart = False, $g_iAutoStartDelay = 10
Global $b_iAutoRestartDelay = 0
Global $g_bCheckGameLanguage = True
Global $g_bAutoUpdateGame = False
Global $g_bAutoAlignEnable = False, $g_iAutoAlignPosition = "EMBED", $g_iAutoAlignOffsetX = "", $g_iAutoAlignOffsetY = ""
Global $g_bUpdatingWhenMinimized = True
Global $g_bHideWhenMinimized = False
Global $g_bUseRandomClick = False
Global $g_bScreenshotPNGFormat = False, $g_bScreenshotHideName = True
Global $g_iAnotherDeviceWaitTime = 120
Global $g_bForceSinglePBLogoff = 0, $g_iSinglePBForcedLogoffTime = 18, $g_iSinglePBForcedEarlyExitTime = 15
Global $g_bAutoResumeEnable = 0, $g_iAutoResumeTime = 5
Global $g_bDisableNotifications = False
Global $g_bForceClanCastleDetection = 0
Global $g_iCmbSwitchAcc = 0
Global $g_bChkGooglePlay = True, $g_bChkSuperCellID = False, $g_bChkSharedPrefs = False
Global $g_bChkSwitchAcc = False, $g_bChkSmartSwitch = False, $g_bDonateLikeCrazy = False, $g_iTotalAcc = -1, $g_iTrainTimeToSkip = 0
Global $g_bInitiateSwitchAcc = True, $g_bReMatchAcc = False, $g_bWaitForCCTroopSpell = False, $g_iNextAccount, $g_iCurAccount
Global $g_abAccountNo[8], $g_asProfileName[8], $g_abDonateOnly[8]
Global $g_aiAttackedCountSwitch[8], $g_iActiveSwitchCounter = 0, $g_iDonateSwitchCounter = 0
Global $g_aiRemainTrainTime[8], $g_aiTimerStart[8], $g_abPBActive[8]
Global $g_aiGoldTotalAcc[8], $g_aiElixirTotalAcc[8], $g_aiDarkTotalAcc[8], $g_aiTrophyLootAcc[8], $g_aiSkippedVillageCountAcc[8], $g_aiAttackedCountAcc[8]
Global $g_aiGoldCurrentAcc[8], $g_aiElixirCurrentAcc[8], $g_aiDarkCurrentAcc[8], $g_aiTrophyCurrentAcc[8], $g_aiFreeBuilderCountAcc[8], $g_aiTotalBuilderCountAcc[8], $g_aiGemAmountAcc[8], $g_aiPersonalBreak[8]
Global Const $g_WIN_POS_DEFAULT = 0xFFFFFFF
Global $g_iFrmBotPosX = $g_WIN_POS_DEFAULT
Global $g_iFrmBotPosY = $g_WIN_POS_DEFAULT
Global $g_iAndroidPosX = $g_WIN_POS_DEFAULT
Global $g_iAndroidPosY = $g_WIN_POS_DEFAULT
Global $g_iFrmBotDockedPosX = $g_WIN_POS_DEFAULT
Global $g_iFrmBotDockedPosY = $g_WIN_POS_DEFAULT
Global $g_iFrmBotAddH = 0
Global $g_bIsHidden = False
Global $g_aiBSpos[2]
Global $g_aiBSrpos[2]
Global $g_bGUIControlDisabled = False
Global Const $g_sDirLanguages = @ScriptDir & "\Languages\"
Global Const $g_sDefaultLanguage = "English"
Global Const $g_sNotifyVersion = "Revamp v1.5.8"
Global Const $g_iPBRemoteControlInterval = 60000
Global Const $g_iPBDeleteOldPushesInterval = 1800000
Global $g_bNotifyDeleteAllPushesNow = False
Global $g_sLootFileName = ""
Global $g_iFreeBuilderCount = 0, $g_iTotalBuilderCount = 0, $g_iGemAmount = 0
Global $g_iFreeBuilderCountBB = 0, $g_iTotalBuilderCountBB = 0
Global $g_iTestFreeBuilderCount = -1
Global $g_iStatsStartedWith[$eLootCount] = [0, 0, 0, 0]
Global $g_iStatsTotalGain[$eLootCount] = [0, 0, 0, 0]
Global $g_iStatsLastAttack[$eLootCount] = [0, 0, 0, 0]
Global $g_iStatsBonusLast[$eLootCount] = [0, 0, 0, 0]
Global $g_iSkippedVillageCount = 0, $g_iDroppedTrophyCount = 0
Global $g_iCostGoldWall = 0, $g_iCostElixirWall = 0, $g_iCostGoldBuilding = 0, $g_iCostElixirBuilding = 0, $g_iCostDElixirHero = 0
Global $g_iNbrOfWallsUpped = 0, $g_iNbrOfWallsUppedGold = 0, $g_iNbrOfWallsUppedElixir = 0
Global $g_iNbrOfBuildingsUppedGold = 0, $g_iNbrOfBuildingsUppedElixir = 0, $g_iNbrOfHeroesUpped = 0
Global $g_iSearchCost = 0, $g_iTrainCostElixir = 0, $g_iTrainCostDElixir = 0
Global $g_iNbrOfOoS = 0
Global $g_iNbrOfTHSnipeFails = 0, $g_iNbrOfTHSnipeSuccess = 0
Global $g_iGoldFromMines = 0, $g_iElixirFromCollectors = 0, $g_iDElixirFromDrills = 0
Global $g_aiAttackedVillageCount[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0]
Global $g_aiTotalGoldGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_aiTotalElixirGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_aiTotalDarkGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_aiTotalTrophyGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0]
Global $g_aiNbrOfDetectedMines[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_aiNbrOfDetectedCollectors[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_aiNbrOfDetectedDrills[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0]
Global $g_aiAttackedCount = 0
Global $g_iSearchCount = 0
Global Const $g_iMaxTrainSkip = 40
Global $g_iActualTrainSkip = 0
Global $g_iSmartZapGain = 0, $g_iNumEQSpellsUsed = 0, $g_iNumLSpellsUsed = 0
Global $g_bMainWindowOk = False
Global $g_aiCurrentLoot[$eLootCount] = [0, 0, 0, 0]
Global $g_iTownHallLevel = 0
Global $g_aiTownHallPos[2] = [-1, -1]
Global $g_aiKingAltarPos[2] = [-1, -1]
Global $g_aiQueenAltarPos[2] = [-1, -1]
Global $g_aiWardenAltarPos[2] = [-1, -1]
Global $g_aiLaboratoryPos[2] = [-1, -1]
Global $g_aiClanCastlePos[2] = [-1, -1]
Global $g_iDetectedImageType = 0
Global $g_abNotNeedAllTime[2] = [True, True]
Global $g_aiCurrentLootBB[$eLootCountBB] = [0, 0, 0]
Global $g_iArmyCapacity = 0
Global $g_iTotalTrainSpaceSpell = 0
Global $g_iCurrentSpells = 0
Global $g_iCurrentCCSpells = 0, $g_iTotalCCSpells = 0
Global $g_bFullArmySpells = False
Global $g_CurrentCampUtilization = 0, $g_iTotalCampSpace = 0
Global $g_iLaboratoryElixirCost = 0
Global $g_iFirstTimeLab = 0
Global $g_sLabUpgradeTime = ""
Global Const $g_aiWallCost[9] = [25000, 50000, 100000, 250000, 500000, 1000000, 2000000, 4000000, 5000000]
Global $g_iWallCost = 0
Global Const $g_iMaxKingLevel = 60
Global Const $g_iMaxQueenLevel = 60
Global Const $g_iMaxWardenLevel = 30
Global Const $g_afKingUpgCost[60] = [10, 12.5, 15, 17.5, 20, 22.5, 25, 27.5, 30, 32.5, 35, 39, 43, 47, 51, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 129, 133, 137, 141, 145, 149, 153, 157, 161, 165, 170, 173, 176, 179, 182, 185, 188, 191, 194, 197, 200, 203, 206, 209, 212, 215, 218, 221, 224, 227]
Global Const $g_afQueenUpgCost[60] = [40, 22.5, 25, 27.5, 30, 32.5, 35, 39, 43, 47, 51, 55, 59, 63, 67, 71, 75, 80, 85, 90, 95, 100, 105, 110, 115, 119, 123, 127, 131, 135, 139, 143, 147, 151, 155, 159, 163, 167, 171, 175, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 204, 208, 212, 216, 220, 224, 228, 232, 236]
Global $g_iWardenLevel = -1
Global Const $g_afWardenUpgCost[30] = [6, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.4, 8.8, 9.1, 9.4, 9.6, 9.8, 10, 10.2, 10.4, 10.6, 10.8, 11, 11.2, 11.4, 11.6, 11.8]
Global $g_bVillageSearchActive = False
Global $g_bCloudsActive = False
Global $g_bAttackActive = False
Global Const $g_asTHText[7] = ["4-6", "7", "8", "9", "10", "11", "12"]
Global Const $g_aiSearchCost[12] = [10, 50, 75, 110, 170, 250, 380, 580, 750, 900, 1000, 1100]
Global $g_bSearchMode = False
Global $g_bIsSearchLimit = False
Global $g_bIsClientSyncError = False
Global $g_iSearchGold = 0, $g_iSearchElixir = 0, $g_iSearchDark = 0, $g_iSearchTrophy = 0, $g_iSearchTH = 0
Global $g_aiMaxTH[$g_iModeCount] = [0, 0, 0]
Global $g_iAimGold[$g_iModeCount] = [0, 0, 0], $g_iAimElixir[$g_iModeCount] = [0, 0, 0], $g_iAimGoldPlusElixir[$g_iModeCount] = [0, 0, 0], $g_iAimDark[$g_iModeCount] = [0, 0, 0], $g_iAimTrophy[$g_iModeCount] = [0, 0, 0], $g_iAimTrophyMax[$g_iModeCount] = [99, 99, 99]
Global $g_iTHx = 0, $g_iTHy = 0
Global $g_bOutOfGold = False
Global $g_iTHside = 0, $g_iTHi = 0
Global $g_iSearchTHLResult = 0
Global $g_sTHLoc = "In"
Global $g_sImglocRedline
Global $g_iImglocTHLevel = 0
Global $g_aiTownHallDetails[4] = [-1, -1, -1, -1]
Global Const $g_aaiTopLeftDropPoints[5][2] = [[66, 299], [174, 210], [240, 169], [303, 127], [390, 55]]
Global Const $g_aaiTopRightDropPoints[5][2] = [[466, 60], [556, 120], [622, 170], [684, 220], [775, 285]]
Global Const $g_aaiBottomLeftDropPoints[5][2] = [[81, 390], [174, 475], [235, 521], [299, 570], [390, 610]]
Global Const $g_aaiBottomRightDropPoints[5][2] = [[466, 600], [554, 555], [615, 510], [678, 460], [765, 394]]
Global Const $g_aaiEdgeDropPoints[4] = [$g_aaiBottomRightDropPoints, $g_aaiTopLeftDropPoints, $g_aaiBottomLeftDropPoints, $g_aaiTopRightDropPoints]
Global Const $g_aiUseAllTroops[33] = [$eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine, $eEDrag, $eMini, $eHogs, $eValk, $eGole, $eWitc, $eLava, $eBowl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell]
Global Const $g_aiUseBarracks[27] = [$eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine, $eEDrag, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $g_aiUseBarbs[15] = [$eBarb, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $g_aiUseArchs[15] = [$eArch, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $g_aiUseBarcher[16] = [$eBarb, $eArch, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $g_aiUseBarbGob[16] = [$eBarb, $eGobl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $g_aiUseArchGob[16] = [$eArch, $eGobl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $g_aiUseBarcherGiant[17] = [$eBarb, $eArch, $eGiant, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $g_aiUseBarcherGobGiant[18] = [$eBarb, $eArch, $eGiant, $eGobl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $g_aiUseBarcherHog[17] = [$eBarb, $eArch, $eHogs, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $g_aiUseBarcherMinion[17] = [$eBarb, $eArch, $eMini, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $g_aaiTroopsToBeUsed[12] = [$g_aiUseAllTroops, $g_aiUseBarracks, $g_aiUseBarbs, $g_aiUseArchs, $g_aiUseBarcher, $g_aiUseBarbGob, $g_aiUseArchGob, $g_aiUseBarcherGiant, $g_aiUseBarcherGobGiant, $g_aiUseBarcherHog, $g_aiUseBarcherMinion]
Global $g_bTHSnipeUsedKing = False
Global $g_bTHSnipeUsedQueen = False
Global $g_bTHSnipeUsedWarden = False
Global $g_avAttackTroops[12][2]
Global $g_bFullArmy = False
Global $g_iKingSlot = -1, $g_iQueenSlot = -1, $g_iWardenSlot = -1, $g_iClanCastleSlot = -1
Global $g_iHeroWaitAttackNoBit[$g_iModeCount][3]
Global $g_iHeroAvailable = $eHeroNone
Global $g_iHeroUpgrading[3] = [0, 0, 0]
Global $g_iHeroUpgradingBit = $eHeroNone
Global $g_bCheckKingPower = False
Global $g_bCheckQueenPower = False
Global $g_bCheckWardenPower = False
Global $g_bDropQueen, $g_bDropKing, $g_bDropWarden
Global $g_aiSlotInArmy[$eTroopCount] = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
Global $g_aiPixelTopLeft[0]
Global $g_aiPixelBottomLeft[0]
Global $g_aiPixelTopRight[0]
Global $g_aiPixelBottomRight[0]
Global $g_aiPixelTopLeftFurther[0]
Global $g_aiPixelBottomLeftFurther[0]
Global $g_aiPixelTopRightFurther[0]
Global $g_aiPixelBottomRightFurther[0]
Global $g_aiPixelMine[0]
Global $g_aiPixelElixir[0]
Global $g_aiPixelDarkElixir[0]
Global $g_aiPixelNearCollector[0]
Global $g_aiPixelRedArea[0]
Global $g_aiPixelRedAreaFurther[0]
Global Enum $eVectorLeftTop, $eVectorRightTop, $eVectorLeftBottom, $eVectorRightBottom
Global $g_bIsCCDropped = False
Global $g_bIsHeroesDropped = False
Global $g_aiDeployCCPosition[2] = [-1, -1]
Global $g_aiDeployHeroesPosition[2] = [-1, -1]
Global $g_aiCSVGoldStoragePos
Global $g_aiCSVElixirStoragePos
Global $g_aiCSVDarkElixirStoragePos
Global $g_aiCSVEagleArtilleryPos
Global $g_aiCSVInfernoPos
Global $g_aiCSVXBowPos
Global $g_aiCSVWizTowerPos
Global $g_aiCSVMortarPos
Global $g_aiCSVAirDefensePos
Global $g_bCSVLocateMine = False
Global $g_bCSVLocateElixir = False
Global $g_bCSVLocateDrill = False
Global $g_bCSVLocateStorageGold = False
Global $g_bCSVLocateStorageElixir = False
Global $g_bCSVLocateStorageDarkElixir = False
Global $g_bCSVLocateStorageTownHall = False
Global $g_bCSVLocateEagle = False
Global $g_bCSVLocateInferno = False
Global $g_bCSVLocateXBow = False
Global $g_bCSVLocateWizTower = False
Global $g_bCSVLocateMortar = False
Global $g_bCSVLocateAirDefense = False
Global $g_iCSVLastTroopPositionDropTroopFromINI = -1
Global $ATTACKVECTOR_A, $ATTACKVECTOR_B, $ATTACKVECTOR_C, $ATTACKVECTOR_D, $ATTACKVECTOR_E, $ATTACKVECTOR_F
Global $ATTACKVECTOR_G, $ATTACKVECTOR_H, $ATTACKVECTOR_I, $ATTACKVECTOR_J, $ATTACKVECTOR_K, $ATTACKVECTOR_L
Global $ATTACKVECTOR_M, $ATTACKVECTOR_N, $ATTACKVECTOR_O, $ATTACKVECTOR_P, $ATTACKVECTOR_Q, $ATTACKVECTOR_R
Global $ATTACKVECTOR_S, $ATTACKVECTOR_T, $ATTACKVECTOR_U, $ATTACKVECTOR_V, $ATTACKVECTOR_W, $ATTACKVECTOR_X
Global $ATTACKVECTOR_Y, $ATTACKVECTOR_Z
Global Const $g_iMilkFarmOffsetX = 56
Global Const $g_iMilkFarmOffsetY = 41
Global Const $g_iMilkFarmOffsetXStep = 35
Global Const $g_iMilkFarmOffsetYStep = 26
Global $g_asCapacityStructureElixir[9], $g_asDestroyedMineIMG[9], $g_asDestroyedElixirIMG[9], $g_asDestroyedDarkIMG[9]
Global $g_bDuringMilkingAttack = False
Global Const $g_asMilkFarmOffsetMine[9] = ["1-1", "1-1", "0-2", "0-4", "1-2", "1-1", "3-5", "3-6", "3-5"]
Global Const $g_asMilkFarmOffsetElixir[9] = ["1-11", "1-11", "1-9", "1-13", "0-11", "0-11", "0-13", "0-11", "0-14"]
Global Const $g_asMilkFarmOffsetDark[7] = ["0-0", "1-4", "1-3", "0-5", "4-8", "0-4", "0-3"]
Global $g_sMilkFarmObjectivesSTR = ""
Global $g_bMilkingAttackOutside = False
Global $g_bTrainEnabled = True
Global $g_bIsFullArmywithHeroesAndSpells = False
Global $g_bOutOfElixir = False
Global $g_aiTimeTrain[3] = [0, 0, 0]
Global Enum $ArmyTAB, $TrainTroopsTAB, $BrewSpellsTAB, $QuickTrainTAB
Global $g_bCheckSpells = False
Global $g_avLabTroops[31][5]
Func TranslateTroopNames()
Dim $g_avLabTroops[31][5] = [ [-1, -1, -1, GetTranslatedFileIni("MBR Global GUI Design", "None", "None"), $eIcnBlank], [123, 340 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBarbarians", "Barbarians"), $eIcnBarbarian], [123, 447 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtArchers", "Archers"), $eIcnArcher], [230, 340 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGiants", "Giants"), $eIcnGiant], [230, 447 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGoblins", "Goblins"), $eIcnGoblin], [337, 340 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWallBreakers", "Wall Breakers"), $eIcnWallBreaker], [337, 447 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBalloons", "Balloons"), $eIcnBalloon], [443, 340 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWizards", "Wizards"), $eIcnWizard], [443, 447 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHealers", "Healers"), $eIcnHealer], [550, 340 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtDragons", "Dragons"), $eIcnDragon], [550, 447 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtPekkas", "Pekkas"), $eIcnPekka], [319, 340 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBabyDragons", "Baby Dragons"), $eIcnBabyDragon], [319, 447 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMiners", "Miners"), $eIcnMiner], [426, 340 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtElectroDragons", "Electro Dragons"), $eIcnElectroDragon], [426, 447 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtLightningSpells", "Lightning Spell"), $eIcnLightSpell], [533, 340 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtHealingSpells", "Healing Spell"), $eIcnHealSpell], [533, 447 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtRageSpells", "Rage Spell"), $eIcnRageSpell], [640, 340 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtJumpSpells", "Jump Spell"), $eIcnJumpSpell], [640, 447 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtFreezeSpells", "Freeze Spell"), $eIcnFreezeSpell], [109, 340 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtCloneSpells", "Clone Spell"), $eIcnCloneSpell], [109, 447 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtPoisonSpells", "Poison Spell"), $eIcnPoisonSpell], [216, 340 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtEarthQuakeSpells", "EarthQuake Spell"), $eIcnEarthQuakeSpell], [216, 447 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtHasteSpells", "Haste Spell"), $eIcnHasteSpell], [322, 340 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtSkeletonSpells", "Skeleton Spell"), $eIcnSkeletonSpell], [322, 447 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMinions", "Minions"), $eIcnMinion], [429, 340 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHogRiders", "Hog Riders"), $eIcnHogRider], [429, 447 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtValkyries", "Valkyries"), $eIcnValkyrie], [536, 340 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGolems", "Golems"), $eIcnGolem], [536, 447 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWitches", "Witches"), $eIcnWitch], _
[642, 340 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtLavaHounds", "Lava Hounds"), $eIcnLavaHound], [642, 447 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBowlers", "Bowlers"), $eIcnBowler]]
EndFunc
Global Const $g_aiDonateTroopPriority[$eTroopCount] = [ $eTroopLavaHound, $eTroopElectroDragon, $eTroopGolem, $eTroopPekka, $eTroopDragon, $eTroopWitch, $eTroopHealer, $eTroopBabyDragon, $eTroopValkyrie, $eTroopBowler, $eTroopMiner, $eTroopGiant, $eTroopBalloon, $eTroopHogRider, $eTroopWizard, $eTroopWallBreaker, $eTroopMinion, $eTroopArcher, $eTroopBarbarian, $eTroopGoblin]
Global Const $g_aiDonateSpellPriority[$eSpellCount] = [ $eSpellLightning, $eSpellHeal, $eSpellRage, $eSpellJump, $eSpellFreeze, $eSpellPoison, $eSpellEarthquake, $eSpellHaste, $eSpellSkeleton]
Global $g_aiDonateStatsTroops[$eTroopCount][2] = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]
Global $g_aiDonateStatsSpells[$eSpellCount][2] = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]
Global $g_iTotalDonateStatsTroops = 0, $g_iTotalDonateStatsTroopsXP = 0
Global $g_iTotalDonateStatsSpells = 0, $g_iTotalDonateStatsSpellsXP = 0
Global $g_iActiveDonate = -1
Global $g_aiDonateTroops[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], $g_aiDonateSpells[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_aiCurrentTroops[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], $g_aiCurrentSpells[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_bDonationEnabled = True
Global $g_iTroopsDonated = 0
Global $g_iTroopsReceived = 0
Global $g_iDonationWindowY = 0
Global $g_bDisableDropTrophy = False
Global $g_avDTtroopsToBeUsed[6][2] = [["Barb", 0], ["Arch", 0], ["Giant", 0], ["Wall", 0], ["Gobl", 0], ["Mini", 0]]
Global $g_bMinorObstacle = False
Global $g_bGfxError = False
Global Const $g_iTaBChkAttack = 0x01
Global Const $g_iTaBChkIdle = 0x02
Global Const $g_iTaBChkTime = 0x04
Global $g_bDisableBreakCheck = False
Global $g_sPBStartTime = ""
Global $g_asShieldStatus = ["", "", ""]
Global Enum $eSideBuildingDES, $eSideBuildingTH
Global $g_iBuildingEdge = 0, $g_iBuildingToLoc = ""
Global $g_iDarkLow = 0
Global $g_iCCRemainTime = 0
Global $g_bCanRequestCC = True
Global $__TEST_ERROR_ADB_DEVICE_NOT_FOUND = False
Global $__TEST_ERROR_SLOW_ADB_SHELL_COMMAND_DELAY = 0
Global $__TEST_ERROR_SLOW_ADB_SCREENCAP_DELAY = 0
Global $__TEST_ERROR_SLOW_ADB_CLICK_DELAY = 0
Global $g_iLSpellLevel = 1
Global $g_iESpellLevel = 1
Global Const $g_fDarkStealFactor = 0.75
Global Const $g_fDarkFillLevel = 0.70
Global Const $g_aDrillLevelHP[6] = [800, 860, 920, 980, 1060, 1160]
Global Const $g_aDrillLevelTotal[6] = [160, 300, 540, 840, 1280, 1800]
Global Const $g_aLSpellDmg[7] = [300, 360, 420, 480, 540, 600, 660]
Global Const $g_aEQSpellDmg[4] = [0.14, 0.17, 0.21, 0.25]
Global Enum $eWeakEagle = 1, $eWeakInferno, $eWeakXBow, $eWeakWizard, $eWeakMortar, $eWeakAirDefense
Global $g_aWeakDefenseNames = ["None", "Eagle Artillery", "Inferno Tower", "XBow", "Wizard Tower", "Mortar", "Air Defense"]
Global Enum $eBldgRedLine, $eBldgTownHall, $eBldgGoldM, $eBldgElixirC, $eBldgDrill, $eBldgGoldS, $eBldgElixirS, $eBldgDarkS, $eBldgEagle, $eBldgInferno, $eBldgXBow, $eBldgWizTower, $eBldgMortar, $eBldgAirDefense
Global $g_sBldgNames = ["Red Line", "Town Hall", "Gold Mine", "Elixir Collector", "Dark Elixir Drill", "Gold Storage", "Elixir Storage", "Dark Elixir Storage", "Eagle Artillery", "Inferno Tower", "XBow", "Wizard Tower", "Mortar", "Air Defense"]
Global Const $g_iMaxCapTroopTH[13] = [0, 20, 30, 70, 80, 135, 150, 200, 200, 220, 240, 260, 280]
Global Const $g_iMaxCapSpellTH[13] = [0, 0, 0, 0, 0, 2, 4, 6, 7, 9, 11, 11, 11]
Global $g_oBldgAttackInfo = ObjCreate("Scripting.Dictionary")
$g_oBldgAttackInfo.CompareMode = 1
Global $g_oBldgLevels = ObjCreate("Scripting.Dictionary")
Func _FilloBldgLevels()
Local Const $aBldgCollector[12] = [2, 4, 6, 8, 10, 10, 11, 12, 12, 12, 12, 12]
$g_oBldgLevels.add($eBldgGoldM, $aBldgCollector)
$g_oBldgLevels.add($eBldgElixirC, $aBldgCollector)
Local Const $aBldgDrill[12] = [0, 0, 0, 0, 0, 0, 3, 3, 6, 6, 6, 6]
$g_oBldgLevels.add($eBldgDrill, $aBldgDrill)
Local Const $aBldgStorage[12] = [1, 3, 6, 8, 9, 10, 11, 11, 11, 11, 12, 13]
$g_oBldgLevels.add($eBldgGoldS, $aBldgStorage)
$g_oBldgLevels.add($eBldgElixirS, $aBldgStorage)
Local Const $aBldgDarkStorage[12] = [0, 0, 0, 0, 0, 0, 2, 4, 6, 6, 6, 7]
$g_oBldgLevels.add($eBldgDarkS, $aBldgDarkStorage)
Local Const $aBldgEagle[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3]
$g_oBldgLevels.add($eBldgEagle, $aBldgEagle)
Local Const $aBldgInferno[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 5, 6]
$g_oBldgLevels.add($eBldgInferno, $aBldgInferno)
Local Const $aBldgMortar[12] = [0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11]
$g_oBldgLevels.add($eBldgMortar, $aBldgMortar)
Local Const $aBldgWizTower[12] = [0, 0, 0, 0, 2, 3, 4, 6, 7, 9, 10, 11]
$g_oBldgLevels.add($eBldgWizTower, $aBldgWizTower)
Local Const $aBldgXBow[12] = [0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 6]
$g_oBldgLevels.add($eBldgXBow, $aBldgXBow)
Local Const $aBldgAirDefense[12] = [0, 0, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10]
$g_oBldgLevels.add($eBldgAirDefense, $aBldgAirDefense)
EndFunc
_FilloBldgLevels()
Global $g_oBldgMaxQty = ObjCreate("Scripting.Dictionary")
Func _FilloBldgMaxQty()
Local Const $aBldgCollector[12] = [1, 2, 3, 4, 5, 6, 6, 6, 6, 7, 7, 7]
$g_oBldgMaxQty.add($eBldgGoldM, $aBldgCollector)
$g_oBldgMaxQty.add($eBldgElixirC, $aBldgCollector)
Local Const $aBldgDrill[12] = [0, 0, 0, 0, 0, 0, 1, 2, 2, 3, 3, 3]
$g_oBldgMaxQty.add($eBldgDrill, $aBldgDrill)
Local Const $aBldgStorage[12] = [1, 1, 2, 2, 2, 2, 2, 3, 4, 4, 4, 4]
$g_oBldgMaxQty.add($eBldgGoldS, $aBldgStorage)
$g_oBldgMaxQty.add($eBldgElixirS, $aBldgStorage)
Local Const $aBldgDarkStorage[12] = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]
$g_oBldgMaxQty.add($eBldgDarkS, $aBldgDarkStorage)
Local Const $aBldgEagle[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]
$g_oBldgMaxQty.add($eBldgEagle, $aBldgEagle)
Local Const $aBldgInferno[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2]
$g_oBldgMaxQty.add($eBldgInferno, $aBldgInferno)
Local Const $aBldgMortar[12] = [0, 0, 1, 1, 1, 2, 3, 4, 4, 4, 4, 4]
$g_oBldgMaxQty.add($eBldgMortar, $aBldgMortar)
Local Const $aBldgWizTower[12] = [0, 0, 0, 0, 1, 2, 2, 3, 4, 4, 5, 5]
$g_oBldgMaxQty.add($eBldgWizTower, $aBldgWizTower)
Local Const $aBldgXBow[12] = [0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 4]
$g_oBldgMaxQty.add($eBldgXBow, $aBldgXBow)
Local Const $aBldgAirDefense[12] = [0, 0, 0, 1, 1, 2, 3, 3, 4, 4, 4, 4]
$g_oBldgMaxQty.add($eBldgAirDefense, $aBldgAirDefense)
EndFunc
_FilloBldgMaxQty()
Global $g_oBldgImages = ObjCreate("Scripting.Dictionary")
$g_oBldgImages.add($eBldgTownHall & "_" & "0", "imglocth-bundle")
$g_oBldgImages.add($eBldgTownHall & "_" & "1", "snow-imglocth-bundle")
$g_oBldgImages.add($eBldgGoldM & "_" & "0", @ScriptDir & "\imgxml\Storages\Mines")
$g_oBldgImages.add($eBldgGoldM & "_" & "1", @ScriptDir & "\imgxml\Storages\Mines_Snow")
$g_oBldgImages.add($eBldgElixirC & "_" & "0", @ScriptDir & "\imgxml\Storages\Collectors")
$g_oBldgImages.add($eBldgElixirC & "_" & "1", @ScriptDir & "\imgxml\Storages\CollectorsSnow")
$g_oBldgImages.add($eBldgDrill & "_" & "0", @ScriptDir & "\imgxml\Storages\Drills")
$g_oBldgImages.add($eBldgGoldS & "_" & "0", @ScriptDir & "\imgxml\Storages\Gold")
$g_oBldgImages.add($eBldgElixirS & "_" & "0", @ScriptDir & "\imgxml\Storages\Elixir")
$g_oBldgImages.add($eBldgEagle & "_" & "0", @ScriptDir & "\imgxml\Buildings\Eagle")
$g_oBldgImages.add($eBldgInferno & "_" & "0", @ScriptDir & "\imgxml\Buildings\Infernos")
$g_oBldgImages.add($eBldgXBow & "_" & "0", @ScriptDir & "\imgxml\Buildings\Xbow")
$g_oBldgImages.add($eBldgWizTower & "_" & "0", @ScriptDir & "\imgxml\Buildings\WTower")
$g_oBldgImages.add($eBldgWizTower & "_" & "1", @ScriptDir & "\imgxml\Buildings\WTowerSnow")
$g_oBldgImages.add($eBldgMortar & "_" & "0", @ScriptDir & "\imgxml\Buildings\Mortars")
$g_oBldgImages.add($eBldgAirDefense & "_" & "0", @ScriptDir & "\imgxml\Buildings\ADefense")
Global $g_bChkClanGamesAir = 0, $g_bChkClanGamesGround = 0, $g_bChkClanGamesMisc = 0
Global $g_bChkClanGamesEnabled = 0
Global $g_bChkClanGamesOnly = 0
Global $g_bChkClanGamesLoot = 0
Global $g_bChkClanGamesBattle = 0
Global $g_bChkClanGamesDestruction = 0
Global $g_bChkClanGamesAirTroop = 0
Global $g_bChkClanGamesGroundTroop = 0
Global $g_bChkClanGamesMiscellaneous = 0
Global $g_bChkClanGamesPurge = 0
Global $g_bChkClanGamesStopBeforeReachAndPurge = 0
Global $g_bChkClanGamesDebug = 0
Global $g_iPurgeJobCount[8] = [0, 0, 0, 0, 0, 0, 0, 0]
Global $g_iPurgeMax = 5
Global $g_bChkCollectFreeMagicItems = True
Global Const $DELAYSLEEP = 100
Global Const $DELAYWAITFORPOPUP = 1500
Global Const $DELAYCLOUDSCLEARED = 1000
Global Const $DELAYRESPOND = 5
Global Const $DELAYRUNBOT1 = 1000
Global Const $DELAYRUNBOT2 = 800
Global Const $DELAYRUNBOT3 = 200
Global Const $DELAYRUNBOT5 = 500
Global Const $DELAYRUNBOT6 = 100
Global Const $DELAYIDLE1 = 200
Global Const $DELAYIDLE2 = 1500
Global Const $DELAYSMARTWAIT = 500
Global Const $DELAYATTACKMAIN1 = 1000
Global Const $DELAYATTACKMAIN2 = 1500
Global Const $DELAYATTCKTHGRID1 = 500
Global Const $DELAYCASTSPELL1 = 10
Global Const $DELAYALGORITHM_ALLTROOPS1 = 2000
Global Const $DELAYALGORITHM_ALLTROOPS2 = 1000
Global Const $DELAYALGORITHM_ALLTROOPS3 = $DELAYWAITFORPOPUP
Global Const $DELAYALGORITHM_ALLTROOPS4 = 100
Global Const $DELAYALGORITHM_ALLTROOPS5 = 500
Global Const $DELAYBARCH1 = 100
Global Const $DELAYBARCH2 = 500
Global Const $DELAYBARCH3 = 1000
Global Const $DELAYATTACKREPORT1 = 500
Global Const $DELAYATTACKREPORT2 = 150
Global Const $DELAYDROPCC1 = 500
Global Const $DELAYDROPCC2 = 500
Global Const $DELAYDROPHEROES1 = 300
Global Const $DELAYDROPHEROES2 = 500
Global Const $DELAYGOLDELIXIRCHANGE1 = 500
Global Const $DELAYGOLDELIXIRCHANGE2 = 1000
Global Const $DELAYGOLDELIXIRCHANGEEBO1 = 500
Global Const $DELAYGOLDELIXIRCHANGEEBO2 = 1000
Global Const $DELAYPREPAREATTACK1 = 250
Global Const $DELAYDROPONPIXEL1 = 50
Global Const $DELAYDROPONPIXEL2 = 250
Global Const $DELAYDROPTROOP1 = 100
Global Const $DELAYDROPTROOP2 = 300
Global Const $DELAYRETURNHOME1 = 1000
Global Const $DELAYRETURNHOME2 = 1500
Global Const $DELAYRETURNHOME3 = 2500
Global Const $DELAYRETURNHOME4 = 2000
Global Const $DELAYRETURNHOME5 = 200
Global Const $DELAYDROPONEDGE1 = 100
Global Const $DELAYDROPONEDGE2 = 300
Global Const $DELAYDROPONEDGE3 = 50
Global Const $DELAYLAUNCHTROOP21 = 100
Global Const $DELAYLAUNCHTROOP22 = 1000
Global Const $DELAYLAUNCHTROOP23 = 300
Global Const $DELAYOLDDROPTROOP1 = 100
Global Const $DELAYOLDDROPTROOP2 = 50
Global Const $DELAYUNBREAKABLE1 = 1000
Global Const $DELAYUNBREAKABLE2 = 2000
Global Const $DELAYUNBREAKABLE3 = 3000
Global Const $DELAYUNBREAKABLE4 = 5000
Global Const $DELAYUNBREAKABLE6 = 30000
Global Const $DELAYUNBREAKABLE7 = 100
Global Const $DELAYUNBREAKABLE8 = 50
Global Const $DELAYCHECKTOMBS1 = 500
Global Const $DELAYCHECKTOMBS2 = 2000
Global Const $DELAYCHECKMAINSCREEN1 = 1000
Global Const $DELAYCHECKOBSTACLES1 = 1000
Global Const $DELAYCHECKOBSTACLES2 = 2000
Global Const $DELAYCHECKOBSTACLES3 = 5000
Global Const $DELAYCHECKOBSTACLES4 = 120000
Global Const $DELAYCHECKOBSTACLES6 = 300000
Global Const $DELAYCHECKOBSTACLES7 = 600000
Global Const $DELAYCHECKOBSTACLES8 = 900000
Global Const $DELAYCHECKOBSTACLES9 = 1200000
Global Const $DELAYCHECKOBSTACLES10 = 1800000
Global Const $DELAYISGEMOPEN1 = 350
Global Const $DELAYISBUILDERBASE = 300
Global Const $DELAYWAITMAINSCREEN1 = 2000
Global Const $DELAYZOOMOUT1 = 1500
Global Const $DELAYZOOMOUT2 = 200
Global Const $DELAYZOOMOUT3 = 1000
Global Const $DELAYCHECKVERSIONHTML1 = 250
Global Const $DELAYDOWNLOADLICENSE = 250
Global Const $DELAYTOGGLEPAUSE1 = 100
Global Const $DELAYTOGGLEPAUSE2 = 250
Global Const $DELAYWINDOWSARRANGE1 = 500
Global Const $DELAYBUILDINGINFO1 = 1500
Global Const $DELAYGETRESOURCES1 = 250
Global Const $DELAYGETRESOURCES3 = 150
Global Const $DELAYPREPARESEARCH1 = 1000
Global Const $DELAYPREPARESEARCH2 = 2000
Global Const $DELAYVILLAGESEARCH1 = 1000
Global Const $DELAYVILLAGESEARCH2 = 100
Global Const $DELAYVILLAGESEARCH3 = 500
Global Const $DELAYBOOSTBARRACKS1 = 1000
Global Const $DELAYBOOSTBARRACKS2 = 600
Global Const $DELAYBOOSTBARRACKS3 = 200
Global Const $DELAYBOOSTHEROES1 = 1000
Global Const $DELAYBOOSTHEROES2 = 2000
Global Const $DELAYBOOSTHEROES3 = 500
Global Const $DELAYBOOSTHEROES4 = 600
Global Const $DELAYBOTCOMMAND1 = 500
Global Const $DELAYBOTDETECT1 = 1000
Global Const $DELAYBOTDETECT3 = 100
Global Const $DELAYCHECKARMYCAMP4 = 500
Global Const $DELAYCHECKARMYCAMP5 = 250
Global Const $DELAYCHECKARMYCAMP6 = 10
Global Const $DELAYCHECKFULLARMY1 = 100
Global Const $DELAYCHECKFULLARMY2 = 200
Global Const $DELAYCHECKFULLARMY3 = 500
Global Const $DELAYCOLLECT1 = 100
Global Const $DELAYCOLLECT2 = 250
Global Const $DELAYCOLLECT3 = 500
Global Const $DELAYDONATECC1 = 200
Global Const $DELAYDONATECC2 = 250
Global Const $DELAYDONATECC3 = 50
Global Const $DELAYDONATECC4 = 1250
Global Const $DELAYDONATEWINDOW1 = 1000
Global Const $DELAYDONATEWINDOW2 = 100
Global Const $DELAYDROPTROPHY1 = 1000
Global Const $DELAYDROPTROPHY4 = 250
Global Const $DELAYGETTHLEVEL1 = 1000
Global Const $DELAYGETTHLEVEL2 = 1500
Global Const $DELAYGETTHLEVEL3 = 200
Global Const $DELAYLABORATORY1 = 750
Global Const $DELAYLABORATORY2 = 200
Global Const $DELAYLABORATORY3 = 1000
Global Const $DELAYLABORATORY4 = 200
Global Const $DELAYLABUPGRADE1 = 1000
Global Const $DELAYLABUPGRADE2 = 200
Global Const $DELAYLABUPGRADE3 = 200
Global Const $DELAYLOCATETH1 = 1000
Global Const $DELAYCHECKUPGRADES = 1000
Global Const $DELAYUPGRADEVALUE1 = 200
Global Const $DELAYUPGRADEVALUE2 = 800
Global Const $DELAYUPGRADEVALUE4 = 1000
Global Const $DELAYUPGRADEVALUE5 = 1250
Global Const $DELAYDEBUGIMAGESAVE1 = 200
Global Const $DELAYPROFILEREPORT1 = 500
Global Const $DELAYPROFILEREPORT2 = 1000
Global Const $DELAYPROFILEREPORT3 = 200
Global Const $DELAYNOTIFY1 = 500
Global Const $DELAYPUSHMSG1 = 500
Global Const $DELAYPUSHMSG2 = 1000
Global Const $DELAYREARM1 = 500
Global Const $DELAYREARM2 = 1500
Global Const $DELAYREARM3 = 700
Global Const $DELAYREARM4 = 200
Global Const $DELAYTREASURY1 = 500
Global Const $DELAYTREASURY2 = 1500
Global Const $DELAYTREASURY4 = 200
Global Const $DELAYREPLAYSHARE1 = 250
Global Const $DELAYREPLAYSHARE2 = 500
Global Const $DELAYREQUESTCC1 = 1000
Global Const $DELAYMAKEREQUEST1 = 500
Global Const $DELAYMAKEREQUEST2 = 1500
Global Const $DELAYTRAIN1 = 1000
Global Const $DELAYTRAIN6 = 20
Global Const $DELAYTRAIN8 = 5000
Global Const $DELAYLVUP = 150
Global Const $DELAYISTRAINPAGE2 = 1000
Global Const $DELAYAUTOUPGRADEBUILDING1 = 1000
Global Const $DELAYUPGRADEBUILDING1 = 200
Global Const $DELAYUPGRADEBUILDING2 = 500
Global Const $DELAYUPGRADENORMAL1 = 700
Global Const $DELAYUPGRADENORMAL2 = 200
Global Const $DELAYUPGRADENORMAL3 = 750
Global Const $DELAYUPGRADEHERO1 = 800
Global Const $DELAYUPGRADEHERO2 = 500
Global Const $DELAYUPGRADEHERO3 = 1000
Global Const $DELAYUPGRADEWALL1 = 500
Global Const $DELAYUPGRADEWALLGOLD2 = 1000
Global Const $DELAYUPGRADEWALLGOLD3 = 500
Global Const $DELAYUPGRADEWALLELIXIR2 = 1000
Global Const $DELAYUPGRADEWALLELIXIR3 = 500
Global Const $DELAYVILLAGEREPORT1 = 500
Global Const $DELAYWAITNOPENCOC10000 = 10000
Global Const $DELAYSEARCHLIMIT = 200
Global Const $DELAYCHECKIMAGETYPE1 = 100
Global Const $DELAYSPECIALCLICK1 = 200
Global Const $DELAYSPECIALCLICK2 = 100
Global Const $DELAYPERSONALSHIELD1 = 1000
Global Const $DELAYPERSONALSHIELD2 = 500
Global Const $DELAYPERSONALSHIELD3 = 100
Global Const $DELAYSTARBONUS100 = 100
Global Const $DELAYSTARBONUS500 = 500
Global Const $DELAYATTACKDISABLE100 = 100
Global Const $DELAYATTACKDISABLE500 = 500
Global Const $DELAYWAITATTACK1 = 60000
Global Const $DELAYWAITATTACK2 = 300000
Global Const $DELAYCLOSEOPEN1000 = 1000
Global Const $DELAYCLOSEOPEN2000 = 2000
Global Const $DELAYCLOSEOPEN3000 = 3000
Global $DELAYSMARTZAP1 = 1000
Global $DELAYSMARTZAP4 = 4000
Global $DELAYSMARTZAP10 = 10000
Global $DELAYSWITCHBASES1 = 1000
Global $DELAYCLOCKTOWER1 = 1000
Global $DELAYCLOCKTOWER2 = 200
Global $g_hSplash = 0, $g_hSplashProgress, $g_lSplashStatus, $g_lSplashPic, $g_lSplashTitle
Global $g_iSplashTotalSteps = Default
Global $g_iSplashCurrentStep = 0
Global $g_hSplashTimer = 0
Global $g_hSplashMutex = 0
Func SplashStep($status, $bIncreaseStep = True)
If $bIncreaseStep = True Then $g_iSplashCurrentStep += 1
SetDebugLog("SplashStep " & $g_iSplashCurrentStep & " of " & $g_iSplashTotalSteps & ": " & $status & "(" & Round(__TimerDiff($g_hSplashTimer) / 1000, 2) & " sec)")
If $g_bDisableSplash Then Return
GUICtrlSetData($g_hSplashProgress,($g_iSplashCurrentStep / $g_iSplashTotalSteps) * 100)
GUICtrlSetData($g_lSplashStatus, $status)
If $g_bMyBotDance Then
Static $aSplashInfo, $iStartX, $iStartY, $iStep, $iStepIndex = 0
If $iStepIndex = 0 Then
$aSplashInfo = WinGetPos($g_hSplash)
If @error Then SetLog("SplashStep " & $g_iSplashCurrentStep & " Failed to find GUI Window!", $COLOR_ERROR)
$iStartY = Int(@DesktopHeight - 50 - $aSplashInfo[3])
$iStartX = Int((@DesktopWidth / 2) -($aSplashInfo[2] / 2))
$iStep = Int($iStartY /($g_iSplashTotalSteps - 1))
EndIf
Local $aSplashLoc[10][2] = [[-100, 0], [100, $iStep], [-100, $iStep * 2], [100, $iStep * 3], [-100, $iStep * 4], [100, $iStep * 5], [-100, $iStep * 6], [100, $iStep * 7], [-100, $iStep * 8], [0, $iStep * 9]]
WinMove($g_hSplash, "", $iStartX - $aSplashLoc[$iStepIndex][0], $iStartY - $aSplashLoc[$iStepIndex][1], Default, Default, 8)
$iStepIndex += 1
If $iStepIndex > 9 Then $iStepIndex = 0
EndIf
EndFunc
Func UpdateSplashTitle($title)
SetDebugLog("UpdateSplashTitle: " & $title)
If $g_bDisableSplash Then Return
GUICtrlSetData($g_lSplashTitle, $title)
EndFunc
Func DestroySplashScreen()
If IsHWnd($g_hSplash) Then GUIDelete($g_hSplash)
ReleaseMutex($g_hSplashMutex)
$g_hSplashMutex = 0
EndFunc
Func MoveSplashScreen()
_WinAPI_PostMessage($g_hSplash, $WM_SYSCOMMAND, 0xF012, 0)
EndFunc
Func CreateSplashScreen($iSteps = Default)
Local $iGuiState = @SW_SHOWNOACTIVATE
Local $bDisableSplash = $g_bDisableSplash
If $iSteps = Default Then
$g_iSplashTotalSteps = 10
Else
$iGuiState = @SW_SHOW
$bDisableSplash = False
$g_iSplashTotalSteps = $iSteps
$g_iSplashCurrentStep = 0
$g_hSplashTimer = 0
EndIf
Local $sSplashImg = $g_sLogoPath
Local $hImage, $iX, $iY
Local $iT = 20
Local $iB = 10
Switch $g_iGuiMode
Case 0
$g_iSplashTotalSteps = 3
Case 2
$g_iSplashTotalSteps = 4
EndSwitch
$g_hSplashMutex = AcquireMutexTicket("Launching", 1, Default, False)
If $bDisableSplash = False Then
Local $hSplashImg = _GDIPlus_BitmapCreateFromFile($sSplashImg)
$iX = _GDIPlus_ImageGetWidth($hSplashImg)
$iY = _GDIPlus_ImageGetHeight($hSplashImg)
Local $iHeight = $iY + $iT + $iB + 60
Local $iCenterX = @DesktopWidth / 2
Local $iCenterY = @DesktopHeight / 2
If $g_bMyBotDance Then
Local $iTop = @DesktopHeight - 50 - $iHeight
Else
Local $iTop = $iCenterY - $iHeight / 2
EndIf
Local $iLeft = $iCenterX - $iX / 2
$g_hSplash = GUICreate("", $iX, $iHeight, $iLeft, $iTop, BitOR($WS_POPUP, $WS_BORDER), BitOR($WS_EX_TOPMOST, $WS_EX_WINDOWEDGE, $WS_EX_TOOLWINDOW))
GUISetBkColor($COLOR_WHITE, $g_hSplash)
$g_lSplashPic = _GUICtrlCreatePic($hSplashImg, 0, $iT)
GUICtrlSetOnEvent(-1, "MoveSplashScreen")
$g_lSplashTitle = GUICtrlCreateLabel($g_sBotTitle, 15, $iY + $iT + $iB + 3, $iX - 30, 15, $SS_CENTER)
GUICtrlSetOnEvent(-1, "MoveSplashScreen")
$g_hSplashProgress = GUICtrlCreateProgress(15, $iY + $iT + $iB + 20, $iX - 30, 10, $PBS_SMOOTH, BitOR($WS_EX_TOPMOST, $WS_EX_WINDOWEDGE, $WS_EX_TOOLWINDOW))
$g_lSplashStatus = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_Loading", "Loading..."), 15, $iY + $iT + $iB + 38, $iX - 30, 15, $SS_CENTER)
GUICtrlSetOnEvent(-1, "MoveSplashScreen")
_GDIPlus_BitmapDispose($hSplashImg)
GUISetState($iGuiState, $g_hSplash)
If $g_bDebugSetlog Then SetDebugLog("Splash created: $g_hSplash=" & $g_hSplash & ", $g_lSplashPic=" & $g_lSplashPic & ", $g_lSplashTitle=" & $g_lSplashTitle & ", $g_hSplashProgress=" & $g_hSplashProgress & ", $g_lSplashStatus=" & $g_lSplashStatus)
$g_hSplashTimer = __TimerInit()
EndIf
EndFunc
Global $aCenterEnemyVillageClickDrag = [65, 545]
Global $aCenterHomeVillageClickDrag = [160, 665]
Global $aIsReloadError[4] = [457, 301 + $g_iMidOffsetY, 0x33B5E5, 10]
Global $aIsMain[4] = [278, 9, 0x77BDE0, 20]
Global $aIsMainGrayed[4] = [278, 9, 0x3C5F70, 15]
Global $aIsOnBuilderBase[4] = [838, 18, 0xffff46, 10]
Global $aTopLeftClient[4] = [1, 1, 0x000000, 0]
Global $aTopRightClient[4] = [850, 1, 0x000000, 0]
Global $aIsConnectLost[4] = [255, 271 + $g_iMidOffsetY, 0x33B5E5, 20]
Global $aIsCheckOOS[4] = [223, 272 + $g_iMidOffsetY, 0x33B5E5, 20]
Global $aIsMaintenance[4] = [350, 273 + $g_iMidOffsetY, 0x33B5E5, 20]
Global $aReloadButton[4] = [443, 408 + $g_iMidOffsetY, 0x282828, 10]
Global $aAttackButton[2] = [60, 614 + $g_iBottomOffsetY]
Global $aFindMatchButton[4] = [195, 480 + $g_iBottomOffsetY, 0xFFBF43, 10]
Global $aFindMatchButton2[4] = [195, 480 + $g_iBottomOffsetY, 0xE75D0D, 10]
Global $aIsAttackShield[4] = [250, 415 + $g_iMidOffsetY, 0xE8E8E0, 10]
Global $aAway[2] = [175, 10]
Global $aNoShield[4] = [448, 20, 0x43484B, 15]
Global $aHaveShield[4] = [455, 19, 0xF0F8FB, 15]
Global $aHavePerGuard[4] = [455, 19, 0x10100D, 15]
Global $aShieldInfoButton[4] = [431, 10, 0x75BDE4, 15]
Global $aIsShieldInfo[4] = [645, 195, 0xED1115, 20]
Global $aSurrenderButton[4] = [70, 545 + $g_iBottomOffsetY, 0xC00000, 40]
Global $aConfirmSurrender[4] = [500, 415 + $g_iMidOffsetY, 0x60AC10, 20]
Global $aCancelFight[4] = [822, 48, 0xD80408, 20]
Global $aCancelFight2[4] = [830, 59, 0xD80408, 20]
Global $aEndFightSceneBtn[4] = [429, 519 + $g_iMidOffsetY, 0xB8E35F, 20]
Global $aEndFightSceneAvl[4] = [241, 196 + $g_iMidOffsetY, 0xFFF090, 20]
Global $aReturnHomeButton[4] = [376, 567 + $g_iMidOffsetY, 0x60AC10, 20]
Global $aChatTab[4] = [331, 325 + $g_iMidOffsetY, 0xF0951D, 20]
Global $aChatTab2[4] = [331, 330 + $g_iMidOffsetY, 0xF0951D, 20]
Global $aChatTab3[4] = [331, 335 + $g_iMidOffsetY, 0xF0951D, 20]
Global $aOpenChat[2] = [19, 349 + $g_iMidOffsetY]
Global $aClanTab[2] = [189, 24]
Global $aArmyCampSize[2] = [110, 136 + $g_iMidOffsetY]
Global $aArmySpellSize[2] = [99, 284 + $g_iMidOffsetY]
Global $g_aArmyCCSpellSize[2] = [473, 438 + $g_iMidOffsetY]
Global $aArmyCCRemainTime[2] = [782, 540 + $g_iMidOffsetY]
Global $aIsCampFull[4] = [128, 151 + $g_iMidOffsetY, 0xFFFFFF, 10]
Global $aBarrackFull[4] = [388, 154 + $g_iMidOffsetY, 0xE84D50, 20]
Global $aBuildersDigits[2] = [324, 21]
Global $aBuildersDigitsBuilderBase[2] = [414, 21]
Global $aTrophies[2] = [69, 84]
Global $aNoCloudsAttack[4] = [25, 606, 0xCD0D0D, 15]
Global $aMessageButton[2] = [38, 143]
Global $aArmyTrainButton[2] = [40, 525 + $g_iBottomOffsetY]
Global $aWonOneStar[4] = [714, 538 + $g_iBottomOffsetY, 0xC0C8C0, 20]
Global $aWonTwoStar[4] = [739, 538 + $g_iBottomOffsetY, 0xC0C8C0, 20]
Global $aCancRequestCCBtn[4] = [340, 250, 0xCC4010, 20]
Global $aSendRequestCCBtn[2] = [524, 250]
Global $atxtRequestCCBtn[2] = [430, 140]
Global $aIsAtkDarkElixirFull[4] = [743, 62 + $g_iMidOffsetY, 0x270D33, 10]
Global $aIsDarkElixirFull[4] = [708, 102 + $g_iMidOffsetY, 0x270D33, 10]
Global $aIsGoldFull[4] = [659, 2 + $g_iMidOffsetY, 0xE7C00D, 10]
Global $aIsElixirFull[4] = [659, 52 + $g_iMidOffsetY, 0xC027C0, 10]
Global $aPerkBtn[4] = [95, 243 + $g_iMidOffsetY, 0x7cd8e8, 10]
Global $aIsGemWindow1[4] = [573, 256 + $g_iMidOffsetY, 0xEB1316, 20]
Global $aIsGemWindow2[4] = [577, 266 + $g_iMidOffsetY, 0xCC2025, 20]
Global $aIsGemWindow3[4] = [586, 266 + $g_iMidOffsetY, 0xCC2025, 20]
Global $aIsGemWindow4[4] = [595, 266 + $g_iMidOffsetY, 0xCC2025, 20]
Global $aLootCartBtn[2] = [430, 640 + $g_iBottomOffsetY]
Global $aCleanYard[4] = [418, 587 + $g_iBottomOffsetY, 0xE1DEBE, 20]
Global $aIsTrainPgChk1[4] = [813, 80 + $g_iMidOffsetY, 0xFF8D95, 10]
Global $aRtnHomeCloud1[4] = [56, 592 + $g_iBottomOffsetY, 0x0A223F, 15]
Global $aRtnHomeCloud2[4] = [72, 592 + $g_iBottomOffsetY, 0x103F7E, 15]
Global $aDetectLang[2] = [16, 634 + $g_iBottomOffsetY]
Global $aGreenArrowTrainTroops[2] = [310, 127]
Global $aGreenArrowBrewSpells[2] = [467, 127]
Global $g_aShopWindowOpen[4] = [804, 54, 0xC00508, 15]
Global $aTreasuryWindow[4] = [689, 138 + $g_iMidOffsetY, 0xFF8D95, 20]
Global $aAttackForTreasury[4] = [88, 619 + $g_iMidOffsetY, 0xF0EBE8, 5]
Global $aAtkHasDarkElixir[4] = [ 31, 144, 0x282020, 10]
Global $aVillageHasDarkElixir[4] = [837, 134, 0x3D2D3D, 10]
Global $aCheckTopProfile[4] = [200, 166, 0x868CAC, 5]
Global $aCheckTopProfile2[4] = [220, 355, 0x4E4D79, 5]
Global $aIsTabOpen[4] = [0, 145, 0xEAEAE3, 25]
Global $aRecievedTroops[4] = [200 ,215 ,0xFFFFFF, 20]
Global $aKingHealth = [-1, 569 + $g_iBottomOffsetY, 0x00D500, 15]
Global $aQueenHealth = [-1, 569 + $g_iBottomOffsetY, 0x00D500, 15]
Global $aWardenHealth = [-1, 569 + $g_iBottomOffsetY, 0x00D500, 15]
Global $aWonOneStarAtkRprt[4] = [325, 180 + $g_iMidOffsetY, 0xC8CaC4, 30]
Global $aWonTwoStarAtkRprt[4] = [398, 180 + $g_iMidOffsetY, 0xD0D6D0, 30]
Global $aWonThreeStarAtkRprt[4] = [534, 180 + $g_iMidOffsetY, 0xC8CAC7, 30]
Global $NextBtn[4] = [780, 546 + $g_iBottomOffsetY, 0xD34300, 20]
Global $aRequestTroopsAO[6] = [761, 580, 0x919191, 0x6DB630, 0xFFFFFE, 15]
Global Const $aCloseChat[4] = [331, 330 + $g_iMidOffsetY, 0xF0951D, 20]
Global Const $aChatDonateBtnColors[4][4] = [[0x0d0d0d, 0, -4, 20], [0xdaf582, 10, 0, 20], [0xcdef75, 10, 5, 20], [0xFFFFFF, 24, 9, 10]]
Global Const $aAtkRprtDECheck[4] = [459, 372 + $g_iMidOffsetY, 0x433350, 20]
Global Const $aAtkRprtTrophyCheck[4] = [327, 189 + $g_iMidOffsetY, 0x3B321C, 30]
Global Const $aAtkRprtDECheck2[4] = [678, 418 + $g_iMidOffsetY, 0x030000, 30]
Global Const $aRtnHomeCheck1[4] = [363, 548 + $g_iMidOffsetY, 0x78C11C, 20]
Global Const $aRtnHomeCheck2[4] = [497, 548 + $g_iMidOffsetY, 0x79C326, 20]
Global Const $aIsAttackPage[4] = [70, 548 + $g_iBottomOffsetY, 0xC80000, 20]
Global Const $aAttackLogPage[4] = [775, 125, 0xEB1115, 40]
Global Const $aAttackLogAttackTab[4] = [437, 114, 0xF0F4F0, 30]
Global Const $aBlueShareReplayButton[4] = [500, 156 + $g_iMidOffsetY, 0x70D4E8, 30]
Global Const $aGrayShareReplayButton[4] = [500, 156 + $g_iMidOffsetY, 0xBBBBBB, 30]
Global Const $aProfileReport[4] = [619, 344, 0x4E4D79, 20]
Global $aArmyTrainButtonRND[4] = [20, 540 + $g_iMidOffsetY, 55, 570 + $g_iMidOffsetY]
Global $aAttackButtonRND[4] = [20, 610 + $g_iMidOffsetY, 100, 670 + $g_iMidOffsetY]
Global $aFindMatchButtonRND[4] = [200, 510 + $g_iMidOffsetY, 300, 530 + $g_iMidOffsetY]
Global $NextBtnRND[4] = [710, 530 + $g_iMidOffsetY, 830, 570 + $g_iMidOffsetY]
Global $aLoginWithSupercellID[4] = [280, 640 + $g_iMidOffsetY, 0xDCF684, 20]
Global $aLoginWithSupercellID2[4] = [266, 653 + $g_iMidOffsetY, 0xFFFFFF , 10]
Global $aButtonSetting[4] = [820, 550 + $g_iMidOffsetY, 0xFFFFFF, 10]
Global $aButtonConnected[4] = [430, 380 + $g_iMidOffsetY, 0xD8F480, 20]
Global $aButtonDisconnected[4] = [430, 380 + $g_iMidOffsetY, 0xFF7C81, 20]
Global $aListAccount[4] = [165, 350 + $g_iMidOffsetY, 0xFFFFFF, 10]
Global $aButtonVillageLoad[4] = [515, 411 + $g_iMidOffsetY, 0x6EBD1F, 20]
Global $aTextBox[4] = [320, 160 + $g_iMidOffsetY, 0xFFFFFF, 10]
Global $aButtonVillageOkay[4] = [500, 170 + $g_iMidOffsetY, 0x81CA2D, 20]
Global $aButtonConnectedSCID[4] = [430, 205 + $g_iMidOffsetY, 0x6EB730, 20]
Global $aButtonLogOutSCID[4] = [700, 285 + $g_iMidOffsetY, 0x308AFB, 20]
Global $aButtonConfirmSCID[4] = [460, 410 + $g_iMidOffsetY, 0x328AFB, 20]
Global $aListAccountSCID[4] = [490, 185 + $g_iMidOffsetY, 0x000000, 10]
Global $aCloseTabSCID[4] = [732, 145]
Global $aTrainBarb[4] = [-1, -1, -1, -1]
Global $aTrainArch[4] = [-1, -1, -1, -1]
Global $aTrainGiant[4] = [-1, -1, -1, -1]
Global $aTrainGobl[4] = [-1, -1, -1, -1]
Global $aTrainWall[4] = [-1, -1, -1, -1]
Global $aTrainBall[4] = [-1, -1, -1, -1]
Global $aTrainWiza[4] = [-1, -1, -1, -1]
Global $aTrainHeal[4] = [-1, -1, -1, -1]
Global $aTrainDrag[4] = [-1, -1, -1, -1]
Global $aTrainPekk[4] = [-1, -1, -1, -1]
Global $aTrainBabyD[4] = [-1, -1, -1, -1]
Global $aTrainMine[4] = [-1, -1, -1, -1]
Global $aTrainEDrag[4] = [-1, -1, -1, -1]
Global $aTrainMini[4] = [-1, -1, -1, -1]
Global $aTrainHogs[4] = [-1, -1, -1, -1]
Global $aTrainValk[4] = [-1, -1, -1, -1]
Global $aTrainGole[4] = [-1, -1, -1, -1]
Global $aTrainWitc[4] = [-1, -1, -1, -1]
Global $aTrainLava[4] = [-1, -1, -1, -1]
Global $aTrainBowl[4] = [-1, -1, -1, -1]
Global $aTrainLSpell[4] = [-1, -1, -1, -1]
Global $aTrainHSpell[4] = [-1, -1, -1, -1]
Global $aTrainRSpell[4] = [-1, -1, -1, -1]
Global $aTrainJSpell[4] = [-1, -1, -1, -1]
Global $aTrainFSpell[4] = [-1, -1, -1, -1]
Global $aTrainCSpell[4] = [-1, -1, -1, -1]
Global $aTrainPSpell[4] = [-1, -1, -1, -1]
Global $aTrainESpell[4] = [-1, -1, -1, -1]
Global $aTrainHaSpell[4] = [-1, -1, -1, -1]
Global $aTrainSkSpell[4] = [-1, -1, -1, -1]
Global $aTrainArmy[$eArmyCount] = [$aTrainBarb, $aTrainArch, $aTrainGiant, $aTrainGobl, $aTrainWall, $aTrainBall, $aTrainWiza, $aTrainHeal, $aTrainDrag, $aTrainPekk, $aTrainBabyD, $aTrainMine, $aTrainEDrag, $aTrainMini, $aTrainHogs, $aTrainValk, $aTrainGole, $aTrainWitc, $aTrainLava, $aTrainBowl, 0, 0, 0, 0, $aTrainLSpell, $aTrainHSpell, $aTrainRSpell, $aTrainJSpell, $aTrainFSpell, $aTrainCSpell, $aTrainPSpell, $aTrainESpell, $aTrainHaSpell, $aTrainSkSpell]
Global $aButtonLanguage[4] = [210, 375 + $g_iMidOffsetY, 0xD0E978, 20]
Global $aListLanguage[4] = [110, 90 + $g_iMidOffsetY, 0xFFFFFF, 10]
Global $aEnglishLanguage[4] = [420, 140 + $g_iMidOffsetY, 0xD7D5C7, 20]
Global $aLanguageOkay[4] = [510, 420 + $g_iMidOffsetY, 0x6FBD1F, 20]
Global $g_sImgImgLocButtons = @ScriptDir & "\imgxml\imglocbuttons"
Global Const $g_sImgAnyoneThere = @ScriptDir & "\imgxml\other\AnyoneThere[[Android]]*"
Global Const $g_sImgPersonalBreak = @ScriptDir & "\imgxml\other\break*"
Global Const $g_sImgAnotherDevice = @ScriptDir & "\imgxml\other\Device[[Android]]*"
Global Const $g_sImgCocStopped = @ScriptDir & "\imgxml\other\CocStopped*"
Global Const $g_sImgCocReconnecting = @ScriptDir & "\imgxml\other\CocReconnecting*"
Global Const $g_sImgAppRateNever = @ScriptDir & "\imgxml\other\RateNever[[Android]]*"
Global Const $g_sImgGfxError = @ScriptDir & "\imgxml\other\GfxError*"
Global Const $g_sImgError = @ScriptDir & "\imgxml\other\Error[[Android]]*"
Global Const $g_sImgOutOfSync = @ScriptDir & "\imgxml\other\Oos[[Android]]*"
Global $g_sImgCollectRessources = @ScriptDir & "\imgxml\Resources\Collect"
Global $g_sImgCollectLootCart = @ScriptDir & "\imgxml\Resources\LootCart\LootCart_0_85.xml"
Global $g_sImgRearm = @ScriptDir & "\imgxml\rearm\"
Global $g_sImgBoat = @ScriptDir & "\imgxml\Boat\BoatNormalVillage_0_89.xml"
Global $g_sImgZoomOutDir = @ScriptDir & "\imgxml\village\NormalVillage\"
Global $g_sImgCheckWallDir = @ScriptDir & "\imgxml\Walls"
Global $g_sImgClearTombs = @ScriptDir & "\imgxml\Resources\Tombs"
Global $g_sImgCleanYard = @ScriptDir & "\imgxml\Resources\Obstacles"
Global $g_sImgCleanYardSnow = @ScriptDir & "\imgxml\Obstacles_Snow"
Global $g_sImgGemBox = @ScriptDir & "\imgxml\Resources\GemBox"
Global $g_sImgCollectReward = @ScriptDir & "\imgxml\Resources\ClaimReward"
Global $g_sImgTrader = @ScriptDir & "\imgxml\FreeMagicItems\TraderIcon"
Global $g_sImgDailyDiscountWindow = @ScriptDir & "\imgxml\FreeMagicItems\DailyDiscount"
Global $g_sImgCollectRessourcesBB = @ScriptDir & "\imgxml\Resources\BuildersBase\Collect"
Global $g_sImgBoatBB = @ScriptDir & "\imgxml\Boat\BoatBuilderBase_0_89.xml"
Global $g_sImgZoomOutDirBB = @ScriptDir & "\imgxml\village\BuilderBase\"
Global $g_sImgStartCTBoost = @ScriptDir & "\imgxml\Resources\BuildersBase\ClockTower\ClockTowerAvailable*.xml"
Global $g_sImgDonateTroops = @ScriptDir & "\imgxml\DonateCC\Troops\"
Global $g_sImgDonateSpells = @ScriptDir & "\imgxml\DonateCC\Spells\"
Global $g_sImgChatDivider = @ScriptDir & "\imgxml\DonateCC\donateccwbl\chatdivider_0_98.xml"
Global $g_sImgChatDividerHidden = @ScriptDir & "\imgxml\DonateCC\donateccwbl\chatdividerhidden_0_98.xml"
Global $g_sImgAUpgradeObst = @ScriptDir & "\imgxml\Resources\Auto Upgrade\Obstacles"
Global $g_sImgAUpgradeZero = @ScriptDir & "\imgxml\Resources\Auto Upgrade\Zero"
Global $g_sImgAUpgradeUpgradeBtn = @ScriptDir & "\imgxml\Resources\Auto Upgrade\UpgradeButton"
Global $g_sImgAUpgradeRes = @ScriptDir & "\imgxml\Resources\Auto Upgrade\Resources"
Global $g_sImgAutoUpgradeGold = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\Gold"
Global $g_sImgAutoUpgradeElixir = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\Elixir"
Global $g_sImgAutoUpgradeWindow = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\Window"
Global $g_sImgAutoUpgradeNew = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\New"
Global $g_sImgAutoUpgradeNoRes = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\NoResources"
Global $g_sImgAutoUpgradeBtnElixir = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\ButtonUpg\Elixir"
Global $g_sImgAutoUpgradeBtnGold = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\ButtonUpg\Gold"
Global $g_sImgAutoUpgradeBtnDir = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\Upgrade"
Global $g_sImgAutoUpgradeZero = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\NewBuildings\Shop"
Global $g_sImgAutoUpgradeClock = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\NewBuildings\Clock"
Global $g_sImgAutoUpgradeInfo = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\NewBuildings\Slot"
Global $g_sImgAutoUpgradeNewBldgYes = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\NewBuildings\Yes"
Global $g_sImgAutoUpgradeNewBldgNo = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\NewBuildings\No"
Global $g_sImgTrainTroops = @ScriptDir & "\imgxml\Train\Train_Train\"
Global $g_sImgTrainSpells = @ScriptDir & "\imgxml\Train\Spell_Train\"
Global $g_sImgArmyOverviewSpells = @ScriptDir & "\imgxml\ArmyOverview\Spells"
Global $g_sImgAttackBarDir = @ScriptDir & "\imgxml\AttackBar"
Global $g_sImgSwitchSiegeMacines = @ScriptDir & "\imgxml\SwitchSiegeMachines\Siege"
Global $g_sImgSwitchSiegeCastle = @ScriptDir & "\imgxml\SwitchSiegeMachines\Castle"
Global $g_sImgElixirStorage = @ScriptDir & "\imgxml\deadbase\elix\storage\"
Global $g_sImgWeakBaseBuildingsDir = @ScriptDir & "\imgxml\Buildings"
Global $g_sImgWeakBaseBuildingsEagleDir = @ScriptDir & "\imgxml\Buildings\Eagle"
Global $g_sImgWeakBaseBuildingsInfernoDir = @ScriptDir & "\imgxml\Buildings\Infernos"
Global $g_sImgWeakBaseBuildingsXbowDir = @ScriptDir & "\imgxml\Buildings\Xbow"
Global $g_sImgWeakBaseBuildingsWizTowerSnowDir = @ScriptDir & "\imgxml\Buildings\WTower_Snow"
Global $g_sImgWeakBaseBuildingsWizTowerDir = @ScriptDir & "\imgxml\Buildings\WTower"
Global $g_sImgWeakBaseBuildingsMortarsDir = @ScriptDir & "\imgxml\Buildings\Mortars"
Global $g_sImgWeakBaseBuildingsAirDefenseDir = @ScriptDir & "\imgxml\Buildings\ADefense"
Global $g_sImgSearchDrill = @ScriptDir & "\imgxml\Storages\Drills"
Global $g_sImgSearchDrillLevel = @ScriptDir & "\imgxml\Storages\Drills\Level"
Global $g_sImgEasyBuildings = @ScriptDir & "\imgxml\easybuildings"
Global Const $g_sImgLoginWithSupercellID = @ScriptDir & "\imgxml\other\LoginWithSupercellID*"
Global Const $g_sImgGoogleSelectAccount = @ScriptDir & "\imgxml\other\GoogleSelectAccount*"
Global Const $g_sImgGoogleSelectEmail = @ScriptDir & "\imgxml\other\GoogleSelectEmail*"
Global Const $g_sImgCaravan = @ScriptDir & "\imgxml\Resources\Clan Games Images\MainLoop\Caravan"
Global Const $g_sImgStart = @ScriptDir & "\imgxml\Resources\Clan Games Images\MainLoop\Start"
Global Const $g_sImgPurge = @ScriptDir & "\imgxml\Resources\Clan Games Images\MainLoop\Purge"
Global Const $g_sImgCoolPurge = @ScriptDir & "\imgxml\Resources\Clan Games Images\MainLoop\Gem"
Global Const $g_sImgTrashPurge = @ScriptDir & "\imgxml\Resources\Clan Games Images\MainLoop\Trash"
Global Const $g_sImgOkayPurge = @ScriptDir & "\imgxml\Resources\Clan Games Images\MainLoop\Okay"
Global Const $g_sImgReward = @ScriptDir & "\imgxml\Resources\Clan Games Images\MainLoop\Reward"
Global Const $g_sImageBuilerGames = @ScriptDir & "\imgxml\Resources\Clan Games Images\MainLoop\BuilderGames"
Global Const $g_sImgGold = @ScriptDir & "\imgxml\Resources\Clan Games Images\Loot Challenges\Gold Challenge"
Global Const $g_sImgElixir = @ScriptDir & "\imgxml\Resources\Clan Games Images\Loot Challenges\Elixir Challenge"
Global Const $g_sImgDark = @ScriptDir & "\imgxml\Resources\Clan Games Images\Loot Challenges\Dark Elixir Challenge\"
Global Const $g_sImgGoldG = @ScriptDir & "\imgxml\Resources\Clan Games Images\Loot Challenges\Gold Grab"
Global Const $g_sImgElixirE = @ScriptDir & "\imgxml\Resources\Clan Games Images\Loot Challenges\Elixir Embezzlement"
Global Const $g_sImgDarkEH = @ScriptDir & "\imgxml\Resources\Clan Games Images\Loot Challenges\Dark Elixir Heist"
Global Const $g_sImgStar = @ScriptDir & "\imgxml\Resources\Clan Games Images\Battle Challenges\Star Collector"
Global Const $g_sImgLordD = @ScriptDir & "\imgxml\Resources\Clan Games Images\Battle Challenges\Lord of Destruction"
Global Const $g_sImgPileVict = @ScriptDir & "\imgxml\Resources\Clan Games Images\Battle Challenges\Pile Of Victories"
Global Const $g_sImgHunt3 = @ScriptDir & "\imgxml\Resources\Clan Games Images\Battle Challenges\Hunt for Three Stars"
Global Const $g_sImgWStreak = @ScriptDir & "\imgxml\Resources\Clan Games Images\Battle Challenges\Winning Streak"
Global Const $g_sImgWStreakC = @ScriptDir & "\imgxml\Resources\Clan Games Images\Battle Challenges\Confirm_WinningStreak"
Global Const $g_sImgSlayingT = @ScriptDir & "\imgxml\Resources\Clan Games Images\Battle Challenges\Slaying The Titans"
Global Const $g_sImgNoMagicZone = @ScriptDir & "\imgxml\Resources\Clan Games Images\Battle Challenges\No-Magic Zone"
Global Const $g_sImgNoHeroics = @ScriptDir & "\imgxml\Resources\Clan Games Images\Battle Challenges\No Heroics Allowed"
Global Const $g_sImgAttUp = @ScriptDir & "\imgxml\Resources\Clan Games Images\Battle Challenges\Attack Up"
Global Const $g_sImgCannon = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Cannon Carnage"
Global Const $g_sImgArcherT = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Archer Tower Assault"
Global Const $g_sImgMortar = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Mortar Mauling"
Global Const $g_sImgAirDef = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Destroy Air Defenses"
Global Const $g_sImgWizard = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Wizard Tower Warfare"
Global Const $g_sImgAirS = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Destroy Air Sweepers"
Global Const $g_sImgTesla = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Destroy Tesla Towers"
Global Const $g_sImgBombT = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Destroy Bomb Towers"
Global Const $g_sImgXBow = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Destroy X-Bows"
Global Const $g_sImgInferno = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Destroy Inferno Towers"
Global Const $g_sImgEagle = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Eagle Artillery Elimination"
Global Const $g_sImgCCC = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Clan Castle Charge"
Global Const $g_sImgGoldRaid = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Gold Storage Raid"
Global Const $g_sImgElixirR = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Elixir Storage Raid"
Global Const $g_sImgDESRaid = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Dark Elixir Storage Raid"
Global Const $g_sImgGoldMM = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Gold Mine Mayhem"
Global Const $g_sImgElixirPE = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Elixir Pump Elimination"
Global Const $g_sImgDarkEP = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Dark Elixir Plumbers"
Global Const $g_sImgLab = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Laboratory Strike"
Global Const $g_sImgSFact = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Spell Factory Sabotage"
Global Const $g_sImgDSFact = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Dark Spell Factory Sabotage"
Global Const $g_sImgBBAltar = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Destroy Barbarian King Altars"
Global Const $g_sImgAQAltar = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Destroy Archer Queen Altars"
Global Const $g_sImgGWAltar = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Destroy Grand Warden Altars"
Global Const $g_sImgHeroHunt = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Hero Level Hunter"
Global Const $g_sImgKingHunt = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\King Level Hunter"
Global Const $g_sImgQueenHunt = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Queen Level Hunter"
Global Const $g_sImgWardenHunt = @ScriptDir & "\imgxml\Resources\Clan Games Images\Destruction Challenges\Warden Level Hunter"
Global Const $g_sImgValk = @ScriptDir & "\imgxml\Resources\Clan Games Images\Ground Troop Challenges\Valk"
Global Const $g_sImgArch = @ScriptDir & "\imgxml\Resources\Clan Games Images\Ground Troop Challenges\Arch"
Global Const $g_sImgBarb = @ScriptDir & "\imgxml\Resources\Clan Games Images\Ground Troop Challenges\Barb"
Global Const $g_sImgBowl = @ScriptDir & "\imgxml\Resources\Clan Games Images\Ground Troop Challenges\Bowl"
Global Const $g_sImgGiant = @ScriptDir & "\imgxml\Resources\Clan Games Images\Ground Troop Challenges\Giant"
Global Const $g_sImgGobl = @ScriptDir & "\imgxml\Resources\Clan Games Images\Ground Troop Challenges\Gobl"
Global Const $g_sImgGole = @ScriptDir & "\imgxml\Resources\Clan Games Images\Ground Troop Challenges\Gole"
Global Const $g_sImgHeal = @ScriptDir & "\imgxml\Resources\Clan Games Images\Ground Troop Challenges\Heal"
Global Const $g_sImgHogs = @ScriptDir & "\imgxml\Resources\Clan Games Images\Ground Troop Challenges\Hogs"
Global Const $g_sImgMine = @ScriptDir & "\imgxml\Resources\Clan Games Images\Ground Troop Challenges\Mine"
Global Const $g_sImgPekka = @ScriptDir & "\imgxml\Resources\Clan Games Images\Ground Troop Challenges\Pekka"
Global Const $g_sImgWall = @ScriptDir & "\imgxml\Resources\Clan Games Images\Ground Troop Challenges\Wall"
Global Const $g_sImgWitch = @ScriptDir & "\imgxml\Resources\Clan Games Images\Ground Troop Challenges\Witch"
Global Const $g_sImgWiza = @ScriptDir & "\imgxml\Resources\Clan Games Images\Ground Troop Challenges\Wiza"
Global Const $g_sImgBabyD = @ScriptDir & "\imgxml\Resources\Clan Games Images\Air Troop Challenges\BabyD"
Global Const $g_sImgBall = @ScriptDir & "\imgxml\Resources\Clan Games Images\Air Troop Challenges\Ball"
Global Const $g_sImgDrag = @ScriptDir & "\imgxml\Resources\Clan Games Images\Air Troop Challenges\Drag"
Global Const $g_sImgLava = @ScriptDir & "\imgxml\Resources\Clan Games Images\Air Troop Challenges\Lava"
Global Const $g_sImgMini = @ScriptDir & "\imgxml\Resources\Clan Games Images\Air Troop Challenges\Mini"
Global Const $g_sImgGard = @ScriptDir & "\imgxml\Resources\Clan Games Images\Miscellaneous Challenges\Gardening Exercise"
Global Const $g_sImgDonS = @ScriptDir & "\imgxml\Resources\Clan Games Images\Miscellaneous Challenges\Donate Spells"
Global Const $g_sImgDonH = @ScriptDir & "\imgxml\Resources\Clan Games Images\Miscellaneous Challenges\Helping Hand"
Func _StringSize($sText, $iSize = 8.5, $iWeight = 400, $iAttrib = 0, $sName = "", $iMaxWidth = 0, $hWnd = 0)
If $iSize = Default Then $iSize = 8.5
If $iWeight = Default Then $iWeight = 400
If $iAttrib = Default Then $iAttrib = 0
If $sName = "" Or $sName = Default Then $sName = _StringSize_DefaultFontName()
If Not IsString($sText) Then Return SetError(1, 1, 0)
If Not IsNumber($iSize) Then Return SetError(1, 2, 0)
If Not IsInt($iWeight) Then Return SetError(1, 3, 0)
If Not IsInt($iAttrib) Then Return SetError(1, 4, 0)
If Not IsString($sName) Then Return SetError(1, 5, 0)
If Not IsNumber($iMaxWidth) Then Return SetError(1, 6, 0)
If Not IsHwnd($hWnd) And $hWnd <> 0 Then Return SetError(1, 7, 0)
Local $aRet, $hDC, $hFont, $hLabel = 0, $hLabel_Handle
Local $iExpTab = BitAnd($iAttrib, 1)
$iAttrib = BitAnd($iAttrib, BitNot(1))
If IsHWnd($hWnd) Then
$hLabel = GUICtrlCreateLabel("", -10, -10, 10, 10)
$hLabel_Handle = GUICtrlGetHandle(-1)
GUICtrlSetFont(-1, $iSize, $iWeight, $iAttrib, $sName)
$aRet = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hLabel_Handle)
If @error Or $aRet[0] = 0 Then
GUICtrlDelete($hLabel)
Return SetError(2, 1, 0)
EndIf
$hDC = $aRet[0]
$aRet = DllCall("user32.dll", "lparam", "SendMessage", "hwnd", $hLabel_Handle, "int", 0x0031, "wparam", 0, "lparam", 0)
If @error Or $aRet[0] = 0 Then
GUICtrlDelete($hLabel)
Return SetError(2, _StringSize_Error_Close(2, $hDC), 0)
EndIf
$hFont = $aRet[0]
Else
$aRet = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Or $aRet[0] = 0 Then Return SetError(2, 1, 0)
$hDC = $aRet[0]
$aRet = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", 90)
If @error Or $aRet[0] = 0 Then Return SetError(2, _StringSize_Error_Close(3, $hDC), 0)
Local $iInfo = $aRet[0]
$aRet = DllCall("gdi32.dll", "handle", "CreateFontW", "int", -$iInfo * $iSize / 72, "int", 0, "int", 0, "int", 0, "int", $iWeight, "dword", BitAND($iAttrib, 2), "dword", BitAND($iAttrib, 4), "dword", BitAND($iAttrib, 8), "dword", 0, "dword", 0, "dword", 0, "dword", 5, "dword", 0, "wstr", $sName)
If @error Or $aRet[0] = 0 Then Return SetError(2, _StringSize_Error_Close(4, $hDC), 0)
$hFont = $aRet[0]
EndIf
$aRet = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hFont)
If @error Or $aRet[0] = 0 Then Return SetError(2, _StringSize_Error_Close(5, $hDC, $hFont, $hLabel), 0)
Local $hPrevFont = $aRet[0]
Local $avSize_Info[4], $iLine_Length, $iLine_Height = 0, $iLine_Count = 0, $iLine_Width = 0, $iWrap_Count, $iLast_Word, $sTest_Line
Local $tSize = DllStructCreate("int X;int Y")
DllStructSetData($tSize, "X", 0)
DllStructSetData($tSize, "Y", 0)
$sText = StringRegExpReplace($sText, "((?<!\x0d)\x0a|\x0d(?!\x0a))", @CRLF)
Local $asLines = StringSplit($sText, @CRLF, 1)
For $i = 1 To $asLines[0]
If $iExpTab Then
$asLines[$i] = StringReplace($asLines[$i], @TAB, " XXXXXXXX")
EndIf
$iLine_Length = StringLen($asLines[$i])
DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $asLines[$i], "int", $iLine_Length, "ptr", DllStructGetPtr($tSize))
If @error Then Return SetError(2, _StringSize_Error_Close(6, $hDC, $hFont, $hLabel), 0)
If DllStructGetData($tSize, "X") > $iLine_Width Then $iLine_Width = DllStructGetData($tSize, "X")
If DllStructGetData($tSize, "Y") > $iLine_Height Then $iLine_Height = DllStructGetData($tSize, "Y")
Next
If $iMaxWidth <> 0 And $iLine_Width > $iMaxWidth Then
For $j = 1 To $asLines[0]
$iLine_Length = StringLen($asLines[$j])
DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $asLines[$j], "int", $iLine_Length, "ptr", DllStructGetPtr($tSize))
If @error Then Return SetError(2, _StringSize_Error_Close(6, $hDC, $hFont, $hLabel), 0)
If DllStructGetData($tSize, "X") < $iMaxWidth - 4 Then
$iLine_Count += 1
$avSize_Info[0] &= $asLines[$j] & @CRLF
Else
$iWrap_Count = 0
While 1
$iLine_Width = 0
$iLast_Word = 0
For $i = 1 To StringLen($asLines[$j])
If StringMid($asLines[$j], $i, 1) = " " Then $iLast_Word = $i - 1
$sTest_Line = StringMid($asLines[$j], 1, $i)
$iLine_Length = StringLen($sTest_Line)
DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $sTest_Line, "int", $iLine_Length, "ptr", DllStructGetPtr($tSize))
If @error Then Return SetError(2, _StringSize_Error_Close(6, $hDC, $hFont, $hLabel), 0)
$iLine_Width = DllStructGetData($tSize, "X")
If $iLine_Width >= $iMaxWidth - 4 Then ExitLoop
Next
If $i > StringLen($asLines[$j]) Then
$iWrap_Count += 1
$avSize_Info[0] &= $sTest_Line & @CRLF
ExitLoop
Else
$iWrap_Count += 1
If $iLast_Word = 0 Then Return SetError(3, _StringSize_Error_Close(0, $hDC, $hFont, $hLabel), 0)
$avSize_Info[0] &= StringLeft($sTest_Line, $iLast_Word) & @CRLF
$asLines[$j] = StringTrimLeft($asLines[$j], $iLast_Word)
$asLines[$j] = StringStripWS($asLines[$j], 1)
EndIf
WEnd
$iLine_Count += $iWrap_Count
EndIf
Next
If $iExpTab Then
$avSize_Info[0] = StringRegExpReplace($avSize_Info[0], "\x20?XXXXXXXX", @TAB)
EndIf
$avSize_Info[1] = $iLine_Height
$avSize_Info[2] = $iMaxWidth
$avSize_Info[3] =($iLine_Count * $iLine_Height) + 4
Else
Local $avSize_Info[4] = [$sText, $iLine_Height, $iLine_Width,($asLines[0] * $iLine_Height) + 4]
EndIf
DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hPrevFont)
DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hFont)
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $hDC)
If $hLabel Then GUICtrlDelete($hLabel)
$tSize = 0
Return $avSize_Info
EndFunc
Func _StringSize_Error_Close($iExtCode, $hDC = 0, $hFont = 0, $hLabel = 0)
If $hFont <> 0 Then DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hFont)
If $hDC <> 0 Then DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $hDC)
If $hLabel Then GUICtrlDelete($hLabel)
Return $iExtCode
EndFunc
Func _StringSize_DefaultFontName()
Local $tNONCLIENTMETRICS = DllStructCreate("uint;int;int;int;int;int;byte[60];int;int;byte[60];int;int;byte[60];byte[60];byte[60]")
DLLStructSetData($tNONCLIENTMETRICS, 1, DllStructGetSize($tNONCLIENTMETRICS))
DLLCall("user32.dll", "int", "SystemParametersInfo", "int", 41, "int", DllStructGetSize($tNONCLIENTMETRICS), "ptr", DllStructGetPtr($tNONCLIENTMETRICS), "int", 0)
Local $tLOGFONT = DllStructCreate("long;long;long;long;long;byte;byte;byte;byte;byte;byte;byte;byte;char[32]", DLLStructGetPtr($tNONCLIENTMETRICS, 13))
$tNONCLIENTMETRICS = 0
If IsString(DllStructGetData($tLOGFONT, 14)) Then
Local $iVal = DllStructGetData($tLOGFONT, 14)
$tLOGFONT = 0
Return $iVal
Else
$tLOGFONT = 0
Return "Tahoma"
EndIf
EndFunc
Global $g_aEMB_Settings[13]
Global $g_aEMB_TempArray = __EMB_GetDefaultFont()
$g_aEMB_Settings[10] = $g_aEMB_TempArray[0]
$g_aEMB_Settings[11] = $g_aEMB_TempArray[1]
$g_aEMB_TempArray = DllCall("User32.dll", "int", "GetSysColor", "int", 15)
$g_aEMB_Settings[8] = BitAND(BitShift(String(Binary($g_aEMB_TempArray[0])), 8), 0xFFFFFF)
$g_aEMB_TempArray = DllCall("User32.dll", "int", "GetSysColor", "int", 8)
$g_aEMB_Settings[9] = BitAND(BitShift(String(Binary($g_aEMB_TempArray[0])), 8), 0xFFFFFF)
$g_aEMB_TempArray = DllCall("user32.dll", "int", "GetSystemMetrics", "int", 11)
$g_aEMB_Settings[12] = $g_aEMB_TempArray[0]
$g_aEMB_TempArray = DllCall("user32.dll", "int", "GetSystemMetrics", "int", 30)
$g_aEMB_Settings[12] +=(($g_aEMB_TempArray[0] < 30) ?($g_aEMB_TempArray[0] * 3) :($g_aEMB_TempArray[0]) )
$g_aEMB_TempArray = 0
$g_aEMB_TempArray = DllCall("dwmapi.dll", "uint", "DwmIsCompositionEnabled", "int*", $g_aEMB_TempArray)
If Not @error And $g_aEMB_TempArray[1] = True Then
$g_aEMB_TempArray = DllCall("user32.dll", "int", "GetSystemMetrics", "int", 7)
$g_aEMB_Settings[12] +=($g_aEMB_TempArray[0] * 4)
EndIf
$g_aEMB_TempArray = 0
$g_aEMB_Settings[0] = 0
$g_aEMB_Settings[1] = 0
$g_aEMB_Settings[2] = $g_aEMB_Settings[8]
$g_aEMB_Settings[3] = $g_aEMB_Settings[9]
$g_aEMB_Settings[4] = $g_aEMB_Settings[10]
$g_aEMB_Settings[5] = $g_aEMB_Settings[11]
$g_aEMB_Settings[6] = 370
$g_aEMB_Settings[7] = 500
Func _ExtMsgBoxSet($iStyle = -1, $iJust = -1, $iBkCol = -1, $iCol = -1, $iFont_Size = -1, $sFont_Name = -1, $iWidth = -1, $iWidth_Abs = -1)
Switch $iStyle
Case Default
$g_aEMB_Settings[0] = 0
$g_aEMB_Settings[1] = 0
$g_aEMB_Settings[2] = $g_aEMB_Settings[8]
$g_aEMB_Settings[3] = $g_aEMB_Settings[9]
$g_aEMB_Settings[5] = $g_aEMB_Settings[11]
$g_aEMB_Settings[4] = $g_aEMB_Settings[10]
$g_aEMB_Settings[6] = 370
$g_aEMB_Settings[7] = 370
Return
Case -1
Case 0 To 127
$g_aEMB_Settings[0] = Int($iStyle)
Case Else
Return SetError(1, 1, 0)
EndSwitch
Switch $iJust
Case Default
$g_aEMB_Settings[1] = 0
Case -1
Case 0, 1, 2, 4, 5, 6
$g_aEMB_Settings[1] = $iJust
Case Else
Return SetError(1, 2, 0)
EndSwitch
Switch $iBkCol
Case Default
$g_aEMB_Settings[2] = $g_aEMB_Settings[8]
Case -1
Case 0 To 0xFFFFFF
$g_aEMB_Settings[2] = Int($iBkCol)
Case Else
Return SetError(1, 3, 0)
EndSwitch
Switch $iCol
Case Default
$g_aEMB_Settings[3] = $g_aEMB_Settings[9]
Case -1
Case 0 To 0xFFFFFF
$g_aEMB_Settings[3] = Int($iCol)
Case Else
Return SetError(1, 4, 0)
EndSwitch
Switch $iFont_Size
Case Default
$g_aEMB_Settings[4] = $g_aEMB_Settings[10]
Case -1
Case 8 To 72
$g_aEMB_Settings[4] = Int($iFont_Size)
Case Else
Return SetError(1, 5, 0)
EndSwitch
Switch $sFont_Name
Case Default
$g_aEMB_Settings[5] = $g_aEMB_Settings[11]
Case -1
Case Else
If IsString($sFont_Name) Then
$g_aEMB_Settings[5] = $sFont_Name
Else
Return SetError(1, 6, 0)
EndIf
EndSwitch
Switch $iWidth
Case Default
$g_aEMB_Settings[6] = 370
Case -1
Case 370 To @DesktopWidth - 20
$g_aEMB_Settings[6] = Int($iWidth)
Case Else
Return SetError(1, 7, 0)
EndSwitch
Switch $iWidth_Abs
Case Default
$g_aEMB_Settings[7] = 370
Case -1
Case 370 To @DesktopWidth - 20
$g_aEMB_Settings[7] = Int($iWidth_Abs)
Case Else
Return SetError(1, 8, 0)
EndSwitch
If $g_aEMB_Settings[7] < $g_aEMB_Settings[6] Then
$g_aEMB_Settings[7] = $g_aEMB_Settings[6]
EndIf
Return 1
EndFunc
Func _ExtMsgBox($vIcon, $vButton, $sTitle, $sText, $iTimeOut = 0, $hWin = $g_hFrmBot, $iVPos = 0, $bMain = True)
Local $iMsg_Width_Max = $g_aEMB_Settings[6], $iMsg_Width_Min = 150, $iMsg_Width_Abs = $g_aEMB_Settings[7]
Local $iMsg_Height_Min = 100
Local $iButton_Width_Def = 80, $iButton_Width_Min = 50
Local $iParent_Win = 0, $fCountdown = False, $cCheckbox, $aLabel_Size, $aRet, $iRet_Value, $iHpos
Local $sButton_Text, $iButton_Width, $iButton_Xpos
$iTimeOut = Int(Number($iTimeOut))
If $vButton == " " And $iTimeOut = 0 Then
$iTimeOut = 5
EndIf
Local $iIcon_Style = 0
Local $iIcon_Reduction = 50
Local $sDLL = "user32.dll"
If StringIsDigit($vIcon) Then
Switch $vIcon
Case 0
$iIcon_Reduction = 0
Case 8
$sDLL = "imageres.dll"
$iIcon_Style = 78
Case 16
$iIcon_Style = -4
Case 32
$iIcon_Style = -3
Case 48
$iIcon_Style = -2
Case 64
$iIcon_Style = -5
Case 128
If $iTimeOut > 0 Then
$fCountdown = True
Else
ContinueCase
EndIf
Case Else
Return SetError(1, 0, -1)
EndSwitch
Else
$sDLL = $vIcon
$iIcon_Style = 0
EndIf
StringRegExpReplace($vButton, "((?<!&)&)(?!&)", "*")
If @extended > 1 Then
Return SetError(2, 0, -1)
EndIf
If IsNumber($vButton) Then
Switch $vButton
Case 0
$vButton = "OK"
Case 1
$vButton = "&OK|Cancel"
Case 2
$vButton = "&Abort|Retry|Ignore"
Case 3
$vButton = "&Yes|No|Cancel"
Case 4
$vButton = "&Yes|No"
Case 5
$vButton = "&Retry|Cancel"
Case 6
$vButton = "&Cancel|Try Again|Continue"
Case Else
Return SetError(3, 0, -1)
EndSwitch
EndIf
Local $aButton_Text[1] = [0]
Local $iButton_Width_Req = 0
If $vButton <> " " Then
$aButton_Text = StringSplit($vButton, "|")
Local $iButton_Width_Abs = Floor((($iMsg_Width_Max - 10) / $aButton_Text[0]) - 10)
If $iButton_Width_Abs < $iButton_Width_Min Then
Return SetError(4, 0, -1)
EndIf
Local $iButton_Width_Text = 0
For $i = 1 To $aButton_Text[0]
$sButton_Text = StringRegExpReplace($aButton_Text[$i], "^&?(.*)$", "$1")
If BitAND($g_aEMB_Settings[0], 4) Then
$aRet = _StringSize($sButton_Text, $g_aEMB_Settings[10], Default, Default, $g_aEMB_Settings[11])
Else
$aRet = _StringSize($sButton_Text, $g_aEMB_Settings[4], Default, Default, $g_aEMB_Settings[5])
EndIf
If IsArray($aRet) And $aRet[2] + 10 > $iButton_Width_Text Then
$iButton_Width_Text = $aRet[2] + 10
EndIf
Next
If $iButton_Width_Text > $iButton_Width_Abs Then
Return SetError(5, 0, -1)
EndIf
$iButton_Width = $iButton_Width_Def
If $iButton_Width_Text > $iButton_Width_Def Then
$iButton_Width = $iButton_Width_Text
EndIf
If $iButton_Width_Abs < $iButton_Width_Def Then
If $iButton_Width_Text > $iButton_Width_Min Then
$iButton_Width = $iButton_Width_Text
Else
$iButton_Width = $iButton_Width_Min
EndIf
EndIf
$iButton_Width_Req =(($iButton_Width + 10) * $aButton_Text[0]) + 10
EndIf
Local $iExpTab = Default
If BitAND($g_aEMB_Settings[0], 8) Then
$iExpTab = 1
EndIf
While 1
Local $aLabel_Pos = _StringSize($sText, $g_aEMB_Settings[4], Default, $iExpTab, $g_aEMB_Settings[5], $iMsg_Width_Max - 20 - $iIcon_Reduction)
If @error Then
If $iMsg_Width_Max >= $iMsg_Width_Abs Then
Return SetError(6, 0, -1)
Else
$iMsg_Width_Max += 10
EndIf
Else
ExitLoop
EndIf
WEnd
$sText = $aLabel_Pos[0]
Local $iLabel_Width = $aLabel_Pos[2]
Local $iLabel_Height = $aLabel_Pos[3]
Local $iMsg_Width = $iLabel_Width + 20 + $iIcon_Reduction
If $iButton_Width_Req > $iMsg_Width Then $iMsg_Width = $iButton_Width_Req
If $iMsg_Width < $iMsg_Width_Min Then
$iMsg_Width = $iMsg_Width_Min
$iLabel_Width = $iMsg_Width_Min - 20
EndIf
Local $iDialog_Width = $iMsg_Width
Local $aTitleSize = _StringSize($sTitle, $g_aEMB_Settings[10], Default, Default, $g_aEMB_Settings[11])
If $aTitleSize[2] >($iMsg_Width - 70) Then
$iDialog_Width =(($aTitleSize[2] <($g_aEMB_Settings[7] - $g_aEMB_Settings[12])) ?($aTitleSize[2] + $g_aEMB_Settings[12]) :($g_aEMB_Settings[7]) )
EndIf
Local $iMsg_Height = $iLabel_Height + 35
If $vButton <> " " Then
$iMsg_Height += 30
EndIf
If BitAND($g_aEMB_Settings[0], 16) Then
$iMsg_Height += 40
EndIf
If $iMsg_Height < $iMsg_Height_Min Then $iMsg_Height = $iMsg_Height_Min
Local $iLabel_Vert = 20
If StringInStr($sText, @CRLF) = 0 Then $iLabel_Vert = 27
If Mod($g_aEMB_Settings[0], 2) = 1 Then
If IsHWnd($hWin) Then
$iParent_Win = $hWin
Else
$iParent_Win = WinGetHandle(AutoItWinGetTitle())
EndIf
EndIf
If $hWin = "" Then
$iHpos =(@DesktopWidth - $iDialog_Width) / 2
$iVPos =(@DesktopHeight - $iMsg_Height) / 2
Else
If IsHWnd($hWin) Then
If BitAND(WinGetState($hWin), 2) Then
Local $aPos = WinGetPos($hWin)
$iHpos =($aPos[2] - $iDialog_Width) / 2 + $aPos[0] - 3
$iVPos =($aPos[3] - $iMsg_Height) / 2 + $aPos[1] - 20
Else
$iHpos =(@DesktopWidth - $iDialog_Width) / 2
$iVPos =(@DesktopHeight - $iMsg_Height) / 2
EndIf
Else
$iHpos = $hWin
EndIf
EndIf
If $bMain Then
If $iHpos < 10 Then $iHpos = 10
If $iHpos + $iDialog_Width > @DesktopWidth - 20 Then $iHpos = @DesktopWidth - 20 - $iDialog_Width
If $iVPos < 10 Then $iVPos = 10
If $iVPos + $iMsg_Height > @DesktopHeight - 60 Then $iVPos = @DesktopHeight - 60 - $iMsg_Height
EndIf
Local $iExtStyle = 0x00000008
If BitAND($g_aEMB_Settings[0], 2) Then $iExtStyle = -1
Local $hMsgGUI = _GUICreate($sTitle, $iDialog_Width, $iMsg_Height, $iHpos, $iVPos, BitOR(0x80880000, 0x00C00000), $iExtStyle, $iParent_Win)
If @error Then
Return SetError(7, 0, -1)
EndIf
If BitAND($g_aEMB_Settings[0], 32) Then
If @Compiled Then
GUISetIcon(@ScriptName, -2, $hMsgGUI)
Else
GUISetIcon(@AutoItExe, -2, $hMsgGUI)
EndIf
EndIf
If $g_aEMB_Settings[2] <> Default Then GUISetBkColor($g_aEMB_Settings[2])
If BitAND($g_aEMB_Settings[0], 64) Then
$aRet = DllCall("User32.dll", "hwnd", "GetSystemMenu", "hwnd", $hMsgGUI, "int", 0)
Local $hSysMenu = $aRet[0]
DllCall("User32.dll", "int", "RemoveMenu", "hwnd", $hSysMenu, "int", 0xF060, "int", 0)
DllCall("User32.dll", "int", "DrawMenuBar", "hwnd", $hMsgGUI)
EndIf
Local $iLabel_Style = 0
If BitAND($g_aEMB_Settings[1], 1) = 1 Then
$iLabel_Style = 1
ElseIf BitAND($g_aEMB_Settings[1], 2) = 2 Then
$iLabel_Style = 2
EndIf
GUICtrlCreateLabel($sText, 10 + $iIcon_Reduction, $iLabel_Vert, $iLabel_Width, $iLabel_Height, $iLabel_Style)
GUICtrlSetFont(-1, $g_aEMB_Settings[4], Default, Default, $g_aEMB_Settings[5])
If $g_aEMB_Settings[3] <> Default Then GUICtrlSetColor(-1, $g_aEMB_Settings[3])
If BitAND($g_aEMB_Settings[0], 16) Then
Local $sAgain = " Do not show again"
Local $iY = $iLabel_Vert + $iLabel_Height + 10
$cCheckbox = GUICtrlCreateCheckbox("", 10 + $iIcon_Reduction, $iY, 20, 20)
Local $cCheckLabel = GUICtrlCreateLabel($sAgain, 20, 20, 20, 20)
GUICtrlSetColor($cCheckLabel, $g_aEMB_Settings[3])
GUICtrlSetBkColor($cCheckLabel, $g_aEMB_Settings[2])
If BitAND($g_aEMB_Settings[0], 4) Then
$aLabel_Size = _StringSize($sAgain)
Else
$aLabel_Size = _StringSize($sAgain, $g_aEMB_Settings[4], 400, 0, $g_aEMB_Settings[5])
GUICtrlSetFont($cCheckLabel, $g_aEMB_Settings[4], 400, 0, $g_aEMB_Settings[5])
EndIf
$iY =($iY + 10) -($aLabel_Size[3] - 4) / 2
ControlMove($hMsgGUI, "", $cCheckLabel, 30 + $iIcon_Reduction, $iY, $iMsg_Width -(30 + $iIcon_Reduction), $aLabel_Size[3])
EndIf
If $fCountdown = True Then
Local $cCountdown_Label = GUICtrlCreateLabel(StringFormat("%2s", $iTimeOut), 10, 20, 32, 32)
GUICtrlSetFont(-1, 18, Default, Default, $g_aEMB_Settings[5])
GUICtrlSetColor(-1, $g_aEMB_Settings[3])
Else
If $iIcon_Reduction Then _GUICtrlCreateIcon($sDLL, $iIcon_Style, 10, 20)
EndIf
Local $aButtonCID[$aButton_Text[0] + 1] = [9999]
If $vButton <> " " Then
$aButtonCID[0] = GUICtrlCreateDummy()
Local $aAccel_Key[1][2] = [["{SPACE}", $aButtonCID[0]]]
GUISetAccelerators($aAccel_Key)
If $aButton_Text[0] = 1 Then
If BitAND($g_aEMB_Settings[1], 4) = 4 Then
$iButton_Xpos =($iMsg_Width - $iButton_Width) / 2
Else
$iButton_Xpos = $iMsg_Width - $iButton_Width - 10
EndIf
Else
$iButton_Xpos =($iMsg_Width -($iButton_Width_Req - 20)) / 2
EndIf
Local $iDefButton_Code = 0
Local $iDef_Button_Style = 0
For $i = 0 To $aButton_Text[0] - 1
Local $iButton_Text = $aButton_Text[$i + 1]
If $aButton_Text[0] = 1 Then
$iDef_Button_Style = 0x0001
ElseIf StringLeft($iButton_Text, 1) = "&" Then
$iDef_Button_Style = 0x0001
$aButton_Text[$i + 1] = StringTrimLeft($iButton_Text, 1)
$iDefButton_Code = $i + 1
EndIf
$aButtonCID[$i + 1] = GUICtrlCreateButton($aButton_Text[$i + 1], $iButton_Xpos +($i *($iButton_Width + 10)), $iMsg_Height - 35, $iButton_Width, 25, $iDef_Button_Style)
If Not BitAND($g_aEMB_Settings[0], 4) Then GUICtrlSetFont(-1, $g_aEMB_Settings[4], 400, 0, $g_aEMB_Settings[5])
$iDef_Button_Style = 0
Next
EndIf
GUISetState(@SW_SHOW, $hMsgGUI)
Local $iTimeout_Begin = __TimerInit()
Local $iCounter = 0
Local $aMsg
Local $iOrgMode = Opt('GUIOnEventMode', 0)
While 1
$aMsg = GUIGetMsg(1)
If $aMsg[1] = $hMsgGUI Then
Select
Case $aMsg[0] = -3
$iRet_Value = 0
ExitLoop
Case $aMsg[0] = $aButtonCID[0]
If $iDefButton_Code Then
$iRet_Value = $iDefButton_Code
ExitLoop
EndIf
Case Else
For $i = 1 To UBound($aButtonCID) - 1
If $aMsg[0] = $aButtonCID[$i] Then
$iRet_Value = $i
ExitLoop 2
EndIf
Next
EndSelect
EndIf
If __TimerDiff($iTimeout_Begin) / 1000 >= $iTimeOut And $iTimeOut > 0 Then
$iRet_Value = 9
ExitLoop
EndIf
If $fCountdown = True Then
Local $iTimeRun = Int(__TimerDiff($iTimeout_Begin) / 1000)
If $iTimeRun <> $iCounter Then
$iCounter = $iTimeRun
GUICtrlSetData($cCountdown_Label, StringFormat("%2s", $iTimeOut - $iCounter))
EndIf
EndIf
WEnd
Opt('GUIOnEventMode', $iOrgMode)
If GUICtrlRead($cCheckbox) = 1 Then
$iRet_Value *= -1
EndIf
GUIDelete($hMsgGUI)
Return $iRet_Value
EndFunc
Func __EMB_GetDefaultFont()
Local $aDefFontData[2] = [9, "Tahoma"]
Local $hWnd = WinGetHandle(AutoItWinGetTitle())
Local $hThemeDLL = DllOpen("uxtheme.dll")
Local $hTheme = DllCall($hThemeDLL, 'ptr', 'OpenThemeData', 'hwnd', $hWnd, 'wstr', "Static")
If @error Then Return $aDefFontData
$hTheme = $hTheme[0]
Local $tFont = DllStructCreate("long;long;long;long;long;byte;byte;byte;byte;byte;byte;byte;byte;wchar[32]")
Local $pFont = DllStructGetPtr($tFont)
DllCall($hThemeDLL, 'long', 'GetThemeSysFont', 'HANDLE', $hTheme, 'int', 805, 'ptr', $pFont)
If @error Then
$tFont = 0
Return $aDefFontData
EndIf
Local $hDC = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Then
$tFont = 0
Return $aDefFontData
EndIf
$hDC = $hDC[0]
Local $iPixel_Y = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", 90)
If Not @error Then
$iPixel_Y = $iPixel_Y[0]
$aDefFontData[0] = Int(2 *(.25 - DllStructGetData($tFont, 1) * 72 / $iPixel_Y)) / 2
EndIf
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
$aDefFontData[1] = DllStructGetData($tFont, 14)
$tFont = 0
Return $aDefFontData
EndFunc
Func MBRFunc($Start = True)
Switch $Start
Case True
$g_hLibMyBot = DllOpen($g_sLibMyBotPath)
If $g_hLibMyBot = -1 Then
SetLog($g_sMBRLib & " not found.", $COLOR_ERROR)
Return False
EndIf
SetDebugLog($g_sMBRLib & " opened.")
setProcessingPoolSize($g_iGlobalThreads)
setMaxDegreeOfParallelism($g_iThreads)
Case False
DllClose($g_hLibMyBot)
SetDebugLog($g_sMBRLib & " closed.")
EndSwitch
EndFunc
Func _DllCallMyBot($sFunc, $sType1 = Default, $vParam1 = Default, $sType2 = Default, $vParam2 = Default, $sType3 = Default, $vParam3 = Default, $sType4 = Default, $vParam4 = Default, $sType5 = Default, $vParam5 = Default , $sType6 = Default, $vParam6 = Default, $sType7 = Default, $vParam7 = Default, $sType8 = Default, $vParam8 = Default, $sType9 = Default, $vParam9 = Default, $sType10 = Default, $vParam10 = Default)
If $sType1 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc)
If $sType2 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1)
If $sType3 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2)
If $sType4 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3)
If $sType5 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4)
If $sType6 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5)
If $sType7 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6)
If $sType8 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7)
If $sType9 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8)
If $sType10 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9)
Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10)
EndFunc
Func DllCallMyBotIsActive()
Return $g_bLibMyBotActive
EndFunc
Func DllCallMyBot($sFunc, $sType1 = Default, $vParam1 = Default, $sType2 = Default, $vParam2 = Default, $sType3 = Default, $vParam3 = Default, $sType4 = Default, $vParam4 = Default, $sType5 = Default, $vParam5 = Default , $sType6 = Default, $vParam6 = Default, $sType7 = Default, $vParam7 = Default, $sType8 = Default, $vParam8 = Default, $sType9 = Default, $vParam9 = Default, $sType10 = Default, $vParam10 = Default)
$g_bLibMyBotActive = True
Local $aResult
If $g_bCloudsActive = False And((BitAND($g_iAndroidSuspendModeFlags, 1) > 0 And($g_bAttackActive Or $g_bVillageSearchActive)) Or BitAND($g_iAndroidSuspendModeFlags, 2) > 0) Then
Local $sFileOrFolder = Default
Switch $sFunc
Case "SearchMultipleTilesBetweenLevels", "FindTile", "SearchTile", "SearchMultipleTilesLevel", "SearchMultipleTiles", "RecheckTile", "DoOCR"
If StringLeft($vParam2, 1) <> "-" Then
$sFileOrFolder = $vParam2
$vParam2 = "-" & _Base64Encode(StringToBinary($vParam2, 4), 1024)
EndIf
EndSwitch
If $g_bDebugBetaVersion And $sFileOrFolder <> Default And StringInStr($sFileOrFolder, "\") And FileExists($sFileOrFolder) = 0 Then SetLog("Cannot access path: " & $sFileOrFolder, $COLOR_ERROR)
Local $bWasSuspended = SuspendAndroid()
$aResult = _DllCallMyBot($sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10)
SuspendAndroid($bWasSuspended)
Else
$aResult = _DllCallMyBot($sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10)
EndIf
$g_bLibMyBotActive = False
Return $aResult
EndFunc
Func debugMBRFunctions($iDebugSearchArea = 0, $iDebugRedArea = 0, $iDebugOcr = 0)
SetDebugLog("debugMBRFunctions: $iDebugSearchArea=" & $iDebugSearchArea & ", $iDebugRedArea=" & $iDebugRedArea & ", $giDebugOcr=" & $iDebugOcr)
Local $activeHWnD = WinGetHandle("")
Local $result = DllCall($g_hLibMyBot, "str", "setGlobalVar", "int", $iDebugSearchArea, "int", $iDebugRedArea, "int", $iDebugOcr)
If @error Then
_logErrorDLLCall($g_sLibMyBotPath & ", setGlobalVar:", @error)
Return SetError(@error)
EndIf
If IsArray($result) Then
If $g_bDebugSetlog And $result[0] = -1 Then SetLog($g_sMBRLib & " error setting Global vars.", $COLOR_DEBUG)
Else
SetDebugLog($g_sMBRLib & " not found.", $COLOR_ERROR)
EndIf
WinActivate($activeHWnD)
EndFunc
Func setAndroidPID($pid = GetAndroidPid())
If $g_hLibMyBot = -1 Then Return
SetDebugLog("setAndroidPID: $pid=" & $pid)
Local $result = DllCall($g_hLibMyBot, "str", "setAndroidPID", "int", $pid)
If @error Then
_logErrorDLLCall($g_sLibMyBotPath & ", setAndroidPID:", @error)
Return SetError(@error)
EndIf
If IsArray($result) Then
If $result[0] = "" Then
SetDebugLog($g_sMBRLib & " error setting Android PID.")
Else
SetDebugLog("Android PID=" & $pid & " initialized: " & $result[0])
debugMBRFunctions(0, $g_bDebugRedArea ? 1 : 0, $g_bDebugOcr ? 1 : 0)
EndIf
Else
SetDebugLog($g_sMBRLib & " not found.", $COLOR_ERROR)
EndIf
EndFunc
Func SetBotGuiPID($pid = $g_iGuiPID)
If $g_hLibMyBot = -1 Then Return
SetDebugLog("SetBotGuiPID: $pid=" & $pid)
Local $result = DllCall($g_hLibMyBot, "str", "SetBotGuiPID", "int", $pid)
If @error Then
_logErrorDLLCall($g_sLibMyBotPath & ", SetBotGuiPID:", @error)
Return SetError(@error)
EndIf
If IsArray($result) Then
If $result[0] = "" Then
SetDebugLog($g_sMBRLib & " error setting Android PID.")
Else
SetDebugLog("Bot GUI PID=" & $pid & " initialized: " & $result[0])
EndIf
Else
SetDebugLog($g_sMBRLib & " not found.", $COLOR_ERROR)
EndIf
EndFunc
Func setVillageOffset($x, $y, $z)
DllCall($g_hLibMyBot, "str", "setVillageOffset", "int", $x, "int", $y, "float", $z)
$g_iVILLAGE_OFFSET[0] = $x
$g_iVILLAGE_OFFSET[1] = $y
$g_iVILLAGE_OFFSET[2] = $z
EndFunc
Func setMaxDegreeOfParallelism($iMaxDegreeOfParallelism = 0)
Local $i = Int($iMaxDegreeOfParallelism)
If $i < 1 Then $i = 0
SetDebugLog("Threading: Using " & $i & " threads for parallelism")
If $i < 1 Then $i = -1
DllCall($g_hLibMyBot, "none", "setMaxDegreeOfParallelism", "int", $i)
EndFunc
Func setProcessingPoolSize($iProcessingPoolSize = 0)
Local $i = Int($iProcessingPoolSize)
If $i < 1 Then $i = 0
SetDebugLog("Threading: Using " & $i & " threads shared across all bot instances")
If $i < 1 Then $i = -1
DllCall($g_hLibMyBot, "none", "setProcessingPoolSize", "int", $i)
EndFunc
Func ConvertVillagePos(ByRef $x, ByRef $y, $zoomfactor = 0)
If $g_hLibMyBot = -1 Then Return
Local $result = DllCall($g_hLibMyBot, "str", "ConvertVillagePos", "int", $x, "int", $y, "float", $zoomfactor)
If IsArray($result) = False Then
If $g_bDebugSetlog Then SetDebugLog("ConvertVillagePos result error", $COLOR_ERROR)
Return
EndIf
Local $a = StringSplit($result[0], "|")
If UBound($a) < 3 Then Return
$x = Int($a[1])
$y = Int($a[2])
EndFunc
Func ConvertToVillagePos(ByRef $x, ByRef $y, $zoomfactor = 0)
If $g_hLibMyBot = -1 Then Return
Local $result = DllCall($g_hLibMyBot, "str", "ConvertToVillagePos", "int", $x, "int", $y, "float", $zoomfactor)
If IsArray($result) = False Then
If $g_bDebugSetlog Then SetDebugLog("ConvertToVillagePos result error", $COLOR_ERROR)
Return
EndIf
Local $a = StringSplit($result[0], "|")
If UBound($a) < 3 Then Return
$x = Int($a[1])
$y = Int($a[2])
EndFunc
Func ConvertFromVillagePos(ByRef $x, ByRef $y)
If $g_hLibMyBot = -1 Then Return
Local $result = DllCall($g_hLibMyBot, "str", "ConvertFromVillagePos", "int", $x, "int", $y)
If IsArray($result) = False Then
If $g_bDebugSetlog Then SetDebugLog("ConvertVillagePos result error", $COLOR_ERROR)
Return
EndIf
Local $a = StringSplit($result[0], "|")
If UBound($a) < 3 Then Return
$x = Int($a[1])
$y = Int($a[2])
EndFunc
Func ReduceBotMemory($bDisposeCaptures = True)
If $bDisposeCaptures = True Then _CaptureDispose()
If $g_iEmptyWorkingSetBot > 0 Then _WinAPI_EmptyWorkingSet(@AutoItPID)
EndFunc
Global Const $g_sAdbScriptsPath = $g_sLibPath & "\adb.scripts"
Global $g_sAndroidAdbPrompt = "mybot.run:"
Global $g_bAndroidAdbPromptUseGiven = True
Global $g_iAndroidCoCPid = 0
Global $g_iAndroidAdbProcess = [0, 0, 0, 0, 0]
Global $g_aiAndroidAdbClicks[1] = [-1]
Global $g_aiAndroidAdbStatsTotal[2][2] = [ [0, 0], [0, 0] ]
Global $g_aiAndroidAdbStatsLast[2][12]
$g_aiAndroidAdbStatsLast[0][0] = 0
$g_aiAndroidAdbStatsLast[0][1] = -1
$g_aiAndroidAdbStatsLast[1][0] = 0
$g_aiAndroidAdbStatsLast[1][1] = -1
Global $g_bWinGetAndroidHandleActive = False
Global $g_bAndroidSuspended = False
Global $g_bAndroidQueueReboot = False
Global $g_iAndroidSuspendedTimer = 0
Global $g_iSuspendAndroidTime = 0
Global $g_iSuspendAndroidTimeCount = 0
Global $g_hSuspendAndroidTimer = 0
Global $g_aiMouseOffset = [0, 0]
Global $g_aiMouseOffsetWindowOnly = [0, 0]
Global $g_bPullPushSharedPrefsAbdCommand = False
Global $g_PushedSharedPrefsProfile = ""
Global $g_PushedSharedPrefsProfile_Timer = 0
Func InitAndroidConfig($bRestart = False)
FuncEnter(InitAndroidConfig)
If $bRestart = False Then
$g_sAndroidEmulator = $g_avAndroidAppConfig[$g_iAndroidConfig][0]
$g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1]
$g_sAndroidTitle = $g_avAndroidAppConfig[$g_iAndroidConfig][2]
EndIf
$g_sAppClassInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][3]
$g_sAppPaneName = $g_avAndroidAppConfig[$g_iAndroidConfig][4]
$g_iAndroidClientWidth = $g_avAndroidAppConfig[$g_iAndroidConfig][5]
$g_iAndroidClientHeight = $g_avAndroidAppConfig[$g_iAndroidConfig][6]
$g_iAndroidWindowWidth = $g_avAndroidAppConfig[$g_iAndroidConfig][7]
$g_iAndroidWindowHeight = $g_avAndroidAppConfig[$g_iAndroidConfig][8]
$g_iAndroidAdbSuCommand = ""
$g_sAndroidAdbDevice = $g_avAndroidAppConfig[$g_iAndroidConfig][10]
$g_iAndroidSupportFeature = $g_avAndroidAppConfig[$g_iAndroidConfig][11]
$g_sAndroidShellPrompt = $g_avAndroidAppConfig[$g_iAndroidConfig][12]
$g_sAndroidMouseDevice = $g_avAndroidAppConfig[$g_iAndroidConfig][13]
$g_iAndroidEmbedMode = $g_avAndroidAppConfig[$g_iAndroidConfig][14]
$g_iAndroidBackgroundModeDefault = $g_avAndroidAppConfig[$g_iAndroidConfig][15]
$g_bAndroidAdbScreencap = $g_bAndroidAdbScreencapEnabled = True And BitAND($g_iAndroidSupportFeature, 2) = 2
$g_bAndroidAdbClick = $g_bAndroidAdbClickEnabled = True And AndroidAdbClickSupported()
$g_bAndroidAdbInput = $g_bAndroidAdbInputEnabled = True And BitAND($g_iAndroidSupportFeature, 8) = 8
$g_bAndroidAdbInstance = $g_bAndroidAdbInstanceEnabled = True And BitAND($g_iAndroidSupportFeature, 16) = 16
$g_bAndroidAdbClickDrag = $g_bAndroidAdbClickDragEnabled = True And BitAND($g_iAndroidSupportFeature, 32) = 32
$g_bAndroidEmbed = $g_bAndroidEmbedEnabled = True And $g_iAndroidEmbedMode > -1
$g_bAndroidBackgroundLaunch = $g_bAndroidBackgroundLaunchEnabled = True
$g_bAndroidBackgroundLaunched = False
$g_bUpdateAndroidWindowTitle = False
If $g_bAndroidAdbScreencap Then
UpdateChkBackground()
EndIf
UpdateHWnD($g_hAndroidWindow, False)
FuncReturn()
EndFunc
Func AndroidSupportFeaturesSet($iValue, $iIdx = $g_iAndroidConfig)
$g_avAndroidAppConfig[$iIdx][11] = BitOR($g_avAndroidAppConfig[$iIdx][11], $iValue)
$g_iAndroidSupportFeature = BitOR($g_iAndroidSupportFeature, $iValue)
EndFunc
Func AndroidSupportFeaturesRemove($iValue, $iIdx = $g_iAndroidConfig)
$g_avAndroidAppConfig[$iIdx][11] = BitAND($g_avAndroidAppConfig[$iIdx][11], BitXOR(-1, $iValue))
$g_iAndroidSupportFeature = BitAND($g_iAndroidSupportFeature, BitXOR(-1, $iValue))
EndFunc
Func AndroidMakeDpiAware()
Return BitAND($g_iAndroidSupportFeature, 64) > 0 And $g_bAndroidAdbScreencap = False
EndFunc
Func CleanSecureFiles($iAgeInUTCSeconds = 600)
If $g_sAndroidPicturesHostPath = "" Then Return
Local $aFiles = _FileListToArray($g_sAndroidPicturesHostPath, "*", $FLTA_FILES)
If @error Then Return
For $i = 1 To $aFiles[0]
If StringRegExp($aFiles[$i], "[0-9A-F]{40}") = 1 Then
Local $aTime = FileGetTime($g_sAndroidPicturesHostPath & $aFiles[$i], $FT_CREATED)
If UBound($aTime) < 6 Then ContinueLoop
Local $tTime = _Date_Time_EncodeFileTime($aTime[1], $aTime[2], $aTime[0], $aTime[3], $aTime[4], $aTime[5])
Local $tLocal = _Date_Time_LocalFileTimeToFileTime($tTime)
Local $lo = DllStructGetData($tLocal, "Lo")
Local $hi = DllStructGetData($tLocal, "Hi")
Local $iCreated = $hi * 0x100000000 + $lo
$tTime = _Date_Time_EncodeFileTime(@MON, @MDAY, @YEAR, @HOUR, @MIN, @SEC)
$tLocal = _Date_Time_LocalFileTimeToFileTime($tTime)
$lo = DllStructGetData($tLocal, "Lo")
$hi = DllStructGetData($tLocal, "Hi")
Local $iNow = $hi * 0x100000000 + $lo
If $iCreated + $iAgeInUTCSeconds * 1000 < $iNow Then
FileDelete($g_sAndroidPicturesHostPath & $aFiles[$i])
EndIf
EndIf
Next
EndFunc
Func GetSecureFilename($Filename)
If BitAND($g_iAndroidSecureFlags, 1) = 0 Then
Return $Filename
EndIf
Return StringMid(_Crypt_HashData($Filename, $CALG_SHA1), 3)
EndFunc
Func UpdateAndroidConfig($instance = Default, $emulator = Default)
FuncEnter(UpdateAndroidConfig)
If $emulator <> Default Then
For $i = 0 To UBound($g_avAndroidAppConfig) - 1
If $g_avAndroidAppConfig[$i][0] = $emulator Then
If $g_iAndroidConfig <> $i Then
$g_iAndroidConfig = $i
$g_sAndroidEmulator = $g_avAndroidAppConfig[$g_iAndroidConfig][0]
SetLog("Android Emulator " & $g_sAndroidEmulator)
EndIf
$emulator = Default
ExitLoop
EndIf
Next
EndIf
If $emulator <> Default Then SetLog("Unknown Android Emulator " & $emulator, $COLOR_RED)
If $instance = "" Then $instance = Default
If $instance = Default Then $instance = $g_avAndroidAppConfig[$g_iAndroidConfig][1]
SetDebugLog("UpdateAndroidConfig(""" & $instance & """)")
InitAndroidConfig(False)
$g_sAndroidInstance = $instance
If BitAND($g_iAndroidSecureFlags, 1) = 1 Then
$g_sAndroidPicturesHostFolder = ""
Else
$g_sAndroidPicturesHostFolder = "mybot.run\"
EndIf
Local $Result = InitAndroid(False, False)
SetDebugLog("UpdateAndroidConfig(""" & $instance & """) END")
Return FuncReturn($Result)
EndFunc
Func UpdateAndroidWindowState()
Local $bChanged = Execute("Update" & $g_sAndroidEmulator & "WindowState()")
If $bChanged = "" And @error <> 0 Then Return False
Return $bChanged
EndFunc
Func GetAndroidControlClass($bCheck = False, $bInit = False)
If $bInit = False And($bCheck = False Or IsString($g_sAppClassInstance) Or IsHWnd($g_sAppClassInstance)) Then Return SetError(0, 0, $g_sAppClassInstance)
$g_hAndroidControl = 0
$g_sAppClassInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][3]
Local $hAndroidWin = GetCurrentAndroidHWnD()
If IsHWnd($hAndroidWin) Then
Local $hCtrl = ControlGetHandle2($hAndroidWin, $g_sAppPaneName, $g_sAppClassInstance, 100, 100)
If $hCtrl = 0 Then
Return SetError(1, 0, $g_sAppClassInstance)
EndIf
Local $AppClass = $g_sControlGetHandle2_Classname
If BitAND($g_iAndroidSupportFeature, 256) > 0 Then $AppClass = $hCtrl
If $g_sAppClassInstance <> $AppClass Then
SetDebugLog("Update $g_sAppClassInstance to: " & $AppClass)
EndIf
$g_sAppClassInstance = $AppClass
Local $hWinParent = __WinAPI_GetParent($hCtrl)
If $hWinParent = 0 Then
$g_sAppClassInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][3]
Return SetError(1, 0, $g_sAppClassInstance)
EndIf
$g_hAndroidControl = $hWinParent
Return SetError(0, 0, $g_sAppClassInstance)
EndIf
Return SetError(0, 0, $g_sAppClassInstance)
EndFunc
Func UpdateHWnD($hWin, $bRestart = True)
FuncEnter(UpdateHWnD)
If $hWin = 0 Then
If $g_hAndroidWindow <> 0 And $bRestart Then
$g_bRestart = True
EndIf
$g_hAndroidWindow = 0
GetAndroidControlClass(True, True)
ResetAndroidProcess()
InitAndroidRebootCondition(False)
Return FuncReturn(False)
EndIf
If $g_hAndroidWindow <> 0 And $bRestart Then
$g_bRestart = True
EndIf
If $g_iAndroidProcessAffinityMask Then
Local $pid = WinGetProcess($hWin)
Local $ai_Handle = _WinAPI_OpenProcess($PROCESS_ALL_ACCESS, False, $pid)
If $ai_Handle Then
_WinAPI_SetProcessAffinityMask($ai_Handle, $g_iAndroidProcessAffinityMask)
EndIf
EndIf
$g_hAndroidWindow = $hWin
CheckDpiAwareness()
InitAndroidTimeLag()
ResetAndroidProcess()
GetAndroidControlClass(True, True)
If @error Then Return FuncReturn(SetError(1, 0, False))
Return FuncReturn(SetError(0, 0, True))
EndFunc
Func WinGetAndroidHandle($bInitAndroid = Default, $bTestPid = False)
FuncEnter(WinGetAndroidHandle)
If $bInitAndroid = Default Then $bInitAndroid = $g_bInitAndroidActive = False
If $g_bWinGetAndroidHandleActive = True Then
Return FuncReturn($g_hAndroidWindow)
EndIf
$g_bWinGetAndroidHandleActive = True
Local $currHWnD = $g_hAndroidWindow
If $g_hAndroidWindow = 0 Or $g_bAndroidBackgroundLaunched = False Then _WinGetAndroidHandle()
If IsHWnd($g_hAndroidWindow) = 1 Then
Local $aPos = WinGetPos($g_hAndroidWindow)
If IsArray($aPos) Then
If $g_bAndroidEmbedded = False And _CheckWindowVisibility($g_hAndroidWindow, $aPos) Then
SetDebugLog("Android Window '" & $g_sAndroidTitle & "' not visible, moving to position: " & $aPos[0] & ", " & $aPos[1])
WinMove($g_hAndroidWindow, "", $aPos[0], $aPos[1])
$aPos = WinGetPos($g_hAndroidWindow)
EndIf
EndIf
AndroidQueueReboot(False)
If($g_iAndroidPosX = $g_WIN_POS_DEFAULT Or $g_iAndroidPosY = $g_WIN_POS_DEFAULT) And UBound($aPos) > 1 Then
$g_iAndroidPosX = $aPos[0]
$g_iAndroidPosY = $aPos[1]
EndIf
If $currHWnD = 0 Or $currHWnD <> $g_hAndroidWindow Then
If $g_bAndroidEmbedded = False And IsArray($aPos) = 1 And($g_bIsHidden = False Or($aPos[0] > -30000 Or $aPos[1] > -30000)) Then
SetDebugLog("Move Android Window '" & $g_sAndroidTitle & "' to position: " & $g_iAndroidPosX & ", " & $g_iAndroidPosY)
HideAndroidWindow(False, Default, Default, "WinGetAndroidHandle:1", 0)
$aPos[0] = $g_iAndroidPosX
$aPos[1] = $g_iAndroidPosY
EndIf
Local $instance =($g_sAndroidInstance = "" ? "" : " (" & $g_sAndroidInstance & ")")
SetLog($g_sAndroidEmulator & $instance & " running in window mode", $COLOR_ACTION)
If $currHWnD <> 0 And $currHWnD <> $g_hAndroidWindow Then
$g_bInitAndroid = True
If $bInitAndroid = True Then InitAndroid(True)
EndIf
EndIf
If $g_bAndroidEmbedded = False And IsArray($aPos) = 1 Then
Local $posX = $g_iAndroidPosX
Local $posY = $g_iAndroidPosY
$g_iAndroidPosX =($aPos[0] > -30000 ? $aPos[0] : $g_iAndroidPosX)
$g_iAndroidPosY =($aPos[1] > -30000 ? $aPos[1] : $g_iAndroidPosY)
If $posX <> $g_iAndroidPosX Or $posY <> $g_iAndroidPosY Then
SetDebugLog("Updating Android Window '" & $g_sAndroidTitle & "' position: " & $g_iAndroidPosX & ", " & $g_iAndroidPosY)
EndIf
If $g_bIsHidden = True And($aPos[0] > -30000 Or $aPos[1] > -30000) Then
HideAndroidWindow(True, Default, Default, "WinGetAndroidHandle:2")
EndIf
EndIf
$g_bWinGetAndroidHandleActive = False
Return FuncReturn($g_hAndroidWindow)
EndIf
If $g_bAndroidBackgroundLaunch = False And $bTestPid = False Then
$g_bWinGetAndroidHandleActive = False
Return FuncReturn($g_hAndroidWindow)
EndIf
If $g_hAndroidWindow <> 0 Then
If $g_hAndroidWindow = ProcessExists2($g_hAndroidWindow) Then
Else
Local $instance =($g_sAndroidInstance = "" ? "" : " (" & $g_sAndroidInstance & ")")
SetDebugLog($g_sAndroidEmulator & $instance & " process with PID = " & $g_hAndroidWindow & " not found")
UpdateHWnD(0)
EndIf
EndIf
If $g_hAndroidWindow = 0 Then
If $g_sAndroidProgramPath <> "" Then
Local $parameter = GetAndroidProgramParameter(False)
Local $parameter2 = GetAndroidProgramParameter(True)
Local $pid = ProcessExists2($g_sAndroidProgramPath, $parameter, 0, 0, "Is" & $g_sAndroidEmulator & "CommandLine")
If $pid = 0 And $parameter <> $parameter2 Then
$parameter = $parameter2
$pid = ProcessExists2($g_sAndroidProgramPath, $parameter, 0, 0, "Is" & $g_sAndroidEmulator & "CommandLine")
EndIf
Local $commandLine = $g_sAndroidProgramPath &($parameter = "" ? "" : " " & $parameter)
Local $instance =($g_sAndroidInstance = "" ? "" : " (" & $g_sAndroidInstance & ")")
If $pid <> 0 Then
SetDebugLog("Found " & $g_sAndroidEmulator & $instance & " process " & $pid & " ('" & $commandLine & "')")
If $bTestPid = True Then
$g_bWinGetAndroidHandleActive = False
Return FuncReturn($pid)
EndIf
If $g_bAndroidAdbScreencap = True And $g_bAndroidAdbClick = False And AndroidAdbClickSupported() = True Then
SetLog("Enabled ADB Click to support background mode", $COLOR_ACTION)
$g_bAndroidAdbClick = True
EndIf
If $g_bAndroidAdbClick = False Or $g_bAndroidAdbScreencap = False Then
If $g_bAndroidQueueReboot = False Then
SetLog("Headless Android not supported because", $COLOR_ERROR)
Local $reason = ""
If $g_bAndroidAdbClick = False Then $reason &= "ADB Click " &($g_bAndroidAdbScreencap = False ? "and " : "")
If $g_bAndroidAdbScreencap = False Then $reason &= "ADB Screencap "
$reason &= "not available!"
SetLog($reason, $COLOR_ERROR)
AndroidQueueReboot(True)
EndIf
UpdateHWnD($pid)
If $currHWnD <> 0 And $currHWnD <> $g_hAndroidWindow Then
$g_bInitAndroid = True
If $bInitAndroid = True Then InitAndroid(True)
EndIf
Else
SetLog($g_sAndroidEmulator & $instance & " running in headless mode", $COLOR_ACTION)
UpdateHWnD($pid)
If $currHWnD <> 0 And $currHWnD <> $g_hAndroidWindow Then
$g_bInitAndroid = True
If $bInitAndroid = True Then InitAndroid(True)
EndIf
$g_bAndroidBackgroundLaunched = True
EndIf
setAndroidPID($pid)
Else
SetDebugLog($g_sAndroidEmulator & $instance & " process not found")
EndIf
EndIf
EndIf
If $g_hAndroidWindow = 0 Then
$g_bInitAndroid = True
$g_bAndroidBackgroundLaunched = False
EndIf
$g_bWinGetAndroidHandleActive = False
Return FuncReturn($g_hAndroidWindow)
EndFunc
Func GetAndroidPid()
Local $h = WinGetAndroidHandle(Default, True)
If IsHWnd($h) Then Return WinGetProcess($h)
Return $h
EndFunc
Func _WinGetAndroidHandle($bFindByTitle = False)
Local $hWin = WinGetHandle($g_hAndroidWindow)
If $hWin > 0 And $hWin = $g_hAndroidWindow Then Return $g_hAndroidWindow
If $g_sAppClassInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][3] Then
SetDebugLog("Restore $g_sAppClassInstance to: " & $g_avAndroidAppConfig[$g_iAndroidConfig][3])
EndIf
$g_sAppClassInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][3]
Local $i
Local $t
Local $ReInitAndroid = $g_hAndroidWindow <> 0
SetDebugLog("Searching " & $g_sAndroidEmulator & " Window: Title = '" & $g_sAndroidTitle & "', Class = '" & $g_sAppClassInstance & "', Text = '" & $g_sAppPaneName & "'")
Local $aWinList
If $bFindByTitle = True Then
$aWinList = WinList($g_sAndroidTitle)
If $aWinList[0][0] > 0 Then
For $i = 1 To $aWinList[0][0]
$hWin = $aWinList[$i][1]
$t = $aWinList[$i][0]
If $g_sAndroidTitle = $t Then
Local $hCtrl = ControlGetHandle2($hWin, $g_sAppPaneName, $g_sAppClassInstance)
If $hCtrl <> 0 Then
SetDebugLog("Found " & $g_sAndroidEmulator & " Window '" & $t & "' (" & $hWin & ") by matching title '" & $g_sAndroidTitle & "' (#1)")
UpdateHWnD($hWin)
$g_sAndroidTitle = UpdateAndroidWindowTitle($g_hAndroidWindow, $t)
If $ReInitAndroid = True And $g_bInitAndroid = False Then
$g_bInitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
EndIf
EndIf
Next
EndIf
Local $iMode = Opt("WinTitleMatchMode", -1)
$hWin = WinGetHandle($g_sAndroidTitle)
Local $error = @error
Opt("WinTitleMatchMode", $iMode)
If $error = 0 Then
$t = WinGetTitle($hWin)
If $g_sAndroidTitle = $t And ControlGetHandle2($hWin, $g_sAppPaneName, $g_sAppClassInstance) <> 0 Then
If $g_hAndroidWindow <> $hWin Then SetDebugLog("Found " & $g_sAndroidEmulator & " Window '" & $t & "' (" & $hWin & ") by matching title '" & $g_sAndroidTitle & "' (#2)")
UpdateHWnD($hWin)
$g_sAndroidTitle = UpdateAndroidWindowTitle($g_hAndroidWindow, $t)
If $ReInitAndroid = True And $g_bInitAndroid = False Then
$g_bInitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
Else
SetDebugLog($g_sAndroidEmulator & " Window title '" & $t & "' not matching '" & $g_sAndroidTitle & "' or control")
EndIf
EndIf
$iMode = Opt("WinTitleMatchMode", -1)
$aWinList = WinList($g_sAndroidTitle)
Opt("WinTitleMatchMode", $iMode)
If $aWinList[0][0] = 0 Then
SetDebugLog($g_sAndroidEmulator & " Window not found")
If $ReInitAndroid = True Then $g_bInitAndroid = True
UpdateHWnD(0)
AndroidEmbed(False, False)
Return 0
EndIf
SetDebugLog("Found " & $aWinList[0][0] & " possible " & $g_sAndroidEmulator & " windows by title '" & $g_sAndroidTitle & "':")
For $i = 1 To $aWinList[0][0]
SetDebugLog($aWinList[$i][1] & ": " & $aWinList[$i][0])
Next
If $g_sAndroidInstance <> "" Then
For $i = 1 To $aWinList[0][0]
$t = $aWinList[$i][0]
$hWin = $aWinList[$i][1]
If StringRight($t, StringLen($g_sAndroidInstance)) = $g_sAndroidInstance And ControlGetHandle2($hWin, $g_sAppPaneName, $g_sAppClassInstance) <> 0 Then
SetDebugLog("Found " & $g_sAndroidEmulator & " Window '" & $t & "' (" & $hWin & ") for instance " & $g_sAndroidInstance)
UpdateHWnD($hWin)
$g_sAndroidTitle = UpdateAndroidWindowTitle($g_hAndroidWindow, $t)
If $ReInitAndroid = True And $g_bInitAndroid = False Then
$g_bInitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
EndIf
Next
EndIf
EndIf
If $g_sAndroidProgramPath <> "" Then
Local $parameter = GetAndroidProgramParameter(False)
Local $parameter2 = GetAndroidProgramParameter(True)
Local $pid = ProcessExists2($g_sAndroidProgramPath, $parameter, 0, 0, "Is" & $g_sAndroidEmulator & "CommandLine")
If $pid = 0 And $parameter <> $parameter2 Then
$parameter = $parameter2
$pid = ProcessExists2($g_sAndroidProgramPath, $parameter, 0, 0, "Is" & $g_sAndroidEmulator & "CommandLine")
EndIf
Local $commandLine = $g_sAndroidProgramPath &($parameter = "" ? "" : " " & $parameter)
If $pid <> 0 Then
If IsArray($aWinList) = 0 Then
Local $aWinList2 = _WinAPI_EnumProcessWindows($pid, True)
If IsArray($aWinList2) = 1 And $aWinList2[0][0] > 0 Then
Local $aWinList[$aWinList2[0][0] + 1][2]
$aWinList[0][0] = $aWinList2[0][0]
For $i = 1 To $aWinList2[0][0]
$aWinList[$i][0] = WinGetTitle($aWinList2[$i][0])
$aWinList[$i][1] = $aWinList2[$i][0]
Next
EndIf
EndIf
If IsArray($aWinList) = 1 Then
For $i = 1 To $aWinList[0][0]
$t = $aWinList[$i][0]
$hWin = $aWinList[$i][1]
If $pid = WinGetProcess($hWin) And ControlGetHandle2($hWin, $g_sAppPaneName, $g_sAppClassInstance) <> 0 Then
SetDebugLog("Found " & $g_sAndroidEmulator & " Window '" & $t & "' (" & $hWin & ") by PID " & $pid & " ('" & $commandLine & "')")
UpdateHWnD($hWin)
$g_sAndroidTitle = UpdateAndroidWindowTitle($g_hAndroidWindow, $t)
If $ReInitAndroid = True And $g_bInitAndroid = False Then
$g_bInitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
EndIf
Next
EndIf
SetDebugLog($g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : " (" & $g_sAndroidInstance & ")") & " Window not found for PID " & $pid)
EndIf
EndIf
SetDebugLog($g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : " (" & $g_sAndroidInstance & ")") & " Window not found in list")
If $ReInitAndroid = True Then $g_bInitAndroid = True
UpdateHWnD(0)
AndroidEmbed(False, False)
Return 0
EndFunc
Func UpdateAndroidWindowTitle($hWin, $t)
If $g_bUpdateAndroidWindowTitle = True And $g_sAndroidInstance <> "" And StringInStr($t, $g_sAndroidInstance) = 0 Then
$t = $g_sAndroidEmulator & " (" & $g_sAndroidInstance & ")"
_WinAPI_SetWindowText($hWin, $t)
EndIf
Return $t
EndFunc
Func AndroidControlAvailable()
If $g_bAndroidBackgroundLaunched = True Then
Return 0
EndIf
Return IsArray(GetAndroidPos(True))
EndFunc
Func GetAndroidSvcPid()
Static $iAndroidSvcPid = 0
If $iAndroidSvcPid <> 0 And $iAndroidSvcPid = ProcessExists2($iAndroidSvcPid) Then
Return $iAndroidSvcPid
EndIf
SetError(0, 0, 0)
Local $pid = Execute("Get" & $g_sAndroidEmulator & "SvcPid()")
If $pid = "" And @error <> 0 Then $pid = GetVBoxAndroidSvcPid()
If $pid <> 0 Then
SetDebugLog("Found " & $g_sAndroidEmulator & " Service PID = " & $pid)
Else
SetDebugLog("Cannot find " & $g_sAndroidEmulator & " Service PID", $COLOR_ERROR)
EndIf
$iAndroidSvcPid = $pid
Return $pid
EndFunc
Func GetVBoxAndroidSvcPid()
Local $aRegExResult = StringRegExp($__VBoxVMinfo, "UUID:\s+(.+)", $STR_REGEXPARRAYMATCH)
Local $uuid = ""
If Not @error Then $uuid = $aRegExResult[0]
If StringLen($uuid) < 32 Then
SetDebugLog("Cannot find VBox UUID", $COLOR_ERROR)
Return 0
EndIf
Local $pid = ProcessExists2("", $uuid, 1, 1)
Return $pid
EndFunc
Func GetAndroidRunningInstance($bStrictCheck = True)
FuncEnter(GetAndroidRunningInstance)
Local $runningInstance = Execute("Get" & $g_sAndroidEmulator & "RunningInstance(" & $bStrictCheck & ")")
Local $i
If $runningInstance = "" And @error <> 0 Then
Local $a[2] = [0, ""]
SetDebugLog("GetAndroidRunningInstance: Try to find """ & $g_sAndroidProgramPath & """")
Local $pids = ProcessesExist($g_sAndroidProgramPath, "", 1)
If UBound($pids) > 0 Then
Local $currentInstance = $g_sAndroidInstance
For $i = 0 To UBound($pids) - 1
Local $pid = $pids[$i]
Local $commandLine = ProcessGetCommandLine($pid)
SetDebugLog("GetAndroidRunningInstance: Found """ & $commandLine & """ by PID=" & $pid)
Local $lastSpace = StringInStr($commandLine, " ", 0, -1)
If $lastSpace > 0 Then
$g_sAndroidInstance = StringStripWS(StringMid($commandLine, $lastSpace + 1), 3)
If $g_sAndroidInstance = "" Then $g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1]
EndIf
If WinGetAndroidHandle() <> 0 Then
SetDebugLog("Running " & $g_sAndroidEmulator & " instance found: """ & $g_sAndroidInstance & """")
If $a[0] = 0 Or $g_sAndroidInstance = $currentInstance Then
$a[0] = $g_hAndroidWindow
$a[1] = $g_sAndroidInstance
If $g_sAndroidInstance = $currentInstance Then ExitLoop
EndIf
Else
$g_sAndroidInstance = $currentInstance
EndIf
Next
EndIf
If $a[0] <> 0 Then SetDebugLog("Running " & $g_sAndroidEmulator & " instance is """ & $g_sAndroidInstance & """")
Return FuncReturn($a)
EndIf
Return FuncReturn($runningInstance)
EndFunc
Func DetectRunningAndroid()
FuncEnter(DetectRunningAndroid)
$g_bFoundRunningAndroid = False
Local $i, $iCurrentConfig = $g_iAndroidConfig
$g_bSilentSetLog = True
For $i = 0 To UBound($g_avAndroidAppConfig) - 1
$g_iAndroidConfig = $i
$g_bInitAndroid = True
If UpdateAndroidConfig() = True Then
Local $aRunning = GetAndroidRunningInstance(False)
If $aRunning[0] = 0 Then
Else
$g_bFoundRunningAndroid = True
$g_bSilentSetLog = False
$g_bInitAndroid = True
If InitAndroid() = True Then
SetDebugLog("Found running " & $g_sAndroidEmulator & " " & $g_sAndroidVersion)
EndIf
Return FuncReturn()
EndIf
EndIf
Next
$g_bInitAndroid = True
$g_iAndroidConfig = $iCurrentConfig
UpdateAndroidConfig()
$g_bSilentSetLog = False
SetDebugLog("Found no running Android Emulator")
FuncReturn()
EndFunc
Func DetectInstalledAndroid()
FuncEnter(DetectInstalledAndroid)
Local $i, $CurrentConfig = $g_iAndroidConfig
$g_bSilentSetLog = True
For $i = 0 To UBound($g_avAndroidAppConfig) - 1
$g_iAndroidConfig = $i
$g_bInitAndroid = True
If UpdateAndroidConfig() Then
$g_bFoundInstalledAndroid = True
$g_bSilentSetLog = False
SetDebugLog("Found installed " & $g_sAndroidEmulator & " " & $g_sAndroidVersion)
Return FuncReturn()
EndIf
Next
$g_iAndroidConfig = $CurrentConfig
$g_bInitAndroid = True
UpdateAndroidConfig()
$g_bSilentSetLog = False
SetDebugLog("Found no installed Android Emulator")
FuncReturn()
EndFunc
Func FindPreferredAdbPath()
Local $adbPath, $i
If FileExists($g_sAndroidAdbPath) Then
Return $g_sAndroidAdbPath
EndIf
$adbPath = Execute("Get" & $g_sAndroidEmulator & "AdbPath()")
If $adbPath = "" Then
For $i = 0 To UBound($g_avAndroidAppConfig) - 1
$adbPath = Execute("Get" & $g_avAndroidAppConfig[$i][0] & "AdbPath()")
If $adbPath <> "" Then ExitLoop
Next
EndIf
If $adbPath <> "" Then
SaveProfileConfigAdbPath(Default, $adbPath)
EndIf
Return $adbPath
EndFunc
Func CompareAndUpdate(ByRef $UpdateWhenDifferent, Const $New)
Local $bDifferent = $UpdateWhenDifferent <> $New
If $bDifferent Then $UpdateWhenDifferent = $New
Return $bDifferent
EndFunc
Func IncrUpdate(ByRef $i, $ReturnInitial = True)
Local $i2 = $i
$i += 1
If $ReturnInitial Then Return $i2
Return $i
EndFunc
Func InitAndroid($bCheckOnly = False, $bLogChangesOnly = True)
FuncEnter(InitAndroid)
If $bCheckOnly = False And $g_bInitAndroid = False Then
Return FuncReturn(True)
EndIf
$g_bAndroidInitialized = False
$g_bInitAndroidActive = True
Local $aPriorValues = [ $g_sAndroidEmulator , $g_iAndroidConfig , $g_sAndroidVersion , $g_sAndroidInstance , $g_sAndroidTitle , $g_sAndroidProgramPath , GetAndroidProgramParameter() ,((IsArray($g_avAndroidProgramFileVersionInfo) ? _ArrayToString($g_avAndroidProgramFileVersionInfo, ",", 1) : "not available")) , $g_iAndroidSecureFlags , $g_sAndroidAdbPath , $__VBoxManage_Path , $g_sAndroidAdbDevice , $g_sAndroidPicturesPath , $g_sAndroidPicturesHostPath , $g_sAndroidPicturesHostFolder , $g_sAndroidMouseDevice , $g_bAndroidAdbScreencap , $g_bAndroidAdbInput , $g_bAndroidAdbClick , $g_bAndroidAdbClickDrag ,($g_bChkBackgroundMode = True ? "enabled" : "disabled") , $g_bNoFocusTampering ]
SetDebugLog("InitAndroid(" & $bCheckOnly & "): " & $g_sAndroidEmulator)
If Not $bCheckOnly Then
If $g_sAndroidInstance = "" Then $g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1]
$__VBoxGuestProperties = ""
$__VBoxExtraData = ""
EndIf
Local $Result = Execute("Init" & $g_sAndroidEmulator & "(" & $bCheckOnly & ")")
If $Result = "" And @error <> 0 Then
SetLog("Android support for " & $g_sAndroidEmulator & " is not available", $COLOR_ERROR)
EndIf
Local $successful = @error = 0, $process_killed
If Not $bCheckOnly And $Result Then
If $b_sAndroidProgramWerFaultExcluded = True Then
Local $sFileOnly = StringMid($g_sAndroidProgramPath, StringInStr($g_sAndroidProgramPath, "\", 0, -1) + 1)
Local $aResult = DllCall("Wer.dll", "int", "WerAddExcludedApplication", "wstr", $sFileOnly, "bool", True)
If(UBound($aResult) > 0 And $aResult[0] = $S_OK) Or RegWrite($g_sHKLM & "\Software\Microsoft\Windows\Windows Error Reporting\ExcludedApplications", $sFileOnly, "REG_DWORD", "1") = 1 Then
SetDebugLog("Disabled WerFault for " & $sFileOnly)
Else
SetDebugLog("Cannot disable WerFault for " & $sFileOnly)
EndIf
EndIf
If FileExists($__VBoxManage_Path) Then
If $__VBoxGuestProperties = "" Then $__VBoxGuestProperties = LaunchConsole($__VBoxManage_Path, "guestproperty enumerate " & $g_sAndroidInstance, $process_killed)
If $__VBoxExtraData = "" Then $__VBoxExtraData = LaunchConsole($__VBoxManage_Path, "getextradata " & $g_sAndroidInstance & " enumerate", $process_killed)
EndIf
UpdateAndroidBackgroundMode()
Local $pAndroidFileVersionInfo
If _WinAPI_GetFileVersionInfo($g_sAndroidProgramPath, $pAndroidFileVersionInfo) Then
$g_avAndroidProgramFileVersionInfo = _WinAPI_VerQueryValue($pAndroidFileVersionInfo)
Else
$g_avAndroidProgramFileVersionInfo = 0
EndIf
Local $i = 0
Local $sText = ""
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidEmulator) Or $bLogChangesOnly = False Then SetDebugLog("Android: " & $g_sAndroidEmulator)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_iAndroidConfig) Or $bLogChangesOnly = False Then SetDebugLog("Android Config: " & $g_iAndroidConfig)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidVersion) Or $bLogChangesOnly = False Then SetDebugLog("Android Version: " & $g_sAndroidVersion)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidInstance) Or $bLogChangesOnly = False Then SetDebugLog("Android Instance: " & $g_sAndroidInstance)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidTitle) Or $bLogChangesOnly = False Then SetDebugLog("Android Window Title: " & $g_sAndroidTitle)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidProgramPath) Or $bLogChangesOnly = False Then SetDebugLog("Android Program Path: " & $g_sAndroidProgramPath)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], GetAndroidProgramParameter()) Or $bLogChangesOnly = False Then SetDebugLog("Android Program Parameter: " & GetAndroidProgramParameter())
$sText =((IsArray($g_avAndroidProgramFileVersionInfo) ? _ArrayToString($g_avAndroidProgramFileVersionInfo, ",", 1) : "not available"))
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $sText) Or $bLogChangesOnly = False Then SetDebugLog("Android Program FileVersionInfo: " & $sText)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_iAndroidSecureFlags) Or $bLogChangesOnly = False Then SetDebugLog("Android SecureME setting: " & $g_iAndroidSecureFlags)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidAdbPath) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Path: " & $g_sAndroidAdbPath)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $__VBoxManage_Path) Or $bLogChangesOnly = False Then SetDebugLog("Android VBoxManage Path: " & $__VBoxManage_Path)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidAdbDevice) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Device: " & $g_sAndroidAdbDevice)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidPicturesPath) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Shared Folder: " & $g_sAndroidPicturesPath)
If FileExists($g_sAndroidPicturesHostPath) Then
If($g_sAndroidPicturesHostFolder <> "" Or BitAND($g_iAndroidSecureFlags, 1) = 1) Then
DirCreate($g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder)
EndIf
ElseIf $g_sAndroidPicturesHostPath <> "" Then
SetLog("Shared Folder doesn't exist, please fix:", $COLOR_ERROR)
SetLog($g_sAndroidPicturesHostPath, $COLOR_ERROR)
EndIf
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidPicturesHostPath) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Shared Folder on Host: " & $g_sAndroidPicturesHostPath)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidPicturesHostFolder) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Shared SubFolder: " & $g_sAndroidPicturesHostFolder)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidMouseDevice) Or $bLogChangesOnly = False Then SetDebugLog("Android Mouse Device: " & $g_sAndroidMouseDevice)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_bAndroidAdbScreencap) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB screencap command enabled: " & $g_bAndroidAdbScreencap)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_bAndroidAdbInput) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB input command enabled: " & $g_bAndroidAdbInput)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_bAndroidAdbClick) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Mouse Click enabled: " & $g_bAndroidAdbClick)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_bAndroidAdbClickDrag) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Click Drag enabled: " & $g_bAndroidAdbClickDrag)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)],($g_bChkBackgroundMode = True ? "enabled" : "disabled")) Or $bLogChangesOnly = False Then SetDebugLog("Bot Background Mode for screen capture: " &($g_bChkBackgroundMode = True ? "enabled" : "disabled"))
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_bNoFocusTampering) Or $bLogChangesOnly = False Then SetDebugLog("No Focus Tampering: " & $g_bNoFocusTampering)
WinGetAndroidHandle()
InitAndroidTimeLag()
InitAndroidPageError()
$g_bInitAndroid = Not $successful
$g_bAndroidInitialized = True
Else
If $bCheckOnly = False Then $g_bInitAndroid = True
EndIf
SetDebugLog("InitAndroid(" & $bCheckOnly & "): " & $g_sAndroidEmulator & " END, initialization successful = " & $successful & ", result = " & $Result)
$g_bInitAndroidActive = False
Return FuncReturn($Result)
EndFunc
Func GetAndroidProgramParameter($bAlternative = False)
Local $parameter = Execute("Get" & $g_sAndroidEmulator & "ProgramParameter(" & $bAlternative & ")")
If $parameter = "" And @error <> 0 Then $parameter = ""
Return $parameter
EndFunc
Func AndroidBotStartEvent()
reHide()
CheckAndroidRebootCondition(True, True)
Local $Result = Execute($g_sAndroidEmulator & "BotStartEvent()")
If $Result = "" And @error <> 0 Then $Result = ""
Return $Result
EndFunc
Func AndroidBotStopEvent()
Local $Result = Execute($g_sAndroidEmulator & "BotStopEvent()")
If $Result = "" And @error <> 0 Then $Result = ""
Return $Result
EndFunc
Func OpenAndroid($bRestart = False, $bStartOnlyAndroid = False, $wasRunState = $g_bRunState)
FuncEnter(OpenAndroid)
Static $OpenAndroidActive = 0
If $OpenAndroidActive >= $g_iOpenAndroidActiveMaxTry Then
SetLog("Cannot open " & $g_sAndroidEmulator & ", tried " & $OpenAndroidActive & " times...", $COLOR_ERROR)
btnStop()
Return FuncReturn(False)
EndIf
$OpenAndroidActive += 1
If $OpenAndroidActive > 1 Then
SetDebugLog("Opening " & $g_sAndroidEmulator & " recursively " & $OpenAndroidActive & ". time...")
EndIf
If $bStartOnlyAndroid = True And $wasRunState = False Then $g_bRunState = True
Local $Result = _OpenAndroid($bRestart, $bStartOnlyAndroid)
If $bStartOnlyAndroid = True And $wasRunState = False Then $g_bRunState = False
WinGetAndroidHandle()
$OpenAndroidActive -= 1
Return FuncReturn($Result)
EndFunc
Func _OpenAndroid($bRestart = False, $bStartOnlyAndroid = False)
ResumeAndroid()
Local $hMutex = AquireAdbDaemonMutex(), $process_killed
LaunchConsole($g_sAndroidAdbPath, "devices", $process_killed)
ReleaseAdbDaemonMutex($hMutex)
If Not InitAndroid() Then
SetLog("Unable to open " & $g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : " instance '" & $g_sAndroidInstance & "'"), $COLOR_ERROR)
SetLog("Please check emulator/installation", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_ERROR)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
AndroidAdbTerminateShellInstance()
If Not $g_bRunState Then Return False
WerFaultClose($g_sAndroidProgramPath)
If $g_bAndroidBackgroundLaunch = False And WinGetAndroidHandle(Default, True) <> 0 Or GetAndroidSvcPid() <> 0 Then
CloseAndroid("_OpenAndroid")
If _Sleep(1000) Then Return False
EndIf
InitAndroidRebootCondition(False)
If Not Execute("Open" & $g_sAndroidEmulator & "(" & $bRestart & ")") Then Return False
InitAndroidRebootCondition(True)
If $bStartOnlyAndroid Then
Return True
EndIf
If Not InitiateLayout() Then Return False
WinGetAndroidHandle(False)
If Not $g_bRunState Then Return False
AndroidBotStartEvent()
If Not $g_bRunState Then Return False
If Not StartAndroidCoC() Then Return False
If $bRestart = False Then
waitMainScreenMini()
If Not $g_bRunState Then Return False
Zoomout()
Else
WaitMainScreenMini()
If Not $g_bRunState Then Return False
If @error = 1 Then
$g_bRestart = True
$g_bIsClientSyncError = False
Return False
EndIf
Zoomout()
EndIf
If Not $g_bRunState Then Return False
Return True
EndFunc
Func StartAndroidCoC()
FuncEnter(StartAndroidCoC)
Return FuncReturn(RestartAndroidCoC(False, False, False))
EndFunc
Func RestartAndroidCoC($bInitAndroid = True, $bRestart = True, $bStopCoC = True)
FuncEnter(RestartAndroidCoC)
Return FuncReturn(_RestartAndroidCoC($bInitAndroid, $bRestart, $bStopCoC))
EndFunc
Func _RestartAndroidCoC($bInitAndroid = True, $bRestart = True, $bStopCoC = True)
$g_bSkipFirstZoomout = False
ResumeAndroid()
If Not $g_bRunState Then Return False
If $bInitAndroid Then
If Not InitAndroid() Then Return False
EndIf
Local $cmdOutput, $process_killed, $connected_to
ResetAndroidProcess()
Local $sRestart = ""
If $bRestart = True Then
If $bStopCoC Then
SetLog("Please wait for CoC restart.....", $COLOR_INFO)
$sRestart = "-S "
Else
SetLog("Please wait for CoC restart....", $COLOR_INFO)
EndIf
Else
SetLog("Launch Clash of Clans now...", $COLOR_SUCCESS)
EndIf
ConnectAndroidAdb()
If Not $g_bRunState Then Return False
If Not $g_bRunState Then Return False
If $g_bChkSharedPrefs And HaveSharedPrefs() And $g_PushedSharedPrefsProfile <> $g_sProfileCurrentName And($g_PushedSharedPrefsProfile_Timer = 0 Or __TimerDiff($g_PushedSharedPrefsProfile_Timer) > 120000) Then PushSharedPrefs()
$cmdOutput = AndroidAdbSendShellCommand("set export=$(am start " & $sRestart & "-n " & $g_sAndroidGamePackage & "/" & $g_sAndroidGameClass & " >&2)", 60000)
If StringInStr($cmdOutput, "Error:") > 0 And StringInStr($cmdOutput, $g_sAndroidGamePackage) > 0 Then
SetLog("Unable to load Clash of Clans, install/reinstall the game.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
If StringInStr($cmdOutput, "Exception") > 0 Then
If Not RebootAndroid() Then Return False
EndIf
If Not IsAdbConnected($cmdOutput) Then
If Not ConnectAndroidAdb() Then Return False
EndIf
If Not $g_bRunState Then Return False
AndroidAdbLaunchShellInstance()
InitAndroidTimeLag()
Return True
EndFunc
Func ResetAndroidProcess()
$g_iAndroidCoCPid = 0
$g_bMainWindowOk = False
EndFunc
Func CloseAndroid($sSource)
FuncEnter(CloseAndroid)
ResumeAndroid()
ResetAndroidProcess()
SetLog("Stopping " & $g_sAndroidEmulator & "....", $COLOR_INFO)
SetDebugLog("CloseAndroid, caller: " & $sSource)
AndroidEmbed(False)
AndroidAdbTerminateShellInstance()
If Not $g_bRunState Then Return FuncReturn(False)
SetLog("Please wait for full " & $g_sAndroidEmulator & " shutdown...", $COLOR_SUCCESS)
Local $pid = GetAndroidPid()
If ProcessExists2($pid) Then
KillProcess($pid, "CloseAndroid")
If _SleepStatus(1000) Then Return FuncReturn(False)
EndIf
Local $Result = Execute("Close" & $g_sAndroidEmulator & "()")
If Not $g_bRunState Then Return FuncReturn(False)
If ProcessExists($pid) Then
SetLog("Failed to stop " & $g_sAndroidEmulator, $COLOR_ERROR)
Else
SetLog($g_sAndroidEmulator & " stopped successfully", $COLOR_SUCCESS)
EndIf
If Not $g_bRunState Then Return FuncReturn(False)
RemoveGhostTrayIcons()
Return FuncReturn(True)
EndFunc
Func CloseVboxAndroidSvc()
Local $process_killed
If Not $g_bRunState Then Return
LaunchConsole($__VBoxManage_Path, "controlvm " & $g_sAndroidInstance & " poweroff", $process_killed, 30000)
If _SleepStatus(3000) Then Return
EndFunc
Func CheckAndroidRunning($bQuickCheck = True, $bStartIfRequired = True, $bStartOnlyAndroid = False)
FuncEnter(CheckAndroidRunning)
Local $hWin = $g_hAndroidWindow
If WinGetAndroidHandle() = 0 Or($bQuickCheck = False And $g_bAndroidBackgroundLaunched = False And AndroidControlAvailable() = 0) Then
SetDebugLog($g_sAndroidEmulator & " not running")
If $bStartIfRequired = True Then
If $hWin = 0 Then
OpenAndroid(True, $bStartOnlyAndroid)
Else
RebootAndroid()
EndIf
EndIf
Return FuncReturn(False)
EndIf
Return FuncReturn(True)
EndFunc
Func SetScreenAndroid()
ResumeAndroid()
If Not $g_bRunState Then Return False
SetLog("Set " & $g_sAndroidEmulator & " screen resolution to " & $g_iAndroidClientWidth & " x " & $g_iAndroidClientHeight, $COLOR_INFO)
Local $Result = Execute("SetScreen" & $g_sAndroidEmulator & "()")
If $Result Then
SetLog("A restart of your computer might be required", $COLOR_ACTION)
SetLog("for the applied changes to take effect.", $COLOR_ACTION)
EndIf
Return $Result
EndFunc
Func CloseUnsupportedAndroid()
ResumeAndroid()
If Not $g_bRunState Then Return False
SetError(0, 0, 0)
Local $Closed = Execute("CloseUnsupported" & $g_sAndroidEmulator & "()")
If $Closed = "" And @error <> 0 Then Return False
Return $Closed
EndFunc
Func RebootAndroidSetScreen()
ResumeAndroid()
If Not $g_bRunState Then Return False
Return Execute("Reboot" & $g_sAndroidEmulator & "SetScreen()")
EndFunc
Func IsAdbTCP()
Return StringInStr($g_sAndroidAdbDevice, ":") > 0
EndFunc
Func WaitForRunningVMS($WaitInSec = 120, $hTimer = 0)
ResumeAndroid()
If Not $g_bRunState Then Return True
Local $cmdOutput, $connected_to, $running, $process_killed, $hMyTimer
$hMyTimer =($hTimer = 0 ? __TimerInit() : $hTimer)
While True
If Not $g_bRunState Then Return True
$cmdOutput = LaunchConsole($__VBoxManage_Path, "list runningvms", $process_killed)
If Not $g_bRunState Then Return True
$running = StringInStr($cmdOutput, """" & $g_sAndroidInstance & """") > 0
If $running = True Then ExitLoop
If $hTimer <> 0 Then _StatusUpdateTime($hTimer)
_Sleep(3000)
If __TimerDiff($hMyTimer) > $WaitInSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for boot completed", $COLOR_ERROR)
SetError(1, @extended, False)
Return True
EndIf
WEnd
Return False
EndFunc
Func FindAvaiableInstances($sVboxManage = $__VBoxManage_Path)
Local $a = []
If FileExists($sVboxManage) = 0 Then
If $g_bDebugAndroid Then SetDebugLog("Cannot check for available " & $g_sAndroidEmulator & " instances: VBoxManager.exe not available", $COLOR_ERROR)
Return $a
EndIf
ResumeAndroid()
Local $cmdOutput, $connected_to, $running, $process_killed, $hMyTimer
$cmdOutput = LaunchConsole($sVboxManage, "list vms", $process_killed)
If $g_bDebugAndroid Then SetDebugLog("Available " & $g_sAndroidEmulator & " instances: " & $cmdOutput, $COLOR_ERROR)
$a = StringRegExp($cmdOutput, """(.*?)""", $STR_REGEXPARRAYGLOBALMATCH)
If @error Then Local $a = []
Return $a
EndFunc
Func GetAndroidVMinfo(ByRef $sVMinfo, $sVboxManage = $__VBoxManage_Path)
Local $process_killed
Local $as_Instances
$sVMinfo = LaunchConsole($sVboxManage, "showvminfo " & $g_sAndroidInstance, $process_killed)
If StringInStr($sVMinfo, "Could not find a registered machine named") > 0 Then
$as_Instances = FindAvaiableInstances($sVboxManage)
For $s In $as_Instances
If StringCompare($g_sAndroidInstance, $s, $STR_NOCASESENSE) = 0 Then
SetDebugLog("Using " & $g_sAndroidEmulator & " instance " & $s & " (" & $g_sAndroidInstance & " not found!)", $COLOR_ERROR)
$g_sAndroidInstance = $s
$sVMinfo = LaunchConsole($sVboxManage, "showvminfo " & $g_sAndroidInstance, $process_killed)
ExitLoop
EndIf
Next
EndIf
If StringInStr($sVMinfo, "Could not find a registered machine named") > 0 Then
SetLog("Cannot find " & $g_sAndroidEmulator & " instance " & $g_sAndroidInstance, $COLOR_ERROR)
If UBound($as_Instances) = 0 Then
SetLog("No " & $g_sAndroidEmulator & " instance found, please check installation", $COLOR_ERROR)
Else
SetLog("Available " & $g_sAndroidEmulator & " instances are:", $COLOR_ERROR)
For $s In $as_Instances
SetLog($s, $COLOR_ERROR)
Next
EndIf
Return False
EndIf
Return True
EndFunc
Func WaitForAndroidBootCompleted($WaitInSec = 120, $hTimer = 0)
ResumeAndroid()
If Not $g_bRunState Then Return True
Local $cmdOutput, $connected_to, $booted, $process_killed, $hMyTimer
$hMyTimer =($hTimer = 0 ? __TimerInit() : $hTimer)
While True
If Not $g_bRunState Then Return True
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " shell getprop sys.boot_completed", $process_killed)
If Not $g_bRunState Then Return True
$connected_to = IsAdbConnected($cmdOutput)
If Not $g_bRunState Then Return True
If Not $connected_to Then ConnectAndroidAdb(False)
If Not $g_bRunState Then Return True
$booted = StringLeft($cmdOutput, 1) = "1"
If $booted = True Then ExitLoop
If $hTimer <> 0 Then _StatusUpdateTime($hTimer)
If _Sleep(5000) Then Return True
If __TimerDiff($hMyTimer) > $WaitInSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for boot completed", $COLOR_ERROR)
SetError(1, @extended, False)
Return True
EndIf
WEnd
Return False
EndFunc
Func IsAdbConnected($cmdOutput = Default)
ResumeAndroid()
If $__TEST_ERROR_ADB_DEVICE_NOT_FOUND Then Return False
Local $process_killed, $connected_to
If $cmdOutput = Default Then
If IsAdbTCP() Then
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "connect " & $g_sAndroidAdbDevice, $process_killed)
$connected_to = StringInStr($cmdOutput, "connected to") > 0
If $connected_to Then
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " shell echo $USER:$USER_ID", $process_killed)
$connected_to = StringInStr($cmdOutput, " not ") = 0 And StringInStr($cmdOutput, "unable") = 0 And StringInStr($cmdOutput, "error: ") = 0 And StringInStr($cmdOutput, "device ") = 0 And $process_killed = False
EndIf
Else
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " shell echo $USER:$USER_ID", $process_killed)
$connected_to = StringInStr($cmdOutput, " not ") = 0 And StringInStr($cmdOutput, "unable") = 0 And StringInStr($cmdOutput, "error: ") = 0 And $process_killed = False
EndIf
Else
$connected_to = StringInStr($cmdOutput, " not ") = 0 And StringInStr($cmdOutput, "unable") = 0 And StringInStr($cmdOutput, "error: ") = 0
EndIf
Return $connected_to
EndFunc
Func AquireAdbDaemonMutex($timout = 30000)
Local $timer = __TimerInit()
Local $g_hMutex_MyBot = 0
While $g_hMutex_MyBot = 0 And __TimerDiff($timer) < $timout
$g_hMutex_MyBot = CreateMutex("MyBot.run/AdbDaemonLaunch")
If $g_hMutex_MyBot <> 0 Then ExitLoop
If _Sleep(250) Then ExitLoop
WEnd
Return $g_hMutex_MyBot
EndFunc
Func ReleaseAdbDaemonMutex($hMutex, $ReturnValue = Default)
Return ReleaseMutex($hMutex, $ReturnValue)
EndFunc
Func KillAdbDaemon($bMutexLock = True)
Local $hMutex = -1
If $bMutexLock Then $hMutex = AquireAdbDaemonMutex()
If $hMutex = 0 Then
SetDebugLog("Cannot acquire ADB mutex to kill daemon", $COLOR_ERROR)
Return False
EndIf
SetDebugLog("Stop ADB daemon!", $COLOR_ERROR)
Local $process_killed
LaunchConsole($g_sAndroidAdbPath, "kill-server", $process_killed)
Local $pids = ProcessesExist($g_sAndroidAdbPath, "", 1)
For $i = 0 To UBound($pids) - 1
KillProcess($pids[$i], $g_sAndroidAdbPath)
Next
Return ReleaseAdbDaemonMutex($hMutex, True)
EndFunc
Func ConnectAndroidAdb($rebootAndroidIfNeccessary = $g_bRunState, $bStartOnlyAndroid = False, $timeout = 15000)
FuncEnter(ConnectAndroidAdb)
Return FuncReturn(_ConnectAndroidAdb($rebootAndroidIfNeccessary, $bStartOnlyAndroid, $timeout))
EndFunc
Func _ConnectAndroidAdb($rebootAndroidIfNeccessary = $g_bRunState, $bStartOnlyAndroid = False, $timeout = 15000)
If $g_sAndroidAdbPath = "" Or FileExists($g_sAndroidAdbPath) = 0 Then
SetLog($g_sAndroidEmulator & " ADB Path not valid: " & $g_sAndroidAdbPath, $COLOR_ERROR)
Return 0
EndIf
ResumeAndroid()
Local $bRebooted = False
If $rebootAndroidIfNeccessary = True Then
WinGetAndroidHandle()
If AndroidInvalidState() Then
SetDebugLog("ConnectAndroidAdb: Reboot Android as it's not running")
$bRebooted = RebootAndroid(True, $bStartOnlyAndroid)
EndIf
EndIf
Local $hMutex = AquireAdbDaemonMutex()
Local $process_killed, $cmdOutput
Local $connected_to = False
Local $timer = __TimerInit()
Local $timerReInit = $timer
While __TimerDiff($timer) < $timeout
$connected_to = IsAdbConnected()
If $connected_to Then Return ReleaseAdbDaemonMutex($hMutex, 1)
Local $ms = $timeout - __TimerDiff($timer)
If $ms > 3000 Then $ms = 3000
If _Sleep($ms) Then Return ReleaseAdbDaemonMutex($hMutex, 0)
If __TimerDiff($timerReInit) >= 10000 Then
$timerReInit = __TimerInit()
$g_bInitAndroid = True
InitAndroid()
EndIf
WEnd
Switch $g_iAndroidRecoverStrategy
Case 0
KillAdbDaemon(False)
$connected_to = IsAdbConnected()
ReleaseAdbDaemonMutex($hMutex)
If Not $connected_to And $g_bRunState = True And $rebootAndroidIfNeccessary = True Then
SetLog("ADB cannot connect to " & $g_sAndroidEmulator & ", restart emulator now...", $COLOR_ERROR)
$bRebooted = RebootAndroid()
If Not $bRebooted Then Return 0
$connected_to = ConnectAndroidAdb(False, $bStartOnlyAndroid)
If Not $connected_to Then
If Not $g_bRunState Then Return 0
SetLog("ADB really cannot connect to " & $g_sAndroidEmulator & "!", $COLOR_ERROR)
SetLog("Please restart bot, emulator and/or PC...", $COLOR_ERROR)
EndIf
EndIf
Case 1
ReleaseAdbDaemonMutex($hMutex)
If $rebootAndroidIfNeccessary Then
SetDebugLog("ConnectAndroidAdb: Reboot Android due to ADB connection problems...", $COLOR_ERROR)
$bRebooted = RebootAndroid()
If Not $bRebooted Then Return 0
Else
SetDebugLog("ConnectAndroidAdb: Reboot Android nor ADB Daemon not allowed", $COLOR_ERROR)
Return 0
EndIf
$connected_to = IsAdbConnected()
If Not $connected_to Then
SetDebugLog("Stop ADB daemon!", $COLOR_ERROR)
LaunchConsole($g_sAndroidAdbPath, "kill-server", $process_killed)
Local $pids = ProcessesExist($g_sAndroidAdbPath, "", 1)
For $i = 0 To UBound($pids) - 1
KillProcess($pids[$i], $g_sAndroidAdbPath)
Next
$connected_to = ConnectAndroidAdb(False, $bStartOnlyAndroid)
If Not $connected_to Then
If Not $g_bRunState Then Return 0
SetLog("ADB really cannot connect to " & $g_sAndroidEmulator & "!", $COLOR_ERROR)
SetLog("Please restart bot, emulator and/or PC...", $COLOR_ERROR)
EndIf
EndIf
EndSwitch
Return(($connected_to) ?(($bRebooted) ?(2) :(1)) :(0))
EndFunc
Func RebootAndroid($bRestart = True, $bStartOnlyAndroid = False)
FuncEnter(RebootAndroid)
ResumeAndroid()
If Not $g_bRunState Then Return FuncReturn(False)
If CloseUnsupportedAndroid() Then
Else
CloseAndroid("RebootAndroid")
EndIf
If _Sleep(1000) Then Return FuncReturn(False)
Return FuncReturn(OpenAndroid($bRestart, $bStartOnlyAndroid))
EndFunc
Func RebootAndroidSetScreenDefault()
ResumeAndroid()
If Not $g_bRunState Then Return False
AndroidSetFontSizeNormal()
If Not $g_bRunState Then Return False
CloseAndroid("RebootAndroidSetScreenDefault")
If _Sleep(1000) Then Return False
SetScreenAndroid()
If Not $g_bRunState Then Return False
Return OpenAndroid(True)
EndFunc
Func CheckScreenAndroid($ClientWidth, $ClientHeight, $bSetLog = True)
ResumeAndroid()
If Not $g_bRunState Then Return True
AndroidAdbLaunchShellInstance()
If Not $g_bRunState Then Return True
Local $AndroidWinPos = WinGetPos($g_hAndroidWindow)
If IsArray($AndroidWinPos) = 1 Then
Local $WinWidth = $AndroidWinPos[2]
Local $WinHeight = $AndroidWinPos[3]
If $WinWidth <> $g_iAndroidWindowWidth Or $WinHeight <> $g_iAndroidWindowHeight Then
SetDebugLog("CheckScreenAndroid: Window size " & $WinWidth & " x " & $WinHeight & " <> " & $g_iAndroidWindowWidth & " x " & $g_iAndroidWindowHeight, $COLOR_ERROR)
Else
SetDebugLog("CheckScreenAndroid: Window size " & $WinWidth & " x " & $WinHeight)
EndIf
EndIf
Local $ok =($ClientWidth = $g_iAndroidClientWidth) And($ClientHeight = $g_iAndroidClientHeight)
If Not $ok Then
If $bSetLog Then SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen resolution of " & $ClientWidth & " x " & $ClientHeight & "!", $COLOR_ERROR)
SetDebugLog("CheckScreenAndroid: " & $ClientWidth & " x " & $ClientHeight & " <> " & $g_iAndroidClientWidth & " x " & $g_iAndroidClientHeight)
Return False
EndIf
Local $s_font_scale = AndroidAdbSendShellCommand("settings get system font_scale")
Local $font_scale = Number($s_font_scale)
If $font_scale > 0 Then
SetDebugLog($g_sAndroidEmulator & " font_scale = " & $font_scale)
If $font_scale <> 1 Then
SetLog("MyBot doesn't work with Display Font Scale of " & $font_scale, $COLOR_ERROR)
Return False
EndIf
Else
Switch $g_sAndroidEmulator
Case "BlueStacks", "BlueStacks2"
Case Else
SetDebugLog($g_sAndroidEmulator & " Display Font Scale cannot be verified", $COLOR_ERROR)
EndSwitch
EndIf
SetError(0, 0, 0)
$ok = Execute("CheckScreen" & $g_sAndroidEmulator & "(" & $bSetLog & ")")
If $ok = "" And @error <> 0 Then Return True
Return $ok
EndFunc
Func AndroidSetFontSizeNormal()
ResumeAndroid()
AndroidAdbLaunchShellInstance($g_bRunState, False)
SetLog("Set " & $g_sAndroidEmulator & " Display Font Scale to normal", $COLOR_INFO)
AndroidAdbSendShellCommand("settings put system font_scale 1.0", Default, Default, False)
EndFunc
Func AndroidInitPrompt()
If Not $g_bAndroidAdbInstance Then Return
Local $bIdentified = False
Local $s
Sleep(250)
If $g_bAndroidAdbPromptUseGiven Then
AndroidAdbSendShellCommand("", -250, Default, False, False)
$s = AndroidAdbSendShellCommand("", -500, Default, False, False)
If $s Then
$g_sAndroidAdbPrompt = StringStripWS($s, $STR_STRIPLEADING)
SetDebugLog("Initialize shell prompt with '" & $g_sAndroidAdbPrompt & "'")
$bIdentified = True
Else
SetDebugLog("ADB Prompt not identified!", $COLOR_ERROR)
SetDebugLog("ADB Result: " & $s, $COLOR_ERROR)
EndIf
EndIf
If Not $bIdentified Then
SetDebugLog("Initialize shell prompt with '" & $g_sAndroidAdbPrompt & "'")
$s = AndroidAdbSendShellCommand(@LF & "PS1=" & $g_sAndroidAdbPrompt, -500, Default, False)
EndIf
Return $s
EndFunc
Func AndroidAdbLaunchShellInstance($wasRunState = Default, $rebootAndroidIfNeccessary = $g_bRunState)
Static $bAndroidAdbLaunchShellInstanceActive = False
Local $bWasActive = $bAndroidAdbLaunchShellInstanceActive
FuncEnter(AndroidAdbLaunchShellInstance)
$bAndroidAdbLaunchShellInstanceActive = True
Local $Result = _AndroidAdbLaunchShellInstance($wasRunState,(($bWasActive) ?(False) :($rebootAndroidIfNeccessary)))
$bAndroidAdbLaunchShellInstanceActive = $bWasActive
Return FuncReturn($Result)
EndFunc
Func _AndroidAdbLaunchShellInstance($wasRunState = Default, $rebootAndroidIfNeccessary = $g_bRunState)
If $wasRunState = Default Then $wasRunState = $g_bRunState
Local $iConnected
If Not $g_bAndroidInitialized Or $g_iAndroidAdbProcess[0] = 0 Or ProcessExists2($g_iAndroidAdbProcess[0]) <> $g_iAndroidAdbProcess[0] Then
Local $SuspendMode = ResumeAndroid()
InitAndroid()
Local $s
Local $hostFolder = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder
If FileExists($hostFolder) = 1 Then
SetDebugLog($hostFolder & " exists")
Local $aTools[1] = ["toybox"]
Local $tool
For $tool In $aTools
Local $srcFile = $g_sAdbScriptsPath & "\" & $tool
Local $dstFile = $hostFolder & $tool
If FileGetTime($srcFile, $FT_MODIFIED, $FT_STRING) <> FileGetTime($dstFile, $FT_MODIFIED, $FT_STRING) Then
FileCopy($srcFile, $dstFile, $FC_OVERWRITE)
EndIf
Next
EndIf
If $g_bAndroidAdbInstance = True Then
$iConnected = ConnectAndroidAdb($rebootAndroidIfNeccessary)
If $iConnected = 0 Or($iConnected = 2 And $g_iAndroidAdbProcess[0] = 0) Then
Return SetError(3, 0)
ElseIf $iConnected = 2 And $g_iAndroidAdbProcess[0] Then
Return SetError(0, 0)
EndIf
AndroidAdbTerminateShellInstance()
$g_iAndroidAdbProcess[0] = RunPipe($g_sAndroidAdbPath & " -s " & $g_sAndroidAdbDevice & " shell", "", @SW_HIDE, BitOR($STDIN_CHILD, $STDERR_MERGED), $g_iAndroidAdbProcess[1], $g_iAndroidAdbProcess[2], $g_iAndroidAdbProcess[3], $g_iAndroidAdbProcess[4])
If $g_iAndroidAdbProcess[0] = 0 Or ProcessExists2($g_iAndroidAdbProcess[0]) <> $g_iAndroidAdbProcess[0] Then
SetLog($g_sAndroidEmulator & " error launching ADB for background mode, zoom-out, mouse click and input", $COLOR_ERROR)
$g_iAndroidAdbProcess[0] = 0
$g_bAndroidAdbScreencap = False
$g_bAndroidAdbClick = False
$g_bAndroidAdbInput = False
If BitAND($g_iAndroidSupportFeature, 1) = 0 Then $g_bChkBackgroundMode = False
Return SetError(1, 0)
Else
AndroidInitPrompt()
EndIf
EndIf
If True Then
$iConnected = ConnectAndroidAdb($rebootAndroidIfNeccessary)
If $iConnected = 0 Or($iConnected = 2 And $g_iAndroidAdbProcess[0] = 0) Then
Return SetError(3, 0)
ElseIf $iConnected = 2 And $g_iAndroidAdbProcess[0] Then
Return SetError(0, 0)
EndIf
Local $pathFound = False
Local $iMount
For $iMount = 0 To 9
If $g_sAndroidPicturesPath = "" Then
SetDebugLog("Problem in configuration, $g_sAndroidPicturesPath is empty", $COLOR_ERROR)
ExitLoop
EndIf
$s = AndroidAdbSendShellCommand("mount", Default, $wasRunState, False)
Local $path = $g_sAndroidPicturesPath
If StringRight($path, 1) = "/" Then $path = StringLeft($path, StringLen($path) - 1)
Local $aRegExResult = StringRegExp($s, $path, $STR_REGEXPARRAYMATCH)
SetError(0)
If UBound($aRegExResult) = 0 Then Local $aRegExResult = []
_ArrayConcatenate($aRegExResult, StringSplit(((StringLeft($path, 1) = "(" And StringRight($path, 1) = ")") ? StringMid($path, 2, StringLen($path) - 2) : $path), "|", $STR_NOCOUNT))
Local $dummyFile = StringMid(_Crypt_HashData($g_sBotTitle & _Now(), $CALG_SHA1), 3)
FileWriteLine($g_sAndroidPicturesHostPath & $dummyFile, _Now())
For $i = 0 To UBound($aRegExResult) - 1
$path = $aRegExResult[$i]
If $path = "" Then ContinueLoop
If StringRight($path, 1) <> "/" Then $path &= "/"
$s = AndroidAdbSendShellCommand("set result=$(ls '" & $path & $dummyFile & "' >&2)", Default, $wasRunState, False)
If StringInStr($s, "No such file or directory") = 0 And StringInStr($s, "syntax error:") = 0 Then
$pathFound = True
$g_sAndroidPicturesPath = $path
SetDebugLog("Using " & $g_sAndroidPicturesPath & " for Android shared folder")
ExitLoop
EndIf
Next
FileDelete($g_sAndroidPicturesHostPath & $dummyFile)
If $pathFound = True Then ExitLoop
If $iMount = 0 Then
SetLog("Waiting for shared folder to get mounted...", $COLOR_GREEN)
Else
SetDebugLog("Still waiting for shared folder to get mounted...")
EndIf
If _Sleep(6000) Then Return
Next
If $pathFound = False Then
SetLog($g_sAndroidEmulator & " cannot use ADB on shared folder, """ & $g_sAndroidPicturesPath & """ not found", $COLOR_ERROR)
EndIf
$g_iAndroidVersionAPI = Int(AndroidAdbSendShellCommand("getprop ro.build.version.sdk", Default, $wasRunState, False))
SetDebugLog("Android Version API = " & $g_iAndroidVersionAPI)
EndIf
If $g_bAndroidAdbInstance = True Then
$s = ""
Local $scriptFile = ""
If $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\shell.init." & $g_sAndroidEmulator & ".script") = 1 Then $scriptFile = "shell.init." & $g_sAndroidEmulator & ".script"
If $scriptFile = "" Then $scriptFile = "shell.init.script"
$s &= AndroidAdbSendShellCommandScript($scriptFile, Default, Default, 3000, $wasRunState, False)
$s &= AndroidInitPrompt()
Local $error = @error
SetDebugLog("ADB shell launched, PID = " & $g_iAndroidAdbProcess[0] & ": " & $s)
If $error <> 0 Then
SuspendAndroid($SuspendMode)
Return
EndIf
EndIf
If StringLen($g_sAndroidMouseDevice) > 0 And $g_sAndroidMouseDevice = $g_avAndroidAppConfig[$g_iAndroidConfig][13] Then
$iConnected = ConnectAndroidAdb($rebootAndroidIfNeccessary)
If $iConnected = 0 Or($iConnected = 2 And $g_iAndroidAdbProcess[0] = 0) Then
Return SetError(3, 0)
ElseIf $iConnected = 2 And $g_iAndroidAdbProcess[0] Then
Return SetError(0, 0)
EndIf
If StringInStr($g_sAndroidMouseDevice, "/dev/input/event") = 0 Then
$s = AndroidAdbSendShellCommand("getevent -p", Default, $wasRunState, False)
SetDebugLog($g_sAndroidEmulator & " getevent -p: " & $s)
Local $aRegExResult = StringRegExp($s, "(\/dev\/input\/event\d+)[\r\n]+.+""" & $g_sAndroidMouseDevice & """((?!\/dev\/input\/event)[\s\S])+ABS", $STR_REGEXPARRAYMATCH)
If @error = 0 Then
$g_sAndroidMouseDevice = $aRegExResult[0]
SetDebugLog("Using " & $g_sAndroidMouseDevice & " for mouse events")
Else
$aRegExResult = StringRegExp($s, "(\/dev\/input\/event\d+)[\r\n]+.+"".+""((?!\/dev\/input\/event)[\s\S])+ABS \(\d+\): 0035.+max " & $g_iGAME_WIDTH & ".+\n.+0036.+max " & $g_iGAME_HEIGHT, $STR_REGEXPARRAYMATCH)
If @error = 0 Then
SetDebugLog("Using " & $aRegExResult[0] & " for mouse events (" & $g_sAndroidMouseDevice & " not found)")
$g_sAndroidMouseDevice = $aRegExResult[0]
Else
$g_bAndroidAdbClick = False
SetLog($g_sAndroidEmulator & " cannot use ADB for mouse events, """ & $g_sAndroidMouseDevice & """ not found", $COLOR_ERROR)
SuspendAndroid($SuspendMode)
Return SetError(2, 1)
EndIf
EndIf
EndIf
SuspendAndroid($SuspendMode)
Return SetError(0, 1)
Else
SetDebugLog($g_sAndroidEmulator & " ADB use " & $g_sAndroidMouseDevice & " for mouse events")
EndIf
EndIf
SetError(0, 0)
EndFunc
Func AndroidAdbTerminateShellInstance()
Local $SuspendMode = ResumeAndroid()
If $g_iAndroidAdbProcess[0] <> 0 Then
If _AndroidAdbSendShellCommand("exit", 500, Default, False, False, True) Then _AndroidAdbSendShellCommand("exit", 0, Default, False, False, True)
If ClosePipe($g_iAndroidAdbProcess[0], $g_iAndroidAdbProcess[1], $g_iAndroidAdbProcess[2], $g_iAndroidAdbProcess[3], $g_iAndroidAdbProcess[4]) = 1 Then
SetDebugLog("ADB shell terminated, PID = " & $g_iAndroidAdbProcess[0])
Else
SetDebugLog("ADB shell not terminated, PID = " & $g_iAndroidAdbProcess[0], $COLOR_ERROR)
EndIf
$g_iAndroidAdbProcess[0] = 0
EndIf
EndFunc
Func AndroidAdbSendShellCommand($cmd = Default, $timeout = Default, $wasRunState = Default, $EnsureShellInstance = True, $bStripPrompt = True, $bNoShellTerminate = False)
FuncEnter(AndroidAdbSendShellCommand)
If Not $g_bAndroidInitialized Then Return FuncReturn()
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Local $Result = _AndroidAdbSendShellCommand($cmd, $timeout, $wasRunState, $EnsureShellInstance, $bStripPrompt, $bNoShellTerminate)
$g_bTogglePauseAllowed = $wasAllowed
Return FuncReturn(SetError(@error, @extended, $Result))
EndFunc
Func _AndroidAdbSendShellCommand($cmd = Default, $timeout = Default, $wasRunState = Default, $EnsureShellInstance = True, $bStripPrompt = True, $bNoShellTerminate = False)
Static $iCommandErrors = 0
If $timeout = Default Then $timeout = 3000
If $wasRunState = Default Then $wasRunState = $g_bRunState
Local $sentBytes = 0
Local $SuspendMode = ResumeAndroid()
SetError(0, 0, 0)
If $EnsureShellInstance = True Then
AndroidAdbLaunchShellInstance($wasRunState)
EndIf
If @error <> 0 Then Return SetError(@error, 0, "")
Local $hTimer = __TimerInit()
Local $s = ""
Local $loopCount = 0
Local $cleanOutput = True
If $g_bAndroidAdbInstance = True Then
Local $aReadPipe = $g_iAndroidAdbProcess[2]
Local $aWritePipe = $g_iAndroidAdbProcess[1]
If UBound($aReadPipe) < 2 Or UBound($aWritePipe) < 2 Then
SetDebugLog("ADB Shell instance not initialized, cannot execute: " & $cmd, $COLOR_ERROR)
Return SetError(1, 0, "")
EndIf
ReadPipe($aReadPipe[0])
If $cmd = Default Then
Else
If $g_bDebugAndroid Then
SetDebugLog("Send ADB shell command: " & $cmd)
EndIf
$sentBytes = WritePipe($aWritePipe[1], $cmd & @LF)
EndIf
If $timeout <> 0 Then
While @error = 0 And($timeout < 0 Or StringCompare(StringRight($s, StringLen($g_sAndroidAdbPrompt) + 1), @LF & $g_sAndroidAdbPrompt, $STR_CASESENSE) <> 0) And __TimerDiff($hTimer) < Abs($timeout)
Sleep(10)
$s &= ReadPipe($aReadPipe[0])
$loopCount += 1
If $wasRunState And Not $g_bRunState Then ExitLoop
WEnd
Else
$s &= ReadPipe($aReadPipe[0])
EndIf
Else
$cleanOutput = False
If $cmd = Default Then
Else
Local $process_killed
If $g_bDebugAndroid Then
SetDebugLog("Execute ADB shell command: " & $cmd)
EndIf
$s = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " shell " & $cmd, $process_killed, Abs($timeout))
EndIf
EndIf
If $cleanOutput Then
Local $i = StringInStr($s, @LF)
If $i > 0 Then $s = StringMid($s, $i)
If $bStripPrompt And StringCompare(StringRight($s, StringLen($g_sAndroidAdbPrompt) + 1), @LF & $g_sAndroidAdbPrompt, $STR_CASESENSE) = 0 Then $s = StringLeft($s, StringLen($s) - StringLen($g_sAndroidAdbPrompt) - 1)
CleanLaunchOutput($s)
If StringLeft($s, 1) = @LF Then $s = StringMid($s, 2)
Else
If StringLeft($s, 1) = @LF Then $s = StringMid($s, 2)
If StringRight($s, 1) = @LF Then $s = StringLeft($s, StringLen($s) - 1)
If StringRight($s, 1) = @CR Then $s = StringLeft($s, StringLen($s) - 1)
EndIf
Local $sRemove = "WARNING: linker: libdvm.so has text relocations. This is wasting memory and is a security risk. Please fix."
If StringLen($s) >= StringLen($sRemove) And StringLeft($s, StringLen($sRemove)) = $sRemove Then
$s = StringMid($s, StringLen($sRemove) + 1)
If StringLeft($s, 1) = @LF Then $s = StringMid($s, 2)
EndIf
If $g_bAndroidAdbInstance = True And $g_bDebugAndroid And StringLen($s) > 0 Then SetDebugLog("ADB shell command output: " & $s)
SuspendAndroid($SuspendMode)
Local $error =(($g_bRunState = False Or __TimerDiff($hTimer) < $timeout Or $timeout < 1) ? 0 : 1)
If $error <> 0 Then
SetDebugLog("(" & $iCommandErrors & "): ADB shell command error " & $error & " (" & $g_sAndroidAdbPrompt & "): " & $s, $COLOR_ERROR)
$iCommandErrors += 1
EndIf
If $__TEST_ERROR_SLOW_ADB_SHELL_COMMAND_DELAY > 0 Then Sleep($__TEST_ERROR_SLOW_ADB_SHELL_COMMAND_DELAY)
$g_iAndroidAdbAutoTerminateCount += 1
If $iCommandErrors > $g_iAndroidRebootAdbCommandErrorCount Or(Mod($g_iAndroidAdbAutoTerminateCount, $g_iAndroidAdbAutoTerminate) = 0 And $EnsureShellInstance = True) Then
If $iCommandErrors > $g_iAndroidRebootAdbCommandErrorCount Then
$iCommandErrors = 0
RebootAndroid()
Else
$iCommandErrors = 0
If $bNoShellTerminate = False Then AndroidAdbTerminateShellInstance()
EndIf
EndIf
Return SetError($error, Int(__TimerDiff($hTimer)) & "ms,#" & $loopCount, $s)
EndFunc
Func GetBinaryEvent($type, $code, $value)
Local $h, $hType, $hCode, $hValue
If IsInt($type) Then
$hType = StringLeft(Hex(Binary($type)), 4)
ElseIf IsString($type) Then
$hType = $type
EndIf
If IsInt($code) Then
$hCode = StringLeft(Hex(Binary($code)), 4)
ElseIf IsString($code) Then
$hCode = $code
EndIf
If IsInt($value) Then
$hValue = StringLeft(Hex(Binary($value)), 8)
ElseIf IsString($value) Then
$hValue = $value
EndIf
$h = "0x0000000000000000" & $hType & $hCode & $hValue
Return Binary($h)
EndFunc
Func AndroidAdbSendShellCommandScript($scriptFile, $variablesArray = Default, $combine = Default, $timeout = Default, $wasRunState = $g_bRunState, $EnsureShellInstance = True)
If $combine = Default Then $combine = False
If $timeout = Default Then $timeout = 20000
Local $hostPath = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder
Local $androidPath = $g_sAndroidPicturesPath & StringReplace($g_sAndroidPicturesHostFolder, "\", "/")
AndroidAdbLaunchShellInstance()
If @error <> 0 Then Return SetError(3, 0)
Local $hTimer = __TimerInit()
Local $hFileOpen = FileOpen($g_sAdbScriptsPath & "\" & $scriptFile)
If $hFileOpen = -1 Then
SetLog("ADB script file not found: " & $scriptFile, $COLOR_ERROR)
Return SetError(5, 0)
EndIf
Local $script = FileRead($hFileOpen)
FileClose($hFileOpen)
Local $scriptModifiedTime = FileGetTime($g_sAdbScriptsPath & "\" & $scriptFile, $FT_MODIFIED, $FT_STRING)
Local $scriptFileSh = $scriptFile
$script = StringReplace($script, "{$AndroidMouseDevice}", $g_sAndroidMouseDevice)
If @extended > 0 Then
$scriptFileSh &= $g_sAndroidMouseDevice
If StringInStr($g_sAndroidMouseDevice, "/dev/input/event") = 0 Then
$g_bAndroidAdbClick = False
SetLog($g_sAndroidEmulator & " mouse device not configured", $COLOR_ERROR)
Return SetError(4, 0, 0)
EndIf
EndIf
Local $i, $j, $k, $iAdditional
Local $additionalFilenames[0]
$i = 1
While FileExists($g_sAdbScriptsPath & "\" & $scriptFile & "." & $i) = 1
Local $srcFile = $g_sAdbScriptsPath & "\" & $scriptFile & "." & $i
Local $secFile = GetSecureFilename($scriptFile & "." & $i)
Local $dstFile = $hostPath & $secFile
If FileGetTime($srcFile, $FT_MODIFIED, $FT_STRING) <> FileGetTime($dstFile, $FT_MODIFIED, $FT_STRING) Then
FileCopy($srcFile, $dstFile, $FC_OVERWRITE)
EndIf
$iAdditional = $i
ReDim $additionalFilenames[$iAdditional]
$additionalFilenames[$iAdditional - 1] = $secFile
$script = StringReplace($script, $scriptFile & "." & $i, $secFile)
$i += 1
WEnd
If UBound($variablesArray, 2) = 2 Then
For $i = 0 To UBound($variablesArray, 1) - 1
$script = StringReplace($script, $variablesArray[$i][0], $variablesArray[$i][1])
If @extended > 0 Then
$scriptFileSh &= "." & $variablesArray[$i][1]
EndIf
Next
EndIf
$scriptFileSh = StringRegExpReplace($scriptFileSh, '[/\:*?"<>|]', '.')
$scriptFileSh &= ".sh"
$scriptFileSh = GetSecureFilename($scriptFileSh)
$script = StringReplace($script, @CRLF, @LF)
Local $aCmds = StringSplit($script, @LF)
Local $hTimer = __TimerInit()
Local $s = ""
If FileExists($hostPath) = 0 Then
SetLog($g_sAndroidEmulator & " ADB script file folder doesn't exist:", $COLOR_ERROR)
SetLog($hostPath, $COLOR_ERROR)
Return SetError(6, 0)
EndIf
SetError(0, 0)
Local $sDev
Local $cmds = ""
Local $dd[1]
Local $ddFile, $ddHandle
For $i = 1 To $aCmds[0]
Local $cmd = $aCmds[$i]
If StringInStr($cmd, "/dev/input/") = 1 Then
Local $aElem = StringSplit($cmd, " ")
$sDev = StringReplace($aElem[1], ":", "")
If $aElem[0] < 4 Then
SetDebugLog("ADB script " & $scriptFile & ": ignore line " & $i & ": " & $cmd, $COLOR_ACTION)
Else
If IsString($combine) = 1 And $combine = "dd" Then
$j = UBound($dd)
ReDim $dd[$j + 1]
$dd[0] = $sDev
$dd[$j] = GetBinaryEvent(Dec($aElem[2]), Dec($aElem[3]), Dec($aElem[4]))
$cmd = ""
Else
$cmd = "sendevent " & $sDev & " " & Dec($aElem[2]) & " " & Dec($aElem[3]) & " " & Dec($aElem[4])
EndIf
EndIf
EndIf
$cmd = StringStripWS($cmd, 3)
If $cmd = "#dd send" Then
$j = UBound($dd) - 1
If $j > 0 Then
$iAdditional += 1
$ddFile = GetSecureFilename($scriptFile & "." & $iAdditional)
ReDim $additionalFilenames[$iAdditional]
$additionalFilenames[$iAdditional - 1] = $ddFile
$ddHandle = FileOpen($hostPath & $ddFile, BitOR($FO_OVERWRITE, $FO_BINARY))
$cmd = "dd obs=" & 16 *($j - 1) & " if=" & $androidPath & $ddFile & " of=" & $dd[0]
For $k = 1 To $j
FileWrite($ddHandle, $dd[$k])
Next
FileClose($ddHandle)
EndIf
EndIf
$aCmds[$i] = $cmd
If $combine = True And IsString($combine) = 0 And StringLen($cmd) > 0 Then
$cmds &= $cmd
If $i < $aCmds[0] Then $cmds &= ";"
EndIf
Next
Local $loopCount = 0
If $combine = True And IsString($combine) = 0 And StringLen($cmds) <= 1024 Then
$s = AndroidAdbSendShellCommand($cmds, $timeout, $wasRunState, $EnsureShellInstance)
If @error <> 0 Then Return SetError(1, 0, $s)
Local $a = StringSplit(@extended, "#")
If $a[0] > 1 Then $loopCount += Number($a[2])
Else
If $scriptModifiedTime <> FileGetTime($hostPath & $scriptFileSh, $FT_MODIFIED, $FT_STRING) Then
FileDelete($hostPath & $scriptFileSh)
EndIf
If FileExists($hostPath & $scriptFileSh) = 0 Then
$script = "#!/bin/sh"
For $i = 1 To $aCmds[0]
If($i = 1 And StringLeft($aCmds[$i], 2) = "#!") Or $aCmds[$i] = "" Then
ContinueLoop
EndIf
$script &=(@LF & $aCmds[$i])
Next
If FileWrite($hostPath & $scriptFileSh, $script) = 1 Then
If BitAND($g_iAndroidSecureFlags, 3) = 0 Then SetLog("ADB script file created: " & $hostPath & $scriptFileSh)
Else
SetLog("ADB cannot create script file: " & $hostPath & $scriptFileSh, $COLOR_ERROR)
Return SetError(7, 0)
EndIf
FileSetTime($hostPath & $scriptFileSh, $scriptModifiedTime, $FT_MODIFIED)
EndIf
$s = AndroidAdbSendShellCommand("sh """ & $androidPath & $scriptFileSh & """", $timeout, $wasRunState, $EnsureShellInstance)
If BitAND($g_iAndroidSecureFlags, 2) = 2 Then
FileDelete($hostPath & $scriptFileSh)
For $i = 0 To $iAdditional - 1
FileDelete($hostPath & $additionalFilenames[$i])
Next
EndIf
If @error <> 0 Then
SetDebugLog("Error executing " & $scriptFileSh & ": " & $s)
Return SetError(1, 0, $s)
EndIf
Local $a = StringSplit(@extended, "#")
If $a[0] > 1 Then $loopCount += Number($a[2])
EndIf
Return SetError(0, Int(__TimerDiff($hTimer)) & "ms,#" & $loopCount, $s)
EndFunc
Func AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount = 0)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Local $Result = _AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount)
$g_bTogglePauseAllowed = $wasAllowed
Return SetError(@error, @extended, $Result)
EndFunc
Func _AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount = 0)
Local $startTimer = __TimerInit()
Local $hostPath = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder
Local $androidPath = $g_sAndroidPicturesPath & StringReplace($g_sAndroidPicturesHostFolder, "\", "/")
If $hostPath = "" Or $androidPath = "" Then
If $hostPath = "" Then
SetLog($g_sAndroidEmulator & " shared folder not configured for host", $COLOR_ERROR)
Else
SetLog($g_sAndroidEmulator & " shared folder not configured for Android", $COLOR_ERROR)
EndIf
SetLog($g_sAndroidEmulator & " ADB screen capture disabled", $COLOR_ERROR)
If BitAND($g_iAndroidSupportFeature, 1) = 0 Then $g_bChkBackgroundMode = False
$g_bAndroidAdbScreencap = False
EndIf
Local $wasRunState = $g_bRunState
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then Return SetError(2, 0)
Local $sBotTitleEx = StringRegExpReplace($g_sBotTitle, '[/:*?"<>|]', '_')
Local $Filename = $sBotTitleEx & ".rgba"
If $g_bAndroidAdbScreencapPngEnabled = True Then $Filename = $sBotTitleEx & ".png"
$Filename = GetSecureFilename($Filename)
Local $s
Local $tBIV5HDR = 0
If $g_bAndroidAdbScreencapPngEnabled = False Then
$tBIV5HDR = DllStructCreate($tagBITMAPV5HEADER)
DllStructSetData($tBIV5HDR, 'bV5Size', DllStructGetSize($tBIV5HDR))
DllStructSetData($tBIV5HDR, 'bV5Width', $iWidth)
DllStructSetData($tBIV5HDR, 'bV5Height', -$iHeight)
DllStructSetData($tBIV5HDR, 'bV5Planes', 1)
DllStructSetData($tBIV5HDR, 'bV5BitCount', 32)
DllStructSetData($tBIV5HDR, 'biCompression', $BI_RGB)
EndIf
Local $pBits = 0
Local $hHBitmap = 0
If $g_iAndroidAdbScreencapTimer <> 0 And $g_bForceCapture = False And __TimerDiff($g_iAndroidAdbScreencapTimer) < $g_iAndroidAdbScreencapTimeout And $g_bRunState = True And $iRetryCount = 0 Then
If $g_bAndroidAdbScreencapPngEnabled = False Then
$hHBitmap = _WinAPI_CreateDIBSection(0, $tBIV5HDR, $DIB_RGB_COLORS, $pBits)
$tBIV5HDR = 0
DllCall($g_sLibPath & "\helper_functions.dll", "none:cdecl", "RGBA2BGRA", "ptr", DllStructGetPtr($g_aiAndroidAdbScreencapBuffer), "ptr", $pBits, "int", $iLeft, "int", $iTop, "int", $iWidth, "int", $iHeight, "int", $g_iAndroidAdbScreencapWidth, "int", $g_iAndroidAdbScreencapHeight)
Return $hHBitmap
ElseIf $g_hAndroidAdbScreencapBufferPngHandle <> 0 Then
If $iWidth > $g_iAndroidAdbScreencapWidth - $iLeft Then $iWidth = $g_iAndroidAdbScreencapWidth - $iLeft
If $iHeight > $g_iAndroidAdbScreencapHeight - $iTop Then $iHeight = $g_iAndroidAdbScreencapHeight - $iTop
Local $hClone = _GDIPlus_BitmapCloneArea($g_hAndroidAdbScreencapBufferPngHandle, $iLeft, $iTop, $iWidth, $iHeight, $GDIP_PXF32ARGB)
Return _GDIPlus_BitmapCreateDIBFromBitmap($hClone)
EndIf
EndIf
FileDelete($hostPath & $Filename)
$s = AndroidAdbSendShellCommand("screencap """ & $androidPath & $Filename & """", $g_iAndroidAdbScreencapWaitAdbTimeout, $wasRunState)
If $__TEST_ERROR_SLOW_ADB_SCREENCAP_DELAY > 0 Then Sleep($__TEST_ERROR_SLOW_ADB_SCREENCAP_DELAY)
Local $shellLogInfo = @extended
Local $hTimer = __TimerInit()
Local $hFile = 0
Local $iSize = 0
Local $iLoopCountFile = 0
Local $AdbStatsType = 0
Local $iF = 0
Local $ExpectedFileSize = 1500
Local $iReadData = 0
If $g_bAndroidAdbScreencapPngEnabled = False Then
Local $tHeader = DllStructCreate("int w;int h;int f")
Local $iHeaderSize = DllStructGetSize($tHeader)
Local $iDataSize = DllStructGetSize($g_aiAndroidAdbScreencapBuffer)
$ExpectedFileSize = $g_iAndroidClientWidth * $g_iAndroidClientHeight * 4 + $iHeaderSize
While $iSize < $ExpectedFileSize And __TimerDiff($hTimer) < $g_iAndroidAdbScreencapWaitFileTimeout
If $hFile = 0 Then $hFile = _WinAPI_CreateFile($hostPath & $Filename, 2, 2, 7)
If $hFile <> 0 Then $iSize = _WinAPI_GetFileSizeEx($hFile)
If $iSize >= $ExpectedFileSize Then ExitLoop
Sleep(10)
If $wasRunState = True And $g_bRunState = False Then
If $hFile <> 0 Then _WinAPI_CloseHandle($hFile)
Return SetError(1, 0)
EndIf
$iLoopCountFile += 1
WEnd
Local $iReadHeader = 0
$g_iAndroidAdbScreencapWidth = 0
$g_iAndroidAdbScreencapHeight = 0
If $hFile <> 0 Then
If $iSize >= $ExpectedFileSize Then
$hTimer = __TimerInit()
While $iReadHeader < $iHeaderSize And __TimerDiff($hTimer) < $g_iAndroidAdbScreencapWaitFileTimeout
If _WinAPI_ReadFile($hFile, $tHeader, $iHeaderSize, $iReadHeader) = True And $iReadHeader = $iHeaderSize Then
ExitLoop
Else
SetDebugLog("Error " & _WinAPI_GetLastError() & ", read " & $iReadHeader & " header bytes, file: " & $hostPath & $Filename, $COLOR_ERROR)
If $iReadHeader > 0 Then _WinAPI_SetFilePointer($hFile, 0)
Sleep(10)
EndIf
WEnd
$g_iAndroidAdbScreencapWidth = DllStructGetData($tHeader, "w")
$g_iAndroidAdbScreencapHeight = DllStructGetData($tHeader, "h")
$iF = DllStructGetData($tHeader, "f")
$hTimer = __TimerInit()
If $iSize - $iHeaderSize < $iDataSize Then $iDataSize = $iSize - $iHeaderSize
While $iReadData < $iDataSize And __TimerDiff($hTimer) < $g_iAndroidAdbScreencapWaitFileTimeout
If _WinAPI_ReadFile($hFile, $g_aiAndroidAdbScreencapBuffer, $iDataSize, $iReadData) = True And $iReadData = $iDataSize Then
ExitLoop
Else
SetDebugLog("Error " & _WinAPI_GetLastError() & ", read " & $iReadData & " data bytes, file: " & $hostPath & $Filename, $COLOR_ERROR)
If $iReadData > 0 Then _WinAPI_SetFilePointer($hFile, $iHeaderSize)
Sleep(10)
EndIf
WEnd
_WinAPI_CloseHandle($hFile)
$hHBitmap = _WinAPI_CreateDIBSection(0, $tBIV5HDR, $DIB_RGB_COLORS, $pBits)
DllCall($g_sLibPath & "\helper_functions.dll", "none:cdecl", "RGBA2BGRA", "ptr", DllStructGetPtr($g_aiAndroidAdbScreencapBuffer), "ptr", $pBits, "int", $iLeft, "int", $iTop, "int", $iWidth, "int", $iHeight, "int", $g_iAndroidAdbScreencapWidth, "int", $g_iAndroidAdbScreencapHeight)
Else
_WinAPI_CloseHandle($hFile)
SetDebugLog("File too small (" & $iSize & " < " & $ExpectedFileSize & "): " & $hostPath & $Filename, $COLOR_ERROR)
EndIf
EndIf
If $hFile = 0 Or $iSize < $ExpectedFileSize Or $iReadHeader < $iHeaderSize Or $iReadData < $iDataSize Then
If $hFile = 0 Then
SetLog("File not found: " & $hostPath & $Filename, $COLOR_ERROR)
Else
If $iSize <> $ExpectedFileSize Then SetDebugLog("File size " & $iSize & " is not " & $ExpectedFileSize & " for " & $hostPath & $Filename, $COLOR_ERROR)
SetDebugLog("Captured screen size " & $g_iAndroidAdbScreencapWidth & " x " & $g_iAndroidAdbScreencapHeight, $COLOR_ERROR)
SetDebugLog("Captured screen bytes read (header/datata): " & $iReadHeader & " / " & $iReadData, $COLOR_ERROR)
EndIf
If $iRetryCount < 10 Then
SetDebugLog("ADB retry screencap in 1000 ms. (restarting ADB session)", $COLOR_ACTION)
_Sleep(1000)
AndroidAdbTerminateShellInstance()
AndroidAdbLaunchShellInstance($wasRunState)
Return AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount + 1)
EndIf
SetLog($g_sAndroidEmulator & " screen not captured using ADB", $COLOR_ERROR)
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] < 50 And AndroidControlAvailable() Then
SetLog($g_sAndroidEmulator & " ADB screen capture disabled", $COLOR_ERROR)
If BitAND($g_iAndroidSupportFeature, 1) = 0 Then $g_bChkBackgroundMode = False
$g_bAndroidAdbScreencap = False
Else
SetLog("Rebooting " & $g_sAndroidEmulator & " due to problems capturing screen", $COLOR_ERROR)
Local $_NoFocusTampering = $g_bNoFocusTampering
$g_bNoFocusTampering = True
RebootAndroid()
$g_bNoFocusTampering = $_NoFocusTampering
EndIf
Return SetError(3, 0)
EndIf
Else
If $g_hAndroidAdbScreencapBufferPngHandle <> 0 Then
_GDIPlus_ImageDispose($g_hAndroidAdbScreencapBufferPngHandle)
_GDIPlus_BitmapDispose($g_hAndroidAdbScreencapBufferPngHandle)
_WinAPI_DeleteObject($g_hAndroidAdbScreencapBufferPngHandle)
$g_hAndroidAdbScreencapBufferPngHandle = 0
EndIf
Local $hBitmap = 0
While $iSize < $ExpectedFileSize And __TimerDiff($hTimer) < $g_iAndroidAdbScreencapWaitFileTimeout
If $hFile = 0 Then $hFile = _WinAPI_CreateFile($hostPath & $Filename, 2, 2, 7)
If $hFile <> 0 Then $iSize = _WinAPI_GetFileSizeEx($hFile)
If $iSize >= $ExpectedFileSize Then ExitLoop
Sleep(10)
If $wasRunState = True And $g_bRunState = False Then Return SetError(1, 0)
$iLoopCountFile += 1
WEnd
Local $hData = _MemGlobalAlloc($iSize, $GMEM_MOVEABLE)
Local $pData = _MemGlobalLock($hData)
Local $tData = DllStructCreate('byte[' & $iSize & ']', $pData)
While $iSize > 0 And $iReadData < $iSize And __TimerDiff($hTimer) < $g_iAndroidAdbScreencapWaitFileTimeout
If _WinAPI_ReadFile($hFile, $tData, $iSize, $iReadData) = True And $iReadData = $iSize Then
ExitLoop
Else
SetDebugLog("Error " & _WinAPI_GetLastError() & ", read " & $iReadData & " data bytes, file: " & $hostPath & $Filename, $COLOR_ERROR)
If $iReadData > 0 Then _WinAPI_SetFilePointer($hFile, 0)
Sleep(10)
EndIf
WEnd
_WinAPI_CloseHandle($hFile)
SetDebugLog($iSize, $COLOR_ERROR)
Local $testTimer = __TimerInit()
Local $msg = ""
_MemGlobalUnlock($hData)
Local $pStream = _WinAPI_CreateStreamOnHGlobal($hData)
$hBitmap = _GDIPlus_BitmapCreateFromStream($pStream)
_WinAPI_ReleaseStream($pStream)
$msg &= ", " & Round(__TimerDiff($testTimer), 2)
If $hBitmap = 0 Then
If $iRetryCount < 10 Then
SetDebugLog("ADB retry screencap in 1000 ms. (restarting ADB session)", $COLOR_ACTION)
_Sleep(1000)
AndroidAdbTerminateShellInstance()
AndroidAdbLaunchShellInstance($wasRunState)
Return AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount + 1)
EndIf
SetLog($g_sAndroidEmulator & " screen not captured using ADB", $COLOR_ERROR)
If FileExists($hostPath & $Filename) = 0 Then SetLog("File not found: " & $hostPath & $Filename, $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " ADB screen capture disabled", $COLOR_ERROR)
$g_bAndroidAdbScreencap = False
Return SetError(5, 0)
Else
$g_iAndroidAdbScreencapWidth = _GDIPlus_ImageGetWidth($hBitmap)
$g_iAndroidAdbScreencapHeight = _GDIPlus_ImageGetHeight($hBitmap)
$msg &= ", " & Round(__TimerDiff($testTimer), 2)
If $iWidth > $g_iAndroidAdbScreencapWidth - $iLeft Then $iWidth = $g_iAndroidAdbScreencapWidth - $iLeft
If $iHeight > $g_iAndroidAdbScreencapHeight - $iTop Then $iHeight = $g_iAndroidAdbScreencapHeight - $iTop
Local $hClone = _GDIPlus_BitmapCloneArea($hBitmap, $iLeft, $iTop, $iWidth, $iHeight, $GDIP_PXF32ARGB)
$msg &= ", " & Round(__TimerDiff($testTimer), 2)
If $hClone = 0 Then
SetDebugLog($g_sAndroidEmulator & " error using " & $g_iAndroidAdbScreencapWidth & "x" & $g_iAndroidAdbScreencapHeight & " on _GDIPlus_BitmapCloneArea(" & $hBitmap & "," & $iLeft & "," & $iTop & "," & $iWidth & "," & $iHeight, $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " screenshot not available", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " ADB screen capture disabled", $COLOR_ERROR)
$g_bAndroidAdbScreencap = False
Return SetError(6, 0)
EndIf
$g_hAndroidAdbScreencapBufferPngHandle = $hBitmap
$msg &= ", " & Round(__TimerDiff($testTimer), 2)
$hHBitmap = _GDIPlus_BitmapCreateDIBFromBitmap($hClone)
EndIf
EndIf
If BitAND($g_iAndroidSecureFlags, 2) = 2 Then
FileDelete($hostPath & $Filename)
EndIf
Local $duration = Int(__TimerDiff($startTimer))
$g_iAndroidAdbScreencapTimeout =($g_iAndroidAdbScreencapTimeoutDynamic = 0 ? $g_iAndroidAdbScreencapTimeoutMax : $duration * $g_iAndroidAdbScreencapTimeoutDynamic)
If $g_iAndroidAdbScreencapTimeout < $g_iAndroidAdbScreencapTimeoutMin Then $g_iAndroidAdbScreencapTimeout = $g_iAndroidAdbScreencapTimeoutMin
If $g_iAndroidAdbScreencapTimeout > $g_iAndroidAdbScreencapTimeoutMax Then $g_iAndroidAdbScreencapTimeout = $g_iAndroidAdbScreencapTimeoutMax
$g_iAndroidAdbScreencapTimer = __TimerInit()
$g_aiAndroidAdbStatsTotal[$AdbStatsType][0] += 1
$g_aiAndroidAdbStatsTotal[$AdbStatsType][1] += $duration
Local $iLastCount = UBound($g_aiAndroidAdbStatsLast, 2) - 2
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] <= $iLastCount Then
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] += $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][$g_aiAndroidAdbStatsTotal[$AdbStatsType][0] + 1] = $duration
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] = $iLastCount Then $g_aiAndroidAdbStatsLast[$AdbStatsType][1] = 0
Else
Local $iLastIdx = $g_aiAndroidAdbStatsLast[$AdbStatsType][1] + 2
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] -= $g_aiAndroidAdbStatsLast[$AdbStatsType][$iLastIdx]
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] += $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][$iLastIdx] = $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][1] = Mod($g_aiAndroidAdbStatsLast[$AdbStatsType][1] + 1, $iLastCount)
EndIf
If $g_aiAndroidAdbStatsLast[$AdbStatsType][1] = 0 Then
Local $totalAvg = Round($g_aiAndroidAdbStatsTotal[$AdbStatsType][1] / $g_aiAndroidAdbStatsTotal[$AdbStatsType][0])
Local $lastAvg = Round($g_aiAndroidAdbStatsLast[$AdbStatsType][0] / $iLastCount)
If $g_bDebugAndroid Or Mod($g_aiAndroidAdbStatsTotal[$AdbStatsType][0], 100) = 0 Then
SetDebugLog("AdbScreencap: " & $totalAvg & "/" & $lastAvg & "/" & $duration & " ms (all/" & $iLastCount & "/1)," & $shellLogInfo & "," & $iLoopCountFile & ",l=" & $iLeft & ",t=" & $iTop & ",w=" & $iWidth & ",h=" & $iHeight & ", " & $Filename & ": w=" & $g_iAndroidAdbScreencapWidth & ",h=" & $g_iAndroidAdbScreencapHeight & ",f=" & $iF)
EndIf
EndIf
$tBIV5HDR = 0
Return $hHBitmap
EndFunc
Func AndroidZoomOut($overWaters = False, $loopCount = 0, $timeout = Default, $wasRunState = $g_bRunState)
If $overWaters = True Then AndroidAdbScript("OverWaters", Default, $timeout, $wasRunState)
Return AndroidAdbScript("ZoomOut", Default, $timeout, $wasRunState)
EndFunc
Func AndroidAdbScript($scriptTag, $variablesArray = Default, $timeout = Default, $wasRunState = $g_bRunState)
ResumeAndroid()
If $g_bAndroidAdbZoomoutEnabled = False Then Return SetError(4, 0)
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then Return SetError(2, 0, 0)
If StringInStr($g_sAndroidMouseDevice, "/dev/input/event") = 0 Then Return SetError(2, 0, 0)
Local $scriptFile = ""
If $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\" & $scriptTag & "." & $g_sAndroidEmulator & ".script") = 1 Then $scriptFile = $scriptTag & "." & $g_sAndroidEmulator & ".script"
If $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\" & $scriptTag & "." & $g_sAndroidEmulator & ".getevent") = 1 Then $scriptFile = $scriptTag & "." & $g_sAndroidEmulator & ".getevent"
If $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\" & $scriptTag & ".script") = 1 Then $scriptFile = $scriptTag & ".script"
If $scriptFile = "" Then $scriptFile = $scriptTag & ".getevent"
AndroidAdbSendShellCommandScript($scriptFile, $variablesArray, Default, $timeout, $wasRunState)
Return SetError(@error, @extended,(@error = 0 ? 1 : 0))
EndFunc
Func AndroidClickDrag($x1, $y1, $x2, $y2, $wasRunState = $g_bRunState)
$x1 = Int($x1) + $g_aiMouseOffset[0]
$y1 = Int($y1) + $g_aiMouseOffset[1]
$x2 = Int($x2) + $g_aiMouseOffset[0]
$y2 = Int($y2) + $g_aiMouseOffset[1]
Execute($g_sAndroidEmulator & "AdjustClickCoordinates($x1,$y1)")
Execute($g_sAndroidEmulator & "AdjustClickCoordinates($x2,$y2)")
Local $swipe_coord[4][2] = [["{$x1}", $x1], ["{$y1}", $y1], ["{$x2}", $x2], ["{$y2}", $y2]]
Return AndroidAdbScript("clickdrag", $swipe_coord, Default, $wasRunState)
EndFunc
Func IsKeepClicksActive($Really = True)
If $Really = True Then
Return $g_bAndroidAdbClick = True And $g_bAndroidAdbClicksEnabled = True And $g_aiAndroidAdbClicks[0] > -1
EndIf
Return $g_bAndroidAdbKeepClicksActive
EndFunc
Func KeepClicks()
$g_bAndroidAdbKeepClicksActive = True
If $g_bAndroidAdbClick = False Or $g_bAndroidAdbClicksEnabled = False Then Return False
If $g_aiAndroidAdbClicks[0] = -1 Then $g_aiAndroidAdbClicks[0] = 0
EndFunc
Func ReleaseClicks($minClicksToRelease = 0, $ReleaseClicksEnabled = $g_bAndroidAdbClicksEnabled)
If $g_bAndroidAdbClick = False Or $ReleaseClicksEnabled = False Then
$g_bAndroidAdbKeepClicksActive = False
Return False
EndIf
If $g_aiAndroidAdbClicks[0] > 0 And $g_bRunState = True Then
If $g_aiAndroidAdbClicks[0] >= $minClicksToRelease Then
AndroidClick(Default, Default, $g_aiAndroidAdbClicks[0], 0)
Else
Return False
EndIf
EndIf
$g_bAndroidAdbKeepClicksActive = False
ReDim $g_aiAndroidAdbClicks[1]
$g_aiAndroidAdbClicks[0] = -1
EndFunc
Func AndroidAdbClickSupported()
Return BitAND($g_iAndroidSupportFeature, 4) = 4
EndFunc
Func AndroidClick($x, $y, $times = 1, $speed = 0, $checkProblemAffect = True)
If Not($x = Default) Then $x = Int($x) + $g_aiMouseOffset[0]
If Not($x = Default) Then $y = Int($y) + $g_aiMouseOffset[1]
ForceCaptureRegion()
AndroidFastClick($x, $y, $times, $speed, $checkProblemAffect)
EndFunc
Func AndroidMoveMouseAnywhere()
Local $_SilentSetLog = $g_bSilentSetLog
Local $hostPath = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder
Local $androidPath = $g_sAndroidPicturesPath & StringReplace($g_sAndroidPicturesHostFolder, "\", "/")
Local $sBotTitleEx = StringRegExpReplace($g_sBotTitle, '[/:*?"<>|]', '_')
Local $Filename = GetSecureFilename($sBotTitleEx & ".moveaway")
Local $recordsNum = 4
Local $iToWrite = $recordsNum * 16
Local $records = ""
If FileExists($hostPath & $Filename) = 0 Then
Local $times = 1
Local $x = 1
Local $y = 40
Execute($g_sAndroidEmulator & "AdjustClickCoordinates($x,$y)")
Local $i = 0
Local $record = "byte[16];"
For $i = 1 To $recordsNum * $times
$records &= $record
Next
Local $data = DllStructCreate($records)
$i = 0
DllStructSetData($data, 1 + $i * $recordsNum, Binary("0x000000000000000003003500" & StringRight(Hex($x, 4), 2) & StringLeft(Hex($x, 4), 2) & "0000"))
DllStructSetData($data, 2 + $i * $recordsNum, Binary("0x000000000000000003003600" & StringRight(Hex($y, 4), 2) & StringLeft(Hex($y, 4), 2) & "0000"))
DllStructSetData($data, 3 + $i * $recordsNum, Binary("0x00000000000000000000020000000000"))
DllStructSetData($data, 4 + $i * $recordsNum, Binary("0x00000000000000000000000000000000"))
Local $data2 = DllStructCreate("byte[" & DllStructGetSize($data) & "]", DllStructGetPtr($data))
Local $iWritten = 0
Local $hFileOpen = _WinAPI_CreateFile($hostPath & $Filename, 1, 4)
If $hFileOpen = 0 Then
Local $error = _WinAPI_GetLastError()
Return SetError($error, 0)
EndIf
_WinAPI_WriteFile($hFileOpen, DllStructGetPtr($data2), $iToWrite, $iWritten)
_WinAPI_CloseHandle($hFileOpen)
EndIf
$g_bSilentSetLog = True
AndroidAdbSendShellCommand("dd if=""" & $androidPath & $Filename & """ of=" & $g_sAndroidMouseDevice & " obs=" & $iToWrite & ">/dev/null 2>&1", Default)
If BitAND($g_iAndroidSecureFlags, 2) = 2 Then
FileDelete($hostPath & $Filename)
EndIf
$g_bSilentSetLog = $_SilentSetLog
EndFunc
Func AndroidFastClick($x, $y, $times = 1, $speed = 0, $checkProblemAffect = True, $iRetryCount = 0)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Local $Result = _AndroidFastClick($x, $y, $times, $speed, $checkProblemAffect, $iRetryCount)
$g_bTogglePauseAllowed = $wasAllowed
Return SetError(@error, @extended, $Result)
EndFunc
Func _AndroidFastClick($x, $y, $times = 1, $speed = 0, $checkProblemAffect = True, $iRetryCount = 0)
Local $_SilentSetLog = $g_bSilentSetLog
Local $hDuration = __TimerInit()
If $times < 1 Then Return SetError(0, 0)
Local $i = 0, $j = 0
Local $Click = [$x, $y, "down-up"]
Local $ReleaseClicks =($x = Default And $y = Default And $g_aiAndroidAdbClicks[0] > 0)
If $ReleaseClicks = False And $g_aiAndroidAdbClicks[0] > -1 Then
Local $pos = $g_aiAndroidAdbClicks[0]
$g_aiAndroidAdbClicks[0] = $pos + $times
ReDim $g_aiAndroidAdbClicks[$g_aiAndroidAdbClicks[0] + 1]
For $i = 1 To $times
$g_aiAndroidAdbClicks[$pos + $i] = $Click
Next
If $g_bDebugAndroid Or $g_bDebugClick Then
$g_bSilentSetLog = True
SetDebugLog("Hold back click (" & $x & "/" & $y & " * " & $times & "): queue size = " & $g_aiAndroidAdbClicks[0], $COLOR_ERROR)
$g_bSilentSetLog = $_SilentSetLog
EndIf
Return
EndIf
$x = Int($x)
$y = Int($y)
Local $wasRunState = $g_bRunState
Local $hostPath = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder
Local $androidPath = $g_sAndroidPicturesPath & StringReplace($g_sAndroidPicturesHostFolder, "\", "/")
If $hostPath = "" Or $androidPath = "" Then
If $hostPath = "" Then
SetLog($g_sAndroidEmulator & " shared folder not configured for host", $COLOR_ERROR)
Else
SetLog($g_sAndroidEmulator & " shared folder not configured for Android", $COLOR_ERROR)
EndIf
SetLog($g_sAndroidEmulator & " shared folder not configured for Android", $COLOR_ERROR)
$g_bAndroidAdbClick = False
SetLog("Disabled " & $g_sAndroidEmulator & " ADB fast mouse click", $COLOR_ERROR)
Return SetError(1, 0)
EndIf
AndroidAdbLaunchShellInstance($wasRunState)
Local $sBotTitleEx = StringRegExpReplace($g_sBotTitle, '[/:*?"<>|]', '_')
Local $Filename = GetSecureFilename($sBotTitleEx & ".click")
Local $record = "byte[16];"
Local $records = ""
Local $loops = 1
Local $remaining = 0
Local $adjustSpeed = 0
Local $timer = __TimerInit()
If $times > $g_iAndroidAdbClickGroup Then
$speed = $g_iAndroidAdbClickGroupDelay
$remaining = Mod($times, $g_iAndroidAdbClickGroup)
$loops = Int($times / $g_iAndroidAdbClickGroup) +($remaining > 0 ? 1 : 0)
$times = $g_iAndroidAdbClickGroup
Else
If $ReleaseClicks = False Then $adjustSpeed = $speed
$speed = 0
EndIf
Local $recordsNum = 10
Local $recordsClicks =($times < $g_iAndroidAdbClickGroup ? $times : $g_iAndroidAdbClickGroup)
For $i = 1 To $recordsNum * $recordsClicks
$records &= $record
Next
If $ReleaseClicks = True Then
If $g_bDebugAndroid Or $g_bDebugClick Then SetDebugLog("Release clicks: queue size = " & $g_aiAndroidAdbClicks[0])
Else
Execute($g_sAndroidEmulator & "AdjustClickCoordinates($x,$y)")
EndIf
Local $data = DllStructCreate($records)
For $i = 0 To $recordsClicks - 1
DllStructSetData($data, 1 + $i * $recordsNum, Binary("0x000000000000000001004a0101000000"))
DllStructSetData($data, 2 + $i * $recordsNum, Binary("0x000000000000000003003a0001000000"))
DllStructSetData($data, 5 + $i * $recordsNum, Binary("0x00000000000000000000020000000000"))
DllStructSetData($data, 6 + $i * $recordsNum, Binary("0x00000000000000000000000000000000"))
DllStructSetData($data, 7 + $i * $recordsNum, Binary("0x000000000000000001004a0100000000"))
DllStructSetData($data, 8 + $i * $recordsNum, Binary("0x000000000000000003003a0000000000"))
DllStructSetData($data, 9 + $i * $recordsNum, Binary("0x00000000000000000000020000000000"))
DllStructSetData($data, 10 + $i * $recordsNum, Binary("0x00000000000000000000000000000000"))
Next
Local $AdbStatsType = 1
Local $data2 = DllStructCreate("byte[" & DllStructGetSize($data) & "]", DllStructGetPtr($data))
Local $hFileOpen = 0
Local $iToWrite = DllStructGetSize($data2)
Local $iWritten = 0
Local $sleep = ""
Local $timeSlept = 0
If $speed > 0 Then
$sleep = "/system/xbin/sleep " &($speed / 1000)
EndIf
For $i = 1 To $loops
If IsKeepClicksActive(False) = False Then
If $checkProblemAffect = True Then
If isProblemAffect(True) Then
SetDebugLog("VOIDED Click " & $x & "," & $y & "," & $times & "," & $speed, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
Return
EndIf
EndIf
EndIf
If $i = $loops And $remaining > 0 Then
$iToWrite =(16 * $recordsNum) * $remaining
$recordsClicks = $remaining
$hFileOpen = 0
ElseIf $ReleaseClicks = True Then
$hFileOpen = 0
EndIf
If $hFileOpen = 0 Then
Local $timer = __TimerInit()
While $hFileOpen = 0 And __TimerDiff($timer) < 3000
$hFileOpen = _WinAPI_CreateFile($hostPath & $Filename, 1, 4)
If $hFileOpen <> 0 Then ExitLoop
SetDebugLog("Error " & _WinAPI_GetLastError() & " (" & Round(__TimerDiff($timer)) & "ms) creating " & $hostPath & $Filename, $COLOR_ERROR)
Sleep(10)
WEnd
If $hFileOpen = 0 Then
Local $error = _WinAPI_GetLastError()
SetLog("Error creating " & $hostPath & $Filename, $COLOR_ERROR)
SetError($error)
ExitLoop
EndIf
For $j = 0 To $recordsClicks - 1
Local $BTN_TOUCH_DOWN = True
Local $BTN_TOUCH_UP = True
If $ReleaseClicks = True Then
$Click = $g_aiAndroidAdbClicks[($i - 1) * $recordsNum + $j + 1]
$x = $Click[0]
$y = $Click[1]
Execute($g_sAndroidEmulator & "AdjustClickCoordinates($x,$y)")
Local $up_down = $Click[2]
$BTN_TOUCH_DOWN = StringInStr($up_down, "down") > 0
$BTN_TOUCH_UP = StringInStr($up_down, "up") > 0
EndIf
If $BTN_TOUCH_DOWN Then
Else
DllStructSetData($data, 1 + $j * $recordsNum, Binary("0x00000000000000000000020000000000"))
DllStructSetData($data, 2 + $j * $recordsNum, Binary("0x00000000000000000000000000000000"))
EndIf
DllStructSetData($data, 3 + $j * $recordsNum, Binary("0x000000000000000003003500" & StringRight(Hex($x, 4), 2) & StringLeft(Hex($x, 4), 2) & "0000"))
DllStructSetData($data, 4 + $j * $recordsNum, Binary("0x000000000000000003003600" & StringRight(Hex($y, 4), 2) & StringLeft(Hex($y, 4), 2) & "0000"))
If $BTN_TOUCH_UP Then
Else
DllStructSetData($data, 7 + $j * $recordsNum, Binary("0x00000000000000000000020000000000"))
DllStructSetData($data, 8 + $j * $recordsNum, Binary("0x00000000000000000000000000000000"))
EndIf
Next
_WinAPI_WriteFile($hFileOpen, DllStructGetPtr($data2), $iToWrite, $iWritten)
If $hFileOpen = 0 Then
Local $error = _WinAPI_GetLastError()
SetLog("Error writing " & $hostPath & $Filename, $COLOR_ERROR)
SetError($error)
ExitLoop
EndIf
_WinAPI_CloseHandle($hFileOpen)
EndIf
If $loops > 1 Then
AndroidMoveMouseAnywhere()
EndIf
$g_bSilentSetLog = True
AndroidAdbSendShellCommand("dd if=""" & $androidPath & $Filename & """ of=" & $g_sAndroidMouseDevice & " obs=" & $iToWrite & ">/dev/null 2>&1", Default)
If BitAND($g_iAndroidSecureFlags, 2) = 2 Then
FileDelete($hostPath & $Filename)
EndIf
$g_bSilentSetLog = $_SilentSetLog
Local $sleepTimer = __TimerInit()
If $speed > 0 Then
Local $sleepTime = $speed - __TimerDiff($sleepTimer)
If $sleepTime > 0 Then _Sleep($sleepTime, False)
EndIf
If $adjustSpeed > 0 Then
Local $wait = Round($adjustSpeed - __TimerDiff($timer))
If $wait > 0 Then
If $g_bDebugAndroid Or $g_bDebugClick Then
$g_bSilentSetLog = True
SetDebugLog("AndroidFastClick: Sleep " & $wait & " ms.")
$g_bSilentSetLog = $_SilentSetLog
EndIf
_Sleep($wait, False)
EndIf
EndIf
$timeSlept += __TimerDiff($sleepTimer)
If $g_bRunState = False Then ExitLoop
If $__TEST_ERROR_SLOW_ADB_CLICK_DELAY > 0 Then Sleep($__TEST_ERROR_SLOW_ADB_CLICK_DELAY)
Next
If @error <> 0 Then
Local $error = @error
If $iRetryCount < 10 Then
SetError(0, 0, 0)
SetDebugLog("ADB retry sending mouse click in 1000 ms. (restarting ADB session)", $COLOR_ACTION)
_Sleep(1000)
AndroidAdbTerminateShellInstance()
AndroidAdbLaunchShellInstance($wasRunState)
Return AndroidFastClick($x, $y, $times, $speed, $checkProblemAffect, $iRetryCount + 1)
EndIf
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] < 10 Then
SetLog("Disabled " & $g_sAndroidEmulator & " ADB fast mouse click due to error " & $error & " (#Err0004)", $COLOR_ERROR)
$g_bAndroidAdbClick = False
Else
SetLog("Rebooting " & $g_sAndroidEmulator & " due to problems sending mouse click", $COLOR_ERROR)
Local $_NoFocusTampering = $g_bNoFocusTampering
$g_bNoFocusTampering = True
RebootAndroid()
$g_bNoFocusTampering = $_NoFocusTampering
EndIf
Return SetError($error, 0)
EndIf
If IsKeepClicksActive(False) = False Then
$g_iAndroidAdbScreencapTimer = 0
EndIf
Local $duration = Round((__TimerDiff($hDuration) - $timeSlept) / $loops)
$g_aiAndroidAdbStatsTotal[$AdbStatsType][0] += 1
$g_aiAndroidAdbStatsTotal[$AdbStatsType][1] += $duration
Local $iLastCount = UBound($g_aiAndroidAdbStatsLast, 2) - 2
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] <= $iLastCount Then
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] += $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][$g_aiAndroidAdbStatsTotal[$AdbStatsType][0] + 1] = $duration
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] = $iLastCount Then $g_aiAndroidAdbStatsLast[$AdbStatsType][1] = 0
Else
Local $iLastIdx = $g_aiAndroidAdbStatsLast[$AdbStatsType][1] + 2
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] -= $g_aiAndroidAdbStatsLast[$AdbStatsType][$iLastIdx]
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] += $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][$iLastIdx] = $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][1] = Mod($g_aiAndroidAdbStatsLast[$AdbStatsType][1] + 1, $iLastCount)
EndIf
If $g_aiAndroidAdbStatsLast[$AdbStatsType][1] = 0 Then
Local $totalAvg = Round($g_aiAndroidAdbStatsTotal[$AdbStatsType][1] / $g_aiAndroidAdbStatsTotal[$AdbStatsType][0])
Local $lastAvg = Round($g_aiAndroidAdbStatsLast[$AdbStatsType][0] / $iLastCount)
If $g_bDebugAndroid Or $g_bDebugClick Or Mod($g_aiAndroidAdbStatsTotal[$AdbStatsType][0], 100) = 0 Then
SetDebugLog("AndroidFastClick: " & $totalAvg & "/" & $lastAvg & "/" & $duration & " ms (all/" & $iLastCount & "/1), $x=" & $x & ", $y=" & $y & ", $times=" & $times & ", $speed = " & $speed & ", $checkProblemAffect=" & $checkProblemAffect)
EndIf
EndIf
EndFunc
Func AndroidSendText($sText, $SymbolFix = False, $wasRunState = $g_bRunState)
AndroidAdbLaunchShellInstance($wasRunState)
Local $error = @error
If $error = 0 Then
Local $newText = $sText
StringRegExpReplace($newText, "[^A-Za-z0-9\.,\?""!@#\$%\^&\*\(\)-_=\+;:<>\/\\\|\}\{\[\]'~ ]", ".")
If @extended <> 0 Then
If $SymbolFix = False Then SetDebugLog("Cannot use ADB to send input text, use Windows method", $COLOR_ERROR)
Return SetError(10, 0)
EndIf
If $SymbolFix = False Then
If $g_iAndroidAdbInputWordsCharLimit = 0 Then
$newText = StringRegExpReplace($newText, "([\\\?""\$\^&\*\(\)\+<>\|'~;])", "\\$1")
$newText = StringReplace($newText, " ", "%s")
AndroidAdbSendShellCommand("input text " & $newText, Default, $wasRunState)
Else
Local $words = StringSplit($newText, " ")
Local $i, $word, $newWord
For $i = 1 To $words[0]
$word = $words[$i]
While StringLen($word) > 0
$newWord = StringRegExpReplace(StringLeft($word, $g_iAndroidAdbInputWordsCharLimit), "([\\\?""\$\^&\*\(\)\+<>\|'~;])", "\\$1")
AndroidAdbSendShellCommand("input text " & $newWord, Default, $wasRunState)
$word = StringMid($word, $g_iAndroidAdbInputWordsCharLimit + 1)
WEnd
If $i < $words[0] Then AndroidAdbSendShellCommand("input text %s", Default, $wasRunState)
Next
EndIf
Else
AndroidAdbSendShellCommand("input text %s", Default, $wasRunState)
EndIf
SetError(0, 0)
Else
If $SymbolFix = False Then
SetDebugLog("Disabled " & $g_sAndroidEmulator & " ADB input due to error", $COLOR_ERROR)
$g_bAndroidAdbInput = False
EndIf
Return SetError($error, 0)
EndIf
EndFunc
Func AndroidInputSwipe($x1, $y1, $x2, $y2, $wasRunState = $g_bRunState)
AndroidAdbLaunchShellInstance($wasRunState)
If @error = 0 Then
AndroidAdbSendShellCommand("input swipe " & $x1 & " " & $y1 & " " & $x2 & " " & $y2 & ";input tap " & $x2 & " " & $y2, Default, $wasRunState)
SetError(0, 0)
Else
Local $error = @error
SetDebugLog("Disabled " & $g_sAndroidEmulator & " ADB input due to error", $COLOR_ERROR)
$g_bAndroidAdbInput = False
Return SetError($error, 0)
EndIf
EndFunc
Func SuspendAndroidTime($Action = False)
If IsBool($Action) And $Action = True Then
Local $iTime = $g_iSuspendAndroidTime
$g_iSuspendAndroidTime = 0
$g_iSuspendAndroidTimeCount = 0
$g_hSuspendAndroidTimer = 0
Return $iTime
ElseIf $Action = False Then
Return $g_iSuspendAndroidTime
EndIf
If $g_hSuspendAndroidTimer = 0 Then
ElseIf $Action = "Stats" Then
SetDebugLog("SuspendAndroidTime: Time = " & $g_iSuspendAndroidTime & ", Count = " & $g_iSuspendAndroidTimeCount)
Else
Local $iSuspendTime =(_HPTimerDiff($g_hSuspendAndroidTimer) - 50)
If $iSuspendTime > 0 Then
$g_iSuspendAndroidTime += $iSuspendTime
$g_iSuspendAndroidTimeCount += 1
EndIf
$g_hSuspendAndroidTimer = 0
EndIf
If $Action = "Start" Then $g_hSuspendAndroidTimer = _HPTimerInit()
Return $g_iSuspendAndroidTime
EndFunc
Func SuspendAndroid($SuspendMode = True, $bDebugLog = Default, $bForceSuspendAndroid = False)
If $bDebugLog = Default Then $bDebugLog = $g_bDebugAndroid
If($g_bAndroidSuspendedEnabled = False Or $g_iAndroidSuspendModeFlags = 0 Or $g_bMainWindowOk = False) And $bForceSuspendAndroid = False Then Return False
If $SuspendMode = False Then Return ResumeAndroid($bDebugLog, $bForceSuspendAndroid)
If $g_bAndroidSuspended = True Then Return True
Local $bSuspendProcess = BitAND($g_iAndroidSuspendModeFlags, 4) = 0
If $bSuspendProcess = True Then
If $g_iAndroidCoCPid = 0 Then $g_iAndroidCoCPid = GetAndroidProcessPID(Default, False)
If $g_iAndroidCoCPid = 0 Then
SuspendAndroidTime(True)
Return False
EndIf
Local $s = AndroidAdbSendShellCommand("kill -STOP " & $g_iAndroidCoCPid, 0)
If StringInStr($s, "No such process") > 0 Then
$g_iAndroidCoCPid = GetAndroidProcessPID(Default, False)
If $g_iAndroidCoCPid = 0 Then
SuspendAndroidTime(True)
Return False
EndIf
$s = AndroidAdbSendShellCommand("kill -STOP " & $g_iAndroidCoCPid, 0)
EndIf
$g_bAndroidSuspended = True
Else
Local $pid = GetAndroidSvcPid()
If $pid = -1 Or $pid = 0 Then $pid = GetAndroidPid()
If $pid = -1 Or $pid = 0 Then
SuspendAndroidTime(True)
Return False
EndIf
$g_bAndroidSuspended = True
_ProcessSuspendResume($pid, True)
$g_iAndroidSuspendedTimer = __TimerInit()
EndIf
SuspendAndroidTime("Start")
If $bDebugLog = True Then SetDebugLog("Android Suspended")
Return False
EndFunc
Func ResumeAndroid($bDebugLog = Default, $bForceSuspendAndroid = False)
If $bDebugLog = Default Then $bDebugLog = $g_bDebugAndroid
If($g_bAndroidSuspendedEnabled = False Or $g_iAndroidSuspendModeFlags = 0) And $bForceSuspendAndroid = False Then Return False
If $g_bAndroidSuspended = False Then Return False
Local $bSuspendProcess = BitAND($g_iAndroidSuspendModeFlags, 4) = 0
SuspendAndroidTime("Stop")
If $bSuspendProcess = True Then
$g_bAndroidSuspended = False
If $g_iAndroidCoCPid = 0 Then $g_iAndroidCoCPid = GetAndroidProcessPID(Default, False)
If $g_iAndroidCoCPid = 0 Then
SuspendAndroidTime(True)
Return False
EndIf
Local $s = AndroidAdbSendShellCommand("kill -CONT " & $g_iAndroidCoCPid)
If StringInStr($s, "No such process") > 0 Then
$g_iAndroidCoCPid = GetAndroidProcessPID(Default, False)
If $g_iAndroidCoCPid = 0 Then
SuspendAndroidTime(True)
Return False
EndIf
$s = AndroidAdbSendShellCommand("kill -CONT " & $g_iAndroidCoCPid)
EndIf
If $bDebugLog = True Then SetDebugLog("Android Resumed")
Else
Local $pid = GetAndroidSvcPid()
If $pid = -1 Or $pid = 0 Then $pid = GetAndroidPid()
If $pid = -1 Or $pid = 0 Then
SuspendAndroidTime(True)
Return False
EndIf
$g_bAndroidSuspended = False
_ProcessSuspendResume($pid, False)
$g_aiAndroidTimeLag[3] += __TimerDiff($g_iAndroidSuspendedTimer)
If $bDebugLog = True Then SetDebugLog("Android Resumed (total time " & Round($g_aiAndroidTimeLag[3]) & " ms)")
EndIf
Return True
EndFunc
Func AndroidCloseSystemBar()
If AndroidInvalidState() Then Return False
Local $wasRunState = $g_bRunState
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then
SetLog("Cannot close " & $g_sAndroidEmulator & " System Bar", $COLOR_ERROR)
Return False
EndIf
Local $cmdOutput = AndroidAdbSendShellCommand("service call activity 42 s16 com.android.systemui", Default, $wasRunState, False)
Local $Result = StringLeft($cmdOutput, 6) = "Result"
SetDebugLog("Closed " & $g_sAndroidEmulator & " System Bar: " & $Result)
Return $Result
EndFunc
Func AndroidOpenSystemBar($bZygote = False)
If AndroidInvalidState() Then Return False
Local $wasRunState = $g_bRunState
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then
SetLog("Cannot open " & $g_sAndroidEmulator & " System Bar", $COLOR_ERROR)
Return False
EndIf
Local $cmdOutput
Local $Result
If $bZygote = True Then
$cmdOutput = AndroidAdbSendShellCommand("setprop ctl.restart zygote", Default, $wasRunState, False)
$Result = $cmdOutput = ""
Else
$cmdOutput = AndroidAdbSendShellCommand("am startservice -n com.android.systemui/.SystemUIService", Default, $wasRunState, False)
$Result = StringLeft($cmdOutput, 16) = "Starting service"
SetDebugLog("Opened " & $g_sAndroidEmulator & " System Bar: " & $Result)
EndIf
Return $Result
EndFunc
Func RedrawAndroidWindow()
Local $Result = Execute("Redraw" & $g_sAndroidEmulator & "Window()")
If $Result = "" And @error <> 0 Then
_WinAPI_RedrawWindow($g_hAndroidWindow, 0, 0, $RDW_INVALIDATE + $RDW_ALLCHILDREN)
_WinAPI_SetWindowPos($g_hAndroidWindow, 0, 0, 0, 0, 0, BitOR($SWP_NOMOVE, $SWP_NOSIZE, $SWP_FRAMECHANGED))
_WinAPI_UpdateWindow($g_hAndroidWindow)
EndIf
Return $Result
EndFunc
Func AndroidQueueReboot($bQueueReboot = True)
$g_bAndroidQueueReboot = $bQueueReboot
EndFunc
Func AndroidInvalidState()
If $g_hAndroidWindow = 0 Then
SetDebugLog("AndroidInvalidState: No Window Handle", $COLOR_ERROR)
Return True
EndIf
If IsHWnd($g_hAndroidWindow) And WinGetHandle($g_hAndroidWindow, "") = 0 Then
SetDebugLog("AndroidInvalidState: Window Handle " & $g_hAndroidWindow & " doesn't exist", $COLOR_ERROR)
Return True
EndIf
If IsHWnd($g_hAndroidWindow) = False And IsNumber($g_hAndroidWindow) And $g_bAndroidBackgroundLaunched = False Then
SetDebugLog("AndroidInvalidState: PID " & $g_hAndroidWindow & " not supported for Headless Mode", $COLOR_ERROR)
Return True
EndIf
If $g_bAndroidBackgroundLaunched = True And ProcessExists2($g_hAndroidWindow) = 0 Then
SetDebugLog("AndroidInvalidState: PID " & $g_hAndroidWindow & " doesn't exist", $COLOR_ERROR)
Return True
EndIf
Return False
EndFunc
Func CheckAndroidReboot($bRebootAndroid = True)
If CheckAndroidTimeLag($bRebootAndroid) = True Or CheckAndroidPageError($bRebootAndroid) = True Or CheckAndroidRebootCondition($bRebootAndroid) = True Then
Local $_NoFocusTampering = $g_bNoFocusTampering
$g_bNoFocusTampering = True
RebootAndroid()
$g_bNoFocusTampering = $_NoFocusTampering
Return True
EndIf
Return False
EndFunc
Func GetAndroidProcessPID($sPackage = Default, $bForeground = True)
If $sPackage = Default Then $sPackage = $g_sAndroidGamePackage
If AndroidInvalidState() Then Return 0
Local $cmd = "set result=$(ps -p|grep """ & $g_sAndroidGamePackage & """ >&2)"
Local $output = AndroidAdbSendShellCommand($cmd)
$output = StringStripWS($output, 7)
Local $aPkgList[0][26]
Local $iCols
_ArrayAdd($aPkgList, $output, 0, " ", @LF, $ARRAYFILL_FORCE_STRING)
For $i = 1 To UBound($aPkgList)
$iCols = _ArraySearch($aPkgList, "", 0, 0, 0, 0, 1, $i, True)
If $iCols > 9 And $aPkgList[$i - 1][$iCols - 1] = $g_sAndroidGamePackage Then
If $bForeground = True And $aPkgList[$i - 1][8] <> "0" Then
SetDebugLog("Android process " & $sPackage & " not running in foreground")
Return 0
EndIf
Return Int($aPkgList[$i - 1][1])
EndIf
Next
SetDebugLog("Android process " & $sPackage & " not running")
Return 0
EndFunc
Func AndroidToFront($hHWndAfter = Default, $sSource = "Unknown")
If $hHWndAfter = Default Then $hHWndAfter = $HWND_TOPMOST
SetDebugLog("AndroidToFront: Source " & $sSource)
WinMove2(GetAndroidDisplayHWnD(), "", -1, -1, -1, -1, $hHWndAfter, 0, False)
If $g_bChkBackgroundMode And($hHWndAfter = $HWND_TOPMOST Or $hHWndAfter = $HWND_TOP) Then WinMove2(GetAndroidDisplayHWnD(), "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
EndFunc
Func ShowAndroidWindow($hHWndAfter = Default, $bRestorePosAndActivateWindow = Default, $bFastCheck = Default, $sSource = "Unknown")
Return HideAndroidWindow(False, $bRestorePosAndActivateWindow, $bFastCheck, $sSource & "->ShowAndroidWindow", $hHWndAfter)
EndFunc
Func HideAndroidWindow($bHide = True, $bRestorePosAndActivateWhenShow = Default, $bFastCheck = Default, $sSource = "Unknown", $hHWndAfter = Default)
If $bFastCheck = Default Then $bFastCheck = True
If $hHWndAfter = Default Then $hHWndAfter = $HWND_TOPMOST
SetDebugLog("HideAndroidWindow: " & $bHide & ", " & $bRestorePosAndActivateWhenShow & ", " & $bFastCheck & ", " & $sSource)
ResumeAndroid()
SetError(0)
If $bFastCheck Then
If Not IsHWnd($g_hAndroidWindow) Then SetError(1)
Else
WinGetAndroidHandle()
WinGetPos($g_hAndroidWindow)
EndIf
If @error <> 0 Or AndroidEmbedded() Then Return SetError(0, 0, 0)
If $bHide = True Then
WinMove($g_hAndroidWindow, "", -32000, -32000)
ElseIf $bHide = False Then
Switch $bRestorePosAndActivateWhenShow
Case True
WinMove($g_hAndroidWindow, "", $g_iAndroidPosX, $g_iAndroidPosY)
WinActivate($g_hAndroidWindow)
Case False
Local $a = WinGetPos($g_hAndroidWindow)
If UBound($a) > 1 And($a[0] < -30000 Or $a[1] < -30000) Then WinMove($g_hAndroidWindow, "", $g_iAndroidPosX, $g_iAndroidPosY)
_WinAPI_ShowWindow($g_hAndroidWindow, @SW_SHOWNOACTIVATE)
Case Default
Local $a = WinGetPos($g_hAndroidWindow)
If UBound($a) > 1 And($a[0] <> $g_iAndroidPosX Or $a[1] <> $g_iAndroidPosY) Then WinMove($g_hAndroidWindow, "", $g_iAndroidPosX, $g_iAndroidPosY)
EndSwitch
If $hHWndAfter <> $g_hAndroidWindow Then AndroidToFront($hHWndAfter, $sSource & "->HideAndroidWindow")
EndIf
Execute("Hide" & $g_sAndroidEmulator & "Window($bHide, $hHWndAfter)")
SetError(0)
EndFunc
Func AndroidPicturePathAutoConfig($myPictures = Default, $subDir = Default, $bSetLog = Default)
If $subDir = Default Then $subDir = $g_sAndroidEmulator & " Photo"
If $bSetLog = Default Then $bSetLog = True
Local $Result = False
Local $path
If $g_bAndroidPicturesPathAutoConfig = True Then
If $g_sAndroidPicturesHostPath = "" Then
If $myPictures = Default Then $myPictures = RegRead("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\", "My Pictures")
If @error = 0 And FileExists($myPictures) = 1 Then
If $subDir <> "" Then $subDir = "\" & $subDir
$path = $myPictures & $subDir
If StringRight($path, 1) <> "\" Then $path &= "\"
If FileExists($path) = 1 Then
$g_sAndroidPicturesHostPath = $path
SetGuiLog("Shared folder: '" & $g_sAndroidPicturesHostPath & "' will be added to " & $g_sAndroidEmulator, $COLOR_SUCCESS, $bSetLog)
$Result = True
ElseIf DirCreate($path) = 1 Then
$g_sAndroidPicturesHostPath = $path
SetGuiLog("Configure " & $g_sAndroidEmulator & " to support shared folder", $COLOR_SUCCESS, $bSetLog)
SetGuiLog("Folder created: " & $path, $COLOR_SUCCESS, $bSetLog)
SetGuiLog("This shared folder will be added to " & $g_sAndroidEmulator, $COLOR_SUCCESS, $bSetLog)
$Result = True
Else
SetGuiLog("Cannot configure " & $g_sAndroidEmulator & " shared folder", $COLOR_SUCCESS, $bSetLog)
SetGuiLog("Cannot create folder: " & $path, $COLOR_ERROR, $bSetLog)
$g_bAndroidPicturesPathAutoConfig = False
EndIf
Else
SetGuiLog("Cannot configure " & $g_sAndroidEmulator & " shared folder", $COLOR_SUCCESS, $bSetLog)
SetGuiLog("Cannot find current user 'My Pictures' folder", $COLOR_ERROR, $bSetLog)
$g_bAndroidPicturesPathAutoConfig = False
EndIf
Else
$path = $g_sAndroidPicturesHostPath
If FileExists($path) = 1 Then
ElseIf DirCreate($path) = 1 Then
SetGuiLog("Shared folder created: " & $path, $COLOR_SUCCESS, $bSetLog)
Else
SetGuiLog("Cannot configure " & $g_sAndroidEmulator & " shared folder", $COLOR_SUCCESS, $bSetLog)
SetGuiLog("Cannot create folder: " & $path, $COLOR_ERROR, $bSetLog)
$g_bAndroidPicturesPathAutoConfig = False
EndIf
EndIf
EndIf
Return $Result
EndFunc
Func OpenAdbShell($bRunInitScript = True)
CheckAndroidRunning(True, True, True)
If ConnectAndroidAdb(True, True) = False Then
SetLog("Cannot open ADB shell, ADB connection not available", $COLOR_ERROR)
Return 0
EndIf
Local $iPid = ShellExecute($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " shell")
SetLog("Launched ADB Shell, PID=" & $iPid & ": """ & $g_sAndroidAdbPath & """ -s " & $g_sAndroidAdbDevice & " shell")
Local $hWnd = 0
Local $hTimer = __TimerInit()
Do
If $hWnd = 0 Then _Sleep(100, True, False)
Local $winlist = WinList()
For $i = 1 To $winlist[0][0]
If $winlist[$i][0] <> "" Then
If WinGetProcess($winlist[$i][1]) = $iPid Then
$hWnd = $winlist[$i][1]
SetDebugLog("Launched ADB Shell, found Window Handle " & $hWnd)
ExitLoop
EndIf
EndIf
Next
Until $hWnd <> 0 Or __TimerDiff($hTimer) > 3000
If $hWnd <> 0 Then
_WinAPI_SetWindowText($hWnd, "ADB Shell: " & $g_sAndroidEmulator & " (" & $g_sAndroidInstance & "), Device = " & $g_sAndroidAdbDevice)
_WinAPI_SetConsoleIcon($g_sLibIconPath, $eIcnGUI, $hWnd)
EndIf
If $hWnd <> 0 And $g_iAndroidAdbSuCommand <> "" Then
ControlSend($hWnd, "", "", "{ENTER}")
SetLog("Send Shell command: " & $g_iAndroidAdbSuCommand)
ControlSend($hWnd, "", "", $g_iAndroidAdbSuCommand & "{ENTER}")
EndIf
Return $iPid
EndFunc
Func OpenPlayStore($sPackage)
CheckAndroidRunning(True, True, True)
If ConnectAndroidAdb(True, True) = False Then
SetLog("Cannot open Play Store, ADB connection not available", $COLOR_ERROR)
Return 0
EndIf
SetLog("Open Play Store App '" & $sPackage & "'", $COLOR_INFO)
AndroidAdbSendShellCommand("am start -a android.intent.action.VIEW -d 'market://details?id=" & $sPackage & "'")
EndFunc
Func OpenPlayStoreGame()
Return OpenPlayStore($g_sUserGamePackage)
EndFunc
Func OpenPlayStoreNovaLauncher()
Return OpenPlayStore("com.teslacoilsw.launcher")
EndFunc
Func LaunchAndroid($sProgramPath, $sCmdParam, $sPath, $iWaitInSecAfterLaunch = Default, $bStopIfLaunchFails = True)
If $iWaitInSecAfterLaunch = Default Then $iWaitInSecAfterLaunch = 10
If $sCmdParam And StringLeft($sCmdParam, 1) <> " " Then
$sCmdParam = " " & $sCmdParam
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
Local $pid = 0
For $i = 1 To 3
SetDebugLog("LaunchAndroid: " & $sProgramPath & $sCmdParam)
$pid = Run($sProgramPath & $sCmdParam, $sPath)
If _Sleep(3000) Then Return False
If $pid <> 0 Then $pid = ProcessExists($pid)
If $pid <> 0 Then ExitLoop
Next
SetDebugLog("$PID= " & $pid)
If $pid = 0 And $bStopIfLaunchFails = True Then
SetLog("Unable to load " & $g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : "(" & $g_sAndroidInstance & ")") & ", please check emulator/installation.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnStop()
SetError(1, 1, -1)
Return 0
EndIf
If $iWaitInSecAfterLaunch > 0 Then
_SleepStatus($iWaitInSecAfterLaunch * 1000)
EndIf
Return $pid
EndFunc
Func UpdateAndroidBackgroundMode()
Local $iMode =(($g_iAndroidBackgroundMode = 0) ?($g_iAndroidBackgroundModeDefault) :($g_iAndroidBackgroundMode))
Local $iBackgroundMode = Execute("Get" & $g_sAndroidEmulator & "BackgroundMode()")
If $iBackgroundMode = "" And @error <> 0 Then
Local $sMode = "Unknown"
Switch $iMode
Case $g_iAndroidBackgroundModeDirectX
$sMode = "DirectX/WinAPI"
Case $g_iAndroidBackgroundModeOpenGL
$sMode = "OpenGL/ADB screencap"
EndSwitch
SetLog($g_sAndroidEmulator & " DirectX/OpenGL cannot be detected")
SetLog("Using " & $sMode & " for Background Mode")
Else
Local $sGraphicsEngine = "Unknown"
Switch $iBackgroundMode
Case $g_iAndroidBackgroundModeDirectX
$sGraphicsEngine = "DirectX"
SetDebugLog($g_sAndroidEmulator & " (" & $g_sAndroidInstance & ") is using DirectX, enable WinAPI for Background Mode")
AndroidSupportFeaturesSet(1)
Case $g_iAndroidBackgroundModeOpenGL
$sGraphicsEngine = "OpenGL"
SetDebugLog($g_sAndroidEmulator & " (" & $g_sAndroidInstance & ") is using OpenGL, disable WinAPI for Background Mode")
AndroidSupportFeaturesRemove(1)
Case Else
$iMode = $g_iAndroidBackgroundModeDefault
Local $sMode = "Unknown"
Switch $iMode
Case $g_iAndroidBackgroundModeDirectX
$sMode = "DirectX/WinAPI"
Case $g_iAndroidBackgroundModeOpenGL
$sMode = "OpenGL/ADB screencap"
EndSwitch
SetLog($g_sAndroidEmulator & " (" & $g_sAndroidInstance & ") unsupported Graphics Engine / Render Mode, using " & $sMode, $COLOR_WARNING)
EndSwitch
EndIf
Switch $iMode
Case 1
If BitAND($g_iAndroidSupportFeature, 1) = 0 Then
If BitAND($g_iAndroidSupportFeature, 2) > 0 Then
SetLog("Android DirectX not available, using ADB screencap for background capture", $COLOR_WARNING)
Else
SetLog("Android DirectX and ADB screencap not available, Background Mode not supported", $COLOR_ERROR)
EndIf
Else
SetDebugLog("Disable ADB screencap, using WinAPI DirectX for Background Mode")
$g_bAndroidAdbScreencap = False
EndIf
Case 2
If $g_bAndroidAdbScreencapEnabled <> True Or $g_bAndroidSharedFolderAvailable <> True Then
SetLog("Android ADB screencap disabled, please check Android Options", $COLOR_ERROR)
Else
If BitAND($g_iAndroidSupportFeature, 2) = 0 Then
If BitAND($g_iAndroidSupportFeature, 1) > 0 Then
SetLog("Android ADB screencap not available, using WinAPI for background capture", $COLOR_WARNING)
Else
SetLog("Android ADB screencap and DirectX not available, Background Mode not supported", $COLOR_ERROR)
EndIf
Else
SetDebugLog("Enable ADB screencap for Background Mode")
$g_bAndroidAdbScreencap = $g_bAndroidAdbScreencapEnabled = True And BitAND($g_iAndroidSupportFeature, 2) = 2
EndIf
EndIf
Case Else
SetLog("Unsupported Android Background Mode " & $iMode, $COLOR_ERROR)
EndSwitch
UpdateChkBackground()
EndFunc
Func GetAndroidCodeName($iAPI = $g_iAndroidVersionAPI)
If $iAPI >= $g_iAndroidNougat Then Return "Nougat"
If $iAPI >= $g_iAndroidLollipop Then Return "Lollipop"
If $iAPI >= $g_iAndroidJellyBean Then Return "JellyBean"
SetDebugLog("Unsupport Android API Version: " & $iAPI, $COLOR_ERROR)
Return ""
EndFunc
Func HaveSharedPrefs($sProfile = $g_sProfileCurrentName, $BothNewOrOld = Default, $bReturnArray = False)
If $sProfile = Default Then $sProfile = $g_sProfileCurrentName
If Not $bReturnArray Then
Return(($BothNewOrOld = Default Or $BothNewOrOld = True) And UBound(_FileListToArray($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", "*", $FLTA_FILES)) > 1) Or(($BothNewOrOld = Default Or $BothNewOrOld = False) And UBound(_FileListToArray($g_sProfilePath & "\" & $sProfile & "\shared_prefs", "*", $FLTA_FILES)) > 1)
EndIf
Local $aFiles
If $BothNewOrOld = Default Or $BothNewOrOld = True Then
$aFiles = _FileListToArray($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", "*", $FLTA_FILES, True)
EndIf
If($BothNewOrOld = Default And UBound($aFiles) < 2) Or $BothNewOrOld = False Then
$aFiles = _FileListToArray($g_sProfilePath & "\" & $sProfile & "\shared_prefs", "*", $FLTA_FILES, True)
EndIf
If UBound($aFiles) < 1 Then Local $aFiles = [0]
Return SetError(0, 0, $aFiles)
EndFunc
Func PullSharedPrefs($sProfile = $g_sProfileCurrentName)
Local $process_killed
DirCreate($g_sPrivateProfilePath & "\" & $sProfile)
Local $cmdOutput
Local $Result = False
Local $iFiles = 5
Local $iFilesPulled = 0
SetDebugLog("Pulling shared_pref of profile " & $sProfile)
DirRemove($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs_tmp", 1)
DirMove($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", $g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs_tmp")
If FileExists($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs") Then
SetLog("Cannot rename " & $g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", $COLOR_ERROR)
SetLog("Error pulling shared_prefs of profile " & $sProfile, $COLOR_ERROR)
Return SetError(0, 0, $Result)
EndIf
If $g_bPullPushSharedPrefsAbdCommand Then
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " pull /data/data/" & $g_sAndroidGamePackage & "/shared_prefs """ & $g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs""", $process_killed)
Else
$cmdOutput = ""
EndIf
If StringInStr($cmdOutput, "files pulled") > 0 And StringInStr($cmdOutput, @LF & "0 files pulled") = 0 And StringInStr($cmdOutput, "failed to ") = 0 And StringInStr($cmdOutput, "Permission denied") = 0 Then
Local $aRegExResult = StringRegExp($cmdOutput, "(\d+) files pulled", $STR_REGEXPARRAYMATCH)
If Not @error Then
$iFilesPulled = Number($aRegExResult[0])
EndIf
$Result = $iFilesPulled >= $iFiles
If Not $Result Then SetLog("Pulled " & $iFilesPulled & " files of " & $iFiles & " total", $COLOR_ERROR)
Else
If $g_bPullPushSharedPrefsAbdCommand Then SetDebugLog("ADB pull failed, try to use host shared folder")
$cmdOutput = AndroidAdbSendShellCommand("set result=$(ls -l /data/data/" & $g_sAndroidGamePackage & "/shared_prefs/ >&2)")
$iFiles = UBound(Ls_l_FilesOnly(StringSplit($cmdOutput, @LF, $STR_NOCOUNT)))
If $iFiles >= 5 And StringInStr($cmdOutput, "Permission denied") = 0 And StringInStr($cmdOutput, "No such file or directory") = 0 Then
Local $androidFolder = StringReplace($g_sAndroidPicturesPath & $g_sAndroidPicturesHostFolder & $sProfile, " ", "\ ")
AndroidAdbSendShellCommand("set result=$(rm -r " & $androidFolder & " >&2)")
AndroidAdbSendShellCommand("set result=$(mkdir -p " & $androidFolder & "/shared_prefs >&2)")
AndroidAdbSendShellCommand("set result=$(cp /data/data/" & $g_sAndroidGamePackage & "/shared_prefs/* " & $androidFolder & "/shared_prefs >&2)")
$cmdOutput = AndroidAdbSendShellCommand("set result=$(ls -l " & $androidFolder & "/shared_prefs/ >&2)")
$iFilesPulled = UBound(Ls_l_FilesOnly(StringSplit($cmdOutput, @LF, $STR_NOCOUNT)))
If $iFilesPulled >= $iFiles And StringInStr($cmdOutput, "Permission denied") = 0 And StringInStr($cmdOutput, "No such file or directory") = 0 Then
Local $hostFolder = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder & $sProfile
$iFilesPulled = UBound(_FileListToArray($hostFolder & "\shared_prefs", "*", $FLTA_FILES)) - 1
If $iFilesPulled >= $iFiles Then
FileDelete($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs")
DirRemove($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", 1)
DirCreate($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs")
If FileCopy($hostFolder & "\shared_prefs\*", $g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", $FC_OVERWRITE) And UBound(_FileListToArray($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", "*", $FLTA_FILES)) - 1 >= $iFiles Then
AndroidAdbSendShellCommand("set result=$(rm -r " & $androidFolder & " >&2)")
$Result = True
Else
SetLog("Cannot copy shared_prefs to " & $g_sPrivateProfilePath & "\" & $sProfile, $COLOR_ERROR)
EndIf
Else
SetLog("Cannot copy shared_prefs to " & $hostFolder, $COLOR_ERROR)
EndIf
Else
SetLog("Cannot copy shared_prefs to " & $androidFolder, $COLOR_ERROR)
EndIf
Else
SetLog($g_sAndroidGamePackage & " has no valid shared_prefs folder or it cannot be accessed", $COLOR_ERROR)
EndIf
EndIf
Local $aFiles = _FileListToArray($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", "*", $FLTA_FILES, True)
$iFilesPulled = UBound($aFiles) - 1
If $Result Then $Result = $iFilesPulled >= $iFiles
If $Result Then
DirRemove($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs_tmp", 1)
Local $a[$iFilesPulled][2]
For $i = 1 To $aFiles[0]
Local $aFileTime = FileGetTime($aFiles[$i], 0)
$a[$i - 1][0] = $aFiles[$i]
$a[$i - 1][1] = _ArrayToString($aFileTime, "-", -1, 2) & " " & _ArrayToString($aFileTime, ":", 3, -1)
Next
SetDebugLog(_ArrayToString($a, ","))
SetLog("Pulled shared_prefs of profile " & $sProfile & " (" & $iFilesPulled & " files)")
Else
DirRemove($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", 1)
DirMove($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs_tmp", $g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs")
SetLog("Error pulling shared_prefs of profile " & $sProfile, $COLOR_ERROR)
EndIf
Return SetError(0, 0, $Result)
EndFunc
Func PushSharedPrefs($sProfile = $g_sProfileCurrentName, $bCloseGameIfRunning = True)
Local $Result = False
Local $bWasRunState = $g_bRunState
Local $process_killed
Local $cmdOutput
Local $aNewFiles = HaveSharedPrefs($sProfile, True, True)
Local $bHaveNew = UBound($aNewFiles) > 1
Local $bHaveOld = HaveSharedPrefs($sProfile, False, True)
If Not $bHaveNew And Not $bHaveOld Then
SetLog("Profile " & $sProfile & " doesn't have shared_prefs folder to push", $COLOR_RED)
Return SetError(0, 0, $Result)
EndIf
SetDebugLog("Pushing shared_pref of profile " & $sProfile)
$cmdOutput = AndroidAdbSendShellCommand("set result=$(ls /data/data/" & $g_sAndroidGamePackage & "/shared_prefs/ >&2)")
If StringInStr($cmdOutput, "No such file or directory") Then
SetLog("Please launch game one time before pushing shared_prefs", $COLOR_ERROR)
Return SetError(0, 0, $Result)
EndIf
If $bCloseGameIfRunning And GetAndroidProcessPID(Default, $bWasRunState) Then
CloseCoC(False, False)
EndIf
If Not $bHaveNew And $bHaveOld Then
SetLog("Migrate shared_prefs to " & $g_sPrivateProfilePath & "\" & $sProfile)
If DirMove($g_sProfilePath & "\" & $sProfile & "\shared_prefs", $g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs") Then
DirRemove($g_sProfilePath & "\" & $sProfile & "\shared_prefs", 1)
$aNewFiles = HaveSharedPrefs($sProfile, True, True)
Else
SetLog("Migration of shared_prefs failed", $COLOR_ERROR)
EndIf
EndIf
Local $iFiles = UBound($aNewFiles) - 1
Local $iFilesPushed = 0
If $g_bPullPushSharedPrefsAbdCommand Then
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " push """ & $g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs"" /data/data/" & $g_sAndroidGamePackage & "/shared_prefs", $process_killed)
Else
$cmdOutput = ""
EndIf
If StringInStr($cmdOutput, "files pushed") > 0 And StringInStr($cmdOutput, @LF & "0 files pushed") = 0 And StringInStr($cmdOutput, "failed to ") = 0 And StringInStr($cmdOutput, "Permission denied") = 0 Then
Local $aRegExResult = StringRegExp($cmdOutput, "(\d+) files pushed", $STR_REGEXPARRAYMATCH)
If Not @error Then
$iFilesPushed = Number($aRegExResult[0])
EndIf
$Result = $iFilesPushed >= $iFiles
If Not $Result Then SetLog("Pushed " & $iFilesPushed & " files of " & $iFiles & " total", $COLOR_ERROR)
Else
If $g_bPullPushSharedPrefsAbdCommand Then SetDebugLog("ADB push failed, try to use host shared folder")
$cmdOutput = AndroidAdbSendShellCommand("set result=$(ls -l /data/data/" & $g_sAndroidGamePackage & "/ >&2)")
Local $aLs = Ls_l_ToArray($cmdOutput)
SetDebugLog("Game folder: " & _ArrayToString($aLs))
Local $iSharedPrefs = _ArraySearch($aLs, "shared_prefs")
If StringInStr($cmdOutput, "Permission denied") = 0 And StringInStr($cmdOutput, "No such file or directory") = 0 And $iSharedPrefs > -1 Then
Local $androidFolder = StringReplace($g_sAndroidPicturesPath & $g_sAndroidPicturesHostFolder & $sProfile, " ", "\ ")
AndroidAdbSendShellCommand("set result=$(rm -r " & $androidFolder & " >&2)")
AndroidAdbSendShellCommand("set result=$(mkdir -p " & $androidFolder & "/shared_prefs >&2)")
Local $hostFolder = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder & $sProfile
Local $iFilesInShared = UBound(_FileListToArray($hostFolder & "\shared_prefs", "*", $FLTA_FILES)) - 1
If FileExists($hostFolder & "\shared_prefs") And $iFilesInShared < 1 Then
If FileCopy($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs\*", $hostFolder & "\shared_prefs", $FC_OVERWRITE) And UBound(_FileListToArray($hostFolder & "\shared_prefs", "*", $FLTA_FILES)) - 1 >= $iFiles Then
AndroidAdbSendShellCommand("set result=$(rm /data/data/" & $g_sAndroidGamePackage & "/shared_prefs/* >&2)")
AndroidAdbSendShellCommand("set result=$(cp " & $androidFolder & "/shared_prefs/* /data/data/" & $g_sAndroidGamePackage & "/shared_prefs >&2)")
$cmdOutput = AndroidAdbSendShellCommand("set result=$(ls -l " & $androidFolder & "/shared_prefs/ >&2)")
$iFilesPushed = UBound(Ls_l_FilesOnly(StringSplit($cmdOutput, @LF, $STR_NOCOUNT)))
If $iFilesPushed >= $iFiles And StringInStr($cmdOutput, "Permission denied") = 0 And StringInStr($cmdOutput, "No such file or directory") = 0 Then
AndroidAdbSendShellCommand("set result=$(rm -r " & $androidFolder & " >&2)")
Local $sPerm = Ls_l_PermissionsToNumber($aLs[$iSharedPrefs][0])
Local $sOwn = $aLs[$iSharedPrefs][1] & ":" & $aLs[$iSharedPrefs][2]
If $g_iAndroidVersionAPI >= $g_iAndroidNougat Then $sOwn = $aLs[$iSharedPrefs][2] & ":" & $aLs[$iSharedPrefs][3]
AndroidAdbSendShellCommand("set result=$(chmod " & $sPerm & " /data/data/" & $g_sAndroidGamePackage & "/shared_prefs/* >&2)")
AndroidAdbSendShellCommand("set result=$(chown " & $sOwn & " /data/data/" & $g_sAndroidGamePackage & "/shared_prefs/* >&2)")
$Result = True
Else
SetLog("Cannot copy sharef_prefs to /data/data/" & $g_sAndroidGamePackage, $COLOR_ERROR)
EndIf
Else
SetLog("Cannot copy shared_prefs to " & $hostFolder, $COLOR_ERROR)
EndIf
Else
SetLog("Cannot create empty folder " & $androidFolder & "/shared_prefs", $COLOR_ERROR)
EndIf
Else
SetLog($g_sAndroidGamePackage & " has no shared_prefs or cannot be accessed, please launch game first", $COLOR_ERROR)
EndIf
EndIf
If $Result Then
AndroidAdbSendShellCommand("set result=$(ls -l /data/data/" & $g_sAndroidGamePackage & "/shared_prefs/ >&2)")
SetLog("Pushed shared_prefs of profile " & $sProfile & " (" & $iFilesPushed & " files)")
$g_PushedSharedPrefsProfile = $sProfile
$g_PushedSharedPrefsProfile_Timer = __TimerInit()
Else
SetLog("Error pushing shared_prefs of profile " & $sProfile, $COLOR_ERROR)
EndIf
Return SetError(0, 0, $Result)
EndFunc
Func Ls_l_FilesOnly($aFiles)
If UBound($aFiles) < 1 Then Return $aFiles
Local $i = 0
While $i < UBound($aFiles)
If IsString($aFiles[$i]) And StringLeft($aFiles[$i], 1) <> "-" Then
_ArrayDelete($aFiles, $i)
Else
$i += 1
EndIf
WEnd
Return $aFiles
EndFunc
Func Ls_l_PermissionsToNumber($sPerm)
If StringLen($sPerm) <> 10 Then Return 770
Local $n = ""
For $u = 0 To 2
Local $p = 0
If StringMid($sPerm, $u * 3 + 2, 1) = "r" Then $p += 4
If StringMid($sPerm, $u * 3 + 3, 1) = "w" Then $p += 2
If StringMid($sPerm, $u * 3 + 4, 1) = "x" Then $p += 1
$n &= $p
Next
Return $n
EndFunc
Func Ls_l_ToArray($sOutput)
$sOutput = StringStripWS($sOutput, $STR_STRIPSPACES)
Local $aFiles = StringSplit($sOutput, @LF, $STR_NOCOUNT)
Local $aResult[UBound($aFiles)][0]
For $i = 0 To UBound($aFiles) - 1
Local $aFile = StringSplit($aFiles[$i], " ", $STR_NOCOUNT)
If UBound($aFile) > UBound($aResult, 2) Then ReDim $aResult[UBound($aFiles)][UBound($aFile)]
For $j = 0 To UBound($aFile) - 1
$aResult[$i][$j] = $aFile[$j]
Next
Next
Return $aResult
EndFunc
Global $g_sNO_COC, $g_sUNKNOWN_COC
Global $_g_asDISTRIBUTORS[24][4]
Func InitializeCOCDistributors()
$g_sNO_COC = "<" & GetTranslatedFileIni("MBR Distributors", "NO_COC", "No COC") & ">"
$g_sUNKNOWN_COC = "<" & GetTranslatedFileIni("MBR Distributors", "Unknown_COC", "Unknown COC") & ">"
Dim $_g_asDISTRIBUTORS[24][4] = [ ["Google", "com.supercell.clashofclans", "com.supercell.clashofclans.GameApp", "Google"], ["Kunlun", "com.supercell.clashofclans.kunlun", "com.supercell.clashofclans.GameAppKunlun", "Kunlun"], ["Qihoo", "com.supercell.clashofclans.qihoo", "com.supercell.clashofclans.GameAppKunlun","Qihoo"], ["Baidu", "com.supercell.clashofclans.baidu", "com.supercell.clashofclans.GameAppKunlun", "Baidu"], ["9game", "com.supercell.clashofclans.uc", "com.supercell.clashofclans.uc.GameApp", "9game"], ["Wandoujia/Downjoy", "com.supercell.clashofclans.wdj", "com.supercell.clashofclans.GameAppKunlun", "Wandoujia/Downjoy"], ["Huawei", "com.supercell.clashofclans.huawei", "com.supercell.clashofclans.GameAppKunlun", "Huawei"], ["OPPO", "com.supercell.clashofclans.nearme.gamecenter", "com.supercell.clashofclans.GameAppKunlun", "OPPO"], ["VIVO", "com.supercell.clashofclans.vivo", "com.supercell.clashofclans.GameAppKunlun", "VIVO"], ["Anzhi", "com.supercell.clashofclans.anzhi", "com.supercell.clashofclans.GameAppKunlun", "Anzhi"], ["Kaopu", "com.supercell.clashofclans.ewan.kaopu", "com.supercell.clashofclans.GameAppKunlun", "Kaopu"], ["Lenovo", "com.supercell.clashofclans.lenovo", "com.supercell.clashofclans.GameAppKunlun", "Lenovo"], ["Guopan", "com.supercell.clashofclans.wdj", "com.flamingo.sdk.view.WDJSplashActivity", "Guopan"], ["Xiaomi", "com.supercell.clashofclans.mi", "com.supercell.clashofclans.mi.GameAppXiaomi","Xiaomi"], ["Haimawan", "com.supercell.clashofclans.ewan.hm", "cn.ewan.supersdk.activity.SplashActivity", "Haimawan"], ["Leshi", "com.supercell.clashofclans.ewan.leshi", "cn.ewan.supersdk.activity.SplashActivity", "Leshi"], ["Microvirt", "com.supercell.clashofclans.ewan.xyaz", "cn.ewan.supersdk.activity.SplashActivity", "Microvirt"], ["Yeshen", "com.supercell.clashofclans.ewan.yeshen", "cn.ewan.supersdk.activity.SplashActivity","Yeshen"], ["Aiyouxi", "com.supercell.clashofclans.ewan.egame", "cn.ewan.supersdk.activity.SplashActivity","Aiyouxi"], ["Tencent", "com.tencent.tmgp.supercell.clashofclans", "com.tencent.tmgp.supercell.clashofclans.GameAppTencent","Tencent"], ["Clash Of Magic, The Black Magic: S1", "net.clashofmagic.s1", "com.supercell.clashofclans.GameApp", "Clash Of Magic, The Black Magic: S1"], ["Clash Of Magic, The Power Of Magic: S2", "net.clashofmagic.s2", "com.supercell.clashofclans.GameApp","Clash Of Magic, The Power Of Magic: S2"], ["Clash Of Magic, The Hall Of Magic: S3", "net.clashofmagic.s3", "com.supercell.clashofclans.GameApp", "Clash Of Magic, The Hall Of Magic: S3"], ["Clash Of Magic, The Hall Of Magic 2: S4", "net.clashofmagic.s4", "com.supercell.clashofclans.GameApp", "Clash Of Magic, The Hall Of Magic 2: S4"] ]
EndFunc
Func GetCOCDistributors()
FuncEnter(GetCOCDistributors)
Static $s_asDistributorsLoaded = -1
If $s_asDistributorsLoaded <> -1 And Not IsBotLaunched() Then Return FuncReturn($s_asDistributorsLoaded)
SetDebugLog("Retrieving CoC distributors")
Local $sPkgList = StringReplace(AndroidAdbSendShellCommand("pm list packages clashofclans;pm list packages clashofmagic"), "package:", "")
If @error <> 0 Or $sPkgList = "" Then Return FuncReturn(SetError(1, 0, ""))
Local $aPkgList = StringSplit($sPkgList, @LF, $STR_ENTIRESPLIT)
Local $aDList[0]
Local $bFirstTimeWDJ = True
Local $iIndex, $wasSilentSetLog
For $i = 1 To $aPkgList[0]
$iIndex = _ArraySearch($_g_asDISTRIBUTORS, $aPkgList[$i], 0, 0, 0, 0, 1, 1)
If @error = 6 Then
$wasSilentSetLog = $g_bSilentSetLog
$g_bSilentSetLog = True
SetLog("Unrecognized COC Package: " & $aPkgList[$i])
$g_bSilentSetLog = $wasSilentSetLog
If $aPkgList[$i] = $g_sUserGamePackage Then _ArrayAdd($aDList, $g_sUserGameDistributor, 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
Else
If $iIndex <> 5 Then
_ArrayAdd($aDList, $_g_asDISTRIBUTORS[$iIndex][3], 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
Else
If $bFirstTimeWDJ Then
_ArrayAdd($aDList, $_g_asDISTRIBUTORS[5][3], 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
_ArrayAdd($aDList, $_g_asDISTRIBUTORS[12][3], 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
$bFirstTimeWDJ = False
EndIf
EndIf
EndIf
Next
If Not IsBotLaunched() Then $s_asDistributorsLoaded = $aDList
If UBound($aDList) = 0 Then Return FuncReturn(SetError(2, 0, ""))
Return FuncReturn(SetError(0, 0, $aDList))
EndFunc
Func GetCOCPackage($sDistributor)
Local $iIndex = _ArraySearch($_g_asDISTRIBUTORS, $sDistributor, 0, 0, 0, 0, 1, 3)
If @error = 6 Then
Return SetError(1, 0, "")
Else
Return SetError(0, 0, $_g_asDISTRIBUTORS[$iIndex][1])
EndIf
EndFunc
Func GetCOCClass($sDistributor)
Local $iIndex = _ArraySearch($_g_asDISTRIBUTORS, $sDistributor, 0, 0, 0, 0, 1, 3)
If @error = 6 Then
Return SetError(1, 0, "")
Else
Return SetError(0, 0, $_g_asDISTRIBUTORS[$iIndex][2])
EndIf
EndFunc
Func GetCOCUnTranslated($sDistributor)
Local $iIndex = _ArraySearch($_g_asDISTRIBUTORS, $sDistributor, 0, 0, 0, 0, 1, 3)
If @error = 6 Then
Return SetError(1, 0, $sDistributor)
Else
Return SetError(0, 0, $_g_asDISTRIBUTORS[$iIndex][0])
EndIf
EndFunc
Func GetCOCTranslated($sDistributor)
Local $iIndex = _ArraySearch($_g_asDISTRIBUTORS, $sDistributor, 0, 0, 0, 0, 1, 0)
If @error = 6 Then
Return SetError(1, 0, $sDistributor)
Else
Return SetError(0, 0, $_g_asDISTRIBUTORS[$iIndex][3])
EndIf
EndFunc
Global Const $CLSID_ShellLink = "{00021401-0000-0000-C000-000000000046}"
Global Const $sIID_IShellLinkW = "{000214F9-0000-0000-C000-000000000046}"
Global Const $tag_IShellLinkW = "GetPath hresult(long;long;long;long);" & "GetIDList hresult(long);" & "SetIDList hresult(long);" & "GetDescription hresult(long;long);" & "SetDescription hresult(wstr);" & "GetWorkingDirectory hresult(long;long);" & "SetWorkingDirectory hresult(long;long);" & "GetArguments hresult(long;long);" & "SetArguments hresult(ptr);" & "GetHotkey hresult(long);" & "SetHotkey hresult(word);" & "GetShowCmd hresult(long);" & "SetShowCmd hresult(int);" & "GetIconLocation hresult(long;long;long);" & "SetIconLocation hresult(wstr;int);" & "SetRelativePath hresult(long;long);" & "Resolve hresult(long;long);" & "SetPath hresult(wstr);"
Global Const $tag_IPersist = "GetClassID hresult(long);"
Global Const $sIID_IPersistFile = "{0000010b-0000-0000-C000-000000000046}"
Global Const $tag_IPersistFile = $tag_IPersist & "IsDirty hresult();" & "Load hresult(wstr;dword);" & "Save hresult(wstr;bool);" & "SaveCompleted hresult(long);" & "GetCurFile hresult(long);"
Global Const $STGM_READ = 0x00000000
Global Const $STGM_READWRITE = 0x00000002
Global Const $STGM_SHARE_DENY_NONE = 0x00000040
Global Const $tagPROPERTYKEY = 'struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];DWORD pid;endstruct'
Global $tagPROPVARIANT = 'USHORT vt;' & 'WORD wReserved1;' & 'WORD wReserved2;' & 'WORD wReserved3;' & 'LONG;PTR'
Global Const $sIID_IPropertyStore = '{886D8EEB-8CF2-4446-8D02-CDBA1DBDCF99}'
Global Const $VT_EMPTY = 0, $VT_LPWSTR = 31
Func _WindowAppId($hWnd, $appid = Default)
Local $tpIPropertyStore = DllStructCreate('ptr')
_WinAPI_SHGetPropertyStoreForWindow($hWnd, $sIID_IPropertyStore, $tpIPropertyStore)
Local $pPropertyStore = DllStructGetData($tpIPropertyStore, 1)
$tpIPropertyStore = 0
Local $oPropertyStore = ObjCreateInterface($pPropertyStore, $sIID_IPropertyStore, 'GetCount HRESULT(PTR);GetAt HRESULT(DWORD; PTR);GetValue HRESULT(PTR;PTR);' & 'SetValue HRESULT(PTR;PTR);Commit HRESULT()')
If Not IsObj($oPropertyStore) Then Return SetError(1, 0, '')
Local $tPKEY = _PKEY_AppUserModel_ID()
Local $tPROPVARIANT = DllStructCreate($tagPROPVARIANT)
Local $sAppId
If $appid = Default Then
$oPropertyStore.GetValue(DllStructGetPtr($tPKEY), DllStructGetPtr($tPROPVARIANT))
If DllStructGetData($tPROPVARIANT, 'vt') <> $VT_EMPTY Then
Local $buf = DllStructCreate('wchar[128]')
DllCall('Propsys.dll', 'long', 'PropVariantToString', 'ptr', DllStructGetPtr($tPROPVARIANT), 'ptr', DllStructGetPtr($buf), 'uint', DllStructGetSize($buf))
If Not @error Then
$sAppId = DllStructGetData($buf, 1)
EndIf
$buf = 0
EndIf
Else
_WinAPI_InitPropVariantFromString($appid, $tPROPVARIANT)
$oPropertyStore.SetValue(DllStructGetPtr($tPKEY), DllStructGetPtr($tPROPVARIANT))
$oPropertyStore.Commit()
$sAppId = $appid
EndIf
$tPROPVARIANT = 0
$tPKEY = 0
Return SetError(($sAppId == '') * 2, 0, $sAppId)
EndFunc
Func _ShortcutAppId($lnkfile, $appid = Default)
Local $oIShellLinkW = ObjCreateInterface($CLSID_ShellLink, $sIID_IShellLinkW, $tag_IShellLinkW)
If Not IsObj($oIShellLinkW) Then Return SetError(1, 0, '')
Local $pIPersistFile, $oIPersistFile, $ret, $sAppId
Local $tRIID_IPersistFile = _WinAPI_GUIDFromString($sIID_IPersistFile)
$oIShellLinkW.QueryInterface($tRIID_IPersistFile, $pIPersistFile)
$oIPersistFile = ObjCreateInterface($pIPersistFile, $sIID_IPersistFile, $tag_IPersistFile)
If IsObj($oIPersistFile) Then
If $appid == Default Then
$ret = $oIPersistFile.Load($lnkfile, BitOR($STGM_READ, $STGM_SHARE_DENY_NONE))
Else
$ret = $oIPersistFile.Load($lnkfile, $STGM_READWRITE)
EndIf
If $ret = 0 Then
Local $tPKEY = _PKEY_AppUserModel_ID()
Local $tPROPVARIANT = DllStructCreate($tagPROPVARIANT)
Local $tRIID_IPropertyStore = _WinAPI_GUIDFromString($sIID_IPropertyStore)
Local $pPropertyStore
$oIShellLinkW.QueryInterface($tRIID_IPropertyStore, $pPropertyStore)
Local $oPropertyStore = ObjCreateInterface($pPropertyStore, $sIID_IPropertyStore, 'GetCount HRESULT(PTR);GetAt HRESULT(DWORD;PTR);GetValue HRESULT(PTR;PTR);' & 'SetValue HRESULT(PTR;PTR);Commit HRESULT()')
If IsObj($oPropertyStore) Then
If $appid == Default Then
$oPropertyStore.GetValue(DllStructGetPtr($tPKEY), DllStructGetPtr($tPROPVARIANT))
If DllStructGetData($tPROPVARIANT, 'vt') <> $VT_EMPTY Then
Local $buf = DllStructCreate('wchar[128]')
DllCall('Propsys.dll', 'long', 'PropVariantToString', 'ptr', DllStructGetPtr($tPROPVARIANT), 'ptr', DllStructGetPtr($buf), 'uint', DllStructGetSize($buf))
$sAppId = DllStructGetData($buf, 1)
$buf = 0
EndIf
Else
_WinAPI_InitPropVariantFromString($appid, $tPROPVARIANT)
$oPropertyStore.SetValue(DllStructGetPtr($tPKEY), DllStructGetPtr($tPROPVARIANT))
$oPropertyStore.Commit()
$oIPersistFile.Save($lnkfile, True)
$sAppId = $appid
EndIf
EndIf
$tPROPVARIANT = 0
$tPKEY = 0
EndIf
EndIf
If IsObj($oPropertyStore) Then $oPropertyStore.Release()
If IsObj($oIPersistFile) Then $oIPersistFile.Release()
If IsObj($oIShellLinkW) Then $oIShellLinkW.Release()
Return SetError(($sAppId == '') * 2, 0, $sAppId)
EndFunc
Func _WinAPI_InitPropVariantFromString($sUnicodeString, ByRef $tPROPVARIANT)
DllStructSetData($tPROPVARIANT, 'vt', $VT_LPWSTR)
Local $aRet = DllCall('Shlwapi.dll', 'LONG', 'SHStrDupW', 'WSTR', $sUnicodeString, 'PTR', DllStructGetPtr($tPROPVARIANT) + 8)
If @error Then Return SetError(@error, @extended, False)
Local $bSuccess = $aRet[0] == 0
If(Not $bSuccess) Then $tPROPVARIANT = DllStructCreate($tagPROPVARIANT)
Return SetExtended($aRet[0], $bSuccess)
EndFunc
Func _PKEY_AppUserModel_ID()
Local $tPKEY = DllStructCreate($tagPROPERTYKEY)
_WinAPI_GUIDFromStringEx('{9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}', DllStructGetPtr($tPKEY))
DllStructSetData($tPKEY, 'pid', 5)
Return $tPKEY
EndFunc
Func _WinAPI_SHGetPropertyStoreForWindow($hWnd, $sIID, ByRef $tPointer)
Local $tIID = _WinAPI_GUIDFromString($sIID)
Local $pp = IsPtr($tPointer) ? $tPointer : DllStructGetPtr($tPointer)
Local $aRet = DllCall('Shell32.dll', 'LONG', 'SHGetPropertyStoreForWindow', 'HWND', $hWnd, 'STRUCT*', $tIID, 'PTR', $pp)
If @error Then Return SetError(@error, @extended, False)
Return SetExtended($aRet[0],($aRet[0] = 0))
EndFunc
Global $g_hToolTip = 0
Func _GUICtrlSetTip($controlID, $tiptext, $title = Default, $icon = Default, $options = Default, $useControlID = True)
If $g_hToolTip = 0 Then
SetDebugLog("_GUICtrlSetTip: Missing $hToolTip! $controlID=" & $controlID, $COLOR_ERROR)
Return False
EndIf
Local $hCtrl =($useControlID = True ? GUICtrlGetHandle($controlID) : $controlID)
Return _GUIToolTip_AddTool($g_hToolTip, 0, $tiptext, $hCtrl)
EndFunc
Func _GUICtrlGetControlID($hCtrl = -1)
Local $aRet = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd",($hCtrl = -1 ? GUICtrlGetHandle(-1) : $hCtrl))
Return(IsArray($aRet) ? $aRet[0] : -1)
EndFunc
Func _GUICtrlCreatePic($sFilename_or_hBitmap, $iLeft, $iTop, $iWidth = -1, $iHeight = -1, $iStyle = -1, $iExStyle = -1)
Local $idPic = GUICtrlCreatePic("", $iLeft, $iTop, $iWidth, $iHeight, $iStyle, $iExStyle)
Local $hBMP
If IsPtr($sFilename_or_hBitmap) Then
$hBMP = $sFilename_or_hBitmap
Else
$hBMP = _GDIPlus_BitmapCreateFromFile($sFilename_or_hBitmap)
EndIf
Local $iBmpWidth = _GDIPlus_ImageGetWidth($hBMP)
Local $iBmpHeight = _GDIPlus_ImageGetHeight($hBMP)
Local $g_hBitmap_Resized = 0
Local $hBMP_Ctxt = 0
If $iWidth = -1 Then $iWidth = $iBmpWidth
If $iHeight = -1 Then $iHeight = $iBmpHeight
If $iWidth <> $iBmpWidth Or $iHeight <> $iBmpHeight Then
$g_hBitmap_Resized = _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight)
$hBMP_Ctxt = _GDIPlus_ImageGetGraphicsContext($g_hBitmap_Resized)
_GDIPlus_GraphicsSetInterpolationMode($hBMP_Ctxt, $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
_GDIPlus_GraphicsDrawImageRect($hBMP_Ctxt, $hBMP, 0, 0, $iWidth, $iHeight)
EndIf
Local $hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap(($g_hBitmap_Resized ? $g_hBitmap_Resized : $hBMP))
Local $hPrevImage = GUICtrlSendMsg($idPic, $STM_SETIMAGE, 0, $hHBMP)
_WinAPI_DeleteObject($hPrevImage)
If IsPtr($sFilename_or_hBitmap) = 0 Then _GDIPlus_BitmapDispose($hBMP)
If $g_hBitmap_Resized Then _GDIPlus_BitmapDispose($g_hBitmap_Resized)
If $hBMP_Ctxt Then _GDIPlus_GraphicsDispose($hBMP_Ctxt)
_WinAPI_DeleteObject($hHBMP)
Return $idPic
EndFunc
Func _GUI_Value_STATE($action_groupe, $group_de_controle)
Local $liste_controle = StringSplit($group_de_controle, "#")
If IsArray($liste_controle) Then
For $i = 1 To $liste_controle[0]
Switch StringUpper($action_groupe)
Case "HIDE"
GUICtrlSetState($liste_controle[$i], $GUI_HIDE)
Case "SHOW"
GUICtrlSetState($liste_controle[$i], $GUI_SHOW)
Case "ENABLE"
GUICtrlSetState($liste_controle[$i], $GUI_ENABLE)
Case "DISABLE"
GUICtrlSetState($liste_controle[$i], $GUI_DISABLE)
Case "UNCHECKED"
GUICtrlSetState($liste_controle[$i], $GUI_UNCHECKED)
Case "CHECKED"
GUICtrlSetState($liste_controle[$i], $GUI_CHECKED)
EndSwitch
Next
EndIf
EndFunc
Global Const $TCM_SETITEM = 0x1306
Global $_GUI_MAIN_WIDTH = 472
Global $_GUI_MAIN_HEIGHT = 692
Global Const $_NORMALGUI_MAIN_WIDTH = $_GUI_MAIN_WIDTH
Global Const $_NORMALGUI_MAIN_HEIGHT = $_GUI_MAIN_HEIGHT
Global Const $_MINIGUI_MAIN_WIDTH = $_GUI_MAIN_WIDTH
Global Const $_MINIGUI_MAIN_HEIGHT = 220
Global $_GUI_MAIN_TOP = 23
Global $_GUI_MAIN_BUTTON_SIZE = [25, 17]
Global $_GUI_MAIN_BUTTON_COUNT = 4
Global $_GUI_CHILD_TOP = 110 + $_GUI_MAIN_TOP
Global Const $_GUI_BOTTOM_HEIGHT = 135
Global Const $_GUI_CHILD_LEFT = 10
Global Const $g_bBtnColor = False
Global Const $g_iSizeWGrpTab1 = $_GUI_MAIN_WIDTH - 20
Global Const $g_iSizeHGrpTab1 = $_GUI_MAIN_HEIGHT - 255
Global Const $g_iSizeWGrpTab2 = $_GUI_MAIN_WIDTH - 30
Global Const $g_iSizeHGrpTab2 = $_GUI_MAIN_HEIGHT - 285
Global Const $g_iSizeWGrpTab3 = $_GUI_MAIN_WIDTH - 40
Global Const $g_iSizeHGrpTab3 = $_GUI_MAIN_HEIGHT - 315
Global Const $g_iSizeWGrpTab4 = $_GUI_MAIN_WIDTH - 50
Global Const $g_iSizeHGrpTab4 = $_GUI_MAIN_HEIGHT - 345
Global $g_iBotDesignFlags = 3
Global $g_bCustomTitleBarActive = Default
Global $g_bBotDockedShrinked = False
Global $g_hFrmBotButtons, $g_hFrmBotLogoUrlSmall, $g_hFrmBotEx = 0, $g_hLblBotTitle, $g_hLblBotShrink = 0, $g_hLblBotExpand = 0, $g_hLblBotMiniGUI = 0, $g_hLblBotNormalGUI = 0 , $g_hLblBotMinimize = 0, $g_hLblBotClose = 0, $g_hFrmBotBottom = 0, $g_hFrmBotEmbeddedShield = 0, $g_hFrmBotEmbeddedShieldInput = 0, $g_hFrmBotEmbeddedGraphics = 0
Global $g_hFrmBot_MAIN_PIC = 0, $g_hFrmBot_URL_PIC = 0, $g_hFrmBot_URL_PIC2 = 0
Global $g_hTabMain = 0, $g_hTabLog = 0, $g_hTabVillage = 0, $g_hTabAttack = 0, $g_hTabBot = 0, $g_hTabAbout = 0
Global $g_hStatusBar = 0
Global $g_hTiShow = 0, $g_hTiHide = 0, $g_hTiDonate = 0, $g_hTiAbout = 0, $g_hTiStartStop = 0, $g_hTiPause = 0, $g_hTiExit = 0
Global $g_aFrmBotPosInit[8] = [0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hFirstControlToHide = 0, $g_hLastControlToHide = 0, $g_aiControlPrevState[1]
Global $g_bFrmBotMinimized = False
Global $g_oCtrlIconData = ObjCreate("Scripting.Dictionary")
Global $g_oGuiNotInMini = ObjCreate("Scripting.Dictionary")
Global $g_hBtnStart = 0, $g_hBtnStop = 0, $g_hBtnPause = 0, $g_hBtnResume = 0, $g_hBtnSearchMode = 0, $g_hBtnMakeScreenshot = 0, $g_hBtnHide = 0, $g_hBtnEmbed = 0, $g_hChkBackgroundMode = 0, $g_hLblDonate = 0, $g_hBtnAttackNowDB = 0, $g_hBtnAttackNowLB = 0, $g_hBtnAttackNowTS = 0
Global $g_hPicTwoArrowShield = 0, $g_hLblVersion = 0, $g_hPicArrowLeft = 0, $g_hPicArrowRight = 0
Global $g_hGrpVillage = 0
Global $g_hLblResultGoldNow = 0, $g_hLblResultGoldHourNow = 0, $g_hPicResultGoldNow = 0, $g_hPicResultGoldTemp = 0
Global $g_hLblResultElixirNow = 0, $g_hLblResultElixirHourNow = 0, $g_hPicResultElixirNow = 0, $g_hPicResultElixirTemp = 0
Global $g_hLblResultDENow = 0, $g_hLblResultDEHourNow = 0, $g_hPicResultDENow = 0, $g_hPicResultDETemp = 0
Global $g_hLblResultTrophyNow = 0, $g_hPicResultTrophyNow = 0, $g_hLblResultRuntimeNow = 0, $g_hPicResultRuntimeNow = 0, $g_hLblResultBuilderNow = 0, $g_hPicResultBuilderNow = 0
Global $g_hLblResultAttackedHourNow = 0, $g_hPicResultAttackedHourNow = 0, $g_hLblResultGemNow = 0, $g_hPicResultGemNow = 0, $g_hLblResultSkippedHourNow = 0, $g_hPicResultSkippedHourNow = 0
Global $g_hLblVillageReportTemp = 0
Global $g_hlblKing = 0, $g_hPicKingGray = 0, $g_hPicKingBlue = 0, $g_hPicKingRed = 0, $g_hPicKingGreen = 0
Global $g_hlblQueen = 0, $g_hPicQueenGray = 0, $g_hPicQueenBlue = 0, $g_hPicQueenRed = 0, $g_hPicQueenGreen = 0
Global $g_hlblWarden = 0, $g_hPicWardenGray = 0, $g_hPicWardenBlue = 0, $g_hPicWardenRed = 0, $g_hPicWardenGreen = 0
Global $g_hlblLab = 0, $g_hPicLabGray = 0, $g_hPicLabRed = 0, $g_hPicLabGreen = 0
Func CreateBottomPanel()
Local $sTxtTip = ""
Local $y_bottom = 0
Local $x = 10, $y = $y_bottom + 10
GUICtrlCreateGroup("https://mybot.run " & GetTranslatedFileIni("MBR GUI Design Bottom", "Group_01", "- freeware bot -"), $x - 5, $y - 10, 190, 108)
$g_hBtnStart = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnStart", "Start Bot"), $x, $y + 2 +5, 90, 40-5)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnStart_Info_01", "Use this to START the bot."))
GUICtrlSetOnEvent(-1, "btnStart")
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0x5CAD85)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hBtnStop = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnStop", "Stop Bot"), -1, -1, 90, 40-5)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnStop_Info_01", "Use this to STOP the bot (or ESC key)."))
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0xDB4D4D)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnPause = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnPause", "Pause"), $x + 90, -1, 90, 40-5)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnPause_Info_01", "Use this to PAUSE all actions of the bot until you Resume (or Pause/Break key)."))
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0xFFA500)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnResume = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnResume", "Resume"), -1, -1, 90, 40-5)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnResume_Info_01", "Use this to RESUME a paused Bot (or Pause/Break key)."))
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0xFFA500)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnSearchMode = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnSearchMode", "Search Mode"), -1, -1, 90, 40-5)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnSearchMode_Info_01", "Does not attack. Searches for a Village that meets conditions."))
GUICtrlSetOnEvent(-1, "btnSearchMode")
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0xFFA500)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hBtnMakeScreenshot = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnMakeScreenshot", "Photo"), $x , $y + 45, 40, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnMakeScreenshot_Info_01", "Click here to take a snaphot of your village and save it to a file."))
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0x5CAD85)
$g_hBtnHide = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnHide", "Hide"), $x + 40, $y + 45, 50, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnHide_Info_01", "Use this to move the Android Window out of sight.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Bottom", "BtnHide_Info_02", "(Not minimized, but hidden)"))
If $g_bBtnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hBtnEmbed = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnEmbed", "Dock"), $x + 90, $y + 45, 90, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnEmbed_Info_01", "Use this to embed the Android Window into Bot."))
If $g_bBtnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "btnEmbed")
$g_hChkBackgroundMode = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Bottom", "ChkBackgroundMode", "Background Mode"), $x + 1, $y + 72, 115, 24)
GUICtrlSetFont(-1, 7)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "ChkBackgroundMode_Info_01", "Check this to ENABLE the Background Mode of the Bot.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Bottom", "ChkBackgroundMode_Info_02", "With this you can also hide the Android Emulator window out of sight."))
If $g_bGuiRemote Then GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkBackground")
GUICtrlSetState(-1,(($g_bAndroidAdbScreencap = True) ?($GUI_CHECKED) :($GUI_UNCHECKED)))
$g_hLblVersion = GUICtrlCreateLabel($g_sBotVersion, $x + 120, $y + 77, 60, 17, $SS_LEFT )
GUICtrlSetColor(-1, $COLOR_MEDGRAY)
$g_hBtnAttackNowDB = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnAttackNowDB", "DB Attack!"), $x + 190, $y - 4, 60, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnAttackNowLB = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnAttackNowLB", "LB Attack!"), $x + 190, $y + 23, 60, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnAttackNowTS = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnAttackNowTS", "TH Snipe!"), $x + 190, $y + 50, 60, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hLblDonate = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Bottom", "LblDonate", "Support the development"), $x + 224, $y + 80, 220, 24, $SS_RIGHT)
GUICtrlSetCursor(-1, 0)
GUICtrlSetFont(-1, 8.5, $FW_BOLD)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "LblDonate_Info_01", "Paypal Donate?"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
If $g_bAndroidAdbScreencap Then chkBackground()
$g_hPicArrowLeft = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnArrowLeft, $x + 269, $y + 30, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Bottom", "GrpVillage_Info_01", "Switch between village info and stats")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicArrowRight = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnArrowRight, $x + 247 + 198, $y + 30, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_SHOW)
Local $x = 202, $y = $y_bottom + 5
$sTxtTip = "Gray - Not Read, Green - Ready to Use, Blue - Healing, Red - Upgrading"
$g_hlblKing = GUICtrlCreateLabel("King", $x, $y, 50, 16, $SS_LEFT)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicKingGray = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGrayShield, $x + 53, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicKingBlue = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBlueShield, $x + 53, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicKingGreen = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGreenShield, $x + 53, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicKingRed = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRedShield, $x + 53, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 25
$g_hlblQueen = GUICtrlCreateLabel("Queen", $x, $y, 50, 16, $SS_LEFT)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicQueenGray = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGrayShield, $x + 53, $y, 16, 16 )
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicQueenBlue = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBlueShield, $x + 53, $y, 16, 16 )
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicQueenGreen = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGreenShield, $x + 53, $y, 16, 16 )
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicQueenRed = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRedShield, $x + 53, $y, 16, 16 )
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 25
$g_hlblWarden = GUICtrlCreateLabel("Warden", $x, $y, 50, 16, $SS_LEFT)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicWardenGray = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGrayShield, $x + 53 , $y, 16, 16 )
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicWardenBlue = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBlueShield, $x + 53, $y, 16, 16 )
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicWardenGreen = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGreenShield, $x + 53, $y, 16, 16 )
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicWardenRed = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRedShield, $x + 53, $y, 16, 16 )
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 25
$sTxtTip = "Green - Lab is Running, Red - Lab Has Stopped"
$g_hlblLab = GUICtrlCreateLabel("Lab", $x, $y, 50, 16, $SS_LEFT)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicLabGray = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGrayShield, $x + 53 , $y, 16, 16 )
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicLabGreen = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGreenShield, $x + 53, $y, 16, 16 )
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicLabRed = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRedShield, $x + 53, $y, 16, 16 )
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
Local $x = 295, $y = $y_bottom + 20
$g_hGrpVillage = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Bottom", "GrpVillage", "Village"), $x - 0, $y - 20, 160, 85)
$g_hLblResultGoldNow = GUICtrlCreateLabel("", $x + 10, $y + 2, 60, 15, $SS_RIGHT)
$g_hLblResultGoldHourNow = GUICtrlCreateLabel("", $x + 10, $y + 2, 60, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultGoldNow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 71, $y, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultGoldTemp = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 15, $y, 16, 16)
$g_hLblResultElixirNow = GUICtrlCreateLabel("", $x + 10, $y + 22, 60, 15, $SS_RIGHT)
$g_hLblResultElixirHourNow = GUICtrlCreateLabel("", $x + 10, $y + 22, 60, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultElixirNow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 71, $y + 20, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultElixirTemp = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 15, $y + 20, 16, 16)
$g_hLblResultDENow = GUICtrlCreateLabel("", $x + 10, $y + 42, 60, 15, $SS_RIGHT)
$g_hLblResultDEHourNow = GUICtrlCreateLabel("", $x, $y + 42, 60, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultDENow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 71, $y + 40, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultDETemp = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 15, $y + 40, 16, 16)
$x += 75
$g_hLblResultTrophyNow = GUICtrlCreateLabel("", $x + 13, $y + 2, 43, 15, $SS_RIGHT)
$g_hPicResultTrophyNow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 59, $y , 16, 16)
$g_hLblResultRuntimeNow = GUICtrlCreateLabel("00:00:00", $x + 13, $y + 2, 43, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultRuntimeNow = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x +57, $y, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hLblResultBuilderNow = GUICtrlCreateLabel("", $x + 13, $y + 22, 43, 15, $SS_RIGHT)
$g_hPicResultBuilderNow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x + 59, $y + 20, 16, 16)
$g_hLblResultAttackedHourNow = GUICtrlCreateLabel("0", $x + 13, $y + 22, 43, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultAttackedHourNow = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x +59, $y + 20, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hLblResultGemNow = GUICtrlCreateLabel("", $x + 13, $y + 42, 43, 15, $SS_RIGHT)
$g_hPicResultGemNow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGem, $x + 59, $y + 40, 16, 16)
$g_hLblResultSkippedHourNow = GUICtrlCreateLabel("0", $x + 13, $y + 42, 43, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultSkippedHourNow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgX, $x + 59, $y + 40, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$x = 335
$g_hLblVillageReportTemp = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Bottom", "LblVillageReportTemp_01", "Village Report") & @CRLF & GetTranslatedFileIni("MBR GUI Design Bottom", "LblVillageReportTemp_02", "will appear here") & @CRLF & GetTranslatedFileIni("MBR GUI Design Bottom", "LblVillageReportTemp_03", "on first run."), $x , $y + 5, 80, 45, BITOR($SS_CENTER, $BS_MULTILINE))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_LOG = 0
Global $g_hTxtLog = 0, $g_hDivider = 0, $g_hTxtAtkLog = 0
Global $g_hCmbLogDividerOption, $g_hBtnAtkLogClear, $g_hBtnAtkLogCopyClipboard
Func CreateLogTab($hWHndLogsOnly = False)
Local $x = 0, $y = 0
Local $activeHWnD = WinGetHandle("")
If $hWHndLogsOnly Then
$g_hTxtLog = _GUICtrlRichEdit_Create($hWHndLogsOnly, "", 0, 0, 20, 20, BitOR($ES_MULTILINE, $ES_READONLY, $WS_VSCROLL, $WS_HSCROLL, $ES_UPPERCASE, $ES_AUTOHSCROLL, $ES_AUTOVSCROLL, $ES_NUMBER, 0x200), $WS_EX_STATICEDGE)
WinSetState($g_hTxtLog, "", @SW_MINIMIZE)
$g_hTxtAtkLog = _GUICtrlRichEdit_Create($hWHndLogsOnly, "", 0, 0, 20, 20, BitOR($ES_MULTILINE, $ES_READONLY, $WS_VSCROLL, 8908), $WS_EX_STATICEDGE)
WinSetState($g_hTxtAtkLog, "", @SW_MINIMIZE)
WinActivate($activeHWnD)
Return
EndIf
$g_hGUI_LOG = _GUICreate("", $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, 0), -1, $g_hFrmBotEx)
If IsHWnd($g_hTxtLog) Then
SetDebugLog("Re-use existing bot log control")
_WinAPI_SetParent($g_hTxtLog, $g_hGUI_LOG)
_WinAPI_SetWindowLong($g_hTxtLog, $GWL_HWNDPARENT, $g_hGUI_LOG)
WinSetState($g_hTxtLog, "", @SW_RESTORE)
Else
$g_hTxtLog = _GUICtrlRichEdit_Create($g_hGUI_LOG, "", 0, 0, 20, 20, BitOR($ES_MULTILINE, $ES_READONLY, $WS_VSCROLL, $WS_HSCROLL, $ES_UPPERCASE, $ES_AUTOHSCROLL, $ES_AUTOVSCROLL, $ES_NUMBER, 0x200), $WS_EX_STATICEDGE)
EndIf
$g_hDivider = GUICtrlCreateLabel("", 0, 0, 20, 20, $SS_SUNKEN + $SS_BLACKRECT)
GUICtrlSetCursor(-1, 11)
If IsHWnd($g_hTxtAtkLog) Then
SetDebugLog("Re-use existing attack log control")
_WinAPI_SetParent($g_hTxtAtkLog, $g_hGUI_LOG)
_WinAPI_SetWindowLong($g_hTxtAtkLog, $GWL_HWNDPARENT, $g_hGUI_LOG)
WinSetState($g_hTxtAtkLog, "", @SW_RESTORE)
Else
$g_hTxtAtkLog = _GUICtrlRichEdit_Create($g_hGUI_LOG, "", 0, 0, 20, 20, BitOR($ES_MULTILINE, $ES_READONLY, $WS_VSCROLL, 8908), $WS_EX_STATICEDGE)
EndIf
WinActivate($activeHWnD)
$y = 410
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Log", "LblLog_Style", "Log Style") & ":", $x, $y + 5, -1, -1)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$g_hCmbLogDividerOption = GUICtrlCreateCombo("", $x + 50, $y, 180, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Log", "LblLog_Style_Info_01", "Use these options to set the Log type."))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Log", "CmbLogDividerOption_Item_01", "Use Divider to Resize Both Logs") & "|" & GetTranslatedFileIni("MBR GUI Design Log", "CmbLogDividerOption_Item_02", "Bot and Attack Log Same Size") & "|" & GetTranslatedFileIni("MBR GUI Design Log", "CmbLogDividerOption_Item_03", "Large Bot Log, Small Attack Log") & "|" & GetTranslatedFileIni("MBR GUI Design Log", "CmbLogDividerOption_Item_04", "Small Bot Log, Large Attack Log") & "|" & GetTranslatedFileIni("MBR GUI Design Log", "CmbLogDividerOption_Item_05", "Full Bot Log, Hide Attack Log") & "|" & GetTranslatedFileIni("MBR GUI Design Log", "CmbLogDividerOption_Item_06", "Hide Bot Log, Full Attack Log"), GetTranslatedFileIni("MBR GUI Design Log", "CmbLogDividerOption_Item_01", -1))
GUICtrlSetOnEvent(-1, "cmbLog")
$g_hBtnAtkLogClear = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Log", "BtnAtkLogClear", "Clear Atk. Log"), $x + 270, $y - 1, 80, 23)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Log", "BtnAtkLogClear_Info_01", "Use this to clear the Attack Log."))
GUICtrlSetOnEvent(-1, "btnAtkLogClear")
If $g_bBtnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
$g_hBtnAtkLogCopyClipboard = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Log", "BtnAtkLogCopyClipboard", "Copy to Clipboard"), $x + 350, $y - 1, 100, 23)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Log", "BtnAtkLogCopyClipboard_Info_01", "Use this to copy the Attack Log to the Clipboard (CTRL+C)"))
GUICtrlSetOnEvent(-1, "btnAtkLogCopyClipboard")
If $g_bBtnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
EndFunc
Global $g_hGUI_VILLAGE = 0
Global $g_hGUI_MISC = 0, $g_hGUI_MISC_TAB = 0, $g_hGUI_MISC_TAB_ITEM1 = 0, $g_hGUI_MISC_TAB_ITEM2 = 0, $g_hGUI_MISC_TAB_ITEM3 = 0
Global $g_hChkBotStop = 0, $g_hCmbBotCommand = 0, $g_hCmbBotCond = 0, $g_hCmbHoursStop = 0
Global $g_hTxtRestartGold = 0, $g_hTxtRestartElixir = 0, $g_hTxtRestartDark = 0
Global $g_hChkTrap = 1, $g_hChkCollect = 1, $g_hChkTombstones = 1, $g_hChkCleanYard = 0, $g_hChkGemsBox = 0
Global $g_hBtnLocateKingAltar = 0, $g_hBtnLocateQueenAltar = 0, $g_hBtnLocateWardenAltar = 0, $g_hBtnLocateLaboratory = 0, $g_hBtnResetBuilding = 0
Global $g_hChkTreasuryCollect = 0, $g_hTxtTreasuryGold = 0, $g_hTxtTreasuryElixir = 0, $g_hTxtTreasuryDark = 0 , $g_hChkFreeMagicItems = 0
Global $g_alblBldBaseStats[4] = ["", "", ""]
Global $g_hChkCollectBuilderBase = 0, $g_hChkStartClockTowerBoost = 0, $g_hChkCTBoostBlderBz = 0
Global $g_hChkBBSuggestedUpgrades = 0, $g_hChkBBSuggestedUpgradesIgnoreGold = 0 , $g_hChkBBSuggestedUpgradesIgnoreElixir , $g_hChkBBSuggestedUpgradesIgnoreHall = 0
Global $g_hChkPlacingNewBuildings = 0
Global $g_hChkClanGamesAir = 0, $g_hChkClanGamesGround = 0, $g_hChkClanGamesMisc = 0
Global $g_hChkClanGamesEnabled = 0 , $g_hChkClanGamesOnly = 0
Global $g_hChkClanGamesLoot = 0 , $g_hChkClanGamesBattle =0 , $g_hChkClanGamesDestruction = 0 , $g_hChkClanGamesAirTroop = 0 , $g_hChkClanGamesGroundTroop = 0 , $g_hChkClanGamesMiscellaneous = 0
Global $g_hChkClanGamesPurge = 0 , $g_hcmbPurgeLimit = 0 , $g_hChkClanGamesStopBeforeReachAndPurge = 0
Global $g_hTxtClanGamesLog = 0
Global $g_hChkClanGamesDebug = 0
Global $g_hLblRemainTime = 0 , $g_hLblYourScore = 0
Func CreateVillageMisc()
$g_hGUI_MISC = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_VILLAGE)
GUISwitch($g_hGUI_MISC)
$g_hGUI_MISC_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_MISC_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "MISC_TAB_ITEM1", "Normal Village"))
CreateMiscNormalVillageSubTab()
$g_hGUI_MISC_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "MISC_TAB_ITEM2", "Builder Base"))
CreateMiscBuilderBaseSubTab()
$g_hGUI_MISC_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "MISC_TAB_ITEM3", "Clan Games"))
CreateMiscClanGamesV3SubTab()
GUICtrlCreateTabItem("")
EndFunc
Func CreateMiscNormalVillageSubTab()
Local $sTxtTip = ""
Local $x = 15, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "Group_01", "Halt Attack"), $x - 10, $y - 20, $g_iSizeWGrpTab3, 98)
$g_hChkBotStop = GUICtrlCreateCheckbox("", $x - 5, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BotStop_Info_01", "Use these options to set when the bot will stop attacking.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkBotStop")
$g_hCmbBotCommand = GUICtrlCreateCombo("", $x + 20, $y - 3, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_01", "Halt Attack") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_02", "Stop Bot") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_03", "Close Bot") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_04", "Close CoC+Bot") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_05", "Shutdown PC") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_06", "Sleep PC") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_07", "Reboot PC"), GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_01", -1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "LblBotCommand", "When..."), $x + 125, $y, 45, 17)
$g_hCmbBotCond = GUICtrlCreateCombo("", $x + 173, $y - 3, 160, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_01", "G and E Full and Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_02", "(G and E) Full or Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_03", "(G or E) Full and Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_04", "G or E Full or Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_05", "Gold and Elixir Full") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_06", "Gold or Elixir Full") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_07", "Gold Full and Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_08", "Elixir Full and Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_09", "Gold Full or Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_10", "Elixir Full or Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_11", "Gold Full") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_12", "Elixir Full") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_13", "Reach Max. Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_14", "Dark Elixir Full") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_15", "All Storage (G+E+DE) Full") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_16", "Bot running for...") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_17", "Now (Train/Donate Only)") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_18", "Now (Donate Only)") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_19", "Now (Only stay online)") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_20", "W/Shield (Train/Donate Only)") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_21", "W/Shield (Donate Only)") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_22", "W/Shield (Only stay online)"), GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_17", -1))
GUICtrlSetOnEvent(-1, "cmbBotCond")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hCmbHoursStop = GUICtrlCreateCombo("", $x + 337, $y - 3, 80, 35, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
Local $sTxtHours = GetTranslatedFileIni("MBR Global GUI Design", "Hours", "Hours")
GUICtrlSetData(-1, "-|1 " & GetTranslatedFileIni("MBR Global GUI Design", "Hour", "Hour") & "|2 " & $sTxtHours & "|3 " & $sTxtHours & "|4 " & $sTxtHours & "|5 " & $sTxtHours & "|6 " & $sTxtHours & "|7 " & $sTxtHours & "|8 " & $sTxtHours & "|9 " & $sTxtHours & "|10 " & $sTxtHours & "|11 " & $sTxtHours & "|12 " & $sTxtHours & "|13 " & $sTxtHours & "|14 " & $sTxtHours & "|15 " & $sTxtHours & "|16 " & $sTxtHours & "|17 " & $sTxtHours & "|18 " & $sTxtHours & "|19 " & $sTxtHours & "|20 " & $sTxtHours & "|21 " & $sTxtHours & "|22 " & $sTxtHours & "|23 " & $sTxtHours & "|24 " & $sTxtHours, "-")
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "LblBotWillHaltAutomatically", "The bot will Halt automatically when you run out of Resources. It will resume when reaching these minimal values."), $x + 20, $y, 400, 25, $BS_MULTILINE)
$y += 30
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "LblResumeAttack", "Resume Attack") & ":", $x + 20, $y + 2, 80, -1)
$x += 90
GUICtrlCreateLabel(ChrW(8805), $x + 22, $y + 2, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 84, $y, 16, 16)
$g_hTxtRestartGold = GUICtrlCreateInput("10000", $x + 32, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtRestartGold_Info_01", "Minimum Gold value for the bot to resume attacking after halting because of low gold."))
GUICtrlSetLimit(-1, 7)
$x += 90
GUICtrlCreateLabel(ChrW(8805), $x + 22, $y + 2, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 84, $y, 16, 16)
$g_hTxtRestartElixir = GUICtrlCreateInput("25000", $x + 32, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtRestartElixir_Info_01", "Minimum Elixir value for the bot to resume attacking after halting because of low elixir."))
GUICtrlSetLimit(-1, 7)
$x += 90
GUICtrlCreateLabel(ChrW(8805), $x + 22, $y + 2, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 84, $y, 16, 16)
$g_hTxtRestartDark = GUICtrlCreateInput("500", $x + 32, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtRestartDark_Info_01", "Minimum Dark Elixir value for the bot to resume attacking after halting because of low dark elixir."))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 15, $y = 145
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "Group_02", "Rearm, Collect, Clear"), $x -10, $y - 20, $g_iSizeWGrpTab3, 217)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrap, $x + 7, $y, 24, 24)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnXbow, $x + 32, $y, 24, 24)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnInferno, $x + 57, $y, 24, 24)
$g_hChkTrap = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTrap", "Rearm Traps && Reload Xbows and Infernos"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTrap_Info_01", "Check this to automatically Rearm Traps, Reload Xbows and Infernos (if any) in your Village."))
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 32
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x - 5, $y, 24, 24)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 24, 24)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 45, $y, 24, 24)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLootCart, $x + 70, $y, 24, 24)
$g_hChkCollect = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCollect", "Collect Resources && Loot Cart"), $x + 100, $y + 4, -1, -1, -1)
GUICtrlSetOnEvent(-1, "ChkCollect")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCollect_Info_01", "Check this to automatically collect the Village's Resources") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCollect_Info_02", "from Gold Mines, Elixir Collectors and Dark Elixir Drills.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCollect_Info_03", "This will also search for a Loot Cart in your village and collect it."))
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 32
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTreasury, $x + 22, $y - 10, 48, 48)
$g_hChkTreasuryCollect = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect", "Treasury"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect_Info_01", "Check this to automatically collect Treasury when FULL,") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect_Info_02", "'OR' when Storage values are BELOW minimum values on right,") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect_Info_03", "Use zero as min values to ONLY collect when Treasury is full") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect_Info_04", "Large minimum values will collect Treasury loot more often!"))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "ChkTreasuryCollect")
$x += 170
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 55, $y + 4, 16, 16)
GUICtrlCreateLabel("<", $x + 47, $y + 6, -1, -1)
$g_hTxtTreasuryGold = GUICtrlCreateInput("1000000", $x + 72, $y + 4, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryGold_Info_01", "Minimum Gold Storage amount to collect Treasury.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryGold_Info_02", "Set same as Resume Attack values to collect when 'out of gold' error") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryGold_Info_03", "happens while searching for attack") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect_Info_01", -1))
GUICtrlSetLimit(-1, 7)
$y += 12
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "LblTreasuryOr", "Or"), $x, $y + 6, -1, -1)
$y += 12
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 55, $y + 4, 16, 16)
GUICtrlCreateLabel("<", $x + 47, $y + 6, -1, -1)
$g_hTxtTreasuryElixir = GUICtrlCreateInput("1000000", $x + 72, $y + 4, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryElixir_Info_01", "Minimum Elixir Storage amount to collect Treasury.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryElixir_Info_02", "Set same as Resume Attack values to collect when 'out of elixir' error") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryElixir_Info_03", "happens during troop training") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect_Info_01", -1))
GUICtrlSetLimit(-1, 7)
$y -= 12
$x += 125
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "LblTreasuryOr", -1), $x + 4, $y + 6, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 55, $y + 4, 16, 16)
GUICtrlCreateLabel("<", $x + 47, $y + 6, -1, -1)
$g_hTxtTreasuryDark = GUICtrlCreateInput("1000", $x + 72, $y + 4, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryDark_Info_01", "Minimum Dark Elixir Storage amount to collect Treasury.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryElixir_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryElixir_Info_03", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect_Info_01", -1))
GUICtrlSetLimit(-1, 6)
$x -=(170 + 126)
$y += 32
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTombstone, $x + 32 , $y, 24, 24)
$g_hChkTombstones = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTombstones", "Clear Tombstones"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTombstones_Info_01", "Check this to automatically clear tombstones after enemy attack."))
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 32
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTree, $x + 20, $y, 24, 24)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBark, $x + 45, $y, 24, 24)
$g_hChkCleanYard = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCleanYard", "Remove Obstacles"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCleanYard_Info_01", "Check this to automatically clear Yard from Trees, Trunks, etc."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 32
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGembox, $x + 32, $y, 24, 24)
$g_hChkGemsBox = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkGemsBox", "Remove GemBox"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkGemsBox_Info_01", "Check this to automatically clear GemBox."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hChkFreeMagicItems = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkFreeMagicItems", "Collect Free Magic Items"), $x + 250, $y + 4, -1, -1)
$y -= 64
Local const $icon = @ScriptDir & "\images\Potion.bmp"
GUICtrlCreatePic($icon, $x + 300, $y + 20, 36, 47, $SS_BITMAP)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 20, $y = 363
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "Group_03", "Locate Manually"), $x - 15, $y - 20, $g_iSizeWGrpTab3, 60)
Local $sTxtRelocate = GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtRelocate_Info_01", "Relocate your") & " "
$x -= 11
$y -= 2
GUICtrlCreateButton(GetTranslatedFileIni("MBR Global GUI Design", "LblTownhall", -1), $x, $y, 36, 36, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnTH12, 1)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnTownhall", "Town Hall"))
GUICtrlSetOnEvent(-1, "btnLocateTownHall")
$x += 38
GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnCC", "Clan Castle"), $x, $y, 36, 36, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnCC, 1)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnCC", "Clan Castle"))
GUICtrlSetOnEvent(-1, "btnLocateClanCastle")
$x += 38
$g_hBtnLocateKingAltar = GUICtrlCreateButton(GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", "King"), $x, $y, 36, 36, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnKingBoostLocate)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnAltarKing_Info_01", "Barbarian King Altar"))
GUICtrlSetOnEvent(-1, "btnLocateKingAltar")
$x += 38
$g_hBtnLocateQueenAltar = GUICtrlCreateButton(GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", "Queen"), $x, $y, 36, 36, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnQueenBoostLocate)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnAltarQueen_Info_01", "Archer Queen Altar"))
GUICtrlSetOnEvent(-1, "btnLocateQueenAltar")
$x += 38
$g_hBtnLocateWardenAltar = GUICtrlCreateButton(GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", "Grand Warden"), $x, $y, 36, 36, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnWardenBoostLocate)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnAltarWarden_Info_01", "Grand Warden Altar"))
GUICtrlSetOnEvent(-1, "btnLocateWardenAltar")
$x += 38
$g_hBtnLocateLaboratory = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnLocateLaboratory", "Lab."), $x, $y, 36, 36, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnLaboratory)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnLocateLaboratory_Info_01", "Laboratory"))
GUICtrlSetOnEvent(-1, "btnLab")
$x += 195
GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnReset", "Reset."), $x, $y, 36, 36, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBldgX)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnReset_Info_01", "Click here to reset all building locations,") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnReset_Info_02", "when you have changed your village layout."))
GUICtrlSetOnEvent(-1, "btnResetBuilding")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateMiscBuilderBaseSubTab()
Local $x = 15, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "Group_05", "Builders Base Stats"), $x - 10, $y - 20, $g_iSizeWGrpTab3, 50)
_GUICtrlCreatePic($g_sIcnBldGold, $x, $y - 2, 24, 24)
$g_alblBldBaseStats[$eLootGoldBB] = GUICtrlCreateLabel("---", $x + 35, $y + 2, 100, -1)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
_GUICtrlCreatePic($g_sIcnBldElixir, $x + 140, $y - 2, 24, 24)
$g_alblBldBaseStats[$eLootElixirBB] = GUICtrlCreateLabel("---", $x + 175, $y + 2, 100, -1)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
_GUICtrlCreatePic($g_sIcnBldTrophy, $x + 280, $y - 2, 24, 24)
$g_alblBldBaseStats[$eLootTrophyBB] = GUICtrlCreateLabel("---", $x + 315, $y + 2, 100, -1)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 15, $y = 100
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "Group_04", "Collect && Activate"), $x - 10, $y - 20, $g_iSizeWGrpTab3, 80)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldMineL5, $x + 7, $y, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixirCollectorL5, $x + 32, $y, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGemMine, $x + 57, $y, 24, 24)
$g_hChkCollectBuilderBase = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCollectBuilderBase", "Collect Ressources"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCollectBuildersBase_Info_01", "Check this to collect Ressources on the Builder Base"))
$y += 32
GUICtrlCreateIcon($g_sLibIconPath, $eIcnClockTower, $x + 32, $y, 24, 24)
$g_hChkStartClockTowerBoost = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkActivateClockTowerBoost", "Activate Clock Tower Boost"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkActivateClockTowerBoost_Info_01", "Check this to activate the Clock Tower Boost when it is available.\r\nThis option doesn't use your Gems"))
GUICtrlSetOnEvent(-1, "chkStartClockTowerBoost")
$g_hChkCTBoostBlderBz = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCTBoostBlderBz", "only when builder is busy"), $x + 260, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCTBoostBlderBz_Info_01", "boost only when the builder is busy"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 15, $y = 190
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "Group_06", "Suggested Upgrades"), $x - 10, $y - 20, $g_iSizeWGrpTab3, 233)
_GUICtrlCreatePic($g_sIcnMBisland, $x , $y , 64, 64)
$g_hChkBBSuggestedUpgrades = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkBBSuggestedUpgrades", "Suggested Upgrades"), $x + 70, $y + 25, -1, -1)
GUICtrlSetOnEvent(-1, "chkActivateBBSuggestedUpgrades")
$g_hChkBBSuggestedUpgradesIgnoreGold = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkBBSuggestedUpgradesIgnore_01", "Ignore Gold values"), $x + 200, $y + 15, -1, -1)
GUICtrlSetOnEvent(-1, "chkActivateBBSuggestedUpgradesGold")
$g_hChkBBSuggestedUpgradesIgnoreElixir = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkBBSuggestedUpgradesIgnore_02", "Ignore Elixir values"), $x + 200, $y + 40, -1, -1)
GUICtrlSetOnEvent(-1, "chkActivateBBSuggestedUpgradesElixir")
$g_hChkBBSuggestedUpgradesIgnoreHall = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkBBSuggestedUpgradesIgnore_03", "Ignore Builder Hall"), $x + 315, $y + 28, -1, -1)
GUICtrlSetOnEvent(-1, "chkActivateBBSuggestedUpgradesGold")
Local $x = 15, $y = 200
$g_hChkPlacingNewBuildings = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkPlacingNewBuildings", "Build 'New' tagged buildings"), $x + 70, $y + 60, -1, -1)
GUICtrlSetOnEvent(-1, "chkPlacingNewBuildings")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateMiscClanGamesV3SubTab()
Local Const $g_sLibIconPathMOD = @ScriptDir & "\images\ClanGames.bmp"
Local $x = 15, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "Group_CG", "Clan Games"), $x - 10, $y - 20, $g_iSizeWGrpTab3, 245)
GUICtrlCreatePic($g_sLibIconPathMOD, $x + 5, $y, 94, 128, $SS_BITMAP)
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesTimeRemaining", "Time Remaining"), $x - 5, $y + 135, 110, 40)
$g_hLblRemainTime = GUICtrlCreateLabel("0d 00h", $x + 15, $y + 135 + 15, 65, 17, $SS_CENTER)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, $GUI_FONTNORMAL)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesYourScore", "Your Score"), $x - 5, $y + 158 + 20, 110, 40)
$g_hLblYourScore = GUICtrlCreateLabel("0/0", $x + 15, $y + 158 + 35, 65, 17, $SS_CENTER)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, $GUI_FONTNORMAL)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 150
$g_hChkClanGamesEnabled = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesEnabled", "Clan Games"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkActivateClangames")
$g_hChkClanGamesOnly = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesOnly", "Clan Games Only"), $x + 100 , $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesOnly_Info_01", "Will Check if the event name is Clan or Builder Games!"))
$g_hChkClanGamesDebug = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesDebug", "Debug"), $x + 205, $y, -1, -1)
$x += 25
$y += 25
$g_hChkClanGamesLoot = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesLoot", "Loot Challenges"), $x, $y, -1, -1)
$y += 25
$g_hChkClanGamesBattle = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesBattle", "Battle Challenges"), $x, $y, -1, -1)
$y += 25
$g_hChkClanGamesDestruction = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesDestruction", "Destruction Challenges"), $x, $y, -1, -1)
$y += 25
$g_hChkClanGamesAirTroop = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesAirTroop", "Air Troops Challenges"), $x, $y, -1, -1)
$y += 25
$g_hChkClanGamesGroundTroop = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesGroundTroop", "Ground Troops Challenges"), $x, $y, -1, -1)
$y += 25
$g_hChkClanGamesMiscellaneous = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesMiscellaneous", "Miscellaneous Challenges"), $x, $y, -1, -1)
$y += 25
$g_hChkClanGamesPurge = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesPurge", "Purge Versus Battles Events"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkPurgeLimits")
$g_hcmbPurgeLimit = GUICtrlCreateCombo("" , $x + 155, $y, 70, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "Unlimited| 1x| 2x| 3x| 4x| 5x| 6x| 7x| 8x| 9x|10x", " 5x")
$y += 25
$g_hChkClanGamesStopBeforeReachAndPurge = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesStopBeforeReachAndPurge", "Stop before completing your limit and only Purge"), $x, $y, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 15
$y = 45
$g_hTxtClanGamesLog = GUICtrlCreateEdit("", $x - 10, 275, $g_iSizeWGrpTab3, 127, BitOR($GUI_SS_DEFAULT_EDIT, $ES_READONLY, $ES_AUTOVSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtClanGamesLog", "--------------------------------------------------------- Clan Games LOG ------------------------------------------------"))
EndFunc
Global $g_hGUI_DONATE = 0, $g_hGUI_DONATE_TAB = 0, $g_hGUI_DONATE_TAB_ITEM1 = 0, $g_hGUI_DONATE_TAB_ITEM2 = 0, $g_hGUI_DONATE_TAB_ITEM3 = 0
Global $g_hChkRequestTroopsEnable = 0, $g_hTxtRequestCC = 0, $g_ahChkRequestCCHours[24] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hChkRequestCCHoursE1 = 0, $g_hChkRequestCCHoursE2 = 0
Global $g_hGrpRequestCC = 0, $g_hLblRequestCCHoursAM = 0, $g_hLblRequestCCHoursPM = 0
Global $g_hLblRequestCChour = 0, $g_ahLblRequestCChoursE = 0
GLobal $g_hLblRequestCChours[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hChkExtraAlphabets = 0, $g_hChkExtraChinese = 0, $g_hChkExtraKorean = 0, $g_hChkExtraPersian = 0
Global $g_ahChkDonateTroop[$eTroopCount + $g_iCustomDonateConfigs] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahChkDonateAllTroop[$eTroopCount + $g_iCustomDonateConfigs] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahTxtDonateTroop[$eTroopCount + $g_iCustomDonateConfigs] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahTxtBlacklistTroop[$eTroopCount + $g_iCustomDonateConfigs] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahGrpDonateTroop[$eTroopCount + $g_iCustomDonateConfigs] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahLblDonateTroop[$eTroopCount + $g_iCustomDonateConfigs] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahBtnDonateTroop[$eTroopCount + $g_iCustomDonateConfigs] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahChkDonateSpell[$eSpellCount] = [0, 0, 0, 0, 0, -1, 0, 0, 0, 0]
Global $g_ahChkDonateAllSpell[$eSpellCount] = [0, 0, 0, 0, 0, -1, 0, 0, 0, 0]
Global $g_ahTxtDonateSpell[$eSpellCount] = [0, 0, 0, 0, 0, -1, 0, 0, 0, 0]
Global $g_ahTxtBlacklistSpell[$eSpellCount] = [0, 0, 0, 0, 0, -1, 0, 0, 0, 0]
Global $g_ahGrpDonateSpell[$eSpellCount] = [0, 0, 0, 0, 0, -1, 0, 0, 0, 0]
Global $g_ahLblDonateSpell[$eSpellCount] = [0, 0, 0, 0, 0, -1, 0, 0, 0, 0]
Global $g_ahBtnDonateSpell[$eSpellCount] = [0, 0, 0, 0, 0, -1, 0, 0, 0, 0]
Global $g_ahCmbDonateCustomA[3] = [0, 0, 0], $g_ahTxtDonateCustomA[3] = [0, 0, 0], $g_ahPicDonateCustomA[3] = [0, 0, 0]
Global $g_ahCmbDonateCustomB[3] = [0, 0, 0], $g_ahTxtDonateCustomB[3] = [0, 0, 0], $g_ahPicDonateCustomB[3] = [0, 0, 0]
Global $g_ahCmbDonateCustomC[3] = [0, 0, 0], $g_ahTxtDonateCustomC[3] = [0, 0, 0], $g_ahPicDonateCustomC[3] = [0, 0, 0]
Global $g_ahCmbDonateCustomD[3] = [0, 0, 0], $g_ahTxtDonateCustomD[3] = [0, 0, 0], $g_ahPicDonateCustomD[3] = [0, 0, 0]
Global $g_hLblDonateTroopTBD1 = 0, $g_hLblDonateTroopTBD2 = 0, $g_hLblDonateTroopTBD3 = 0, $g_hLblDonateTroopCustomC = 0, $g_hLblDonateTroopCustomD = 0, $g_hLblDonateTroopCustomF = 0, $g_hLblDonateTroopCustomG = 0, $g_hLblDonateTroopCustomH = 0, $g_hLblDonateTroopCustomI = 0, $g_hLblDonateTroopCustomJ = 0, $g_hLblDonateSpellTBD1 = 0
Global $g_hGrpDonateGeneralBlacklist = 0, $g_hTxtGeneralBlacklist = 0
Global $lblBtnCustomE = 0
Global $g_hChkDonateHoursEnable = 0, $g_ahChkDonateHours[24] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hCmbFilterDonationsCC = 0, $g_hChkSkipDonateNearFullTroopsEnable = 0
Global $g_hLblDonateHours1 = 0, $g_hLblDonateHoursPM = 0
Global $g_hLblSkipDonateNearFullTroopsText = 0, $g_hTxtSkipDonateNearFullTroopsPercentage = 0, $g_hLblSkipDonateNearFullTroopsText1 = 0
Global $g_hGrpDonateCC = 0, $g_ahChkDonateHoursE1 = 0, $g_ahChkDonateHoursE2 = 0
Global $g_hGUI_RequestCC = 0, $g_hGUI_DONATECC = 0, $g_hGUI_ScheduleCC = 0
Global $g_hGrpDonate = 0, $g_hChkDonate = 1, $g_hLblDonateDisabled = 0, $g_hLblScheduleDisabled = 0
Global $g_hChkUseCCBalanced = 0, $g_hCmbCCDonated = 0, $g_hCmbCCReceived = 0
GLobal $g_hLblDonateCChour = 0, $g_ahLblDonateCChoursE = 0
GLobal $g_hLblDonateCChours[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Func CreateVillageDonate()
$g_hGUI_DONATE = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_VILLAGE)
Local $x = 82
$g_hChkDonate = GUICtrlCreateCheckbox("", $x + 131, 6, 13, 13)
GUICtrlSetState(-1,$GUI_CHECKED)
GUICtrlSetOnEvent(-1, "Doncheck")
CreateRequestSubTab()
CreateDonateSubTab()
CreateScheduleSubTab()
GUISwitch($g_hGUI_DONATE)
$g_hGUI_DONATE_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_DONATE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_02_STab_01", "Request Troops"))
$g_hGUI_DONATE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_02_STab_02", "Donate Troops") & "    ")
$g_hLblDonateDisabled = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_02_STab_02_STab_Info_01", "Note: Donate is disabled, tick the checkmark on the") & " " & GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_02_STab_02", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_02", -1), 5, 30, $g_iSizeWGrpTab3, 374)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hGUI_DONATE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_02_STab_03", "Schedule Donations"))
$g_hLblScheduleDisabled = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_02_STab_02_STab_Info_01", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_02_STab_02", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_02", -1), 5, 30, $g_iSizeWGrpTab3, 374)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateTabItem("")
EndFunc
Func CreateRequestSubTab()
Local $xStart = 25, $yStart = 45
$g_hGUI_RequestCC = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, $xStart - 20, $yStart - 20, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DONATE)
Local $xStart = 20, $yStart = 20
Local $x = $xStart
Local $y = $yStart
$g_hGrpRequestCC = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "Group_01", "Clan Castle Troops"), $x - 20, $y - 20, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3)
$y += 10
$x += 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCCRequest, $x - 5, $y, 64, 64, $BS_ICON)
$g_hChkRequestTroopsEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "ChkRequestTroopsEnable", "Request Troops / Spells"), $x + 40 + 30, $y - 6)
GUICtrlSetOnEvent(-1, "chkRequestCCHours")
$g_hTxtRequestCC = GUICtrlCreateInput(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "TxtRequestCC", "Anything please"), $x + 40 + 30, $y + 15, 214, 20, BitOR($SS_CENTER, $ES_AUTOHSCROLL))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "TxtRequestCC_Info_01", "This text is used on your request for troops in the Clan chat."))
$x += 29 + 30
$y += 60
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", "Only during these hours of each day"), $x + 30, $y, 300, 20, $BS_MULTILINE)
$x += 30
$y += 25
$g_hLblRequestCChour = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Hour", "Hour") & ":", $x, $y, -1, 15)
Local $sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblRequestCChours[0] = GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[1] = GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[2] = GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[3] = GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[4] = GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[5] = GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[6] = GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[7] = GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[8] = GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[9] = GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[10] = GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[11] = GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahLblRequestCChoursE = GUICtrlCreateLabel("X", $x + 213, $y+2, 11, 11)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$g_ahChkRequestCCHours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkRequestCCHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", "This button will clear or set the entire row of boxes"))
GUICtrlSetOnEvent(-1, "chkRequestCCHoursE1")
$g_hLblRequestCCHoursAM = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "AM", "AM"), $x + 5, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$g_ahChkRequestCCHours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkRequestCCHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkRequestCCHoursE2")
$g_hLblRequestCCHoursPM = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "PM", "PM"), $x + 5, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateDonateSubTab()
Local $xStart = 25, $yStart = 45
$g_hGUI_DONATECC = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, $xStart - 20, $yStart - 20, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DONATE)
Local $xStart = 20, $yStart = 20
Local $sTxtBlacklist1 = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklist1", "Blacklist")
Local $sDonateTxtCustomA = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "DonateTxtCustom", "Custom Troops")
Local $sDonateTxtCustomB = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "DonateTxtCustom", -1)
Local $sDonateTxtCustomC = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "DonateTxtCustom", -1)
Local $sDonateTxtCustomD = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "DonateTxtCustom", -1)
Local $sTxtNothing = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtNothing", "Nothing")
Local $sTxtDonate = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonate", "Donate")
Local $sTxtDonateTip = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTip", "Check this to donate")
Local $sTxtDonateAll = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateAll", "Donate to All")
Local $sTxtIgnoreAll = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtIgnoreAll", "This will also ignore ALL keywords.")
Local $sTxtKeywords = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtKeywords", "Keywords for donating")
Local $sTxtKeywordsNo = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtKeywordsNo", "Do NOT donate to these keywords")
Local $sTxtKeywordsNoTip = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtKeywordsNoTip", "Blacklist for donating")
Local $sTxtDonateTipTroop = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTipTroop", "if keywords match the Chat Request.")
Local $sTxtDonateTipAll = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTipAll", "to ALL Chat Requests.")
Local $sTxtBarbarians = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBarbarians", "Barbarians")
Local $sTxtArchers = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtArchers", "Archers")
Local $sTxtGiants = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGiants", "Giants")
Local $sTxtGoblins = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGoblins", "Goblins")
Local $sTxtWallBreakers = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWallBreakers", "Wall Breakers")
Local $sTxtBalloons = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBalloons", "Balloons")
Local $sTxtWizards = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWizards", "Wizards")
Local $sTxtHealers = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHealers", "Healers")
Local $sTxtDragons = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtDragons", "Dragons")
Local $sTxtPekkas = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtPekkas", "Pekkas")
Local $sTxtMinions = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMinions", "Minions")
Local $sTxtHogRiders = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHogRiders", "Hog Riders")
Local $sTxtValkyries = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtValkyries", "Valkyries")
Local $sTxtGolems = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGolems", "Golems")
Local $sTxtWitches = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWitches", "Witches")
Local $SetLog = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtLavaHounds", "Lava Hounds")
Local $sTxtBowlers = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBowlers", "Bowlers")
Local $sTxtBabyDragons = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBabyDragons", "Baby Dragons")
Local $sTxtMiners = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMiners", "Miners")
Local $sTxtElectroDragons = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtElectroDragons", "Electro Dragons")
Local $sTxtLightningSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortLightningSpells", "Lightning")
Local $sTxtHealSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHealSpells", "Heal")
Local $sTxtRageSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortRageSpells", "Rage")
Local $sTxtJumpSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortJumpSpells", "Jump")
Local $sTxtFreezeSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortFreezeSpells", "Freeze")
Local $sTxtPoisonSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortPoisonSpells", "Poison")
Local $sTxtEarthquakeSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortEarthquakeSpells", "EarthQuake")
Local $sTxtHasteSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHasteSpells", "Haste")
Local $sTxtSkeletonSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortSkeletonSpells", "Skeleton")
Local $x = $xStart
Local $y = $yStart
Local $Offx = 38
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "Group_01", "Donate Troops Selection Menu"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 185)
$x = $xStart - 18
$g_ahLblDonateTroop[$eTroopBarbarian] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopBarbarian] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBarbarian, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopArcher] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopArcher] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnArcher, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopGiant] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopGiant] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGiant, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopGoblin] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopGoblin] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoblin, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopWallBreaker] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopWallBreaker] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnWallBreaker, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopBalloon] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopBalloon] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBalloon, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$x += 4
$g_ahLblDonateTroop[$eTroopElectroDragon] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopElectroDragon] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnElectroDragon, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopMinion] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopMinion] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnMinion, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopHogRider] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopHogRider] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnHogRider, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopValkyrie] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopValkyrie] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnValkyrie, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopGolem] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopGolem] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGolem, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x = $xStart - 18
$y += 40
$g_ahLblDonateTroop[$eTroopWizard] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopWizard] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnWizard, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopHealer] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopHealer] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnHealer, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopDragon] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopDragon] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDragon, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopPekka] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopPekka] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnPekka, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopBabyDragon] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopBabyDragon] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBabyDragon, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopMiner] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopMiner] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnMiner, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$x += 4
$g_ahLblDonateTroop[$eTroopWitch] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopWitch] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnWitch, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopLavaHound] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopLavaHound] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnLavaHound, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopBowler] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopBowler] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBowler, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_hLblDonateTroopTBD1 = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$g_hLblDonateTroopTBD2 = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x = $xStart - 18
$y += 40
$g_ahLblDonateSpell[$eSpellLightning] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellLightning] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnLightSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellHeal] = GUICtrlCreateLabel("", $x , $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellHeal] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnHealSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellRage] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellRage] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnRageSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellJump] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellJump] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnJumpSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellFreeze] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellFreeze] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnFreezeSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$lblBtnCustomE = GUICtrlCreateLabel("", $x + 2, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += 4
$x += $Offx
$g_ahLblDonateSpell[$eSpellPoison] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellPoison] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnPoisonSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellEarthquake] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellEarthquake] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnEarthQuakeSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellHaste] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellHaste] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnHasteSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellSkeleton] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellSkeleton] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnSkeletonSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_hLblDonateSpellTBD1 = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x = $xStart - 18
$y += 40
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$g_hLblDonateTroopCustomF = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$g_hLblDonateTroopCustomG = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$g_hLblDonateTroopCustomH = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$g_ahLblDonateTroop[$eCustomA] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eCustomA] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDonCustom, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eCustomB] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eCustomB] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDonCustomB, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += 4
$x += $Offx
$g_ahLblDonateTroop[$eCustomC] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eCustomC] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDonCustom, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eCustomD] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eCustomD] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDonCustomB, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_hLblDonateTroopCustomC = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$g_hLblDonateTroopCustomD = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDonBlacklist, 1)
GUICtrlSetOnEvent(-1, "btnDonateBlacklist")
Local $Offy = $yStart + 185
$x = $xStart
$y = $yStart + 185
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblExtraAlphabets", "Extra Alphabet Recognitions:"), $x - 15, $y + 153, -1, -1)
$g_hChkExtraAlphabets = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraAlphabets", "Cyrillic"), $x + 127 , $y + 149, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraAlphabets_Info_01", "Check this to enable the Cyrillic Alphabet."))
$g_hChkExtraChinese = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraChinese", "Chinese"), $x + 191, $y + 149, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraChinese_Info_01", "Check this to enable the Chinese Alphabet."))
$g_hChkExtraKorean = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraKorean", "Korean"), $x + 265, $y + 149, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraKorean_Info_01", "Check this to enable the Korean Alphabet."))
$g_hChkExtraPersian = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraPersian", "Persian"), $x + 340, $y + 149, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraPersian_Info_01", "Check this to enable the Persian Alphabet."))
GUICtrlCreateGroup("", -99, -99, 1, 1)
$g_ahGrpDonateTroop[$eTroopBarbarian] = GUICtrlCreateGroup($sTxtBarbarians, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBarbarian, $x + 215, $y, 64, 64, $BS_ICON)
$g_ahChkDonateTroop[$eTroopBarbarian] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBarbarians, $x + 285, $y + 10, -1, -1)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBarbarians & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopBarbarian] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBarbarians & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBarbarians & ":", $x - 5, $y + 5, -1, -1)
$g_ahTxtDonateTroop[$eTroopBarbarian] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_01", "barbarians\r\nbarb")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBarbarians)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
$g_ahTxtBlacklistTroop[$eTroopBarbarian] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_01", "no barbarians\r\nno barb\r\nbarbarians no\r\nbarb no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBarbarians)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopArcher] = GUICtrlCreateGroup($sTxtArchers, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonArcher, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopArcher] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtArchers, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtArchers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopArcher] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtArchers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtArchers & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopArcher] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_02", "archers\r\narch")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtArchers)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopArcher] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_02", "no archers\r\nno arch\r\narchers no\r\narch no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtArchers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopGiant] = GUICtrlCreateGroup($sTxtGiants, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonGiant, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopGiant] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtGiants, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGiants & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopGiant] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGiants & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtGiants & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopGiant] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_03", "giants\r\ngiant\r\nany\r\nreinforcement")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtGiants)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopGiant] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_03", "no giants\r\ngiants no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtGiants)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopGoblin] = GUICtrlCreateGroup($sTxtGoblins, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonGoblin, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopGoblin] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtGoblins, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGoblins & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopGoblin] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGoblins & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtGoblins & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopGoblin] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_04", "goblins\r\ngoblin")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtGoblins)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopGoblin] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_04", "no goblins\r\ngoblins no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtGoblins)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopWallBreaker] = GUICtrlCreateGroup($sTxtWallBreakers, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonWallBreaker, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopWallBreaker] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtWallBreakers, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWallBreakers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopWallBreaker] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWallBreakers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtWallBreakers & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopWallBreaker] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_05", "wall breakers\r\nbreaker")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtWallBreakers)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopWallBreaker] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_05", "no wall breakers\r\nwall breakers no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtWallBreakers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopBalloon] = GUICtrlCreateGroup($sTxtBalloons, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBalloon, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopBalloon] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBalloons, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBalloons & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopBalloon] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBalloons & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBalloons & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopBalloon] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_06", "balloons\r\nballoon")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBalloons)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopBalloon] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_06", "no balloon\r\nballoons no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBalloons)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopWizard] = GUICtrlCreateGroup($sTxtWizards, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonWizard, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopWizard] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtWizards, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWizards & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopWizard] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWizards & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtWizards & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopWizard] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_07", "wizards\r\nwizard\r\nwiz")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtWizards)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopWizard] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_07", "no wizards\r\nwizards no\r\nno wizard\r\nwizard no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtWizards)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopHealer] = GUICtrlCreateGroup($sTxtHealers, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonHealer, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopHealer] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtHealers, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHealers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopHealer] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHealers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtHealers & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopHealer] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_08", "healer")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtHealers)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopHealer] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_08", "no healer\r\nhealer no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtHealers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopDragon] = GUICtrlCreateGroup($sTxtDragons, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonDragon, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopDragon] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtDragons, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtDragons & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopDragon] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtDragons & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtDragons & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopDragon] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_09", "dragon")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtDragons)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopDragon] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_09", "no dragon\r\ndragon no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtDragons)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopPekka] = GUICtrlCreateGroup($sTxtPekkas, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonPekka, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopPekka] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtPekkas, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPekkas & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopPekka] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPekkas & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtPekkas & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopPekka] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_10", "PEKKA\r\npekka")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtPekkas)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopPekka] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_10", "no PEKKA\r\npekka no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtPekkas)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopBabyDragon] = GUICtrlCreateGroup($sTxtBabyDragons, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBabyDragon, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopBabyDragon] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBabyDragons, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBabyDragons & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopBabyDragon] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBabyDragons & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBabyDragons & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopBabyDragon] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_11", "baby dragon\r\nbaby")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBabyDragons)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopBabyDragon] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_11", "no baby dragon\r\nbaby dragon no\r\nno baby\r\nbaby no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBabyDragons)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopMiner] = GUICtrlCreateGroup($sTxtMiners, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonMiner, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopMiner] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtMiners, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMiners & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopMiner] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMiners & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtMiners & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopMiner] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_12", "miner|mine")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtMiners)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopMiner] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_12", "no miner\r\nminer no\r\nno mine\r\nmine no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtMiners)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellLightning] = GUICtrlCreateGroup($sTxtLightningSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellLightning] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtLightningSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtLightningSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellLightning] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtLightningSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtLightningSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellLightning] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_13", "lightning")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtLightningSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellLightning] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_13", "no lightning\r\nlightning no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtLightningSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellHeal] = GUICtrlCreateGroup($sTxtHealSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellHeal] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtHealSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHealSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellHeal] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHealSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtHealSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellHeal] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_14", "heal")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtHealSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellHeal] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_14", "no heal\r\nheal no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtHealSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellRage] = GUICtrlCreateGroup($sTxtRageSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellRage] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtRageSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtRageSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellRage] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtRageSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtRageSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellRage] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_15", "rage")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtRageSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellRage] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_15", "no rage\r\nrage no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtRageSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellJump] = GUICtrlCreateGroup($sTxtJumpSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellJump] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtJumpSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtJumpSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellJump] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtJumpSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtJumpSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellJump] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_16", "jump")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtJumpSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellJump] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_16", "no jump\r\njump no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtJumpSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellFreeze] = GUICtrlCreateGroup($sTxtFreezeSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellFreeze] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtFreezeSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtFreezeSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellFreeze] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtFreezeSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtFreezeSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellFreeze] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_17", "freeze")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtFreezeSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellFreeze] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_17", "no freeze\r\nfreeze no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtFreezeSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopElectroDragon] = GUICtrlCreateGroup($sTxtElectroDragons, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElectroDragon, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopElectroDragon] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtElectroDragons, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtElectroDragons & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopElectroDragon] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtElectroDragons & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtElectroDragons & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopElectroDragon] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_31", "electro dragon\r\nelectrodrag\r\nedrag")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtElectroDragons)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopElectroDragon] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_31", "no electro dragon\r\nelectrodrag no\r\nedrag no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtElectroDragons)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopMinion] = GUICtrlCreateGroup($sTxtMinions, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonMinion, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopMinion] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtMinions, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMinions & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopMinion] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMinions & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtMinions & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopMinion] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_18", "minions\r\nminion")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtMinions)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopMinion] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_18", "no minions\r\nminions no\r\nno minion\r\nminion no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtMinions)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopHogRider] = GUICtrlCreateGroup($sTxtHogRiders, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonHogRider, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopHogRider] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtHogRiders, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHogRiders & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopHogRider] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHogRiders & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtHogRiders & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopHogRider] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_19", "hogriders\r\nhogs\r\nhog")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtHogRiders)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopHogRider] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_19", "no hogs\r\nhog no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtHogRiders)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopValkyrie] = GUICtrlCreateGroup($sTxtValkyries, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonValkyrie, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopValkyrie] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtValkyries, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtValkyries & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopValkyrie] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtValkyries & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtValkyries & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopValkyrie] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_20", "valkyries\r\nvalkyrie\r\nvalk")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtValkyries)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopValkyrie] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_20", "no valkyries\r\nvalkyries no\r\nno valk\r\nvalk no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtValkyries)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopGolem] = GUICtrlCreateGroup($sTxtGolems, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonGolem, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopGolem] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtGolems, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGolems & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopGolem] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGolems & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtGolems & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopGolem] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_21", "golem")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtGolems)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopGolem] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_21", "no golem\r\ngolem no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtGolems)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopWitch] = GUICtrlCreateGroup($sTxtWitches, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonWitch, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopWitch] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtWitches, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWitches & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopWitch] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWitches & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtWitches & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopWitch] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_22", "witches\r\nwitch")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtWitches)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopWitch] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_22", "no witches\r\nwitch no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtWitches)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopLavaHound] = GUICtrlCreateGroup($SetLog, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonLavaHound, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopLavaHound] = GUICtrlCreateCheckbox($sTxtDonate & " " & $SetLog, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $SetLog & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopLavaHound] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $SetLog & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $SetLog & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopLavaHound] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_23", "lavahound\r\nlava\r\nhound")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $SetLog)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopLavaHound] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_23", "no lavahound\r\nlava no\r\nhound no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $SetLog)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopBowler] = GUICtrlCreateGroup($sTxtBowlers, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBowler, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopBowler] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBowlers, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBowlers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopBowler] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBowlers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBowlers & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopBowler] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_24", "bowler\r\nbowlers\r\nbowl")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBowlers)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopBowler] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_24", "no bowler\r\nbowl no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBowlers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellPoison] = GUICtrlCreateGroup($sTxtPoisonSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonPoisonSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellPoison] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtPoisonSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPoisonSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellPoison] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPoisonSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtPoisonSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellPoison] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_25", "poison")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtPoisonSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellPoison] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_25", "no poison\r\npoison no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtPoisonSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellEarthquake] = GUICtrlCreateGroup($sTxtEarthQuakeSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonEarthQuakeSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellEarthquake] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtEarthQuakeSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtEarthQuakeSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellEarthquake] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtEarthQuakeSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtEarthQuakeSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellEarthquake] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_26", "earthquake\r\nquake")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtEarthQuakeSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellEarthquake] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_26", "no earthquake\r\nquake no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtEarthQuakeSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellHaste] = GUICtrlCreateGroup($sTxtHasteSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonHasteSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellHaste] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtHasteSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHasteSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellHaste] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHasteSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtHasteSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellHaste] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_27", "haste")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtHasteSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellHaste] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_27", "no haste\r\nhaste no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtHasteSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellSkeleton] = GUICtrlCreateGroup($sTxtSkeletonSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonSkeletonSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellSkeleton] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtSkeletonSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtSkeletonSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellSkeleton] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtSkeletonSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtSkeletonSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellSkeleton] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_28", "skeleton|skel")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtSkeletonSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellSkeleton] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_28", "no skeleton\r\nskeleton no\r\nno skel")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtSkeletonSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eCustomA] = GUICtrlCreateGroup($sDonateTxtCustomA, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 2
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonCustom, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eCustomA] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sDonateTxtCustomA, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomA & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eCustomA] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomA & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sDonateTxtCustomA & ":", $x - 5, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eCustomA] = GUICtrlCreateEdit("", $x - 5, $y + 95, 205, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_29", "ground support\r\nground")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sDonateTxtCustomA)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_01", "1st") & ":", $x, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomA[0] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonWizard, $x + 25, $y, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomA[0] = GUICtrlCreateCombo("", $x + 60, $y, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtWizards)
GUICtrlSetOnEvent(-1, "cmbDonateCustomA")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomA[0] = GUICtrlCreateInput("2", $x + 165, $y, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_02", "2nd") & ":", $x, $y + 29, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomA[1] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonArcher, $x + 25, $y + 25, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomA[1] = GUICtrlCreateCombo("", $x + 60, $y + 25, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtArchers)
GUICtrlSetOnEvent(-1, "cmbDonateCustomA")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomA[1] = GUICtrlCreateInput("3", $x + 165, $y + 25, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_03", "3rd") & ":", $x, $y + 54, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomA[2] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBarbarian, $x + 25, $y + 50, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomA[2] = GUICtrlCreateCombo("", $x + 60, $y + 50, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtBarbarians)
GUICtrlSetOnEvent(-1, "cmbDonateCustomA")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomA[2] = GUICtrlCreateInput("1", $x + 165, $y + 50, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eCustomA] = GUICtrlCreateEdit("", $x + 215, $y + 95, 200, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_29", "no ground\r\nground no\r\nonly")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sDonateTxtCustomA)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eCustomB] = GUICtrlCreateGroup($sDonateTxtCustomB, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 2
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonCustomB, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eCustomB] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sDonateTxtCustomB, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomB & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eCustomB] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomB & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sDonateTxtCustomB & ":", $x - 5, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eCustomB] = GUICtrlCreateEdit("", $x - 5, $y + 95, 205, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_30", "air support\r\nany air")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sDonateTxtCustomB)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_01", -1) & ":", $x, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomB[0] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBabyDragon, $x + 25, $y, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomB[0] = GUICtrlCreateCombo("", $x + 60, $y, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtBabyDragons)
GUICtrlSetOnEvent(-1, "cmbDonateCustomB")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomB[0] = GUICtrlCreateInput("1", $x + 165, $y, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_02", -1) & ":", $x, $y + 29, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomB[1] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBalloon, $x + 25, $y + 25, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomB[1] = GUICtrlCreateCombo("", $x + 60, $y + 25, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtBalloons)
GUICtrlSetOnEvent(-1, "cmbDonateCustomB")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomB[1] = GUICtrlCreateInput("3", $x + 165, $y + 25, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_03", -1) & ":", $x, $y + 54, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomB[2] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonMinion, $x + 25, $y + 50, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomB[2] = GUICtrlCreateCombo("", $x + 60, $y + 50, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtMinions)
GUICtrlSetOnEvent(-1, "cmbDonateCustomB")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomB[2] = GUICtrlCreateInput("5", $x + 165, $y + 50, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eCustomB] = GUICtrlCreateEdit("", $x + 215, $y + 95, 200, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_30", "no air\r\nair no\r\nonly\r\njust")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sDonateTxtCustomB)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eCustomC] = GUICtrlCreateGroup($sDonateTxtCustomC, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 2
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonCustom, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eCustomC] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sDonateTxtCustomC, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomC & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eCustomC] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomC & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sDonateTxtCustomC & ":", $x - 5, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eCustomC] = GUICtrlCreateEdit("", $x - 5, $y + 95, 205, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_29", -1)))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sDonateTxtCustomC)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_01", -1) & ":", $x, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomC[0] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonWizard, $x + 25, $y, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomC[0] = GUICtrlCreateCombo("", $x + 60, $y, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtWizards)
GUICtrlSetOnEvent(-1, "cmbDonateCustomC")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomC[0] = GUICtrlCreateInput("1", $x + 165, $y, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_02", -1) & ":", $x, $y + 29, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomC[1] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonArcher, $x + 25, $y + 25, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomC[1] = GUICtrlCreateCombo("", $x + 60, $y + 25, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtArchers)
GUICtrlSetOnEvent(-1, "cmbDonateCustomC")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomC[1] = GUICtrlCreateInput("3", $x + 165, $y + 25, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_03", -1) & ":", $x, $y + 54, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomC[2] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBarbarian, $x + 25, $y + 50, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomC[2] = GUICtrlCreateCombo("", $x + 60, $y + 50, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtBarbarians)
GUICtrlSetOnEvent(-1, "cmbDonateCustomC")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomC[2] = GUICtrlCreateInput("5", $x + 165, $y + 50, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eCustomC] = GUICtrlCreateEdit("", $x + 215, $y + 95, 200, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_29", -1)))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sDonateTxtCustomC)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eCustomD] = GUICtrlCreateGroup($sDonateTxtCustomD, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 2
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonCustomB, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eCustomD] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sDonateTxtCustomD, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomD & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eCustomD] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomD & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sDonateTxtCustomD & ":", $x - 5, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eCustomD] = GUICtrlCreateEdit("", $x - 5, $y + 95, 205, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_30", -1)))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sDonateTxtCustomD)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_01", -1) & ":", $x, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomD[0] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBabyDragon, $x + 25, $y, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomD[0] = GUICtrlCreateCombo("", $x + 60, $y, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtBabyDragons)
GUICtrlSetOnEvent(-1, "cmbDonateCustomD")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomD[0] = GUICtrlCreateInput("1", $x + 165, $y, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_02", -1) & ":", $x, $y + 29, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomD[1] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBalloon, $x + 25, $y + 25, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomD[1] = GUICtrlCreateCombo("", $x + 60, $y + 25, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtBalloons)
GUICtrlSetOnEvent(-1, "cmbDonateCustomD")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomD[1] = GUICtrlCreateInput("3", $x + 165, $y + 25, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_03", -1) & ":", $x, $y + 54, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomD[2] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonMinion, $x + 25, $y + 50, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomD[2] = GUICtrlCreateCombo("", $x + 60, $y + 50, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtMinions)
GUICtrlSetOnEvent(-1, "cmbDonateCustomD")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomD[2] = GUICtrlCreateInput("5", $x + 165, $y + 50, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eCustomD] = GUICtrlCreateEdit("", $x + 215, $y + 95, 200, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_30", -1)))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sDonateTxtCustomD)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_hGrpDonateGeneralBlacklist = GUICtrlCreateGroup( GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "Group_02", "General Blacklist"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBlacklist, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblGeneralBlacklist", "Do NOT donate to any of these keywords") & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hTxtGeneralBlacklist = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtGeneralBlacklist_Item_01", "clan war\r\nwar\r\ncw")))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtGeneralBlacklist_Info_01", "General Blacklist for donation requests"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateScheduleSubTab()
Local $xStart = 25, $yStart = 45
$g_hGUI_ScheduleCC = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, $xStart - 20, $yStart - 20, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DONATE)
Local $xStart = 20, $yStart = 20
Local $x = $xStart
Local $y = $yStart
$g_hGrpDonateCC = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "Group_01", "Donate Schedule"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 120)
$y += 10
$x += 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCCDonate, $x - 5, $y, 64, 60, $BS_ICON)
$g_hChkDonateHoursEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1), $x + 40 + 30, $y - 6)
GUICtrlSetOnEvent(-1, "chkDonateHours")
$y += 20
$x += 90
$g_hLblDonateCChour = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Hour", -1) & ":", $x, $y, -1, 15)
Local $sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblDonateCChours[0] = GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[1] = GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[2] = GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[3] = GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[4] = GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[5] = GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[6] = GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[7] = GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[8] = GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[9] = GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[10] = GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[11] = GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahLblDonateCChoursE = GUICtrlCreateLabel("X", $x + 213, $y + 2, 11, 11)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$g_ahChkDonateHours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkDonateHoursE1")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "AM", -1), $x + 5, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$g_ahChkDonateHours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkDonateHoursE2")
$g_hLblDonateHoursPM = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "PM", -1), $x + 5, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 16
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $yStart + 130
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "Group_02", "Donation Clan Mates Filter"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 155)
$y += 10
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "LblOption_donate_members", "Using this option you can choose to donate to all members of your team (No Filter), donate only to certain friends (White List) or give everyone except a few members of your team (Black List)"), $x , $y - 10, 380, 40, $BS_MULTILINE)
$y += 35
$g_hCmbFilterDonationsCC = GUICtrlCreateCombo("", $x, $y, 300, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "CmbFilterDonationsCC_Item_01", "No Filter, donate at all Clan Mates") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "CmbFilterDonationsCC_Item_02", "No Filter but collect Clan Mates Images") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "CmbFilterDonationsCC_Item_03", "Donate only at Clan Mates in White List") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "CmbFilterDonationsCC_Item_04", "Donate at all Except at Clan Mates in Black List"), GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "CmbFilterDonationsCC_Item_01", -1))
GUICtrlSetOnEvent(-1, "cmbABAlgorithm")
$y += 35
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "LblImages_of_Clan_Mates", "Images of Clan Mates are captured and stored in main folder, move to appropriate folder (White or Black List)"), $x , $y - 10, 380, 30, $BS_MULTILINE)
$y += 20
GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "BtnOpen_Images_of_Clan_Mates", "Open Clan Mates Image Folder"), $x + 2, $y, 300, 20,-1)
GUICtrlSetOnEvent(-1, "btnFilterDonationsCC")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 60
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "Group_03", "Skip donation near full troops"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 45)
$g_hChkSkipDonateNearFullTroopsEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "ChkSkipDonateNearFullTroopsEnable", "Skip donation near full troops"), $x, $y - 4)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetOnEvent(-1, "chkskipDonateNearFulLTroopsEnable")
$x += 180
$g_hLblSkipDonateNearFullTroopsText = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "LblSkipDonateNearFullTroopsText", "if troops army camps are greater than"), $x, $y)
$x += 110
$g_hTxtSkipDonateNearFullTroopsPercentage = GUICtrlCreateInput("90", $x + 40 + 30, $y - 2, 20, 20, BitOR($SS_CENTER, $ES_AUTOHSCROLL))
GUICtrlSetLimit(-1, 2)
$x += 95
$g_hLblSkipDonateNearFullTroopsText1 = GUICtrlCreateLabel("%", $x, $y)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y += 25
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "Group_04", "Balance Donate/Receive"), $x - 20, $y, $g_iSizeWGrpTab3, 40)
$y += 12
$g_hChkUseCCBalanced = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "Group_04", -1), $x, $y+2, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "ChkUseCCBalanced_Info_01", "Disable Clan Castle Usage or Donations if Ratio is not correct. Will Auto Continue when the Ratio is correct again"))
GUICtrlSetOnEvent(-1, "chkBalanceDR")
$x += 290
$g_hCmbCCDonated = GUICtrlCreateCombo("", $x + 40, $y, 30, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "CmbCCDonated_Info_01", "Donated ratio"))
GUICtrlSetData(-1, "1|2|3|4|5", "1")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbBalanceDR")
GUICtrlCreateLabel("/", $x + 73, $y + 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "LblCCDonated-Received_Info_01", "Wanted donated / received ratio") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "LblCCDonated-Received_Info_02", "1/1 means donated = received, 1/2 means donated = half the received etc."))
$g_hCmbCCReceived = GUICtrlCreateCombo("", $x + 80, $y, 30, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "CmbCCReceived_Info_01", "Received ratio"))
GUICtrlSetData(-1, "1|2|3|4|5", "1")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbBalanceDR")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_UPGRADE = 0, $g_hGUI_UPGRADE_TAB = 0, $g_hGUI_UPGRADE_TAB_ITEM1 = 0, $g_hGUI_UPGRADE_TAB_ITEM2 = 0, $g_hGUI_UPGRADE_TAB_ITEM3 = 0, $g_hGUI_UPGRADE_TAB_ITEM4 = 0, $g_hGUI_UPGRADE_TAB_ITEM5 = 0
Global $g_hChkAutoLabUpgrades = 0, $g_hCmbLaboratory = 0, $g_hLblNextUpgrade = 0, $g_hBtnResetLabUpgradeTime = 0, $g_hPicLabUpgrade = 0
Global $g_hChkUpgradeKing = 0, $g_hChkUpgradeQueen = 0, $g_hChkUpgradeWarden = 0, $g_hPicChkKingSleepWait = 0, $g_hPicChkQueenSleepWait = 0, $g_hPicChkWardenSleepWait = 0
Global $g_hChkUpgrade[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hPicUpgradeStatus[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hTxtUpgradeName[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hTxtUpgradeLevel[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hPicUpgradeType[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hTxtUpgradeValue[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hTxtUpgradeTime[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hTxtUpgradeEndTime[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hChkUpgradeRepeat[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hTxtUpgrMinGold = 0, $g_hTxtUpgrMinElixir = 0, $g_hTxtUpgrMinDark = 0
Global $g_hChkWalls = 0, $g_hTxtWallMinGold = 0, $g_hTxtWallMinElixir = 0, $g_hRdoUseGold = 0, $g_hRdoUseElixir = 0, $g_hRdoUseElixirGold = 0, $g_hChkSaveWallBldr = 0, $g_hCmbWalls = 4
Global $g_hLblWallCost = 0, $g_hBtnFindWalls = 0
Global $g_ahWallsCurrentCount[14] = [-1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahPicWallsLevel[14] = [-1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hChkAutoUpgrade = 0, $g_hLblAutoUpgrade = 0, $g_hTxtAutoUpgradeLog = 0
Global $g_hTxtSmartMinGold = 0, $g_hTxtSmartMinElixir = 0, $g_hTxtSmartMinDark = 0
Global $g_hChkResourcesToIgnore[3] = [0, 0, 0]
Global $g_hChkUpgradesToIgnore[13] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Func CreateVillageUpgrade()
InitTranslatedTextUpgradeTab()
$g_hGUI_UPGRADE = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_VILLAGE)
GUISwitch($g_hGUI_UPGRADE)
$g_hGUI_UPGRADE_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_UPGRADE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_03_STab_01", "Laboratory"))
CreateLaboratorySubTab()
$g_hGUI_UPGRADE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_03_STab_02", "Heroes"))
CreateHeroesSubTab()
$g_hGUI_UPGRADE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_03_STab_03", "Buildings"))
CreateBuildingsSubTab()
$g_hGUI_UPGRADE_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_03_STab_05", "Auto Upgrade"))
CreateAutoUpgradeSubTab()
$g_hGUI_UPGRADE_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_03_STab_04", "Walls"))
CreateWallsSubTab()
GUICtrlCreateTabItem("")
EndFunc
Func CreateLaboratorySubTab()
Local $sTxtNames = GetTranslatedFileIni("MBR Global GUI Design", "None", "None") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBarbarians", "Barbarians") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtArchers", "Archers") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGiants", "Giants") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGoblins", "Goblins") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWallBreakers", "Wall Breakers") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBalloons", "Balloons") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWizards", "Wizards") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHealers", "Healers") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtDragons", "Dragons") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtPekkas", "Pekkas") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBabyDragons", "Baby Dragons") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMiners", "Miners") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtEDragon", "Electro Dragon") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtLightningSpells", "Lightning Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtHealingSpells", "Healing Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtRageSpells", "Rage Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtJumpSpells", "Jump Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtFreezeSpells", "Freeze Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtCloneSpells", "Clone Spell")& "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtPoisonSpells", "Poison Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtEarthQuakeSpells", "EarthQuake Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtHasteSpells", "Haste Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtSkeletonSpells", "Skeleton Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMinions", "Minions") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHogRiders", "Hog Riders") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtValkyries", "Valkyries") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGolems", "Golems") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWitches", "Witches") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtLavaHounds", "Lava Hounds") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBowlers", "Bowlers")
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child VIllage - Upgrade_Laboratory", "Group_01", "Laboratory"), $x - 20, $y - 20, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLaboratory, $x, $y, 64, 64)
$g_hChkAutoLabUpgrades = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child VIllage - Upgrade_Laboratory", "ChkAutoLabUpgrades", "Auto Laboratory Upgrades"), $x + 80, $y + 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child VIllage - Upgrade_Laboratory", "ChkAutoLabUpgrades_Info_01", "Check box to enable automatically starting Upgrades in laboratory"))
GUICtrlSetOnEvent(-1, "chkLab")
$g_hLblNextUpgrade = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child VIllage - Upgrade_Laboratory", "LblNextUpgrade", "Next one") & ":", $x + 80, $y + 38, 50, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hCmbLaboratory = GUICtrlCreateCombo("", $x + 135, $y + 35, 140, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtNames, GetTranslatedFileIni("MBR Global GUI Design", "None", "None"))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child VIllage - Upgrade_Laboratory", "CmbLaboratory_Info_01", "Select the troop type to upgrade with this pull down menu") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child VIllage - Upgrade_Laboratory", "CmbLaboratory_Info_02", "The troop icon will appear on the right.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child VIllage - Upgrade_Laboratory", "CmbLaboratory_Info_03", "Any Dark Spell/Troop have priority over Upg Heroes!"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbLab")
$g_hBtnResetLabUpgradeTime = GUICtrlCreateButton("", $x + 120 + 172, $y + 36, 18, 18, BitOR($BS_PUSHLIKE,$BS_DEFPUSHBUTTON))
GUICtrlSetBkColor(-1, $COLOR_ERROR)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child VIllage - Upgrade_Laboratory", "BtnResetLabUpgradeTime_Info_01", "Visible Red button means that laboratory upgrade in process") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child VIllage - Upgrade_Laboratory", "BtnResetLabUpgradeTime_Info_02", "This will automatically disappear when near time for upgrade to be completed.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child VIllage - Upgrade_Laboratory", "BtnResetLabUpgradeTime_Info_03", "If upgrade has been manually finished with gems before normal end time,") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child VIllage - Upgrade_Laboratory", "BtnResetLabUpgradeTime_Info_04", "Click red button to reset internal upgrade timer BEFORE STARTING NEW UPGRADE") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child VIllage - Upgrade_Laboratory", "BtnResetLabUpgradeTime_Info_05", "Caution - Unnecessary timer reset will force constant checks for lab status"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetOnEvent(-1, "ResetLabUpgradeTime")
$g_hPicLabUpgrade = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBlank, $x + 330, $y, 64, 64)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateHeroesSubTab()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "Group_01", "Upgrade Heroes Continuously"), $x - 20, $y - 20, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "LblAutoUpgrading_01", "Auto upgrading of your Heroes"), $x - 10, $y, -1, -1)
$y += 20
$g_hChkUpgradeKing = GUICtrlCreateCheckbox("", $x, $y + 25, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeKing_Info_01", "Enable upgrading of your King when you have enough Dark Elixir (Saving Min. Dark Elixir)") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeKing_Info_02", "You can manually locate your Kings Altar on Misc Tab") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeHeroes_Info_01", "Verify your Resume Bot Dark Elixir value at Misc Tab vs Saving Min. Dark Elixir here!") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeKing_Info_04", "Enabled with TownHall 7 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeKing")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnKingUpgr, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicChkKingSleepWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingKing, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 95
$g_hChkUpgradeQueen = GUICtrlCreateCheckbox("", $x, $y + 25, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeQueen_Info_01", "Enable upgrading of your Queen when you have enough Dark Elixir (Saving Min. Dark Elixir)") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeQueen_Info_02", "You can manually locate your Queens Altar on Misc Tab") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeHeroes_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeQueen_Info_03", "Enabled with TownHall 9 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeQueen")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueenUpgr, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicChkQueenSleepWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingQueen, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 95
$g_hChkUpgradeWarden = GUICtrlCreateCheckbox("", $x, $y + 25, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeWarden_Info_01", "Enable upgrading of your Warden when you have enough Elixir (Saving Min. Elixir)") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeWarden_Info_02", "You can manually locate your Wardens Altar on Misc Tab") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeHeroes_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeWarden_Info_03", "Enabled with TownHall 11")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeWarden")
GUICtrlSetColor(-1, $COLOR_ERROR )
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWardenUpgr, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicChkWardenSleepWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingWarden, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateBuildingsSubTab()
Local $sTxtShowType = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtShowType", "This shows type of upgrade, click to show location")
Local $sTxtStatus = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtStatus", "Status: Red=not programmed, Yellow=programmed, not completed, Green=Completed")
Local $sTxtShowName = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtShowName", "This box is updated with unit name after upgrades are checked")
Local $sTxtShowLevel = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtShowLevel", "This unit box is updated with unit level after upgrades are checked")
Local $sTxtShowCost = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtShowCost", "This upgrade cost box is updated after upgrades are checked")
Local $sTxtShowTime = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtShowTime", "This box is updated with time length of upgrade after upgrades are checked")
Local $sTxtChkRepeat = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtChkRepeat", "Check box to Enable Upgrade to repeat continuously")
Local $sTxtShowEndTime = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtShowEndTime", "This box is updated with estimate end time of upgrade after upgrades are checked")
Local $sTxtCheckBox = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtCheckBox", "Check box to Enable Upgrade")
Local $sTxtAfterUsing = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtAfterUsing", "after using Locate Upgrades button")
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Group_01", "Buildings or Heroes"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 30 +($g_iUpgradeSlots * 22))
$x -= 7
$y -= 7
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Table header_01", "Unit Name"), $x + 71, $y, 70, 18)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Table header_02", "Lvl"), $x + 153, $y, 40, 18)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Table header_03", "Type"), $x + 173, $y, 50, 18)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Table header_04", "Cost"), $x + 219, $y, 50, 18)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Table header_05", "Time"), $x + 270, $y, 50, 18)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Table header_06", "Rep."), $x + 392, $y, 50, 18)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Table header_07", "Estimate End"), $x + 314, $y, 70, 18)
$y += 13
For $i = 0 To $g_iUpgradeSlots - 1
$g_hPicUpgradeStatus[$i]= _GUICtrlCreateIcon($g_sLibIconPath, $eIcnTroops, $x - 10, $y + 1, 14, 14)
_GUICtrlSetTip(-1, $sTxtStatus)
$g_hChkUpgrade[$i] = GUICtrlCreateCheckbox($i + 1 & ":", $x + 5, $y + 1, 34, 15)
_GUICtrlSetTip(-1, $sTxtCheckBox & " #" & $i + 1 & " " & $sTxtAfterUsing)
GUICtrlSetOnEvent(-1, "btnchkbxUpgrade")
$g_hTxtUpgradeName[$i] = GUICtrlCreateInput("", $x + 40, $y, 107, 17, BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowName)
$g_hTxtUpgradeLevel[$i] = GUICtrlCreateInput("", $x + 150, $y, 23, 17, BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowLevel)
$g_hPicUpgradeType[$i]= _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBlank, $x + 178, $y + 1, 15, 15)
_GUICtrlSetTip(-1, $sTxtShowType)
GUICtrlSetOnEvent(-1, "picUpgradeTypeLocation")
$g_hTxtUpgradeValue[$i] = GUICtrlCreateInput("", $x + 197, $y, 65, 17, BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowCost)
$g_hTxtUpgradeTime[$i] = GUICtrlCreateInput("", $x + 266, $y, 35, 17, BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowTime)
$g_hTxtUpgradeEndTime[$i] = GUICtrlCreateInput("", $x + 305, $y, 85, 17, BitOR($ES_LEFT, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
GUICtrlSetFont(-1, 7)
_GUICtrlSetTip(-1, $sTxtShowEndTime)
$g_hChkUpgradeRepeat[$i] = GUICtrlCreateCheckbox("", $x + 395, $y + 1, 15, 15)
_GUICtrlSetTip(-1, $sTxtChkRepeat)
GUICtrlSetOnEvent(-1, "btnchkbxRepeat")
$y += 22
Next
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x += 5
$y += 8
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x - 15, $y, 15, 15)
GUICtrlCreateLabel( GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "LblUpgrMinGold", "Min. Gold") & ":", $x + 5, $y + 3, -1, -1)
$g_hTxtUpgrMinGold = GUICtrlCreateInput("250000", $x + 55, $y, 61, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtUpgrMinGold_Info_01", "Save this much Gold after the upgrade completes.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtUpgrMinGold_Info_02", "Set this value as needed to save for searching, or wall upgrades."))
GUICtrlSetLimit(-1, 7)
$y += 18
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x - 15, $y, 15, 15)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "LblUpgrMinElixir", "Min. Elixir") & ":", $x + 5, $y + 3, -1, -1)
$g_hTxtUpgrMinElixir = GUICtrlCreateInput("250000", $x + 55, $y, 61, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtUpgrMinElixir_Info_01", "Save this much Elixir after the upgrade completes") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtUpgrMinElixir_Info_02", "Set this value as needed to save for making troops or wall upgrades."))
GUICtrlSetLimit(-1, 7)
$x -= 15
$y -= 8
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 140, $y, 15, 15)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "LblUpgrMinDark", "Min. Dark") & ":", $x + 160, $y + 3, -1, -1)
$g_hTxtUpgrMinDark = GUICtrlCreateInput("3000", $x + 210, $y, 61, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtUpgrMinDark_Info_01", "Save this amount of Dark Elixir after the upgrade completes.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtUpgrMinDark_Info_02", "Set this value higher if you want make war troops."))
GUICtrlSetLimit(-1, 6)
$y -= 8
GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "BtnLocateUpgrades", "Locate Upgrades"), $x + 290, $y - 4, 120, 18, BitOR($BS_MULTILINE, $BS_VCENTER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "BtnLocateUpgrades_Info_01", "Push button to locate and record information on building/Hero upgrades") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "BtnLocateUpgrades_Info_02", "Any upgrades with repeat enabled are skipped and can not be located again"))
GUICtrlSetOnEvent(-1, "btnLocateUpgrades")
GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "BtnResetUpgrades", "Reset Upgrades"), $x + 290, $y + 16, 120, 18, BitOR($BS_MULTILINE, $BS_VCENTER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "BtnResetUpgrades_Info_01", "Push button to reset & remove upgrade information") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "BtnResetUpgrades_Info_02", "If repeat box is checked, data will not be reset"))
GUICtrlSetOnEvent(-1, "btnResetUpgrade")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateWallsSubTab()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "Group_01", "Walls"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 120)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWall, $x - 12, $y - 6, 24, 24)
$g_hChkWalls = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "ChkWalls", "Auto Wall Upgrade"), $x + 18, $y - 2, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "ChkWalls_Info_01", "Check this to upgrade Walls if there are enough resources."))
GUICtrlSetState(-1, $GUI_ENABLE)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkWalls")
$g_hBtnFindWalls = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "BtnFindWalls", "TEST"), $x + 150, $y + 26, 45, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "BtnFindWalls_Info_01", "Click here to test the Wall Detection."))
GUICtrlSetOnEvent(-1, "btnWalls")
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0x5CAD85)
$g_hRdoUseGold = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseGold", "Use Gold"), $x + 25, $y + 16, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseGold_Info_01", "Use only Gold for Walls.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseGold_Info_02", "Available at all Wall levels."))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hRdoUseElixir = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseElixir", "Use Elixir"), $x + 25, $y + 34, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseElixir_Info_01", "Use only Elixir for Walls.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseElixir_Info_02", "Available only at Wall levels upgradeable with Elixir."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hRdoUseElixirGold = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseElixirGold", "Try Elixir first, Gold second"), $x + 25, $y + 52, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseElixirGold_Info_01", "Try to use Elixir first. If not enough Elixir try to use Gold second for Walls.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseElixir_Info_02", -1))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x - 12, $y + 72, 20, 20)
$g_hChkSaveWallBldr = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "ChkSaveWallBldr", "Save ONE builder for Walls"), $x + 18, $y + 72, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "ChkSaveWallBldr_Info_01", "Check this to reserve 1 builder exclusively for walls and") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "ChkSaveWallBldr_Info_02", "reduce the available builder by 1 for other upgrades"))
GUICtrlSetState(-1, $GUI_ENABLE)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkSaveWallBldr")
$x += 225
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblSearchforWalls", "Search for Walls level") & ":", $x, $y + 2, -1, -1)
$g_hCmbWalls = GUICtrlCreateCombo("", $x + 110, $y, 61, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL), $WS_EX_RIGHT)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "CmbWalls_Info_01", "Search for Walls of this level and try to upgrade them one by one."))
GUICtrlSetData(-1, "4   |5   |6   |7   |8   |9   |10   |11   |12   ", "4   ")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbWalls")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblNextWalllevelcosts", "Next Wall level costs") & ":", $x, $y + 25, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblNextWalllevelcosts_Info_01", "Use this value as an indicator.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblNextWalllevelcosts_Info_02", "The value will update if you select an other wall level."))
$g_hLblWallCost = GUICtrlCreateLabel("30 000", $x + 110, $y + 25, 50, -1, $SS_RIGHT)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x, $y + 47, 16, 16)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblMin.Goldtosave", "Min. Gold to save"), $x + 20, $y + 47, -1, -1)
$g_hTxtWallMinGold = GUICtrlCreateInput("250000", $x + 110, $y + 45, 61, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblMin.Goldtosave_Info_01", "Save this much Gold after the wall upgrade completes,") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblMin.Goldtosave_Info_02", "Set this value to save Gold for other upgrades, or searching."))
GUICtrlSetLimit(-1, 7)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 2
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x, $y + 67, 16, 16)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblMin.Elixirtosave", "Min. Elixir to save"), $x + 20, $y + 70, -1, -1)
$g_hTxtWallMinElixir = GUICtrlCreateInput("250000", $x + 110, $y + 65, 61, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblMin.Elixirtosave_Info_01", "Save this much Elixir after the wall upgrade completes,") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblMin.Elixirtosave_Info_02", "Set this value to save Elixir for other upgrades or troop making."))
GUICtrlSetLimit(-1, 7)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 25, $y = 170
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "Group_02", "Walls counter"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 100)
$x -= 3
$g_ahWallsCurrentCount[4] = GUICtrlCreateInput("0", $x - 10, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", "Input number of Walls level") & " 4 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", "you have."))
$g_ahPicWallsLevel[4] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall04, $x + 17, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[5] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 5 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[5] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall05, $x + 27, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[6] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 6 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[6] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall06, $x + 27, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[7] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 7 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[7] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall07, $x + 27, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[8] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 8 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[8] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall08, $x + 27, $y - 2, 24, 24)
Local $x = 25
$x -= 3
$x += 10
$y += 40
$g_ahWallsCurrentCount[9] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 9 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[9] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall09, $x + 27, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[10] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 10 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[10] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall10, $x + 27, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[11] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 11 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[11] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall11, $x + 27, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[12] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 12 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[12] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall12, $x + 27, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[13] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 13 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[13] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall13, $x + 27, $y - 2, 24, 24)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateAutoUpgradeSubTab()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "Group_01", "Auto Upgrade"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 100)
$g_hChkAutoUpgrade = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "ChkAutoUpgrade", "Enable Auto Upgrade"), $x - 5, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "ChkAutoUpgrade_Info_01", "Check box to enable automatically starting Upgrades from builders menu"))
GUICtrlSetOnEvent(-1, "chkAutoUpgrade")
$g_hLblAutoUpgrade = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "Label_01", "Save"), $x, $y + 32, -1, -1)
$g_hTxtSmartMinGold = GUICtrlCreateInput("150000", $x + 33, $y + 29, 60, 21, BitOR($ES_CENTER, $ES_NUMBER))
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 98, $y + 32, 16, 16)
$g_hTxtSmartMinElixir = GUICtrlCreateInput("150000", $x + 118, $y + 29, 60, 21, BitOR($ES_CENTER, $ES_NUMBER))
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 183, $y + 32, 16, 16)
$g_hTxtSmartMinDark = GUICtrlCreateInput("1500", $x + 203, $y + 29, 60, 21, BitOR($ES_CENTER, $ES_NUMBER))
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 268, $y + 32, 16, 16)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "Label_02", "after launching upgrade"), $x + 290, $y + 32, -1, -1)
$g_hChkResourcesToIgnore[0] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "Ignore_01", "Ignore Gold Upgrades"), $x, $y + 55, -1, -1)
GUICtrlSetOnEvent(-1, "chkResourcesToIgnore")
$g_hChkResourcesToIgnore[1] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "Ignore_02", "Ignore Elixir Upgrades"), $x + 130, $y + 55, -1, -1)
GUICtrlSetOnEvent(-1, "chkResourcesToIgnore")
$g_hChkResourcesToIgnore[2] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "Ignore_03", "Ignore Dark Elixir Upgrades"), $x + 258, $y + 55, -1, -1)
GUICtrlSetOnEvent(-1, "chkResourcesToIgnore")
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "Group_02", "Upgrades to ignore"), $x - 20, $y + 85, $g_iSizeWGrpTab3, 137)
Local $x = 21, $y = 100
Local $iIconSize = 32
Local $xOff =(40 - $iIconSize) / 2
Local $yRow1 = 50
Local $yRow2 = 110
Local $yChkOff = 32
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTH11, $x + 5, $y + $yRow1, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[0] = GUICtrlCreateCheckbox("", $x + 20 - $xOff, $y + $yRow1 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x + 95, $y + $yRow1, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[1] = GUICtrlCreateCheckbox("", $x + 110 - $xOff, $y + $yRow1 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x + 140, $y + $yRow1, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[2] = GUICtrlCreateCheckbox("", $x + 155 - $xOff, $y + $yRow1 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x + 185, $y + $yRow1, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[3] = GUICtrlCreateCheckbox("", $x + 200 - $xOff, $y + $yRow1 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCC, $x + 275, $y + $yRow1, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[4] = GUICtrlCreateCheckbox("", $x + 290 - $xOff, $y + $yRow1 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLaboratory, $x + 365, $y + $yRow1, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[5] = GUICtrlCreateCheckbox("", $x + 380 - $xOff, $y + $yRow1 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBarrack, $x + 5, $y + $yRow2, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[6] = GUICtrlCreateCheckbox("", $x + 20 - $xOff, $y + $yRow2 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDarkBarrack, $x + 50, $y + $yRow2, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[7] = GUICtrlCreateCheckbox("", $x + 65 - $xOff, $y + $yRow2 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSpellFactory, $x + 140, $y + $yRow2, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[8] = GUICtrlCreateCheckbox("", $x + 155 - $xOff, $y + $yRow2 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDarkSpellFactory, $x + 185, $y + $yRow2, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[9] = GUICtrlCreateCheckbox("", $x + 200 - $xOff, $y + $yRow2 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 275, $y + $yRow2, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[10] = GUICtrlCreateCheckbox("", $x + 290 - $xOff, $y + $yRow2 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 320, $y + $yRow2, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[11] = GUICtrlCreateCheckbox("", $x + 335 - $xOff, $y + $yRow2 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 365, $y + $yRow2, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[12] = GUICtrlCreateCheckbox("", $x + 380 - $xOff, $y + $yRow2 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$g_hTxtAutoUpgradeLog = GUICtrlCreateEdit("", $x - 16, 275, $g_iSizeWGrpTab3, 127, BitOR($GUI_SS_DEFAULT_EDIT, $ES_READONLY))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "TxtAutoUpgradeLog", "------------------------------------------------ AUTO UPGRADE LOG ------------------------------------------------"))
EndFunc
Global $g_hChkUnbreakable = 0, $g_hTxtUnbreakable = 0, $g_hTxtUnBrkMinGold = 0, $g_hTxtUnBrkMaxGold = 0, $g_hTxtUnBrkMinElixir = 0, $g_hTxtUnBrkMaxElixir = 0, $g_hTxtUnBrkMinDark = 0, $g_hTxtUnBrkMaxDark = 0
Global $g_hLblUnbreakableHelp = 0, $g_hLblUnbreakableLink = 0
Func CreateVillageAchievements()
Local $x = 25
Local $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "Group_01", "Defense Farming"), $x - 20, $y - 20, $g_iSizeWGrpTab2, 150)
$y +=10
$g_hChkUnbreakable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "ChkUnbreakable", "Enable Unbreakable"), $x - 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "ChkUnbreakable_Info_01", "Enable farming Defense Wins for Unbreakable achievement."))
GUICtrlSetOnEvent(-1, "chkUnbreakable")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldStar, $x + 10, $y + 51, 32, 32)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldStar, $x + 42, $y + 36, 48, 48)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldStar, $x + 90, $y + 51, 32, 32)
$x = 150
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "LblUnbreakable", "Wait Time") & ":", $x - 10, $y + 3, 86, -1, $SS_RIGHT)
$g_hTxtUnbreakable = GUICtrlCreateInput("5", $x + 80, $y, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnbreakable_Info_01", "Set the amount of time to stop CoC and wait for enemy attacks to gain defense wins. (1-99 minutes)"))
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Minutes", "Minutes"), $x + 113, $y + 3, -1, -1)
$y += 28
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "Lbl_FarmMin._Info_01", "Farm Min."), $x + 25, $y, -1, -1)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "Lbl_SaveMin._Info_01", "Save Min."), $x + 115, $y, -1, -1)
$y += 16
$g_hTxtUnBrkMinGold = GUICtrlCreateInput("50000", $x + 20, $y, 58, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMinGold_Info_01", "Amount of Gold that stops Defense farming, switches to normal farming if below.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMinGold_Info_02", "Set this value to amount of Gold you need for searching or upgrades."))
GUICtrlSetLimit(-1, 7)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 80, $y + 2, 16, 16)
$g_hTxtUnBrkMaxGold = GUICtrlCreateInput("600000", $x + 110, $y, 58, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMaxGold_Info_01", "Amount of Gold in Storage Required to Enable Defense Farming.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMaxGold_Info_02", "Input amount of Gold you need to attract enemy or for upgrades."))
GUICtrlSetLimit(-1, 7)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 170, $y + 2, 16, 16)
$y += 26
$g_hTxtUnBrkMinElixir = GUICtrlCreateInput("50000", $x + 20, $y, 58, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMinElixir_Info_01", "Amount of Elixir that stops Defense farming, switches to normal farming if below.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMinElixir_Info_02", "Set this value to amount of Elixir you need for making troops or upgrades."))
GUICtrlSetLimit(-1, 7)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 80, $y, 16, 16)
$g_hTxtUnBrkMaxElixir = GUICtrlCreateInput("600000", $x + 110, $y, 58, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMaxElixir_Info_01", "Amount of Elixir in Storage Required to Enable Defense Farming.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMaxElixir_Info_02", "Input amount of Elixir you need to attract enemy or for upgrades."))
GUICtrlSetLimit(-1, 7)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 170, $y, 16, 16)
$y += 24
$g_hTxtUnBrkMinDark = GUICtrlCreateInput("5000", $x + 20, $y, 58, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMinDark_Info_01", "Amount of Dark Elixir that stops Defense farming, switches to normal farming if below.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMinDark_Info_02", "Set this value to amount of Dark Elixir you need for making troops or upgrades."))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 80, $y, 16, 16)
$g_hTxtUnBrkMaxDark = GUICtrlCreateInput("6000", $x + 110, $y, 58, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMaxDark_Info_01", "Amount of Dark Elixir in Storage Required to Enable Defense Farming.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMaxDark_Info_02", "Input amount of Dark Elixir you need to attract enemy or for upgrades."))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 170, $y, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 200
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "Group_02", "How to use Unbreakable Mode"), $x - 20, $y - 20, $g_iSizeWGrpTab2, 200)
Local $txtHelp = GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "txtHelp_01", "Unbreakable mode will help you gain defense wins and the ""Unbreakable"" achievement.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "txtHelp_02", "Set ""Wait Time"" to how long you want the bot to wait for defenses.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "txtHelp_03", "Farm Min is how many resources the bot must have before attacking.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "txtHelp_04", "Save Min is how many resources the bot must have before starting unbreakable mode.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "txtHelp_05", "Click the below link for more information:")
$g_hLblUnbreakableHelp = GUICtrlCreateLabel($txtHelp, $x - 10, $y, 430, 100)
$g_hLblUnbreakableLink = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "LblUnbreakableLink", "More Info"), $x - 10, $y + 100, 100, 20)
_GUICtrlSetTip(-1, "https://mybot.run/forums/index.php?/topic/2964-guide-how-to-use-mybot-unbreakable-mode-updated/")
GUICtrlSetFont(-1, 8.5, $FW_BOLD, $GUI_FONTUNDER)
GUICtrlSetColor(-1, $COLOR_INFO)
GUICtrlSetCursor(-1, 0)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_NOTIFY = 0, $g_hGUI_NOTIFY_TAB = 0, $g_hGUI_NOTIFY_TAB_ITEM2 = 0, $g_hGUI_NOTIFY_TAB_ITEM6 = 0
Global $g_hGrpNotify = 0
Global $g_hChkNotifyPBEnable = 0, $g_hTxtNotifyPBToken = 0, $g_hChkNotifyTGEnable = 0, $g_hTxtNotifyTGToken = 0
Global $g_hChkNotifyRemote = 0, $g_hTxtNotifyOrigin = 0
Global $g_hChkNotifyDeleteAllPBPushes = 0, $g_hBtnNotifyDeleteMessages = 0, $g_hChkNotifyDeleteOldPBPushes = 0, $g_hCmbNotifyPushHours = 0, $g_hChkNotifyAlertMatchFound = 0, $g_hChkNotifyAlertLastRaidIMG = 0, $g_hChkNotifyAlertLastRaidTXT = 0, $g_hChkNotifyAlertCampFull = 0, $g_hChkNotifyAlertUpgradeWall = 0, $g_hChkNotifyAlertOutOfSync = 0, $g_hChkNotifyAlertTakeBreak = 0, $g_hChkNotifyAlertBuilderIdle = 0, $g_hChkNotifyAlertVillageStats = 0, $g_hChkNotifyAlertLastAttack = 0, $g_hChkNotifyAlertAnotherDevice = 0, $g_hChkNotifyAlertMaintenance = 0, $g_hChkNotifyAlertBAN = 0, $g_hChkNotifyBOTUpdate = 0, $g_hChkNotifyAlertSmartWaitTime = 0
Global $g_hChkNotifyOnlyHours = 0, $g_hChkNotifyOnlyWeekDays = 0, $g_hChkNotifyhours[24] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], $g_hChkNotifyWeekdays[7] = [0, 0, 0, 0, 0, 0, 0]
GLobal $g_hLblNotifyhour = 0, $g_ahLblNotifyhoursE = 0, $g_hChkNotifyhoursE1 = 0, $g_hChkNotifyhoursE2 = 0, $g_hLblNotifyhoursAM = 0, $g_hLblNotifyhoursPM = 0
GLobal $g_hLblNotifyhours[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hLblNotifyWeekdays[7] = [0, 0, 0, 0, 0, 0, 0], $g_ahLblNotifyWeekdaysE = 0, $g_ahChkNotifyWeekdaysE = 0
Func CreateVillageNotify()
$g_hGUI_NOTIFY = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_VILLAGE)
GUISwitch($g_hGUI_NOTIFY)
$g_hGUI_NOTIFY_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_NOTIFY_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_05_STab_01", "PushBullet/Telegram"))
CreatePushBulletTelegramSubTab()
$g_hGUI_NOTIFY_TAB_ITEM6 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_05_STab_02", "Notify Schedule"))
CreateNotifyScheduleSubTab()
GUICtrlCreateTabItem("")
EndFunc
Func CreatePushBulletTelegramSubTab()
Local $sTxtTip = ""
Local $x = 25, $y = 45
$g_hGrpNotify = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "Group_01", "PushBullet/Telegram Notify") & " " & $g_sNotifyVersion, $x - 20, $y - 20, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3)
$x -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnNotify, $x + 3, $y, 32, 32)
$g_hChkNotifyPBEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyPBEnable", "Enable PushBullet"), $x + 40, $y + 5)
GUICtrlSetOnEvent(-1, "chkPBTGenabled")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyPBEnable_Info_01", "Enable PushBullet notifications"))
$g_hChkNotifyDeleteAllPBPushes = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyDeleteAllPBPushes", "Delete Msg on Start"), $x + 160, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyDeleteAllPBPushes_Info_01", "It will delete all previous push notification when you start bot"))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hBtnNotifyDeleteMessages = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "BtnNotifyDeleteMessages", "Delete all Msg now"), $x + 300, $y, 100, 20)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "BtnNotifyDeleteMessages_Info_01", "Click here to delete all PushBullet messages."))
GUICtrlSetOnEvent(-1, "btnDeletePBMessages")
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0x5CAD85)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 22
$g_hChkNotifyDeleteOldPBPushes = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyDeleteOldPBPushes", "Delete Msg older than"), $x + 160, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyDeleteOldPBPushes_Info_01", "Delete all previous push notification older than specified hour"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkDeleteOldPBPushes")
$g_hCmbNotifyPushHours = GUICtrlCreateCombo("", $x + 300, $y, 100, 35, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "CmbNotifyPushHours_Info_01", "Set the interval for messages to be deleted."))
Local $sTxtHours = GetTranslatedFileIni("MBR Global GUI Design", "Hours", -1)
GUICtrlSetData(-1, "1 " & GetTranslatedFileIni("MBR Global GUI Design", "Hour", -1) &"|2 " & $sTxtHours & "|3 " & $sTxtHours & "|4 " & $sTxtHours & "|5 " & $sTxtHours & "|6 " & $sTxtHours & "|7 " & $sTxtHours & "|8 " &$sTxtHours & "|9 " & $sTxtHours & "|10 " & $sTxtHours & "|11 " & $sTxtHours & "|12 " & $sTxtHours & "|13 " & $sTxtHours & "|14 " & $sTxtHours & "|15 " & $sTxtHours & "|16 " & $sTxtHours & "|17 " & $sTxtHours & "|18 " & $sTxtHours & "|19 " & $sTxtHours & "|20 " & $sTxtHours & "|21 " & $sTxtHours & "|22 " & $sTxtHours & "|23 " & $sTxtHours & "|24 " & $sTxtHours )
_GUICtrlComboBox_SetCurSel(-1,0)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 30
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyPBToken", "Token (PushBullet)") & ":", $x, $y, -1, -1, $SS_RIGHT)
$g_hTxtNotifyPBToken = GUICtrlCreateInput("", $x + 120, $y - 3, 280, 19)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyPBToken_Info_01", "You need a Token to use PushBullet notifications. Get a token from PushBullet.com"))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTelegram, $x + 3, $y, 32, 32)
$g_hChkNotifyTGEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyTGEnable", "Enable Telegram"), $x + 40, $y + 5)
GUICtrlSetOnEvent(-1, "chkPBTGenabled")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyTGEnable_Info_01", "Enable Telegram notifications"))
$y += 40
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyTGToken", "Token (Telegram)") & ":", $x, $y, -1, -1, $SS_RIGHT)
$g_hTxtNotifyTGToken = GUICtrlCreateInput("", $x + 120, $y - 3, 280, 19)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyTGToken_Info_01", "You need a Token to use Telegram notifications. Get a token from Telegram.com"))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 30
$g_hChkNotifyRemote = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyRemote", "Remote Control"), $x + 10, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyRemote_Info_01", "Enables PushBullet Remote function"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyOrigin", "Origin") & ":", $x + 120, $y + 3, -1, -1, $SS_RIGHT)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyOrigin_Info_01", "Origin - Village name.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtNotifyOrigin = GUICtrlCreateInput("", $x + 170, $y, 230, 19)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyOptions", "Send a PushBullet/Telegram message for these options") & ":", $x, $y, -1, -1, $SS_RIGHT)
$y += 15
$g_hChkNotifyAlertMatchFound = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertMatchFound", "Match Found"), $x + 10, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertMatchFound_Info_01", "Send the amount of available loot when bot finds a village to attack."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertLastRaidIMG = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertLastRaidIMG", "Last raid as image"), $x + 100, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertLastRaidIMG_Info_01", "Send the last raid screenshot."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertLastRaidTXT = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertLastRaidTXT", "Last raid as Text"), $x + 210, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertLastRaidTXT_Info_01", "Send the last raid results as text."))
$g_hChkNotifyAlertCampFull = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertCampFull", "Army Camp Full"), $x + 315, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertCampFull_Info_01", "Sent an Alert when your Army Camp is full."))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$g_hChkNotifyAlertUpgradeWall = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertUpgradeWall", "Wall upgrade"), $x + 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertUpgradeWall_Info_01", "Send info about wall upgrades."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertOutOfSync = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertOutOfSync", "Error: Out Of Sync"), $x + 100, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertOutOfSync_Info_01", "Send an Alert when you get the Error: Client and Server out of sync"))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertTakeBreak = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertTakeBreak", "Take a break"), $x + 210, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertTakeBreak_Info_01", "Send an Alert when you have been playing for too long and your villagers need to rest."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertBuilderIdle = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertBuilderIdle", "Builder Idle"), $x + 315, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertBuilderIdle_Info_01", "Send an Alert when at least one builder is idle."))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$g_hChkNotifyAlertVillageStats = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertVillageStats", "Village Report"), $x + 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertVillageStats_Info_01", "Send a Village Report."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertLastAttack = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertLastAttack", "Alert Last Attack"), $x + 100, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertLastAttack_Info_01", "Send info about the Last Attack."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertAnotherDevice = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertAnotherDevice", "Another device"), $x + 210, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertAnotherDevice_Info_01", "Send an Alert when your village is connected to from another device."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertSmartWaitTime = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertSmartWaitTime", "Smart Wait Time"), $x + 315, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertSmartWaitTime_Info_02", "Send an Alert when your village take wait troops."))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$g_hChkNotifyAlertMaintenance = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertMaintenance", "Maintenance"), $x + 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertMaintenance_Info_01", "Send an Alert when CoC is under maintenance by SuperCell"))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertBAN = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertBAN", "BAN"), $x + 100, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertBAN_Info_01", "Send an Alert if your village was BANNED by SuperCell"))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyBOTUpdate = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyBOTUpdate", "BOT Update"), $x + 210, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyBOTUpdate_Info_01", "Send an Alert when there is a new version of the bot."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyHelp", "Help ?"), $x + 197, $y + 93, 220, 24, $SS_RIGHT)
GUICtrlSetOnEvent(-1, "NotifyHelp")
GUICtrlSetCursor(-1, 0)
GUICtrlSetFont(-1, 8.5, $FW_BOLD)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyHelp_Info_01", "Click here to get Help about Notify Remote commands to PushBullet and Telegram"))
GUICtrlSetColor(-1, $COLOR_NAVY)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateNotifyScheduleSubTab()
Local $x = 25
Local $y = 150 - 105
Local $sTxtTip = ""
GUICtrlCreateGroup(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_05_STab_02", -1), $x - 20, $y - 20, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3)
$x += 10
$y += 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnPBNotify, $x - 5, $y, 64, 64, $BS_ICON)
$g_hChkNotifyOnlyHours = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", "Only during these hours of each day"), $x + 70, $y - 6)
GUICtrlSetOnEvent(-1, "chkNotifyHours")
$x += 59
$y += 85
$g_hLblNotifyhour = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Hour", "Hour") & ":", $x, $y, -1, 15)
$sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNotifyhours[0] = GUICtrlCreateLabel(" 0", $x + 30, $y)
$g_hLblNotifyhours[1] = GUICtrlCreateLabel(" 1", $x + 45, $y)
$g_hLblNotifyhours[2] = GUICtrlCreateLabel(" 2", $x + 60, $y)
$g_hLblNotifyhours[3] = GUICtrlCreateLabel(" 3", $x + 75, $y)
$g_hLblNotifyhours[4] = GUICtrlCreateLabel(" 4", $x + 90, $y)
$g_hLblNotifyhours[5] = GUICtrlCreateLabel(" 5", $x + 105, $y)
$g_hLblNotifyhours[6] = GUICtrlCreateLabel(" 6", $x + 120, $y)
$g_hLblNotifyhours[7] = GUICtrlCreateLabel(" 7", $x + 135, $y)
$g_hLblNotifyhours[8] = GUICtrlCreateLabel(" 8", $x + 150, $y)
$g_hLblNotifyhours[9] = GUICtrlCreateLabel(" 9", $x + 165, $y)
$g_hLblNotifyhours[10] = GUICtrlCreateLabel("10", $x + 180, $y)
$g_hLblNotifyhours[11] = GUICtrlCreateLabel("11", $x + 195, $y)
$g_ahLblNotifyhoursE = GUICtrlCreateLabel("X", $x + 214, $y + 1, 11, 11)
$y += 15
$g_hChkNotifyhours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkNotifyhoursE1")
$g_hLblNotifyhoursAM = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "AM", -1), $x + 10, $y)
$y += 15
$g_hChkNotifyhours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkNotifyhoursE2")
$g_hLblNotifyhoursPM = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "PM", -1), $x + 10, $y)
$x = 35
$y = 220
$g_hChkNotifyOnlyWeekDays = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", "Only during these day of week"), $x + 70, $y - 6)
GUICtrlSetOnEvent(-1, "chkNotifyWeekDays")
GUICtrlSetState(-1, $GUI_DISABLE)
$x += 59
$y += 19
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Day", "Day") & ":", $x, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_hLblNotifyWeekdays[0] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Su", "Su"), $x + 30, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Sunday", "Sunday"))
$g_hLblNotifyWeekdays[1] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Mo", "Mo"), $x + 46, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Monday", "Monday"))
$g_hLblNotifyWeekdays[2] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Tu", "Tu"), $x + 62, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Tuesday", "Tuesday"))
$g_hLblNotifyWeekdays[3] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "We", "We"), $x + 80, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Wednesday", "Wednesday"))
$g_hLblNotifyWeekdays[4] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Th", "Th"), $x + 99, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Thursday", "Thursday"))
$g_hLblNotifyWeekdays[5] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Fr", "Fr"), $x + 116, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Friday", "Friday"))
$g_hLblNotifyWeekdays[6] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Sa", "Sa"), $x + 133, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Saturday", "Saturday"))
$g_ahLblNotifyWeekdaysE = GUICtrlCreateLabel("X", $x + 155, $y + 1, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
$y += 13
$g_hChkNotifyWeekdays[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyWeekdays[1] = GUICtrlCreateCheckbox("", $x + 47, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyWeekdays[2] = GUICtrlCreateCheckbox("", $x + 64, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyWeekdays[3] = GUICtrlCreateCheckbox("", $x + 81, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyWeekdays[4] = GUICtrlCreateCheckbox("", $x + 99, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyWeekdays[5] = GUICtrlCreateCheckbox("", $x + 117, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyWeekdays[6] = GUICtrlCreateCheckbox("", $x + 133, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkNotifyWeekdaysE = GUICtrlCreateCheckbox("", $x + 151, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "ChkNotifyWeekdaysE")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_VILLAGE_TAB = 0, $g_hGUI_VILLAGE_TAB_ITEM1 = 0, $g_hGUI_VILLAGE_TAB_ITEM2 = 0, $g_hGUI_VILLAGE_TAB_ITEM3 = 0, $g_hGUI_VILLAGE_TAB_ITEM4 = 0, $g_hGUI_VILLAGE_TAB_ITEM5 = 0
Func CreateVillageTab()
$g_hGUI_VILLAGE = _GUICreate("", $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hFrmBotEx)
CreateVillageMisc()
CreateVillageDonate()
CreateVillageUpgrade()
CreateVillageNotify()
GUISwitch($g_hGUI_VILLAGE)
$g_hGUI_VILLAGE_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_VILLAGE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_01", "Misc"))
$g_hGUI_VILLAGE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_02", "Req. && Donate"))
$g_hGUI_VILLAGE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_03", "Upgrade"))
$g_hGUI_VILLAGE_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_04", "Achievements"))
CreateVillageAchievements()
$g_hGUI_VILLAGE_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_05", "Notify"))
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_ATTACK = 0
Global $g_hGUI_ATTACK_TAB = 0, $g_hGUI_ATTACK_TAB_ITEM1 = 0, $g_hGUI_ATTACK_TAB_ITEM2 = 0, $g_hGUI_ATTACK_TAB_ITEM3 = 0
Global $g_hGUI_DropOrder = 0
Global $g_hGUI_TRAINARMY = 0
Global $g_hGUI_TRAINARMY_TAB = 0, $g_hGUI_TRAINARMY_TAB_ITEM1 = 0, $g_hGUI_TRAINARMY_TAB_ITEM2 = 0, $g_hGUI_TRAINARMY_TAB_ITEM3 = 0, $g_hGUI_TRAINARMY_TAB_ITEM4 = 0
Global $g_hChkUseQuickTrain = 0, $g_ahChkArmy[3] = [0, 0, 0]
Global $g_ahTxtTrainArmyTroopCount[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahLblTrainArmyTroopLevel[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahTxtTrainArmySpellCount[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahLblTrainArmySpellLevel[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hTxtFullTroop = 0, $g_hChkTotalCampForced = 0, $g_hTxtTotalCampForced = 0, $g_hChkForceBrewBeforeAttack = 0
Global $g_hGrpTrainTroops = 0, $g_hGrpCookSpell = 0
Global $g_ahPicTrainArmyTroop[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahPicTrainArmySpell[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hLblTotalTimeCamp = 0, $g_hLblElixirCostCamp = 0, $g_hLblDarkCostCamp = 0, $g_hCalTotalTroops = 0, $g_hLblTotalProgress = 0, $g_hLblCountTotal = 0, $g_hTxtTotalCountSpell = 0, $g_hLblTotalTimeSpell = 0, $g_hLblElixirCostSpell = 0, $g_hLblDarkCostSpell = 0
Global $g_hCmbBoostBarracks = 0, $g_hCmbBoostSpellFactory = 0, $g_hCmbBoostBarbarianKing = 0, $g_hCmbBoostArcherQueen = 0, $g_hCmbBoostWarden = 0
Global $g_hLblBoosthour = 0, $g_ahLblBoosthoursE = 0
Global $g_hLblBoosthours[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hChkBoostBarracksHours[24] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], $g_hChkBoostBarracksHoursE1 = 0, $g_hChkBoostBarracksHoursE2 = 0
Func LoadTranslatedTrainTroopsOrderList()
Global $g_asTroopOrderList = ["", GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBarbarians", "Barbarians"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtArchers", "Archers"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGiants", "Giants"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGoblins", "Goblins"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWallBreakers", "Wall Breakers"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBalloons", "Balloons"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWizards", "Wizards"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHealers", "Healers"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtDragons", "Dragons"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtPekkas", "Pekkas"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBabyDragons", "Baby Dragons"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMiners", "Miners"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtElectroDragons", "Electro Dragons"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMinions", "Minions"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHogRiders", "Hog Riders"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtValkyries", "Valkyries"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGolems", "Golems"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWitches", "Witches"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtLavaHounds", "Lava Hounds"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBowlers", "Bowlers")]
EndFunc
Global $g_hChkCustomTrainOrderEnable = 0
Global $g_ahCmbTroopOrder[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahImgTroopOrder[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hBtnTroopOrderSet = 0, $g_ahImgTroopOrderSet = 0
Global $g_hBtnRemoveTroops
Func LoadTranslatedBrewSpellsOrderList()
Global $g_asSpellsOrderList = ["", GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortLightningSpells", "Lightning"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHealSpells", "Heal"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortRageSpells", "Rage"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortJumpSpells", "Jump"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortFreezeSpells", "Freeze"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortCloneSpells", "Clone"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortPoisonSpells", "Poison"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortEarthquakeSpells", "EarthQuake"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHasteSpells", "Haste"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortSkeletonSpells", "Skeleton")]
EndFunc
Global $g_hChkCustomBrewOrderEnable = 0
Global $g_ahCmbSpellsOrder[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahImgSpellsOrder[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hBtnSpellsOrderSet = 0, $g_ahImgSpellsOrderSet = 0
Global $g_hBtnRemoveSpells
Global $g_hChkCloseWhileTraining = 0, $g_hChkCloseWithoutShield = 0, $g_hChkCloseEmulator = 0, $g_hChkSuspendComputer = 0, $g_hChkRandomClose = 0, $g_hRdoCloseWaitExact = 0, $g_hRdoCloseWaitRandom = 0, $g_hCmbCloseWaitRdmPercent = 0, $g_hCmbMinimumTimeClose = 0, $g_hSldTrainITDelay = 0, $g_hChkTrainAddRandomDelayEnable = 0, $g_hTxtAddRandomDelayMin = 0, $g_hTxtAddRandomDelayMax = 0
Global $g_hLblCloseWaitRdmPercent = 0, $g_hLblCloseWaitingTroops = 0, $g_hLblSymbolWaiting = 0, $g_hLblWaitingInMinutes = 0, $g_hLblTrainITDelay = 0, $g_hLblTrainITDelayTime = 0, $g_hLblAddDelayIdlePhaseBetween = 0, $g_hLblAddDelayIdlePhaseSec = 0, $g_hPicCloseWaitTrain = 0, $g_hPicCloseWaitStop = 0, $g_hPicCloseWaitExact = 0
Func CreateAttackTroops()
$g_hGUI_TRAINARMY = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_ATTACK)
$g_hGUI_TRAINARMY_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
CreateTroopsSpellsSubTab()
CreateBoostSubTab()
CreateTrainOrderSubTab()
CreateOptionsSubTab()
EndFunc
Func CreateTroopsSpellsSubTab()
$g_hGUI_TRAINARMY_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_01_STab_01", "Troops/Spells"))
Local $sTxtSetPerc = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "TxtSetTroop_Info_01", "Enter the No. of")
Local $sTxtSetPerc2 = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "TxtSetTroop_Info_02", "to make.")
Local $x = 0
Local $y = 8
$g_hChkUseQuickTrain = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "ChkUseQuickTrain", "Use Quick Train"), $x + 15, $y + 19, -1, 15)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkUseQTrain")
For $i = 0 To 2
$g_ahChkArmy[$i] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "ChkArmy", "Army ") & $i + 1, $x + 120 + $i * 60, $y + 20, 50, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
If $i = 0 Then GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkQuickTrainCombo")
Next
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Btn_Remove_Army", "Remove Army"), $x + 335, $y + 20, -1, 15, $SS_LEFT)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnResetButton, $x + 405, $y + 17, 24, 24)
GUICtrlSetOnEvent(-1, "Removecamp")
$x = 10
$y = 45
$g_hGrpTrainTroops = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Group_01", "Train Troops"), $x - 5, $y, $g_iSizeWGrpTab3, 195)
$x = 30
$y += 20
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBarbarians", "Barbarians")
$g_ahPicTrainArmyTroop[$eTroopBarbarian] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBarbarian, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", "Level") & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", "Mouse Left Click to Up level" & @CRLF & "Shift + Mouse Left Click to Down level"))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopBarbarian] = GUICtrlCreateLabel("1", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopBarbarian] = GUICtrlCreateInput("58", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGiants", "Giants")
$g_ahPicTrainArmyTroop[$eTroopGiant] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGiant, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopGiant] = GUICtrlCreateLabel("1", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopGiant] = GUICtrlCreateInput("4", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWallBreakers", "Wall Breakers")
$g_ahPicTrainArmyTroop[$eTroopWallBreaker] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallBreaker, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopWallBreaker] = GUICtrlCreateLabel("1", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopWallBreaker] = GUICtrlCreateInput("4", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWizards", "Wizards")
$g_ahPicTrainArmyTroop[$eTroopWizard] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWizard, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopWizard] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopWizard] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtDragons", "Dragons")
$g_ahPicTrainArmyTroop[$eTroopDragon] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDragon, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopDragon] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopDragon] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBabyDragons", "Baby Dragons")
$g_ahPicTrainArmyTroop[$eTroopBabyDragon] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBabyDragon, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopBabyDragon] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopBabyDragon] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 45
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtElectroDragons", "Electro Dragons")
$g_ahPicTrainArmyTroop[$eTroopElectroDragon] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnElectroDragon, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopElectroDragon] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopElectroDragon] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMinions", "Minions")
$g_ahPicTrainArmyTroop[$eTroopMinion] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnMinion, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopMinion] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopMinion] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtValkyries", "Valkyries")
$g_ahPicTrainArmyTroop[$eTroopValkyrie] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnValkyrie, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopValkyrie] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopValkyrie] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWitches", "Witches")
$g_ahPicTrainArmyTroop[$eTroopWitch] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWitch, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopWitch] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopWitch] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x = 30
$y += 60
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtArchers", "Archers")
$g_ahPicTrainArmyTroop[$eTroopArcher] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnArcher, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopArcher] = GUICtrlCreateLabel("1", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopArcher] = GUICtrlCreateInput("115", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGoblins", "Goblins")
$g_ahPicTrainArmyTroop[$eTroopGoblin] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoblin, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopGoblin] = GUICtrlCreateLabel("1", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopGoblin] = GUICtrlCreateInput("19", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBalloons", "Balloons")
$g_ahPicTrainArmyTroop[$eTroopBalloon] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBalloon, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopBalloon] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopBalloon] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHealers", "Healers")
$g_ahPicTrainArmyTroop[$eTroopHealer] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealer, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopHealer] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopHealer] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtPekkas", "Pekkas")
$g_ahPicTrainArmyTroop[$eTroopPekka] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnPekka, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopPekka] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopPekka] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMiners", "Miners")
$g_ahPicTrainArmyTroop[$eTroopMiner] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnMiner, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopMiner] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopMiner] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 45
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBowlers", "Bowlers")
$g_ahPicTrainArmyTroop[$eTroopBowler] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBowler, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopBowler] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopBowler] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHogRiders", "Hog Riders")
$g_ahPicTrainArmyTroop[$eTroopHogRider] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHogRider, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopHogRider] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopHogRider] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGolems", "Golems")
$g_ahPicTrainArmyTroop[$eTroopGolem] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGolem, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopGolem] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopGolem] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtLavaHounds", "Lava Hounds")
$g_ahPicTrainArmyTroop[$eTroopLavaHound] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLavaHound, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopLavaHound] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopLavaHound] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x = 30
$y += 66
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCamp, $x - 10, $y - 15, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "LblFullTroop", "'Full' Camps"), $x + 16, $y - 7, 55, 17)
GUICtrlCreateLabel(ChrW(8805), $x + 75, $y - 7, -1, 17)
$g_hTxtFullTroop = GUICtrlCreateInput("100", $x + 84, $y - 10, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetOnEvent(-1, "SetComboTroopComp")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "TxtFullTroop_Info_01", "Army camps are 'Full' when reaching this %, then start attack."))
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel("%", $x + 115, $y - 7, -1, 17)
$x += 180
$y -= 23
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTroopsCost, $x - 33, $y + 10, 24, 24)
$g_hLblTotalTimeCamp = GUICtrlCreateLabel(" 0s", $x - 11, $y + 15, 70, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
$g_hLblElixirCostCamp = GUICtrlCreateLabel(" 0", $x + 65, $y + 15, 77, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 63, $y + 14, 16, 16)
$g_hLblDarkCostCamp = GUICtrlCreateLabel(" 0", $x + 148, $y + 15, 62, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 146, $y + 14, 16, 16)
$x -= 195
$y += 35
$g_hChkTotalCampForced = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "ChkTotalCampForced", "Force Total Army Camp") & ":", $x + 3, $y, -1, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkTotalCampForced")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "ChkTotalCampForced_Info_01", "If not detected set army camp values (instead ask)"))
$g_hTxtTotalCampForced = GUICtrlCreateInput("220", $x + 137, $y + 3, 30, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetOnEvent(-1, "SetComboTroopComp")
GUICtrlSetLimit(-1, 3)
$g_hCalTotalTroops = GUICtrlCreateProgress($x, $y + 22, 407, 10)
$g_hLblTotalProgress = GUICtrlCreateLabel("", $x, $y + 22, 407, 10)
GUICtrlSetBkColor(-1, $COLOR_RED)
GUICtrlSetState(-1, BitOR($GUI_DISABLE, $GUI_HIDE))
$x += 38
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "LblCountTotal", "Total"), $x + 295, $y + 7, -1, -1, $SS_RIGHT)
$g_hLblCountTotal = GUICtrlCreateLabel(0, $x + 330, $y + 5, 30, 15, $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "LblCountTotal_Info_01", "The total Units of Troops should equal Total Army Camps."))
GUICtrlSetBkColor(-1, $COLOR_MONEYGREEN)
GUICtrlCreateLabel("x", $x + 364, $y + 7, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 10
$y = 240
$g_hGrpCookSpell = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Group_02", "Brew Spells"), $x - 5, $y, $g_iSizeWGrpTab3, 123)
$x += 20
$y += 17
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "SpellCapacity", "Spell Capacity") & ":", $x - 15, $y, -1, -1, $SS_RIGHT)
$g_hTxtTotalCountSpell = GUICtrlCreateCombo("", $x + 80, $y - 3, 35, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "TxtTotalCountSpell_Info_01", "Enter the No. of Spells Capacity. Set to ZERO if you don't want any Spells"))
GUICtrlSetData(-1, "0|2|4|6|7|8|9|10|11", "0")
GUICtrlSetOnEvent(-1, "TotalSpellCountClick")
$y += 13
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtLightningSpells", "Lightning Spell")
$g_ahPicTrainArmySpell[$eSpellLightning] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellLightning] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellLightning] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtHealingSpells", "Healing Spell")
$g_ahPicTrainArmySpell[$eSpellHeal] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellHeal] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellHeal] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtRageSpells", "Rage Spell")
$g_ahPicTrainArmySpell[$eSpellRage] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellRage] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellRage] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtJumpSpells", "Jump Spell")
$g_ahPicTrainArmySpell[$eSpellJump] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellJump] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellJump] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtFreezeSpells", "Freeze Spell")
$g_ahPicTrainArmySpell[$eSpellFreeze] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellFreeze] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellFreeze] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtCloneSpells", "Clone Spell")
$g_ahPicTrainArmySpell[$eSpellClone] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnCloneSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellClone] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellClone] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 45
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtPoisonSpells", "Poison Spell")
$g_ahPicTrainArmySpell[$eSpellPoison] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellPoison] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellPoison] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtEarthQuakeSpells", "EarthQuake Spell")
$g_ahPicTrainArmySpell[$eSpellEarthquake] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellEarthquake] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellEarthquake] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtHasteSpells", "Haste Spell")
$g_ahPicTrainArmySpell[$eSpellHaste] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellHaste] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellHaste] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtSkeletonSpells", "Skeleton Spell")
$g_ahPicTrainArmySpell[$eSpellSkeleton] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSkeletonSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellSkeleton] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellSkeleton] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$y += 56
$x = 17
$g_hChkForceBrewBeforeAttack = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "ChkForceBrewBeforeAttack", "Force Brew Spells"), $x, $y + 12, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$x = 210
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSpellsCost, $x - 33, $y + 10, 24, 24)
$g_hLblTotalTimeSpell = GUICtrlCreateLabel(" 0s", $x - 11, $y + 15, 70, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
$g_hLblElixirCostSpell = GUICtrlCreateLabel(" 0", $x + 65, $y + 15, 77, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 63, $y + 14, 16, 16)
$g_hLblDarkCostSpell = GUICtrlCreateLabel(" 0", $x + 148, $y + 15, 62, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 146, $y + 14, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateBoostSubTab()
Local $sTextBoostLeft = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "TextBoostLeft", "Boosts left")
Local $sTxtTip = ""
$g_hGUI_TRAINARMY_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_01_STab_02", "Boost"))
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "Group_01", "Boost Barracks"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 60)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBarrackBoost, $x - 10, $y + 5, 24, 24)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDarkBarrackBoost, $x + 19, $y + 5, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblBarracksBoost", "Barracks") & " " & $sTextBoostLeft, $x + 20 + 29, $y + 4 + 7, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblBarracksBoost_Info_01", "Use this to boost your Barracks with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostBarracks = GUICtrlCreateCombo("", $x + 140 + 45, $y + 7, 60, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|No limit", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 65
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "Group_02", "Boost Spell Factories"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 50)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSpellFactoryBoost, $x - 10, $y - 2, 24, 24)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDarkSpellBoost, $x + 19, $y - 2, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblSpellFactoryBoost", "Spell Factory") & " " & $sTextBoostLeft, $x + 20 + 29, $y + 4, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblSpellFactoryBoost_Info_01", "Use this to boost your Spell Factory with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostSpellFactory = GUICtrlCreateCombo("", $x + 185, $y, 60, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|No limit", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 55
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "Group_03", "Boost Heroes"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 95)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnKingBoost, $x - 10, $y - 2, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & " " & $sTextBoostLeft, $x + 20, $y + 4, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblKingBoost_Info_01", "Use this to boost your Barbarian King with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostBarbarianKing = GUICtrlCreateCombo("", $x + 185, $y, 60, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|No limit", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeKing")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueenBoost, $x - 10, $y - 2, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & " " & $sTextBoostLeft, $x + 20, $y + 4, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblQueenBoost_Info_01", "Use this to boost your Archer Queen with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostArcherQueen = GUICtrlCreateCombo("", $x + 185, $y, 60, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|No limit", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeQueen")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWardenBoost, $x - 10, $y - 2, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1) & " " & $sTextBoostLeft, $x + 20, $y + 4, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblWardenBoost_Info_01", "Use this to boost your Grand Warden with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostWarden = GUICtrlCreateCombo("", $x + 185, $y, 60, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|No limit", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeWarden")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 50
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "Group_04", "Boost Schedule"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 70)
$g_hLblBoosthour = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Hour", -1) & ":", $x, $y, -1, 15)
$sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblBoosthours[0] = GUICtrlCreateLabel(" 0", $x + 30, $y)
$g_hLblBoosthours[1] = GUICtrlCreateLabel(" 1", $x + 45, $y)
$g_hLblBoosthours[2] = GUICtrlCreateLabel(" 2", $x + 60, $y)
$g_hLblBoosthours[3] = GUICtrlCreateLabel(" 3", $x + 75, $y)
$g_hLblBoosthours[4] = GUICtrlCreateLabel(" 4", $x + 90, $y)
$g_hLblBoosthours[5] = GUICtrlCreateLabel(" 5", $x + 105, $y)
$g_hLblBoosthours[6] = GUICtrlCreateLabel(" 6", $x + 120, $y)
$g_hLblBoosthours[7] = GUICtrlCreateLabel(" 7", $x + 135, $y)
$g_hLblBoosthours[8] = GUICtrlCreateLabel(" 8", $x + 150, $y)
$g_hLblBoosthours[9] = GUICtrlCreateLabel(" 9", $x + 165, $y)
$g_hLblBoosthours[10] = GUICtrlCreateLabel("10", $x + 180, $y)
$g_hLblBoosthours[11] = GUICtrlCreateLabel("11", $x + 195, $y)
$g_ahLblBoosthoursE = GUICtrlCreateLabel("X", $x + 213, $y + 2, 11, 11)
$y += 15
$g_hChkBoostBarracksHours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", "This button will clear or set the entire row of boxes"))
GUICtrlSetOnEvent(-1, "chkBoostBarracksHoursE1")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "AM", "AM"), $x + 5, $y)
$y += 15
$g_hChkBoostBarracksHours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkBoostBarracksHoursE2")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "PM", "PM"), $x + 5, $y)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
EndFunc
Func CreateTrainOrderSubTab()
$g_hGUI_TRAINARMY_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_01_STab_03", "Train Order"))
SetDefaultTroopGroup(False)
LoadTranslatedTrainTroopsOrderList()
LoadTranslatedBrewSpellsOrderList()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "Group_01", "Training Order"), $x - 20, $y - 20, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3)
$g_hChkCustomTrainOrderEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "ChkCustomTrainOrderEnable", "Troops Order"), $x - 5, $y, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "ChkCustomTrainOrderEnable_Info_01", "Enable to select a custom troop training order") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "ChkCustomTrainOrderEnable_Info_02", "Changing train order can be useful with CSV scripted attack armies!"))
GUICtrlSetOnEvent(-1, "chkTroopOrder2")
If UBound($g_asTroopOrderList) - 1 <> $eTroopCount Then
If $g_bDebugSetlogTrain Then SetLog("UBound($g_asTroopOrderList) - 1: " & UBound($g_asTroopOrderList) - 1 & " = " & "$eTroopCount: " & $eTroopCount, $COLOR_DEBUG)
SetLog("Monkey ate bad banana, fix $g_asTroopOrderList & $eTroopCount arrays!", $COLOR_RED)
EndIf
Local $sComboData = ""
For $j = 0 To UBound($g_asTroopOrderList) - 1
$sComboData &= $g_asTroopOrderList[$j] & "|"
Next
Local $txtTroopOrder = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "TxtTroopOrder", "Enter sequence order for training of troop #")
$y += 23
For $z = 0 To $eTroopCount - 1
If $z < 12 Then
GUICtrlCreateLabel($z + 1 & ":", $x - 16, $y + 2, -1, 18)
$g_ahCmbTroopOrder[$z] = GUICtrlCreateCombo("", $x, $y, 94, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "GUITrainOrder")
GUICtrlSetData(-1, $sComboData, "")
_GUICtrlSetTip(-1, $txtTroopOrder & $z + 1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahImgTroopOrder[$z] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnOptions, $x + 96, $y + 1, 18, 18)
$y += 22
Else
If $z = 12 Then
$x += 128
$y = 45 + 23
EndIf
GUICtrlCreateLabel($z + 1 & ":", $x - 13, $y + 2, -1, 18)
$g_ahCmbTroopOrder[$z] = GUICtrlCreateCombo("", $x + 4, $y, 94, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "GUITrainOrder")
GUICtrlSetData(-1, $sComboData, "")
_GUICtrlSetTip(-1, $txtTroopOrder & $z + 1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahImgTroopOrder[$z] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnOptions, $x + 100, $y + 1, 18, 18)
$y += 22
EndIf
Next
$y += 23
$g_hBtnRemoveTroops = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnRemoveTroops", "Empty troop list"), $x, $y, 110, 22)
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnRemoveTroops_Info_01", "Push button to remove all troops from list and start over"))
GUICtrlSetOnEvent(-1, "btnRemoveTroops")
$x = 25
$y = 45 + 291
$g_hBtnTroopOrderSet = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnTroopOrderSet", "Apply New Order"), $x, $y, 222, 20)
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnTroopOrderSet_Info_01", "Push button when finished selecting custom troop training order") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnTroopOrderSet_Info_02", "Icon changes color based on status: Red= Not Set, Green = Order Set") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnTroopOrderSet_Info_03", "When not all troop slots are filled, will use random troop order in empty slots!"))
GUICtrlSetOnEvent(-1, "btnTroopOrderSet")
$g_ahImgTroopOrderSet = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSilverStar, $x + 226, $y + 2, 18, 18)
Local $x = 300, $y = 45
$g_hChkCustomBrewOrderEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "ChkCustomBrewOrderEnable", "Spells Order"), $x - 5, $y, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "ChkCustomBrewOrderEnable_Info_01", "Enable to select a Brew Spells order") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "ChkCustomBrewOrderEnable_Info_02", "Changing spells order can be useful with CSV scripted attack armies!"))
GUICtrlSetOnEvent(-1, "chkSpellsOrder")
Local $sComboData = ""
For $j = 0 To UBound($g_asSpellsOrderList) - 1
$sComboData &= $g_asSpellsOrderList[$j] & "|"
Next
Local $txtSpellsOrder = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "txtSpellsOrder", "Enter sequence order for brew Spells #")
$y += 23
For $z = 0 To $eSpellCount - 1
GUICtrlCreateLabel($z + 1 & ":", $x - 16, $y + 2, -1, 18)
$g_ahCmbSpellsOrder[$z] = GUICtrlCreateCombo("", $x, $y, 94, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "GUISpellsOrder")
GUICtrlSetData(-1, $sComboData, "")
_GUICtrlSetTip(-1, $txtSpellsOrder & $z + 1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahImgSpellsOrder[$z] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnOptions, $x + 96, $y + 1, 18, 18)
$y += 22
Next
$y += 20
$g_hBtnRemoveSpells = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnRemoveSpells", "Empty Spell list"), $x, $y, 94, 22)
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnRemoveSpells_Info_01", "Push button to remove all spells from list and start over"))
GUICtrlSetOnEvent(-1, "BtnRemoveSpells")
$y += 25
$g_hBtnSpellsOrderSet = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnSpellsOrderSet", "Apply New Order"), $x, $y, 94, 22)
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnSpellsOrderSet_Info_01", "Push button when finished selecting custom spells brew order") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnSpellsOrderSet_Info_02", "Icon changes color based on status: Red= Not Set, Green = Order Set") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnSpellsOrderSet_Info_03", "When not all spells slots are filled, will use random spell order in empty slots!"))
GUICtrlSetOnEvent(-1, "BtnSpellsOrderSet")
$g_ahImgSpellsOrderSet = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSilverStar, $x + 98, $y + 2, 18, 18)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateOptionsSubTab()
$g_hGUI_TRAINARMY_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_01_STab_04", "Options"))
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "Group_01", "Training Idle Time"), $x - 20, $y - 20, 151, 294)
$g_hChkCloseWhileTraining = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseWhileTraining", "Close While Training"), $x - 12, $y, 140, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseWhileTraining_Info_01", "Option will exit CoC game for time required to complete TROOP training when SHIELD IS ACTIVE") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseWhileTraining_Info_02", "Close for Spell creation will be enabled when 'Wait for Spells' is selected on Search tabs") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseWhileTraining_Info_03", "Close for Hero healing will be enabled when 'Wait for Heroes' is enabled on Search tabs"))
GUICtrlSetOnEvent(-1, "chkCloseWaitEnable")
$y += 28
$g_hChkCloseWithoutShield = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseWithoutShield", "Without Shield"), $x + 18, $y + 1, 110, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseWithoutShield_Info_01", "Option will ALWAYS close CoC for idle training time and when NO SHIELD IS ACTIVE!") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseWithoutShield_Info_02", "Note - You can be attacked and lose trophies when this option is enabled!")
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkCloseWaitTrain")
$g_hPicCloseWaitTrain = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnNoShield, $x - 13, $y, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
$g_hChkCloseEmulator = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseEmulator", "Close Emulator"), $x + 18, $y + 1, 110, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseEmulator_Info_01", "Option will close Android Emulator completely when selected") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseEmulator_Info_02", "Adding this option may increase offline time slightly due to variable times required for startup")
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "btnCloseWaitStop")
$g_hPicCloseWaitStop = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRecycle, $x - 13, $y + 13, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
$g_hChkSuspendComputer = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkSuspendComputer", "Suspend Computer"), $x + 18, $y + 1, 110, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkSuspendComputer_Info_01", "Option will suspend computer when selected\r\nAdding this option may increase offline time slightly due to variable times required for startup")
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "btnCloseWaitSuspendComputer")
$y += 28
$g_hChkRandomClose = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkRandomClose", "Random Close"), $x + 18, $y + 1, 110, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkRandomClose_Info_01", "Option will Randomly choose between time out, close CoC, or Close emulator when selected") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkRandomClose_Info_02", "Adding this option may increase offline time slightly due to variable times required for startup"))
GUICtrlSetOnEvent(-1, "btnCloseWaitStopRandom")
$y += 28
$g_hRdoCloseWaitExact = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "RdoCloseWaitExact", "Exact Time"), $x + 18, $y + 1, 110, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "RdoCloseWaitExact_Info_01", "Select to wait exact time required for troops to complete training"))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "btnCloseWaitRandom")
$g_hPicCloseWaitExact = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x - 13, $y + 13, 24, 24)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "RdoCloseWaitExact_Info_02", "Select how much time to wait when feature enables"))
$y += 24
$g_hRdoCloseWaitRandom = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "RdoCloseWaitRandom", "Random Time"), $x + 18, $y + 1, 110, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "RdoCloseWaitRandom_Info_01", "Select to ADD a random extra wait time like human who forgets to clash"))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "btnCloseWaitRandom")
$y += 28
$g_hCmbCloseWaitRdmPercent = GUICtrlCreateCombo("", $x + 36, $y, 40, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "CmbCloseWaitRdmPercent_Info_01", "Enter maximum percentage of additional time to be used creating random wait times,") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "CmbCloseWaitRdmPercent_Info_02", "Bot will compute a random wait time between exact time needed, and") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "CmbCloseWaitRdmPercent_Info_03", "maximum random percent entered to appear more human like")
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15", "10")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblCloseWaitRdmPercent = GUICtrlCreateLabel("%", $x + 84, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
$g_hLblCloseWaitingTroops = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "LblCloseWaitingTroops", "Minimum Time To Close") & ": ", $x - 12, $y, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "LblCloseWaitingTroops_Info_01", "Will be close CoC If train time troops >= (Minimum time required to close)" & @CRLF & "Just stay in the main screen if train time troops < (Minimum time required to close)"))
GUICtrlSetOnEvent(-1, "chkCloseWaitEnable")
$y += 22
$g_hLblSymbolWaiting = GUICtrlCreateLabel(">", $x + 26, $y + 3, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "LblSymbolWaiting_Info_01", "Enter number Minimum time to close in minutes for close CoC which you want, Default Is (2)")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbMinimumTimeClose = GUICtrlCreateCombo("", $x + 36, $y, 40, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "2|3|4|5|6|7|8|9|10", "2")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblWaitingInMinutes = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "min.", "min."), $x + 84, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 53
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "Group_02", "Train Click Timing"), $x - 20, $y - 20, 151, 60)
$g_hLblTrainITDelay = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "LblTrainITDelay", "delay"), $x - 10, $y, 37, 30)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "LblTrainITDelay_Info_01", "Increase the delay if your PC is slow or to create human like training click speed")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTrainITDelayTime = GUICtrlCreateLabel("40 ms", $x - 10, $y + 15, 37, 30)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hSldTrainITDelay = GUICtrlCreateSlider($x + 30, $y, 90, 25, BitOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "LblTrainITDelay_Info_01", -1))
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-100, 100)
GUICtrlSetLimit(-1, 500, 1)
GUICtrlSetData(-1, 40)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetOnEvent(-1, "sldTrainITDelay")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25 + 151 + 5
$y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "Group_03", "Training Add Random Delay"), $x - 20, $y - 20, 173, 81)
$y += 15
$g_hChkTrainAddRandomDelayEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkTrainAddRandomDelayEnable", "Add Random Delay"), $x + 18, $y - 11, 130, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkTrainAddRandomDelayEnable_Info_01", "Add random delay between two calls of train army.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkTrainAddRandomDelayEnable_Info_02", "This option reduces the calls to the training window  humanizing the bot spacing calls each time with a causal interval chosen between the minimum and maximum values indicated below.")
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkAddDelayIdlePhaseEnable")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDelay, $x - 13, $y - 13, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 18
$y += 18
$g_hLblAddDelayIdlePhaseBetween = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "LblAddDelayIdlePhaseBetween", "Between"), $x - 12, $y, 50, 30)
$g_hTxtAddRandomDelayMin = GUICtrlCreateInput($g_iTrainAddRandomDelayMin, $x + 32, $y - 2, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 999)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtWaitForCastleSpell", "And"), $x + 61, $y, 20, 30)
$g_hTxtAddRandomDelayMax = GUICtrlCreateInput($g_iTrainAddRandomDelayMax, $x + 82, $y - 2, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 999)
$g_hLblAddDelayIdlePhaseSec = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", "sec."), $x + 110, $y, 20, 30)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_SEARCH = 0
Global $g_ahChkMaxMortar[$g_iModeCount] = [0, 0, 0], $g_ahChkMaxWizTower[$g_iModeCount] = [0, 0, 0], $g_ahChkMaxAirDefense[$g_iModeCount] = [0, 0, 0], $g_ahChkMaxXBow[$g_iModeCount] = [0, 0, 0], $g_ahChkMaxInferno[$g_iModeCount] = [0, 0, 0], $g_ahChkMaxEagle[$g_iModeCount] = [0, 0, 0]
Global $g_ahCmbWeakMortar[$g_iModeCount] = [0, 0, 0], $g_ahCmbWeakWizTower[$g_iModeCount] = [0, 0, 0], $g_ahCmbWeakAirDefense[$g_iModeCount] = [0, 0, 0], $g_ahCmbWeakXBow[$g_iModeCount] = [0, 0, 0], $g_ahCmbWeakInferno[$g_iModeCount] = [0, 0, 0], $g_ahCmbWeakEagle[$g_iModeCount] = [0, 0, 0]
Global $g_ahPicWeakMortar[$g_iModeCount] = [0, 0, 0], $g_ahPicWeakWizTower[$g_iModeCount] = [0, 0, 0], $g_ahPicWeakAirDefense[$g_iModeCount] = [0, 0, 0], $g_ahPicWeakXBow[$g_iModeCount] = [0, 0, 0], $g_ahPicWeakInferno[$g_iModeCount] = [0, 0, 0], $g_ahPicWeakEagle[$g_iModeCount] = [0, 0, 0]
Global $g_ahChkMeetOne[$g_iModeCount] = [0, 0, 0]
Global $g_hGUI_DEADBASE = 0
Global $g_hGUI_DEADBASE_ATTACK_STANDARD = 0
Global $g_hCmbStandardDropOrderDB = 0, $g_hCmbStandardDropSidesDB = 0, $g_hCmbStandardUnitDelayDB = 0, $g_hCmbStandardWaveDelayDB = 0, $g_hChkRandomSpeedAtkDB = 0, $g_hChkSmartAttackRedAreaDB = 0, $g_hCmbSmartDeployDB = 0, $g_hChkAttackNearGoldMineDB = 0, $g_hChkAttackNearElixirCollectorDB = 0, $g_hChkAttackNearDarkElixirDrillDB = 0
Global $g_hLblSmartDeployDB = 0, $g_hPicAttackNearDarkElixirDrillDB = 0
Global $g_hBtnCustomDropOrderDB = 0
Func CreateAttackSearchDeadBaseStandard()
$g_hGUI_DEADBASE_ATTACK_STANDARD = _GUICreate("", $_GUI_MAIN_WIDTH - 195, $g_iSizeHGrpTab4, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DEADBASE)
Local $sTxtTip = ""
Local $x = 25, $y = 20
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Group_01", "Deploy"), $x - 20, $y - 20, 270, $g_iSizeHGrpTab4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Label_01", "Troop Drop Order"), $x, $y, 143, 18, $SS_LEFT)
$y += 15
$g_hCmbStandardDropOrderDB = GUICtrlCreateCombo("", $x, $y, 150, Default, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_01", "Default(All Troops)") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_02", "Barch/BAM/BAG") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_03", "GiBarch"), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_01", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Info_01", "Select a preset troop drop order.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Info_02", "Each option deploys troops in a different order and in different waves") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Info_03", "Only the troops selected in the ""Only drop these troops"" option will be dropped"))
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Label_02", "Attack on") & ":", $x, $y + 5, -1, -1)
$g_hCmbStandardDropSidesDB = GUICtrlCreateCombo("", $x + 55, $y, 120, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_01", "Attack on a single side, penetrates through base") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_02", "Attack on two sides, penetrates through base") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_03", "Attack on three sides, gets outer and some inside of base") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_04", "Select the No. of sides to attack on."))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_01", "one side") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_02", "two sides") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_03", "three sides") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_04", "all sides equally"), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_04", -1))
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardUnitDelay", "Delay Unit") & ":", $x, $y + 5, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardUnitDelay_Info_01", "This delays the deployment of troops, 1 (fast) = like a Bot, 10 (slow) = Like a Human.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardUnitDelay_Info_02", "Random will make bot more varied and closer to a person.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbStandardUnitDelayDB = GUICtrlCreateCombo("", $x + 55, $y, 36, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardWaveDelay_Info_01", "Wave") & ":", $x + 100, $y + 5, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbStandardWaveDelayDB = GUICtrlCreateCombo("", $x + 140, $y, 36, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
$y += 22
$g_hChkRandomSpeedAtkDB = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkRandomSpeedAtk", "Randomize delay for Units && Waves"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkRandomSpeedAtkDB")
$y +=22
$g_hChkSmartAttackRedAreaDB = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkSmartAttackRedArea", "Use Smart Attack: Near Red Line."), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkSmartAttackRedArea_Info_01", "Use Smart Attack to detect the outer 'Red Line' of the village to attack. And drop your troops close to it."))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkSmartAttackRedAreaDB")
$y += 22
$g_hLblSmartDeployDB = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy", "Drop Type") & ":", $x, $y + 5, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy_Info_01", "Select the Deploy Mode for the waves of Troops.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy_Info_02", "Type 1: Drop a single wave of troops on each side then switch troops, OR") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy_Info_03", "Type 2: Drop a full wave of all troops (e.g. giants, barbs and archers) on each side then switch sides.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbSmartDeployDB = GUICtrlCreateCombo("", $x + 55, $y, 120, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbSmartDeploy_Info_01", "Sides, then Troops") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbSmartDeploy_Info_02", "Troops, then Sides"), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbSmartDeploy_Info_01", -1))
_GUICtrlSetTip(-1, $sTxtTip)
$y += 26
$g_hChkAttackNearGoldMineDB = GUICtrlCreateCheckbox("", $x + 20, $y, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkAttackNearGoldMine_Info_01", "Drop troops near Gold Mines")
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 40 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
$g_hChkAttackNearElixirCollectorDB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkAttackNearElixirCollector_Info_01", "Drop troops near Elixir Collectors")
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 55
$g_hChkAttackNearDarkElixirDrillDB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkAttackNearDarkElixirDrill_Info_01", "Drop troops near Dark Elixir Drills")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicAttackNearDarkElixirDrillDB = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 20 , $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 40
$x = 98
$g_hBtnCustomDropOrderDB = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnCustomDropOrder", "Drop Order"), $x, $y, 85, 25)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnCustomDropOrder_Info_01", "Select Custom Troops Dropping Order"))
GUICtrlSetOnEvent(-1, "CustomDropOrder")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_DEADBASE_ATTACK_SCRIPTED = 0
Global $g_hCmbScriptNameDB = 0, $g_hCmbScriptRedlineImplDB = 0, $g_hCmbScriptDroplineDB = 0
Global $g_hLblNotesScriptDB = 0
Func CreateAttackSearchDeadBaseScripted()
$g_hGUI_DEADBASE_ATTACK_SCRIPTED = _GUICreate("", $_GUI_MAIN_WIDTH - 195, $g_iSizeHGrpTab4, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DEADBASE)
Local $x = 25, $y = 20
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "Group_01", "Deploy"), $x - 20, $y - 20, 270, $g_iSizeHGrpTab4)
$y += 15
$g_hCmbScriptNameDB = GUICtrlCreateCombo("", $x, $y, 200, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL, $WS_VSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptName", "Choose the script; You can edit/add new scripts located in folder: 'CSV/Attack'"))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptNameDB")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnReload, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconReload_Info_01", "Reload Script Files"))
GUICtrlSetOnEvent(-1, 'UpdateComboScriptNameDB')
$y += 25
$g_hLblNotesScriptDB = GUICtrlCreateLabel("", $x, $y + 5, 200, 180)
$g_hCmbScriptRedlineImplDB = GUICtrlCreateCombo("", $x, $y + 195, 230, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptRedlineImpl", "ImgLoc Raw Redline (default)|ImgLoc Redline Drop Points|Original Redline|External Edges"))
_GUICtrlComboBox_SetCurSel(-1, $g_aiAttackScrRedlineRoutine[$DB])
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptRedlineImpl_Info_01", "Choose the Redline implementation. ImgLoc Redline is default and best."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptRedlineImplDB")
$g_hCmbScriptDroplineDB = GUICtrlCreateCombo("", $x, $y + 220, 230, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptDropline", "Drop line fix outer corner|Drop line fist Redline point|Full Drop line fix outer corner|Full Drop line fist Redline point|No Drop line"))
_GUICtrlComboBox_SetCurSel(-1, $g_aiAttackScrDroplineEdge[$DB])
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptDropline_Info_01", "Choose the drop line edges. Default is outer corner and safer. First Redline point can improve attack."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptDroplineDB")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnEdit, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconShow-Edit_Info_01", "Show/Edit current Attack Script"))
GUICtrlSetOnEvent(-1, "EditScriptDB")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnAddcvs, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconCreate_Info_01", "Create a new Attack Script"))
GUICtrlSetOnEvent(-1, "NewScriptDB")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCopy, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconCopy_Info_01", "Copy current Attack Script to a new name"))
GUICtrlSetOnEvent(-1, "DuplicateScriptDB")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrain, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconApply_Info_01", "Apply Settings of troop, spell, redline, dropline, and request"))
GUICtrlSetOnEvent(-1, "ApplyScriptDB")
GUICtrlCreateGroup("", -99, -99, 1, 1)
UpdateComboScriptNameDB()
Local $tempindex = _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameDB, $g_sAttackScrScriptName[$DB])
If $tempindex = -1 Then $tempindex = 0
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameDB, $tempindex)
EndFunc
Global $g_hGUI_DEADBASE_ATTACK_MILKING = 0
Global $g_hCmbMilkAttackType = 0, $g_hCmbMilkLvl[13] = [-1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hChkAtkElixirExtractors = 0, $g_hChkAtkGoldMines = 0, $g_hCmbAtkGoldMinesLevel = 0, $g_hChkAtkDarkDrills = 0, $g_hCmbAtkDarkDrillsLevel = 0
Global $g_hCmbRedlineResDistance = 0, $g_hChkAttackMinesIfGold = 0, $g_hTxtAttackMinesIfGold = 0, $g_hChkAttackMinesIfElixir = 0, $g_hTxtAttackMinesIfElixir = 0, $g_hChkAttackMinesIfDarkElixir = 0, $g_hTxtAttackMinesIfDarkElixir = 0
Global $g_hTxtLowerXWave = 0, $g_hTxtUpperXWave = 0, $g_hTxtMaxWaves = 0, $g_hTxtLowerDelayWaves = 0, $g_hTxtUpperDelayWaves = 0
Global $g_hCmbMilkingAttackDropGoblinAlgorithm = 0, $g_hCmbStructureOrder = 0
Global $g_hChkStructureDestroyedBeforeAttack = 0, $g_hChkStructureDestroyedAfterAttack = 0
Global $g_hChkMilkAfterAttackTHSnipe = 0, $g_hTxtMaxTilesMilk = 0, $g_hCmbMilkSnipeAlgorithm = 0, $g_hChkSnipeIfNoElixir = 0, $g_hChkMilkAfterAttackScripted = 0, $g_hCmbMilkingCSVScriptName = 0
Global $g_hGrpSnipeOutsideTHAtEnd = 0, $g_hGrpDeploy = 0, $g_hLblMilkingCSVNotesScript = 0
Global $g_hChkMilkFarmForceTolerance = 0, $g_hTxtMilkFarmForceToleranceNormal = 0, $g_hTxtMilkFarmForceToleranceBoosted = 0, $g_hTxtMilkFarmForceToleranceDestroyed = 0
Global $g_hGrpMilkingDebug = 0, $g_hChkMilkingDebugIMG = 0, $g_hChkMilkingDebugVillage = 0, $g_hChkMilkingDebugFullSearch = 0
Func CreateAttackSearchDeadBaseMilking()
$g_hGUI_DEADBASE_ATTACK_MILKING = _GUICreate("", $_GUI_MAIN_WIDTH - 195, $g_iSizeHGrpTab4, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DEADBASE)
Local $sTxtDisable = GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "TxtDisable", "DIS.")
Local $x = 5, $y = 0
GUICtrlCreateTab($x, $y, 268, 306, $TCS_MULTILINE)
GUICtrlCreateTabItem(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_03_SubItem_01", "A - Structures"))
Local $x = 15, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "Group_01", "Choose Milking Search Type"), $x - 5, $y - 5, 260, 45)
$y += 15
$g_hCmbMilkAttackType = GUICtrlCreateCombo("", $x, $y, 250, 20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbMilkAttackType_Item_01", "Slower: Check the Resources in each collector.") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbMilkAttackType_Item_02", "Faster: Only check the Level of each collector."), GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbMilkAttackType_Item_02", -1))
$y += 30
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "Group_02", "Elixir Collectors Min. Level to Attack"), $x - 5, $y, 210, 145)
$y += 20
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbMilkLvl_01", "Levels 1-4"), $x, $y)
$g_hCmbMilkLvl[4] = GUICtrlCreateCombo("", $x, $y + 16, 65, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%", $sTxtDisable)
$x += 67
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbMilkLvl_05", "Level 5"), $x, $y)
$g_hCmbMilkLvl[5] = GUICtrlCreateCombo("", $x, $y + 16, 65, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%", $sTxtDisable)
$x += 67
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbMilkLvl_06", "Level 6"), $x, $y)
$g_hCmbMilkLvl[6] = GUICtrlCreateCombo("", $x, $y + 16, 65, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%", $sTxtDisable)
$x = 15
$y += 40
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbMilkLvl_07", "Level 7"), $x, $y)
$g_hCmbMilkLvl[7] = GUICtrlCreateCombo("", $x, $y + 16, 65, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%", $sTxtDisable)
$x += 67
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbMilkLvl_08", "Level 8"), $x, $y)
$g_hCmbMilkLvl[8] = GUICtrlCreateCombo("", $x, $y + 16, 65, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%", $sTxtDisable)
$x += 67
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbMilkLvl_09", "Level 9"), $x, $y)
$g_hCmbMilkLvl[9] = GUICtrlCreateCombo("", $x, $y + 16, 65, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%", $sTxtDisable)
$x = 15
$y += 40
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbMilkLvl_10", "Level 10"), $x, $y)
$g_hCmbMilkLvl[10] = GUICtrlCreateCombo("", $x, $y + 16, 65, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%", "5-19%")
$x += 67
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbMilkLvl_11", "Level 11"), $x, $y)
$g_hCmbMilkLvl[11] = GUICtrlCreateCombo("", $x, $y + 16, 65, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%", "5-19%")
$x += 67
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbMilkLvl_12", "Level 12"), $x, $y)
$g_hCmbMilkLvl[12] = GUICtrlCreateCombo("", $x, $y + 16, 65, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%", "5-19%")
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 10, $y = 240
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "Group_03", "Legend"), $x, $y, 260, 65)
$x = 23
$y = 255
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CapacityStructure_01", "0-4%"), $x, $y)
$x = 21
$y = 273
_GUICtrlCreatePic(@ScriptDir & "\Images\CapacityStructure\elixir_8_0_70_A.bmp", $x, $y, 25, 25)
$x = 65
$y = 255
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CapacityStructure_02", "5-19%"), $x, $y)
$x = 66
$y = 273
_GUICtrlCreatePic(@ScriptDir & "\Images\CapacityStructure\elixir_8_1_70_A.bmp", $x, $y, 25, 25)
$x = 117
$y = 255
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CapacityStructure_03", "20-74%"), $x, $y)
$x = 121
$y = 273
_GUICtrlCreatePic(@ScriptDir & "\Images\CapacityStructure\elixir_8_2_70_A.bmp", $x, $y, 25, 25)
$x = 173
$y = 255
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CapacityStructure_04", "75-89%"), $x, $y)
$x = 176
$y = 273
_GUICtrlCreatePic(@ScriptDir & "\Images\CapacityStructure\elixir_8_3_70_A.bmp", $x, $y, 25, 25)
$x = 224
$y = 255
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CapacityStructure_05", "90-100%"), $x, $y)
$x = 232
$y = 273
_GUICtrlCreatePic(@ScriptDir & "\Images\CapacityStructure\elixir_8_4_70_A.bmp", $x, $y, 25, 25)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
GUICtrlCreateTabItem( GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_03_SubItem_02", "B - Conditions"))
Local $x = 14, $y = 45
GUICtrlCreateGroup( GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "Group_04", "Structures to Attack"), $x - 5, $y, 260, 100)
$y += 22
$g_hChkAtkElixirExtractors = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkAtkGEDExtractors", "Attack"), $x, $y, -1, 18)
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 55, $y - 6, 24, 24)
$y += 26
$g_hChkAtkGoldMines = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkAtkGEDExtractors", -1), $x, $y, -1, 18)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkAtkGoldMines")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 55, $y - 6, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "LblWhichLevel", "Which have a Level") & " " & ChrW(8805), $x + 75, $y + 2, 115, 18, $SS_RIGHT)
$g_hCmbAtkGoldMinesLevel = GUICtrlCreateCombo("", $x + 200, $y - 2, 50, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "1-4|5|6|7|8|9|10|11", "5")
$y += 26
$g_hChkAtkDarkDrills = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkAtkGEDExtractors", -1), $x, $y, -1, 18)
GUICtrlSetOnEvent(-1, "chkAtkDarkDrills")
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 55, $y - 6, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "LblWhichLevel", -1) & " " & ChrW(8805), $x + 75, $y + 2, 115, 18, $SS_RIGHT)
$g_hCmbAtkDarkDrillsLevel = GUICtrlCreateCombo("", $x + 200, $y - 2, 50, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "1|2|3|4|5|6", "1")
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 14, $y = 155
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "Group_05", "Only Attack If"), $x - 5, $y - 5, 260, 110)
$y += 15
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "LblRedline-and-Collectors", "Distance between red line and collectors"), $x, $y)
$g_hCmbRedlineResDistance = GUICtrlCreateCombo("", $x + 200, $y - 4, 50, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0 tile|1 tile|2 tiles", "0 tile")
$y += 21
$g_hChkAttackMinesIfGold = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkAttackMinesIfGold", "Attack Gold Mines If Gold Under"), $x, $y)
GUICtrlSetOnEvent(-1, "chkAttackMinesifGold")
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hTxtAttackMinesIfGold = GUICtrlCreateInput("9950000", $x + 200, $y, 50, 18, $SS_CENTER)
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlSetLimit(-1, 7)
$y += 21
$g_hChkAttackMinesIfElixir = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkAttackMinesIfElixir", "Attack Elixir Collectors If Elixir Under"), $x, $y)
GUICtrlSetOnEvent(-1, "chkAttackMinesifElixir")
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hTxtAttackMinesIfElixir = GUICtrlCreateInput("9950000", $x + 200, $y, 50, 18, $SS_CENTER)
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlSetLimit(-1, 7)
$y += 21
$g_hChkAttackMinesIfDarkElixir = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkAttackMinesIfDarkElixir", "Attack Dark Elixir Drills If Dark Under"), $x, $y)
GUICtrlSetOnEvent(-1, "chkAttackMinesifDarkElixir")
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hTxtAttackMinesIfDarkElixir = GUICtrlCreateInput("200000", $x + 200, $y, 50, 18, $SS_CENTER)
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
GUICtrlCreateTabItem(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_03_SubItem_03", "C - Attack"))
Local $x = 9
Local $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "Group_06", "4. Troops To Use For Each Building"), $x, $y, 260, 90)
$x = 15
$y += 20
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "TxtXWave", "- Troops Per Wave:"), $x, $y)
$g_hTxtLowerXWave = GUICtrlCreateInput("4", 180 - 10, $y - 3, 35, 18, $SS_CENTER)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel("-", 213, $y)
$g_hTxtUpperXWave = GUICtrlCreateInput("6", 245 - 20, $y - 3, 35, 18, $SS_CENTER)
GUICtrlSetLimit(-1, 2)
$y += 20
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "TxtMaxWaves", "- Max Waves:"), $x, $y)
$g_hTxtMaxWaves = GUICtrlCreateInput("3", 180 - 10, $y - 3, 35, 18, $SS_CENTER)
GUICtrlSetLimit(-1, 2)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "TxtMaxWaves_Info_01", "Choose the maximum number of waves of troops to drop at each collector.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "TxtMaxWaves_Info_02", "If the collector gets destroyed, then no more waves will be dropped at it."))
$y += 20
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "TxtDelayWaves", "- Delay Between Waves (ms):"), $x, $y)
$g_hTxtLowerDelayWaves = GUICtrlCreateInput("3000", 180 - 10, $y - 3, 35, 18, $SS_CENTER)
GUICtrlSetLimit(-1, 5)
GUICtrlCreateLabel("-", 213, $y)
$g_hTxtUpperDelayWaves = GUICtrlCreateInput("5000", 245 - 20, $y - 3, 35, 18, $SS_CENTER)
GUICtrlSetLimit(-1, 5)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 9
$y += 40
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "Group_07", "5. Dropping options"), $x, $y, 260, 80)
$y += 21
$g_hCmbMilkingAttackDropGoblinAlgorithm = GUICtrlCreateCombo("", $x + 5, $y, 250, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbMilkingAttackDropGoblinAlgorithm_Item_01", "Drop each Goblin in the same place") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbMilkingAttackDropGoblinAlgorithm_Item_02", "Drop each Goblin in a different place"), GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbMilkingAttackDropGoblinAlgorithm_Item_01", -1))
$y += 25
$g_hCmbStructureOrder = GUICtrlCreateCombo("", $x + 5, $y, 250, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbStructureOrder_Item_01", "Attack Order: as found") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbStructureOrder_Item_02", "Attack Order: Random") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbStructureOrder_Item_03", "Attack Order: by side"), GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "CmbStructureOrder_Item_03", -1))
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 9
$y += 40
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "Group_08", "Check Destroyed Structures"), $x, $y, 260, 70)
$y += 20
$x += 5
$g_hChkStructureDestroyedBeforeAttack = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkStructureDestroyedBeforeAttack", "Check Structure Destruction Before Wave"), $x, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkStructureDestroyedBeforeAttack_Info_01", "Before attacking a structure, check to see if it has been destroyed by another wave.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkStructureDestroyedBeforeAttack_Info_02", "You must have a high delay between waves to use this option"))
$y += 20
$g_hChkStructureDestroyedAfterAttack = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkStructureDestroyedAfterAttack", "Check Structure Destruction After Wave"), $x, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkStructureDestroyedAfterAttack_Info_01", "After attacking a structure, check to see if it has been destroyed by another wave.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkStructureDestroyedAfterAttack_Info_02", "You must have a high delay between waves to use this option"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
GUICtrlCreateTabItem(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_03_SubItem_04", "D - After Milking"))
Local $x = 9
Local $y = 45
$g_hGrpSnipeOutsideTHAtEnd = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "Group_09", "5a. Snipe Outside TH After Milking"), $x, $y - 4, 260, 120)
$x = 15
$y+= 15
$g_hChkMilkAfterAttackTHSnipe = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkMilkAfterAttackTHSnipe", "Enable TH Snipe"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkMilkAfterAttackTHSnipe", -1))
GUICtrlSetOnEvent(-1, "chkMilkAfterAttackTHSnipe")
$y += 21
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "LblMaxTilesMilk", "Max Tiles From Border") & ":", $x, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtMaxTilesMilk = GUICtrlCreateInput("1", $x + 115, $y - 3, 30, 18, $SS_CENTER)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "LblMilkSnipeAlgorithm", "Use Algorithm") & ":", $x, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hCmbMilkSnipeAlgorithm = GUICtrlCreateCombo("", 130, $y - 2, 133, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetState(-1, $GUI_DISABLE)
PopulateCmbMilkSnipeAlgorithm()
_GUICtrlComboBox_SetCurSel($g_hCmbMilkSnipeAlgorithm, _GUICtrlComboBox_FindStringExact($g_hCmbMilkSnipeAlgorithm, "Queen&GobTakeTH"))
$y += 20
$g_hChkSnipeIfNoElixir = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkSnipeIfNoElixir", "Snipe Even If No Collectors can be Milked"), $x, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 9
$y += 85
$g_hGrpDeploy = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "Group_10", "5b. Continue With An Scripted Attack"), $x , $y - 20, 260, 70)
$x += 15
$g_hChkMilkAfterAttackScripted = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkMilkAfterAttackScripted", "Enable Scripted Attack"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkMilkAfterAttackScripted", "Enable Scripted Attack"))
$y += 21
$g_hCmbMilkingCSVScriptName = GUICtrlCreateCombo("", $x - 10 , $y, 250, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkMilkAfterAttackScripted_Info_02", "Use scripted attack for dead bases, this disables standard attack"))
PopulateComboMilkingCSVScriptsFiles()
_GUICtrlComboBox_SetCurSel($g_hCmbMilkingCSVScriptName, _GUICtrlComboBox_FindStringExact($g_hCmbMilkingCSVScriptName, "Barch four fingers"))
$y += 25
$g_hLblMilkingCSVNotesScript = GUICtrlCreateLabel("", $x, $y + 5, 180, 118)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
GUICtrlCreateTabItem(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_03_SubItem_05", "Advanced"))
Local $x = 9
Local $y = 45
$y += 21
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "Group_11", "Tolerance Settings"), $x, $y, 260, 120)
$x += 5
$y += 21
$g_hChkMilkFarmForceTolerance = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkMilkFarmForceTolerance", "Force Tolerance"), $x, $y)
GUICtrlSetOnEvent(-1,"chkMilkFarmForcetolerance")
$y += 21
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkMilkFarmForceTolerance_Info_01", "Tolerance Normal"), $x, $y)
$g_hTxtMilkFarmForceToleranceNormal = GUICtrlCreateInput("60", 235 - 31, $y - 3, 60 - 8, 20, $SS_CENTER)
GUICtrlSetLimit(-1, 4)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 21
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkMilkFarmForceTolerance_Info_02", "Tolerance Boosted"), $x, $y)
$g_hTxtMilkFarmForceToleranceBoosted = GUICtrlCreateInput("60", 235 - 31, $y - 3, 60 - 8, 20, $SS_CENTER)
GUICtrlSetLimit(-1, 4)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 21
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkMilkFarmForceTolerance_Info_03", "Tolerance Destroyed"), $x, $y)
$g_hTxtMilkFarmForceToleranceDestroyed = GUICtrlCreateInput("60", 235 - 31, $y - 3, 60 - 8, 20, $SS_CENTER)
GUICtrlSetLimit(-1, 4)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 9
$y += 50
$g_hGrpMilkingDebug = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "Group_12", "Debug"), $x, $y, 260, 100)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$x += 5
$g_hChkMilkingDebugIMG = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkMilkingDebugIMG", "Make Images of each extractor with offset"), $x, $y)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkMilkingDebugVillage = GUICtrlCreateCheckbox( GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkMilkingDebugVillage", "Make Images of villages"), $x, $y)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkMilkingDebugFullSearch = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkMilkingDebugFullSearch", "fullsearch, only for debug purpose (very slow)"), $x, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase Attack Milking", "ChkMilkingDebugFullSearch_Info_01", "with this options you can detect images of undetected Elixir Extractors"))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
EndFunc
Global $g_hChkDBActivateSearches = 0, $g_hTxtDBSearchesMin = 0, $g_hTxtDBSearchesMax = 0
Global $g_hChkDBActivateTropies = 0, $g_hTxtDBTropiesMin = 0, $g_hTxtDBTropiesMax = 0
Global $g_hChkDBActivateCamps = 0, $g_hTxtDBArmyCamps = 0
Global $g_hChkDBKingWait = 0, $g_hChkDBQueenWait = 0, $g_hChkDBWardenWait = 0, $g_hChkNotWaitHeros = 0, $g_hChkDBNotWaitHeroes = 0
Global $g_hChkDBSpellsWait = 0, $g_hChkDBWaitForCastleSpell = 0, $g_hCmbDBWaitForCastleSpell = 0, $g_hCmbDBWaitForCastleSpell = 0,$g_hCmbDBWaitForCastleSpell2 = 0, $g_hTxtDBWaitForCastleSpell = 0, $g_hChkDBWaitForCastleTroops = 0
Global $g_hLblDBSearches = 0, $g_hLblDBTropies = 0, $g_hLblDBArmyCamps = 0
Global $g_hPicDBHeroesWait = 0, $g_hTxtDBHeroesWait = 0, $g_hPicDBKingWait = 0, $g_hPicDBKingSleepWait = 0, $g_hPicDBQueenWait = 0, $g_hPicDBQueenSleepWait = 0, $g_hPicDBWardenWait = 0, $g_hPicDBWardenSleepWait = 0
Global $g_hPicDBLightSpellWait = 0, $g_hPicDBHealSpellWait = 0, $g_hPicDBRageSpellWait = 0, $g_hPicDBJumpSpellWait = 0, $g_hPicDBFreezeSpellWait = 0, $g_hPicDBPoisonSpellWait = 0, $g_hPicDBEarthquakeSpellWait = 0, $g_hPicDBHasteSpellWait = 0
Global $g_hCmbDBMeetGE = 0, $g_hTxtDBMinGold = 0, $g_hTxtDBMinElixir = 0, $g_hTxtDBMinGoldPlusElixir = 0
Global $g_hChkDBMeetDE = 0, $g_hTxtDBMinDarkElixir = 0
Global $g_hChkDBMeetTrophy = 0, $g_hTxtDBMinTrophy = 0, $g_hTxtDBMaxTrophy = 0
Global $g_hChkDBMeetTH = 0, $g_hCmbDBTH = 0, $g_hChkDBMeetTHO = 0
Global $g_hGrpDBFilter = 0, $g_hPicDBMinGold = 0, $g_hPicDBMinElixir = 0, $g_hPicDBMinGPEGold = 0, $g_hPicDBMinDarkElixir = 0, $g_hPicDBMinTrophies = 0
Global $g_ahPicDBMaxTH[13]
Func CreateAttackSearchDeadBaseSearch()
Local $sTxtLightningSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortLightningSpells", -1)
Local $sTxtHealSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHealSpells", -1)
Local $sTxtRageSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortRageSpells", -1)
Local $sTxtJumpSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortJumpSpells", -1)
Local $sTxtFreezeSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortFreezeSpells", -1)
Local $sTxtPoisonSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortPoisonSpells", -1)
Local $sTxtEarthquakeSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortEarthquakeSpells", -1)
Local $sTxtHasteSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHasteSpells", -1)
Local $sTxtSkeletonSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortSkeletonSpells", -1)
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_01", "Start Search IF"), $x - 20, $y - 20, 190, $g_iSizeHGrpTab4)
$x -= 15
$g_hChkDBActivateSearches = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches", "Search"), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", "Note - enables SEARCH range for this attack type ONLY.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", "Setting will not set search limit to restart search process!"))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBActivateSearches")
$g_hTxtDBSearchesMin = GUICtrlCreateInput("1", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMinSearches_Info_01", "Set the Min. number of searches to activate this attack option") & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", -1))
GUICtrlSetLimit(-1, 6)
$g_hLblDBSearches = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
$g_hTxtDBSearchesMax = GUICtrlCreateInput("9999", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMaxSearches_Info_01", "Set the Max number of searches to activate this attack option") & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", -1))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMagnifier, $x + 163, $y + 1, 16, 16)
$y += 21
$g_hChkDBActivateTropies = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies", "Trophies"), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", "This option will NOT adjust tropies to stay in range entered!"))
GUICtrlSetOnEvent(-1, "chkDBActivateTropies")
$g_hTxtDBTropiesMin = GUICtrlCreateInput("0", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMinTropies_Info_01", "Set the Min. number of tropies where this attack will be used") & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetLimit(-1, 6)
$g_hLblDBTropies = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtDBTropiesMax = GUICtrlCreateInput("6000", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMaxTropies_Info_01", "Set the Max number of tropies where this attack will be used") & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 163, $y + 1, 16, 16)
$y += 21
$g_hChkDBActivateCamps = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateCamps", "Army Camps"), $x, $y, 110, 18)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateCamps_Info_01", "Set the % Army camps required to enable this attack option while searching")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDBActivateCamps")
$g_hLblDBArmyCamps = GUICtrlCreateLabel(ChrW(8805), $x + 113 - 1, $y + 2, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtDBArmyCamps = GUICtrlCreateInput("80", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
GUICtrlCreateLabel("%", $x + 163 + 3, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 23
$g_hPicDBHeroesWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x - 1, $y + 3, 16, 16)
$g_hTxtDBHeroesWait = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtHeroesWait", "Wait for Heroes to be Ready") & ":", $x + 20, $y + 4, 180, 18)
$y += 20
$x += 20
$g_hChkDBKingWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
Local $sTxtKingWait = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtHeroesWait_Info_01", "Wait for Hero option disabled when continuous Upgrade Hero selected!")
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtKingWait_Info_01", "Wait for King to be ready before attacking...") & @CRLF & $sTxtKingWait & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtKingWait_Info_02", "Enabled with TownHall 7 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDBKingWait")
$g_hPicDBKingWait=_GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicDBKingSleepWait=_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$x += 55
$g_hChkDBQueenWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtQueenWait_Info_01", "Wait for Queen to be ready before attacking...") & @CRLF & $sTxtKingWait & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtQueenWait_Info_02", "Enabled with TownHall 9 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDBQueenWait")
$g_hPicDBQueenWait=_GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicDBQueenSleepWait=_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$x += 55
$g_hChkDBWardenWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtWardenWait_Info_01", "Wait for Warden to be ready before attacking...") & @CRLF & $sTxtKingWait & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtWardenWait_Info_02", "Enabled with TownHall 11")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDBWardenWait")
$g_hPicDBWardenWait=_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicDBWardenSleepWait=_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 75
$x = 10
$g_hChkDBNotWaitHeroes = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkNotWaitHeroes", "Not wait for Heroes when upgrade"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkNotWaitHeroes_Info_01", "Continue to attack, when Upgrade heroes and enable Wait for heroes."))
GUICtrlSetOnEvent(-1, "chkNotWaitHeroes")
$y += 25
$x = 8
$g_hPicDBLightSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y, 22, 22)
$g_hPicDBHealSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x + 23, $y, 22, 22)
$g_hPicDBRageSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x + 46, $y, 22, 22)
$g_hPicDBJumpSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x + 69, $y, 22, 22)
$g_hPicDBFreezeSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x + 92, $y, 22, 22)
$g_hPicDBPoisonSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x + 115, $y, 22, 22)
$g_hPicDBEarthquakeSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell, $x + 138, $y, 22, 22)
$g_hPicDBHasteSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x + 161, $y, 22, 22)
$y += 22
$x = 10
$g_hChkDBSpellsWait = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkSpellsWait", "Wait for Spells to be Ready"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkSpellsWait_Info_01", "Stop searching for this attack type when Spells are not ready") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkSpellsWait_Info_02", "Warning: Do not enable unless you have spell factory or bot will not attack!"))
GUICtrlSetOnEvent(-1, "chkDBSpellsWait")
$g_hChkDBWaitForCastleSpell = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastleSpell", "Wait to get Castle Spell"), $x, $y + 25, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastleSpell_Info_01", "Wait until Someone Donate you an Spell"))
GUICtrlSetOnEvent(-1, "chkDBWaitForCCSpell")
$g_hCmbDBWaitForCastleSpell = GUICtrlCreateCombo(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbWaitForCastleSpell", "Any"), $x, $y + 50, 70, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtLightningSpells & "|" & $sTxtHealSpells & "|" & $sTxtRageSpells & "|" & $sTxtJumpSpells & "|" & $sTxtFreezeSpells & "|" & $sTxtPoisonSpells & "|" & $sTxtEarthquakeSpells & "|" & $sTxtHasteSpells & "|" & $sTxtSkeletonSpells)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastleSpell_Info_01", -1))
GUICtrlSetOnEvent(-1, "cmbDBWaitForCCSpell")
$g_hTxtDBWaitForCastleSpell = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtWaitForCastleSpell", "And"), $x + 80, $y + 53, -1, -1)
$g_hCmbDBWaitForCastleSpell2 = GUICtrlCreateCombo(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbWaitForCastleSpell", -1), $x + 110, $y + 50, 70, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtPoisonSpells & "|" & $sTxtEarthquakeSpells & "|" & $sTxtHasteSpells & "|" & $sTxtSkeletonSpells)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastleSpell_Info_01", -1))
$g_hChkDBWaitForCastleTroops = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastleTroops", "Wait for Castle troops to be full"), $x, $y + 75, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastleTroops_Info_01", "Wait until your Clan Castle be Full"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 220, $y = 45
$g_hGrpDBFilter = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_02", "Filters"), $x - 20, $y - 20, 225, $g_iSizeHGrpTab4)
$x -= 15
$g_hCmbDBMeetGE = GUICtrlCreateCombo("", $x, $y + 10, 65, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_01", "G And E") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_02", "G Or E") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_03", "G + E"), GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_01", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_01", "Search for a base that meets the values set for Gold And/Or/Plus Elixir.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_02", "AND: Both conditions must meet, Gold and Elixir.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_03", "OR: One condition must meet, Gold or Elixir.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_04", "+ (PLUS): Total amount of Gold + Elixir must meet."))
GUICtrlSetOnEvent(-1, "cmbDBGoldElixir")
$g_hTxtDBMinGold = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinGold_Info_01", "Set the Min. amount of Gold to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicDBMinGold = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtDBMinElixir = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinElixir_Info_01", "Set the Min. amount of Elixir to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicDBMinElixir = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y -= 11
$g_hTxtDBMinGoldPlusElixir = GUICtrlCreateInput("160000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinGoldPlusElixir_Info_01", "Set the Min. amount of Gold + Elixir to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicDBMinGPEGold = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldElixir, $x + 140, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 34
$g_hChkDBMeetDE = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetDE", "Dark Elixir"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkDBMeetDE")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetDE_Info_01", "Search for a base that meets the value set for Min. Dark Elixir."))
$g_hTxtDBMinDarkElixir = GUICtrlCreateInput("0", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinDarkElixir_Info_01", "Set the Min. amount of Dark Elixir to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlEdit_SetReadOnly(-1, True)
$g_hPicDBMinDarkElixir = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hChkDBMeetTrophy = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies", -1), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkDBMeetTrophy")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTrophy_Info_01", "Search for a base that meets the value set for Min. Trophies."))
$g_hTxtDBMinTrophy = GUICtrlCreateInput("0", $x + 85, $y, 20, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTrophy_Info_02", "Set the Min. amount of Trophies to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlEdit_SetReadOnly(-1, True)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel("-", $x + 109, $y + 2, -1, -1)
$g_hTxtDBMaxTrophy = GUICtrlCreateInput("0", $x + 115, $y, 20, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTrophy_Info_03", "Set the Max. amount of Trophies to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlEdit_SetReadOnly(-1, True)
GUICtrlSetLimit(-1, 2)
$g_hPicDBMinTrophies = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hChkDBMeetTH = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR Global GUI Design", "LblTownhall", -1), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkDBMeetTH")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTH_Info_01", "Search for a base that meets the value set for Max. Townhall Level."))
$g_hCmbDBTH = GUICtrlCreateCombo("", $x + 85, $y - 1, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbDBTH", "Set the Max. level of the Townhall to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetData(-1, "4-6|7|8|9|10|11|12", "4-6")
GUICtrlSetOnEvent(-1, "CmbDBTH")
$g_ahPicDBMaxTH[6] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV06, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_SHOW)
$g_ahPicDBMaxTH[7] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV07, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDBMaxTH[8] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV08, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDBMaxTH[9] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV09, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDBMaxTH[10] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV10, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDBMaxTH[11] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV11, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahPicDBMaxTH[12] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV12, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 24
$g_hChkDBMeetTHO = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTHO", "Townhall Outside"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTHO_Info_01", "Search for a base that has an exposed Townhall. (Outside of Walls)"))
$y += 24
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_03", "Weak base | max defenses"), $x, $y, 215, 100)
$x += 5
$y += 20
Local $xStartColumn = $x, $yStartColumn = $y
$g_ahChkMaxMortar[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxMortar", "Search for a base that has Mortar below this level."))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakMortar[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 52, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxMortar_Info_01", "Set the Max. level of the Mortar to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9|Lvl 10|Lvl 11", "Lvl 5")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakMortar[$DB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnMortar, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxWizTower[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxWizTower", "Search for a base that has Wizard Tower below this level"))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakWizTower[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 52, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxWizTower_Info_01", "Set the Max. level of the Wizard Tower to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9|Lvl 10|Lvl 11", "Lvl 4")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakWizTower[$DB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWizTower, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxAirDefense[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxAirDefense", "Search for a base that has Air Defense below this level"))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakAirDefense[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 53, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxAirDefense_Info_01", "Set the Max. level of the Air Defense to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9|Lvl 10", "Lvl 7")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakAirDefense[$DB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnAirdefense, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x = $xStartColumn + 104
$y = $yStartColumn
$g_ahChkMaxXBow[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxXBow", "Search for a base that has X-Bow below this level"))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakXBow[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxXBow_Info_01", "Set the Max. level of the X-Bow to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakXBow[$DB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnXBow3, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxInferno[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxInferno", "Search for a base that has Inferno below this level"))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakInferno[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxInferno_Info_01", "Set the Max. level of the Inferno Tower to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakInferno[$DB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnInferno4, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxEagle[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxEagle", "Search for a base that has Eagle Artillery below this level"))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakEagle[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxEagle_Info_01", "Set the Max. level of the Eagle Artillery to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3", "Lvl 1")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakEagle[$DB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEagleArt, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 44
$x = $xStartColumn
$g_ahChkMeetOne[$DB] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetOne", "Meet One Then Attack"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetOne_Info_01", "Just meet only ONE of the above conditions, then Attack."))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hCmbDBAlgorithm = 0, $g_hCmbDBSelectTroop = 0, $g_hChkDBKingAttack = 0, $g_hChkDBQueenAttack = 0, $g_hChkDBWardenAttack = 0, $g_hChkDBDropCC = 0
Global $g_hChkDBLightSpell = 0, $g_hChkDBHealSpell = 0, $g_hChkDBRageSpell = 0, $g_hChkDBJumpSpell = 0, $g_hChkDBFreezeSpell = 0, $g_hChkDBCloneSpell = 0, $g_hChkDBPoisonSpell = 0, $g_hChkDBEarthquakeSpell = 0, $g_hChkDBHasteSpell = 0, $g_hChkDBSkeletonSpell = 0
Global $g_hPicDBKingAttack = 0, $g_hPicDBQueenAttack = 0, $g_hPicDBWardenAttack = 0, $g_hPicDBDropCC = 0
Global $g_hPicDBLightSpell = 0, $g_hPicDBHealSpell = 0, $g_hPicDBRageSpell = 0, $g_hPicDBJumpSpell = 0, $g_hPicDBFreezeSpell = 0, $g_hPicDBCloneSpell = 0, $g_hPicDBPoisonSpell = 0, $g_hPicDBEarthquakeSpell = 0, $g_hPicDBHasteSpell = 0, $g_hPicDBSkeletonSpell = 0
Global $g_hChkTHSnipeBeforeDBEnable = 0, $g_hTxtTHSnipeBeforeDBTiles = 0, $g_hCmbTHSnipeBeforeDBScript = 0
Global $g_hLblTHSnipeBeforeDBTiles = 0
Func CreateAttackSearchDeadBaseAttack()
Local $sTxtTip = ""
Local $x = 25, $y = 40
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Group_01", "Attack with"), $x - 20, $y - 15, 145, 223)
$x -= 15
$y += 5
$g_hCmbDBAlgorithm = GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, "")
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_01", "Standard Attack") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_02", "Scripted Attack") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_03", "Milking Attack"), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_01", -1))
GUICtrlSetOnEvent(-1, "cmbDBAlgorithm")
$y += 30
$g_hCmbDBSelectTroop = GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_01", "Use All Troops") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_02", "Use Troops in Barracks") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_03", "Barb Only") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_04", "Arch Only") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_05", "B+A") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_06", "B+Gob") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_07", "A+Gob") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_08", "B+A+Gi") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_09", "B+A+Gob+Gi") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_10", "B+A+Hog Rider") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_11", "B+A+Minion"), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_01", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Info_01", "Select the troops to use in attacks"))
$y += 30
$g_hPicDBKingAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x , $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-King_Info_01", "Use your King when Attacking...") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-King_Info_02", "Enabled with TownHall 7 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBKingAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBQueenAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Queen_Info_01", "Use your Queen when Attacking...") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Queen_Info_02", "Enabled with TownHall 9 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBQueenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBWardenAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Warden_Info_01", "Use your Warden when Attacking...") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Warden_Info_02", "Enabled with Townhall 11")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBWardenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicDBDropCC = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnCC, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Clan Castle_Info_01", "Drop your Clan Castle in battle if it contains troops.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBDropCC = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBLightSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Light_Info_01", "Use your Light Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBLightSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBHealSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Healing_Info_01", "Use your Healing Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBHealSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicDBRageSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Rage_Info_01", "Use your Rage Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBRageSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBJumpSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Jump_Info_01", "Use your Jump Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBJumpSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBFreezeSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Freeze_Info_01", "Use your Freeze Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBFreezeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicDBCloneSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnCloneSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Clone_Info_01", "Use your Clone Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBCloneSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBPoisonSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Poison_Info_01", "Use your Poison Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBPoisonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBEarthquakeSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Earthquake_Info_01", "Use your Earthquake Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBEarthquakeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicDBHasteSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Haste_Info_01", "Use your Haste Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBHasteSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBSkeletonSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSkeletonSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Skeleton_Info_01", "Use your Skeletons Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBSkeletonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 10, $y = 268
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Group_02", "TH Snipe"), $x - 5, $y - 20, 145, 84,$SS_CENTER)
$g_hChkTHSnipeBeforeDBEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkTHSnipeBeforeEnable", "Snipe TH External first"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkTHSnipeBeforeEnable_Info_01", "If TH is external start with a TH Snipe"))
GUICtrlSetOnEvent(-1, "chkTHSnipeBeforeDBEnable")
$y += 16
$g_hLblTHSnipeBeforeDBTiles = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "LblTHSnipeBeforeTiles", "Add Tiles")& ":", $x, $y + 3, 70, -1, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtTHSnipeBeforeDBTiles = GUICtrlCreateInput("2", $x + 75, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "LblTHSnipeBeforeTiles_Info_01", "Max numbers of tiles from border to consider TH as external")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTiles, $x + 107, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hCmbTHSnipeBeforeDBScript = GUICtrlCreateCombo("", $x, $y, 130, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "CmbTHSnipeBeforeScript_Info_01", "You can add/edit CSV settings in the CSV\THSnipe folder"))
GUICtrlSetState(-1, $GUI_DISABLE)
LoadDBSnipeAttacks()
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeDBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeDBScript, "Bam"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkStopAtkDBNoLoot1 = 0, $g_hTxtStopAtkDBNoLoot1 = 0, $g_hChkStopAtkDBNoLoot2 = 0, $g_hTxtStopAtkDBNoLoot2 = 0, $g_hTxtDBMinGoldStopAtk2 = 0, $g_hTxtDBMinElixirStopAtk2 = 0, $g_hTxtDBMinDarkElixirStopAtk2 = 0, $g_hChkDBEndNoResources = 0, $g_hChkDBEndOneStar = 0, $g_hChkDBEndTwoStars = 0, $g_hChkDBEndPercentHigher = 0, $g_hTxtDBPercentHigher = 0, $g_hChkDBEndPercentChange = 0, $g_hTxtDBPercentChange = 0
Global $g_hGrpDBEndBattle = 0, $g_hLblStopAtkDBNoLoot1a = 0, $g_hLblStopAtkDBNoLoot1b = 0, $g_hLblStopAtkDBNoLoot2a = 0, $g_hLblStopAtkDBNoLoot2b = 0, $g_hLblDBMinRerourcesAtk2 = 0, $g_hPicDBMinGoldStopAtk2 = 0, $g_hPicDBMinElixirStopAtk2 = 0, $g_hPicDBMinDarkElixirStopAtk2 = 0, $g_hLblDBPercentHigher = 0, $g_hLblDBPercentHigherSec = 0, $g_hLblDBPercentChange = 0, $g_hLblDBPercentChangeSec = 0
Func CreateAttackSearchDeadBaseEndBattle()
Local $sTxtTip = ""
Local $x = 10, $y = 45
$g_hGrpDBEndBattle = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "Group_01", "Exit Battle"), $x - 5, $y - 20, $g_iSizeWGrpTab4, $g_iSizeHGrpTab4)
$y -= 5
$g_hChkStopAtkDBNoLoot1 = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot", "When no New loot"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_01", "End Battle if there is no extra loot raided within this No. of seconds.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_02", "Countdown is started after all Troops and Royals are deployed in battle.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkStopAtkDBNoLoot1")
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 20
$g_hLblStopAtkDBNoLoot1a = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblStopAtkNoLoot", "raided within") & ":", $x + 16, $y + 3, -1, -1)
$g_hTxtStopAtkDBNoLoot1 = GUICtrlCreateInput("15", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
$g_hLblStopAtkDBNoLoot1b = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 120, $y + 3, -1, -1)
$y += 20
$g_hChkStopAtkDBNoLoot2 = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot", -1), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkStopAtkDBNoLoot2")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 20
$g_hLblStopAtkDBNoLoot2a = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblStopAtkNoLoot", -1) & ":", $x + 16, $y + 3, -1, -1)
$g_hTxtStopAtkDBNoLoot2 = GUICtrlCreateInput("5", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblStopAtkDBNoLoot2b = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 120, $y + 3, -1, -1)
$y += 21
$g_hLblDBMinRerourcesAtk2 = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblMinRerourcesAtk2", "And Resources are below") & ":", $x + 16, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblMinRerourcesAtk2_Info_01", "End Battle if below this amount of Gold.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 21
$g_hTxtDBMinGoldStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicDBMinGoldStopAtk2 = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtDBMinElixirStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicDBMinElixirStopAtk2 = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtDBMinDarkElixirStopAtk2 = GUICtrlCreateInput("50", $x + 65, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 4)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicDBMinDarkElixirStopAtk2 = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hChkDBEndNoResources = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndNoResources", "When no Resources left"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndNoResources_Info_01", "End Battle when all Gold, Elixir and Dark Elixir = 0"))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkDBEndOneStar = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndOneStar", "When One Star is won"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndOneStar_Info_01", "Will End the Battle if 1 star is won in battle"))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkDBEndTwoStars = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndTwoStars", "When Two Stars are won"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndTwoStars_Info_01", "Will End the Battle if 2 stars are won in battle"))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkDBEndPercentHigher = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentHigher", "When Percentage is"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentHigher_Info_01", "End Battle if Overall Damage Percentage is above"))
GUICtrlSetOnEvent(-1, "chkDBEndPercentHigher")
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 20
$g_hLblDBPercentHigher = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblPercentHigher", "above") & ":", $x + 16, $y + 2, -1, -1)
$g_hTxtDBPercentHigher = GUICtrlCreateInput("60", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentHigher_Info_01", -1))
GUICtrlSetLimit(-1, 3)
$g_hLblDBPercentHigherSec = GUICtrlCreateLabel("%", $x + 120, $y + 3, -1, -1)
$y += 21
$g_hChkDBEndPercentChange = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentChange", "When Percentage doesn't"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentChange_Info_01", "End Battle when Percentage doesn't change in"))
GUICtrlSetOnEvent(-1, "chkDBEndPercentChange")
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 20
$g_hLblDBPercentChange = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblPercentChange", "change in") & ":", $x + 16, $y + 3, -1, -1)
$g_hTxtDBPercentChange = GUICtrlCreateInput("15", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentChange_Info_01", -1))
GUICtrlSetLimit(-1, 2)
$g_hLblDBPercentChangeSec = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 120, $y + 3, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkDBDisableCollectorsFilter = 0
Global $g_ahChkDBCollectorLevel[13] = [-1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahCmbDBCollectorLevel[13] = [-1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0]
Global $g_hCmbMinCollectorMatches = 0, $g_hSldCollectorTolerance = 0, $g_hLblCollectorWarning = 0
Func CreateAttackSearchDeadBaseCollectors()
Local $x = 10, $y = 45
Local $s_TxtTip1 = GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkCollectorLevel_Info_01", "If this box is checked, then the bot will look")
Local $g_hTxtFull = GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkCollectorLevel_Info_02", "Full")
Local $sTxtTip = ""
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "Group_01", "Collectors"), $x - 5, $y - 20, $g_iSizeWGrpTab4, $g_iSizeHGrpTab4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel", "Choose which collectors to search for while looking for a dead base. Also, choose how full they must be."), $x, $y, 250, 28)
$g_hChkDBDisableCollectorsFilter = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkDisableCollectorsFilter", "Disable Collector Filter"), $x + 250, $y + 60, 150, 18)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkDisableCollectorsFilter_Info_01", "Disable Collector Filter CHANGES DeadBase into another ActiveBase search"))
$y += 40
$g_ahChkDBCollectorLevel[6] = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$sTxtTip = $s_TxtTip1 & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkCollectorLevel6_Info_01", "for level 6 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
GUICtrlSetOnEvent(-1, "chkDBCollector")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel6", "Lvl 6. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahCmbDBCollectorLevel[6] = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel6_Info_01", 'Select how full a level 6 collector needs to be for it to be marked "dead"'))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetData(-1, "50%|100%", "50%")
GUICtrlSetOnEvent(-1, "cmbDBCollector")
GUICtrlCreateLabel($g_hTxtFull, $x + 205, $y + 3)
$y += 25
$g_ahChkDBCollectorLevel[7] = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$sTxtTip = $s_TxtTip1 & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkCollectorLevel7_Info_01", "for level 7 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBCollector")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel7", "Lvl 7. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahCmbDBCollectorLevel[7] = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel7_Info_01", 'Select how full a level 7 collector needs to be for it to be marked "dead"'))
GUICtrlSetData(-1, "50%|100%", "50%")
GUICtrlSetOnEvent(-1, "cmbDBCollector")
GUICtrlCreateLabel($g_hTxtFull, $x + 205, $y + 3)
$y += 25
$g_ahChkDBCollectorLevel[8] = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$sTxtTip = $s_TxtTip1 & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkCollectorLevel8_Info_01", "for level 8 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBCollector")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel8", "Lvl 8. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahCmbDBCollectorLevel[8] = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel8_Info_01", 'Select how full a level 8 collector needs to be for it to be marked "dead"'))
GUICtrlSetData(-1, "50%|100%", "50%")
GUICtrlSetOnEvent(-1, "cmbDBCollector")
GUICtrlCreateLabel($g_hTxtFull, $x + 205, $y + 3)
$y += 25
$g_ahChkDBCollectorLevel[9] = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$sTxtTip = $s_TxtTip1 & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkCollectorLevel9_Info_01", "for level 9 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBCollector")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel9", "Lvl 9. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahCmbDBCollectorLevel[9] = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel9_Info_01", 'Select how full a level 9 collector needs to be for it to be marked "dead"'))
GUICtrlSetData(-1, "50%|100%", "50%")
GUICtrlSetOnEvent(-1, "cmbDBCollector")
GUICtrlCreateLabel($g_hTxtFull, $x + 205, $y + 3)
$y += 25
$g_ahChkDBCollectorLevel[10] = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$sTxtTip = $s_TxtTip1 & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkCollectorLevel10_Info_01", "for level 10 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBCollector")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel10", "Lvl 10. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahCmbDBCollectorLevel[10] = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel10_Info_01", 'Select how full a level 10 collector needs to be for it to be marked "dead"'))
GUICtrlSetData(-1, "50%|100%", "50%")
GUICtrlSetOnEvent(-1, "cmbDBCollector")
GUICtrlCreateLabel($g_hTxtFull, $x + 205, $y + 3)
$y += 25
$g_ahChkDBCollectorLevel[11] = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$sTxtTip = $s_TxtTip1 & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkCollectorLevel11_Info_01", "for level 11 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBCollector")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel11", "Lvl 11. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahCmbDBCollectorLevel[11] = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel11_Info_01", 'Select how full a level 11 collector needs to be for it to be marked "dead"'))
GUICtrlSetData(-1, "50%|100%", "50%")
GUICtrlSetOnEvent(-1, "cmbDBCollector")
GUICtrlCreateLabel($g_hTxtFull, $x + 205, $y + 3)
$y += 25
$g_ahChkDBCollectorLevel[12] = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$sTxtTip = $s_TxtTip1 & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkCollectorLevel12_Info_01", "for level 12 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBCollector")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel12", "Lvl 12. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahCmbDBCollectorLevel[12] = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel12_Info_01", 'Select how full a level 12 collector needs to be for it to be marked "dead"'))
GUICtrlSetData(-1, "50%|100%", "50%")
GUICtrlSetOnEvent(-1, "cmbDBCollector")
GUICtrlCreateLabel($g_hTxtFull, $x + 205, $y + 3)
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblMinCollectorMatches", "Collectors required"), $x, $y + 3, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "CmbMinCollectorMatches_Info_01", 'Select how many collectors are needed to consider village "dead"')
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbMinCollectorMatches = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6", "3")
GUICtrlSetOnEvent(-1, "cmbMinCollectorMatches")
$y += 25
GUICtrlCreateLabel("-15" & _PadStringCenter(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorTolerance", "Tolerance"), 66, " ") & "15", $x, $y)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 15
$g_hSldCollectorTolerance = GUICtrlCreateSlider($x, $y, 250, 20, BITOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "SldCollectorTolerance_Info_01", "Use this slider to adjust the tolerance of ALL images.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "SldCollectorTolerance_Info_02", "If you want to adjust individual images, you must edit the files.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "SldCollectorTolerance_Info_03", "WARNING: Do not change this setting unless you know what you are doing. Set it to 0 if you're not sure."))
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-1, 1)
GUICtrlSetLimit(-1, 15, -15)
GUICtrlSetData(-1, 0)
GUICtrlSetOnEvent(-1, "sldCollectorTolerance")
GUICtrlSetState(-1, $GUI_HIDE)
$y += 25
$g_hLblCollectorWarning = GUICtrlCreateLabel("Warning: no collecters are selected. The bot will never find a dead base.", $x, $y, 255, 30)
GUICtrlSetFont(-1, 10, $FW_BOLD)
GUICtrlSetColor(-1, $COLOR_ERROR)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_DEADBASE_TAB = 0, $g_hGUI_DEADBASE_TAB_ITEM1 = 0, $g_hGUI_DEADBASE_TAB_ITEM2 = 0, $g_hGUI_DEADBASE_TAB_ITEM3 = 0, $g_hGUI_DEADBASE_TAB_ITEM4 = 0
Func CreateAttackSearchDeadBase()
$g_hGUI_DEADBASE = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_SEARCH)
CreateAttackSearchDeadBaseStandard()
CreateAttackSearchDeadBaseScripted()
CreateAttackSearchDeadBaseMilking()
GUISwitch($g_hGUI_DEADBASE)
$g_hGUI_DEADBASE_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_DEADBASE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_01", "Search"))
CreateAttackSearchDeadBaseSearch()
$g_hGUI_DEADBASE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_02", "Attack"))
CreateAttackSearchDeadBaseAttack()
$g_hGUI_DEADBASE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_03", "End Battle"))
CreateAttackSearchDeadBaseEndBattle()
$g_hGUI_DEADBASE_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_01_STab_01", "Collectors"))
CreateAttackSearchDeadBaseCollectors()
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_ACTIVEBASE = 0
Global $g_hGUI_ACTIVEBASE_ATTACK_STANDARD = 0
Global $g_hCmbStandardDropOrderAB = 0, $g_hCmbStandardDropSidesAB = 0, $g_hCmbStandardUnitDelayAB = 0, $g_hCmbStandardWaveDelayAB = 0, $g_hChkRandomSpeedAtkAB = 0, $g_hChkSmartAttackRedAreaAB = 0, $g_hCmbSmartDeployAB = 0, $g_hChkAttackNearGoldMineAB = 0, $g_hChkAttackNearElixirCollectorAB = 0, $g_hChkAttackNearDarkElixirDrillAB = 0
Global $g_hLblSmartDeployAB = 0, $g_hPicAttackNearDarkElixirDrillAB = 0
Global $g_hBtnCustomDropOrderAB = 0
Func CreateAttackSearchActiveBaseStandard()
$g_hGUI_ACTIVEBASE_ATTACK_STANDARD = _GUICreate("", $_GUI_MAIN_WIDTH - 195, $g_iSizeHGrpTab4, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_ACTIVEBASE)
Local $sTxtTip = ""
Local $x = 25, $y = 20
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Group_01", -1), $x - 20, $y - 20, 270, $g_iSizeHGrpTab4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Label_01", -1), $x, $y, 143, 18, $SS_LEFT)
$y += 15
$g_hCmbStandardDropOrderAB = GUICtrlCreateCombo("", $x, $y, 150, Default, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_02", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_03", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_01", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Info_03", -1))
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Label_02", "Attack on") & ":", $x, $y + 5, -1, -1)
$g_hCmbStandardDropSidesAB = GUICtrlCreateCombo("", $x + 55, $y, 120, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_03", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_05", "Attack on the single side closest to the Dark Elixir Storage") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_06", "Attack on the single side closest to the Townhall") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_04", -1))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_02", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_03", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_04", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_05", "DE Side Attack") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_06", "TH Side Attack"), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_04", -1))
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardUnitDelay", -1) & ":", $x, $y + 5, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardUnitDelay_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardUnitDelay_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbStandardUnitDelayAB = GUICtrlCreateCombo("", $x + 55, $y, 36, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardWaveDelay_Info_01", -1) & ":", $x + 100, $y + 5, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbStandardWaveDelayAB = GUICtrlCreateCombo("", $x + 140, $y, 36, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
$y += 22
$g_hChkRandomSpeedAtkAB = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkRandomSpeedAtk", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkRandomSpeedAtkAB")
$y +=22
$g_hChkSmartAttackRedAreaAB = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkSmartAttackRedArea", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkSmartAttackRedArea_Info_01", -1))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkSmartAttackRedAreaAB")
$y += 22
$g_hLblSmartDeployAB = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy", -1) & ":", $x, $y + 5, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy_Info_03", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbSmartDeployAB = GUICtrlCreateCombo("", $x + 55, $y, 120, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbSmartDeploy_Info_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbSmartDeploy_Info_02", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbSmartDeploy_Info_01", -1))
_GUICtrlSetTip(-1, $sTxtTip)
$y += 26
$g_hChkAttackNearGoldMineAB = GUICtrlCreateCheckbox("", $x + 20, $y, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkAttackNearGoldMine_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 40 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
$g_hChkAttackNearElixirCollectorAB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkAttackNearElixirCollector_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 55
$g_hChkAttackNearDarkElixirDrillAB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkAttackNearDarkElixirDrill_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicAttackNearDarkElixirDrillAB = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 20 , $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 40
$x = 98
$g_hBtnCustomDropOrderAB = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnCustomDropOrder", -1), $x, $y, 85, 25)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnCustomDropOrder_Info_01", -1))
GUICtrlSetOnEvent(-1, "CustomDropOrder")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED = 0
Global $g_hCmbScriptNameAB = 0, $g_hCmbScriptRedlineImplAB = 0, $g_hCmbScriptDroplineAB = 0
Global $g_hLblNotesScriptAB = 0 , $g_hbtnAttNow
Func CreateAttackSearchActiveBaseScripted()
$g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED = _GUICreate("", $_GUI_MAIN_WIDTH - 195, $g_iSizeHGrpTab4, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_ACTIVEBASE)
Local $x = 25, $y = 20
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "Group_01", -1), $x - 20, $y - 20, 270, $g_iSizeHGrpTab4)
$y += 15
$g_hCmbScriptNameAB = GUICtrlCreateCombo("", $x , $y, 200, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL, $WS_VSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptName", -1))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptNameAB")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnReload, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconReload_Info_01", -1))
GUICtrlSetOnEvent(-1, 'UpdateComboScriptNameAB')
$y += 25
$g_hLblNotesScriptAB = GUICtrlCreateLabel("", $x, $y + 5, 200, 180)
$g_hCmbScriptRedlineImplAB = GUICtrlCreateCombo("", $x, $y + 195, 230, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptRedlineImpl", "ImgLoc Raw Redline (default)|ImgLoc Redline Drop Points|Original Redline|External Edges"))
_GUICtrlComboBox_SetCurSel(-1, $g_aiAttackScrRedlineRoutine[$LB])
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptRedlineImpl_Info_01", "Choose the Redline implementation. ImgLoc Redline is default and best."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptRedlineImplAB")
$g_hCmbScriptDroplineAB = GUICtrlCreateCombo("", $x, $y + 220, 230, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptDropline", "Drop line fix outer corner|Drop line fist Redline point|Full Drop line fix outer corner|Full Drop line fist Redline point|No Drop line"))
_GUICtrlComboBox_SetCurSel(-1, $g_aiAttackScrDroplineEdge[$LB])
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptDropline_Info_01", "Choose the drop line edges. Default is outer corner and safer. First Redline point can improve attack."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptDroplineAB")
$g_hbtnAttNow = GUICtrlCreateButton("Attack Now", $x + 70, $y + 250, 91, 25)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "btnAttNow_Info_01", "Attack now Button Which it will make CSV Makers/testers life Easy. You should be in Attack Screen"))
GUICtrlSetOnEvent(-1, "AttackNow")
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnEdit, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconShow-Edit_Info_01", -1))
GUICtrlSetOnEvent(-1, "EditScriptAB")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnAddcvs, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconCreate_Info_01", -1))
GUICtrlSetOnEvent(-1, "NewScriptAB")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCopy, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconCopy_Info_01", -1))
GUICtrlSetOnEvent(-1, "DuplicateScriptAB")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrain, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconApply_Info_01", -1))
GUICtrlSetOnEvent(-1, "ApplyScriptAB")
GUICtrlCreateGroup("", -99, -99, 1, 1)
UpdateComboScriptNameAB()
Local $tempindex = _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameAB, $g_sAttackScrScriptName[$LB])
If $tempindex = -1 Then $tempindex = 0
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameAB, $tempindex)
EndFunc
Global $g_hChkABActivateSearches = 0, $g_hTxtABSearchesMin = 0, $g_hTxtABSearchesMax = 0
Global $g_hChkABActivateTropies = 0, $g_hTxtABTropiesMin = 0, $g_hTxtABTropiesMax = 0
Global $g_hChkABActivateCamps = 0, $g_hTxtABArmyCamps = 0
Global $g_hChkABKingWait = 0, $g_hChkABQueenWait = 0, $g_hChkABWardenWait = 0, $g_hChkABNotWaitHeroes = 0
Global $g_hChkABSpellsWait = 0, $g_hChkABWaitForCastleSpell = 0, $g_hCmbABWaitForCastleSpell = 0,$g_hCmbABWaitForCastleSpell2 = 0, $g_hTxtABWaitForCastleSpell = 0, $g_hChkABWaitForCastleTroops = 0
Global $g_hLblABSearches = 0, $g_hLblABTropies = 0, $g_hLblABArmyCamps = 0
Global $g_hPicABHeroesWait = 0, $g_hTxtABHeroesWait = 0, $g_hPicABKingWait = 0, $g_hPicABKingSleepWait = 0, $g_hPicABQueenWait = 0, $g_hPicABQueenSleepWait = 0, $g_hPicABWardenWait = 0, $g_hPicABWardenSleepWait = 0
Global $g_hPicABLightSpellWait = 0, $g_hPicABHealSpellWait = 0, $g_hPicABRageSpellWait = 0, $g_hPicABJumpSpellWait = 0, $g_hPicABFreezeSpellWait = 0, $g_hPicABPoisonSpellWait = 0, $g_hPicABEarthquakeSpellWait = 0, $g_hPicABHasteSpellWait = 0
Global $g_hCmbABMeetGE = 0, $g_hTxtABMinGold = 0, $g_hTxtABMinElixir = 0, $g_hTxtABMinGoldPlusElixir = 0
Global $g_hChkABMeetDE = 0, $g_hTxtABMinDarkElixir = 0
Global $g_hChkABMeetTrophy = 0, $g_hTxtABMinTrophy = 0, $g_hTxtABMaxTrophy = 0
Global $g_hChkABMeetTH = 0, $g_hCmbABTH = 0, $g_hChkABMeetTHO = 0
Global $g_hGrpABFilter = 0, $g_hPicABMinGold = 0, $g_hPicABMinElixir = 0, $g_hPicABMinGPEGold = 0, $g_hPicABMinDarkElixir = 0, $g_hPicABMinTrophies = 0
Global $g_ahPicABMaxTH[13]
Func CreateAttackSearchActiveBaseSearch()
Local $sTxtLightningSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortLightningSpells", -1)
Local $sTxtHealSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHealSpells", -1)
Local $sTxtRageSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortRageSpells", -1)
Local $sTxtJumpSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortJumpSpells", -1)
Local $sTxtFreezeSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortFreezeSpells", -1)
Local $sTxtPoisonSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortPoisonSpells", -1)
Local $sTxtEarthquakeSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortEarthquakeSpells", -1)
Local $sTxtHasteSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHasteSpells", -1)
Local $sTxtSkeletonSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortSkeletonSpells", -1)
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_01", -1), $x - 20, $y - 20, 190, $g_iSizeHGrpTab4)
$x -= 15
$g_hChkABActivateSearches = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches", -1), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", -1))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkABActivateSearches")
$g_hTxtABSearchesMin = GUICtrlCreateInput("1", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMinSearches_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", -1))
GUICtrlSetLimit(-1, 6)
$g_hLblABSearches = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
$g_hTxtABSearchesMax = GUICtrlCreateInput("9999", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMaxSearches_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTrophy_Info_01", -1))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMagnifier, $x + 163, $y + 1, 16, 16)
$y += 21
$g_hChkABActivateTropies = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies", -1), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetOnEvent(-1, "chkABActivateTropies")
$g_hTxtABTropiesMin = GUICtrlCreateInput("0", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMinTropies_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetLimit(-1, 6)
$g_hLblABTropies = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtABTropiesMax = GUICtrlCreateInput("6000", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMaxTropies_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 163, $y + 1, 16, 16)
$y += 21
$g_hChkABActivateCamps = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateCamps", -1), $x, $y, 110, 18)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateCamps_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkABActivateCamps")
$g_hLblABArmyCamps = GUICtrlCreateLabel(ChrW(8805), $x + 113 - 1, $y + 2, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtABArmyCamps = GUICtrlCreateInput("100", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
GUICtrlCreateLabel("%", $x + 163 + 3, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 23
$g_hPicABHeroesWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x - 1, $y + 3, 16, 16)
$g_hTxtABHeroesWait = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtHeroesWait", -1) & ":", $x + 20, $y + 4, 180, 18)
$y += 20
$x += 20
$g_hChkABKingWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
Local $sTxtKingWait = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtHeroesWait_Info_01", -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtKingWait_Info_01", -1) & @CRLF & $sTxtKingWait & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtKingWait_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkABKingWait")
$g_hPicABKingWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicABKingSleepWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$x += 55
$g_hChkABQueenWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtQueenWait_Info_01", -1) & @CRLF & $sTxtKingWait & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtQueenWait_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkABQueenWait")
$g_hPicABQueenWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicABQueenSleepWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$x += 55
$g_hChkABWardenWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtWardenWait_Info_01", -1) & @CRLF & $sTxtKingWait & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtWardenWait_Info_02", -1)
GUICtrlSetOnEvent(-1, "chkABWardenWait")
$g_hPicABWardenWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicABWardenSleepWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 75
$x = 10
$g_hChkABNotWaitHeroes = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkNotWaitHeroes", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkNotWaitHeroes_Info_01", -1))
GUICtrlSetOnEvent(-1, "chkNotWaitHeroes")
$y += 25
$x = 8
$g_hPicABLightSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y, 22, 22)
$g_hPicABHealSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x + 23, $y, 22, 22)
$g_hPicABRageSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x + 46, $y, 22, 22)
$g_hPicABJumpSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x + 69, $y, 22, 22)
$g_hPicABFreezeSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x + 92, $y, 22, 22)
$g_hPicABPoisonSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x + 115, $y, 22, 22)
$g_hPicABEarthquakeSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell, $x + 138, $y, 22, 22)
$g_hPicABHasteSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x + 161, $y, 22, 22)
$y += 22
$x = 10
$g_hChkABSpellsWait = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkSpellsWait", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkSpellsWait_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkSpellsWait_Info_02", -1))
GUICtrlSetOnEvent(-1, "chkABSpellsWait")
$g_hChkABWaitForCastleSpell = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastleSpell", -1), $x, $y + 25, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastleSpell_Info_01", -1))
GUICtrlSetOnEvent(-1, "chkABWaitForCCSpell")
$g_hCmbABWaitForCastleSpell = GUICtrlCreateCombo(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbWaitForCastleSpell", -1), $x, $y + 50, 70, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtLightningSpells & "|" & $sTxtHealSpells & "|" & $sTxtRageSpells & "|" & $sTxtJumpSpells & "|" & $sTxtFreezeSpells & "|" & $sTxtPoisonSpells & "|" & $sTxtEarthquakeSpells & "|" & $sTxtHasteSpells & "|" & $sTxtSkeletonSpells)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastleSpell_Info_01", -1))
GUICtrlSetOnEvent(-1, "cmbABWaitForCCSpell")
$g_hTxtABWaitForCastleSpell = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtWaitForCastleSpell", "And"), $x + 80, $y + 53, -1, -1)
$g_hCmbABWaitForCastleSpell2 = GUICtrlCreateCombo(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbWaitForCastleSpell", -1), $x + 110, $y + 50, 70, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtPoisonSpells & "|" & $sTxtEarthquakeSpells & "|" & $sTxtHasteSpells & "|" & $sTxtSkeletonSpells)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastleSpell_Info_01", -1))
$g_hChkABWaitForCastleTroops = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastleTroops", -1), $x, $y + 75, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastleTroops_Info_01", -1))
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 220, $y = 45
$g_hGrpABFilter = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_02", -1), $x - 20, $y - 20, 225, $g_iSizeHGrpTab4)
$x -= 15
$g_hCmbABMeetGE = GUICtrlCreateCombo("", $x, $y + 10, 65, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_02", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_03", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_01", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_03", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_04", -1))
GUICtrlSetOnEvent(-1, "cmbABGoldElixir")
$g_hTxtABMinGold = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinGold_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicABMinGold = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtABMinElixir = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinElixir_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicABMinElixir = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y -= 11
$g_hTxtABMinGoldPlusElixir = GUICtrlCreateInput("160000", $x + 85, $y, 50, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinGoldPlusElixir_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicABMinGPEGold = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldElixir, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 34
$g_hChkABMeetDE = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetDE", -1), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkABMeetDE")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetDE_Info_01", -1))
$g_hTxtABMinDarkElixir = GUICtrlCreateInput("0", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinDarkElixir_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlEdit_SetReadOnly(-1, True)
$g_hPicABMinDarkElixir = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hChkABMeetTrophy = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies", -1), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkABMeetTrophy")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTrophy_Info_01", -1))
$g_hTxtABMinTrophy = GUICtrlCreateInput("0", $x + 85, $y, 20, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTrophy_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlEdit_SetReadOnly(-1, True)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel("-", $x + 109, $y + 2, -1, -1)
$g_hTxtABMaxTrophy = GUICtrlCreateInput("0", $x + 115, $y, 20, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTrophy_Info_03", -1)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlEdit_SetReadOnly(-1, True)
GUICtrlSetLimit(-1, 2)
$g_hPicABMinTrophies = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hChkABMeetTH = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR Global GUI Design", "LblTownhall", -1), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkABMeetTH")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTH_Info_01", -1))
$g_hCmbABTH = GUICtrlCreateCombo("", $x + 85, $y - 1, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbDBTH", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetData(-1, "4-6|7|8|9|10|11|12", "4-6")
GUICtrlSetOnEvent(-1, "CmbABTH")
$g_ahPicABMaxTH[6] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV06, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_SHOW)
$g_ahPicABMaxTH[7] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV07, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicABMaxTH[8] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV08, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicABMaxTH[9] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV09, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicABMaxTH[10] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV10, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicABMaxTH[11] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV11, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahPicABMaxTH[12] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV12, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 24
$g_hChkABMeetTHO = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTHO", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTHO_Info_01", -1))
$y += 24
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_03", -1), $x, $y, 215, 100)
$x += 5
$y += 20
Local $xStartColumn = $x, $yStartColumn = $y
$g_ahChkMaxMortar[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxMortar", -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakMortar[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 52, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxMortar_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9|Lvl 10|Lvl 11", "Lvl 5")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakMortar[$LB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnMortar, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxWizTower[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxWizTower", -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakWizTower[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 52, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxWizTower_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9|Lvl 10|Lvl 11", "Lvl 4")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakWizTower[$LB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWizTower, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxAirDefense[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxAirDefense", -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakAirDefense[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 53, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxAirDefense_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9|Lvl 10", "Lvl 7")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakAirDefense[$LB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnAirdefense, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x = $xStartColumn + 104
$y = $yStartColumn
$g_ahChkMaxXBow[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxXBow", -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakXBow[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxXBow_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakXBow[$LB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnXBow3, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxInferno[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxInferno", -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakInferno[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxInferno_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakInferno[$LB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnInferno4, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxEagle[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxEagle", -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakEagle[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxEagle_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3", "Lvl 1")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakEagle[$LB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEagleArt, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 44
$x = $xStartColumn
$g_ahChkMeetOne[$LB] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetOne", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetOne_Info_01", -1))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hCmbABAlgorithm = 0, $g_hCmbABSelectTroop = 0, $g_hChkABKingAttack = 0, $g_hChkABQueenAttack = 0, $g_hChkABWardenAttack = 0, $g_hChkABDropCC = 0
Global $g_hChkABLightSpell = 0, $g_hChkABHealSpell = 0, $g_hChkABRageSpell = 0, $g_hChkABJumpSpell = 0, $g_hChkABFreezeSpell = 0, $g_hChkABCloneSpell = 0, $g_hChkABPoisonSpell = 0, $g_hChkABEarthquakeSpell = 0, $g_hChkABHasteSpell = 0, $g_hChkABSkeletonSpell = 0
Global $g_hGrpABAttack = 0, $g_hPicABKingAttack = 0, $g_hPicABQueenAttack = 0, $g_hPicABWardenAttack = 0, $g_hPicABDropCC = 0
Global $g_hPicABLightSpell = 0, $g_hPicABHealSpell = 0, $g_hPicABRageSpell = 0, $g_hPicABJumpSpell = 0, $g_hPicABFreezeSpell = 0, $g_hPicABCloneSpell = 0, $g_hPicABPoisonSpell = 0, $g_hPicABEarthquakeSpell = 0, $g_hPicABHasteSpell = 0, $g_hPicABSkeletonSpell = 0
Global $g_hChkTHSnipeBeforeLBEnable = 0, $g_hTxtTHSnipeBeforeLBTiles = 0, $g_hCmbTHSnipeBeforeLBScript = 0
Global $g_hLblTHSnipeBeforeLBTiles = 0
Func CreateAttackSearchActiveBaseAttack()
Local $sTxtTip = ""
Local $x = 25, $y = 40
$g_hGrpABAttack = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Group_01", -1), $x - 20, $y - 15, 145, 223)
$x -= 15
$y += 5
$g_hCmbABAlgorithm = GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, "")
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_02", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_01", -1))
GUICtrlSetOnEvent(-1, "cmbABAlgorithm")
$y += 30
$g_hCmbABSelectTroop = GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_02", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_03", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_04", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_05", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_06", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_07", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_08", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_09", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_10", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_11", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_01", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Info_01", -1))
$y += 30
$g_hPicABKingAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x , $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-King_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-King_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABKingAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABQueenAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Queen_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Queen_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABQueenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABWardenAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Warden_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Warden_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABWardenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicABDropCC = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnCC, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Clan Castle_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABDropCC = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABLightSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Light_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABLightSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABHealSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Healing_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABHealSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicABRageSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Rage_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABRageSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABJumpSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Jump_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABJumpSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABFreezeSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Freeze_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABFreezeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicABCloneSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnCloneSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Clone_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABCloneSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABPoisonSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Poison_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABPoisonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABEarthquakeSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Earthquake_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABEarthquakeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicABHasteSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Haste_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABHasteSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABSkeletonSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSkeletonSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Skeleton_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABSkeletonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 10, $y = 268
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Group_02", -1), $x - 5, $y - 20, 145, 84,$SS_CENTER)
$g_hChkTHSnipeBeforeLBEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkTHSnipeBeforeEnable", -1), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkTHSnipeBeforeEnable_Info_01", -1))
GUICtrlSetOnEvent(-1, "chkTHSnipeBeforeLBEnable")
$y += 16
$g_hLblTHSnipeBeforeLBTiles = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "LblTHSnipeBeforeTiles", -1) & ":", $x, $y + 3, 70, -1, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtTHSnipeBeforeLBTiles = GUICtrlCreateInput("2", $x + 75, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "LblTHSnipeBeforeTiles_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTiles, $x + 107, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hCmbTHSnipeBeforeLBScript = GUICtrlCreateCombo("", $x, $y, 130, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "CmbTHSnipeBeforeScript_Info_01", -1))
GUICtrlSetState(-1, $GUI_DISABLE)
LoadABSnipeAttacks()
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeLBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeLBScript, "Bam"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkStopAtkABNoLoot1 = 0, $g_hTxtStopAtkABNoLoot1 = 0, $g_hChkStopAtkABNoLoot2 = 0, $g_hTxtStopAtkABNoLoot2 = 0, $g_hTxtABMinGoldStopAtk2 = 0, $g_hTxtABMinElixirStopAtk2 = 0, $g_hTxtABMinDarkElixirStopAtk2 = 0, $g_hChkABEndNoResources = 0, $g_hChkABEndOneStar = 0, $g_hChkABEndTwoStars = 0, $g_hChkABEndPercentHigher = 0, $g_hTxtABPercentHigher = 0, $g_hChkABEndPercentChange = 0, $g_hTxtABPercentChange = 0
Global $g_hChkDESideEB = 0, $g_hTxtDELowEndMin = 0, $g_hChkDisableOtherEBO = 0, $g_hChkDEEndOneStar = 0, $g_hChkDEEndBk = 0, $g_hChkDEEndAq = 0
Global $g_hGrpABEndBattle = 0, $g_hLblABTimeStopAtka = 0, $g_hLblABTimeStopAtk = 0, $g_hLblABTimeStopAtk2a = 0, $g_hLblABTimeStopAtk2 = 0, $g_hLblABMinRerourcesAtk2 = 0, $g_hPicABMinGoldStopAtk2 = 0, $g_hPicABMinElixirStopAtk2 = 0, $g_hPicABMinDarkElixirStopAtk2 = 0
Global $g_hLblDELowEndMin = 0, $g_hLblDEEndAq = 0, $g_hLblABPercentHigher = 0, $g_hLblABPercentHigherSec = 0, $g_hLblABPercentChange = 0, $g_hLblABPercentChangeSec = 0
Func CreateAttackSearchActiveBaseEndBattle()
Local $sTxtTip = ""
Local $x = 10, $y = 45
$g_hGrpABEndBattle = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "Group_01", -1), $x - 5, $y - 20, 155, $g_iSizeHGrpTab4)
$y -=5
$g_hChkStopAtkABNoLoot1 = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot", -1), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkStopAtkABNoLoot1")
GUICtrlSetState(-1, $GUI_CHECKED)
$y +=20
$g_hLblABTimeStopAtka = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblStopAtkNoLoot", -1) & ":", $x + 16, $y + 3, -1, -1)
$g_hTxtStopAtkABNoLoot1 = GUICtrlCreateInput("20", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
$g_hLblABTimeStopAtk = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 120, $y + 3, -1, -1)
$y += 20
$g_hChkStopAtkABNoLoot2 = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot", -1), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkStopAtkABNoLoot2")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 20
$g_hLblABTimeStopAtk2a = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblStopAtkNoLoot", -1) & ":", $x + 16, $y + 3, -1, -1)
$g_hTxtStopAtkABNoLoot2 = GUICtrlCreateInput("5", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblABTimeStopAtk2 = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 120, $y + 3, -1, -1)
$y += 21
$g_hLblABMinRerourcesAtk2 = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblMinRerourcesAtk2", -1) & ":", $x + 16, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblMinRerourcesAtk2_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 21
$g_hTxtABMinGoldStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicABMinGoldStopAtk2 = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtABMinElixirStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicABMinElixirStopAtk2 = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtABMinDarkElixirStopAtk2 = GUICtrlCreateInput("50", $x + 65, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 4)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicABMinDarkElixirStopAtk2 = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hChkABEndNoResources = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndNoResources", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndNoResources_Info_01", -1))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkABEndOneStar = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndOneStar", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndOneStar_Info_01", -1))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkABEndTwoStars = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndTwoStars", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndTwoStars_Info_01", -1))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkABEndPercentHigher = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentHigher", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentHigher_Info_01", -1))
GUICtrlSetOnEvent(-1, "chkABEndPercentHigher")
GUICtrlSetState(-1, $GUI_ENABLE)
$y +=20
$g_hLblABPercentHigher = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblPercentHigher", -1) & ":", $x + 16, $y + 2, -1, -1)
$g_hTxtABPercentHigher = GUICtrlCreateInput("60", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentHigher_Info_01", -1))
GUICtrlSetLimit(-1, 2)
$g_hLblABPercentHigherSec = GUICtrlCreateLabel("%", $x + 120, $y + 3, -1, -1)
$y += 21
$g_hChkABEndPercentChange = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentChange", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentChange_Info_01", -1))
GUICtrlSetOnEvent(-1, "chkABEndPercentChange")
GUICtrlSetState(-1, $GUI_ENABLE)
$y +=20
$g_hLblABPercentChange = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblPercentChange", -1) & ":", $x + 16, $y + 3, -1, -1)
$g_hTxtABPercentChange = GUICtrlCreateInput("15", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentChange_Info_01", -1))
GUICtrlSetLimit(-1, 2)
$g_hLblABPercentChangeSec = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 120, $y + 3, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 185, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "Group_02", "DE side End Battle options"), $x - 20, $y - 20, 259, $g_iSizeHGrpTab4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LabelDE_01", "Attack Dark Elixir Side, End Battle Options") & ":", $x - 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LabelDE_Info_01", "Enabled by selecting DE side attack in ActiveBase Deploy - Attack On: options"))
$y += 15
$x -= 10
$g_hChkDESideEB = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDESideEB", "When below") & ":", $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDESideEB_Info_01", "Enables Special conditions for Dark Elixir side attack.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDESideEB_Info_02", "If no additional filters are selected will end battle when below Total Dark Elixir Percent.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDESideEB")
$g_hTxtDELowEndMin = GUICtrlCreateInput("25", $x + 92, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDELowEndMin = GUICtrlCreateLabel("%", $x + 136, $y + 2, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 147, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
$g_hChkDisableOtherEBO = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDisableOtherEBO", "Disable Normal End Battle Options"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDisableOtherEBO_Info_01", "Disable Normal End Battle Options when DE side attack is found."))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$g_hChkDEEndOneStar = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndOneStar", -1) & ":", $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndOneStar_Info_02", "Will End the Battle when below min DE and One Star is won.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSilverStar, $x + 135, $y + 2, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
$g_hChkDEEndBk = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDEEnd", "When"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDEEnd_Info_01", "Will End the Battle when below min DE and King is weak")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x + 50, $y + 2, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblDEEnd", "is weak"), $x + 70, $y + 4, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
$g_hChkDEEndAq = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDEEnd", -1), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDEEnd_Info_02", "Will End the Battle when below min DE and Queen is weak")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x + 50, $y + 2, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblDEEndAq = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblDEEnd", -1), $x + 70, $y + 4, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_ACTIVEBASE_TAB = 0, $g_hGUI_ACTIVEBASE_TAB_ITEM1 = 0, $g_hGUI_ACTIVEBASE_TAB_ITEM2 = 0, $g_hGUI_ACTIVEBASE_TAB_ITEM3 = 0
Func CreateAttackSearchActiveBase()
$g_hGUI_ACTIVEBASE = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_SEARCH)
CreateAttackSearchActiveBaseStandard()
CreateAttackSearchActiveBaseScripted()
GUISwitch($g_hGUI_ACTIVEBASE)
$g_hGUI_ACTIVEBASE_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_ACTIVEBASE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_01", -1))
CreateAttackSearchActiveBaseSearch()
$g_hGUI_ACTIVEBASE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_02", -1))
CreateAttackSearchActiveBaseAttack()
$g_hGUI_ACTIVEBASE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_03", -1))
CreateAttackSearchActiveBaseEndBattle()
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_THSNIPE = 0
Global $g_hChkTSActivateSearches = 0, $g_hTxtTSSearchesMin = 0, $g_hTxtTSSearchesMax = 0, $g_hChkTSActivateTropies = 0, $g_hTxtTSTropiesMin = 0, $g_hTxtTSTropiesMax = 0, $g_hChkTSActivateCamps = 0, $g_hTxtTSArmyCamps = 0
Global $g_hLblTSSearches = 0, $g_hLblTSTropies = 0, $g_hLblTSArmyCamps = 0
Global $g_hCmbTSMeetGE = 0, $g_hTxtTSMinGold = 0, $g_hTxtTSMinElixir = 0, $g_hTxtTSMinGoldPlusElixir = 0
Global $g_hChkTSMeetDE = 0, $g_hTxtTSMinDarkElixir = 0
Global $g_hTxtSWTTiles = 0, $g_hTxtTHaddTiles = 0
Global $g_hGrpTSFilter = 0, $g_hPicTSMinGold = 0, $g_hPicTSMinElixir = 0, $g_hPicTSMinGPEGold = 0, $g_hPicTSMinDarkElixir = 0
Global $g_hLblAddTiles = 0, $g_hLblAddTiles2 = 0, $g_hLblSWTTiles = 0, $g_hLblTHadd = 0
Func CreateAttackSearchTHSnipeSearch()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_01", -1), $x - 20, $y - 20, 190, $g_iSizeHGrpTab4)
$x -= 15
$g_hChkTSActivateSearches = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches", -1), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", -1))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkTSActivateSearches")
$g_hTxtTSSearchesMin = GUICtrlCreateInput("1", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMinSearches_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", -1))
GUICtrlSetLimit(-1, 6)
$g_hLblTSSearches = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
$g_hTxtTSSearchesMax = GUICtrlCreateInput("9999", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMaxSearches_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", -1))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMagnifier, $x + 163, $y + 1, 16, 16)
$y += 21
$g_hChkTSActivateTropies = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies", -1), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetOnEvent(-1, "chkTSActivateTropies")
$g_hTxtTSTropiesMin = GUICtrlCreateInput("0", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMinTropies_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetLimit(-1, 6)
$g_hLblTSTropies = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtTSTropiesMax = GUICtrlCreateInput("6000", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMaxTropies_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 163, $y + 1, 16, 16)
$y += 21
$g_hChkTSActivateCamps = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateCamps", -1), $x, $y, 110, 18)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateCamps_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkTSActivateCamps")
$g_hLblTSArmyCamps = GUICtrlCreateLabel(ChrW(8805), $x + 113 - 1, $y + 2, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtTSArmyCamps = GUICtrlCreateInput("50", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
GUICtrlCreateLabel("%", $x + 163 + 3, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 220, $y = 45
$g_hGrpTSFilter = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_02", -1), $x - 20, $y - 20, 225, $g_iSizeHGrpTab4)
$x -= 15
$g_hCmbTSMeetGE = GUICtrlCreateCombo("", $x, $y + 10, 65, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_03", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_04", -1)
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_02", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_03", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_01", -1))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "cmbTSGoldElixir")
$g_hTxtTSMinGold = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinGold_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicTSMinGold = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtTSMinElixir = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinElixir_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicTSMinElixir = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y -= 11
$g_hTxtTSMinGoldPlusElixir = GUICtrlCreateInput("160000", $x + 85, $y, 50, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinGoldPlusElixir_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicTSMinGPEGold = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldElixir, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 34
$g_hChkTSMeetDE = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetDE", -1), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetDE_Info_01", -1)
GUICtrlSetOnEvent(-1, "chkTSMeetDE")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtTSMinDarkElixir = GUICtrlCreateInput("600", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinDarkElixir_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlEdit_SetReadOnly(-1, True)
$g_hPicTSMinDarkElixir = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$y += 35
$g_hLblAddTiles = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblAddTiles_01", "TownHall, Distance From"), $x, $y + 4, -1, -1, $SS_LEFT)
$y += 16
$g_hLblAddTiles2 = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblAddTiles_02", "Border, Add Tiles") & ":", $x + 5, $y + 4, -1, -1, $SS_LEFT)
$y += 21
$g_hLblSWTTiles = GUICtrlCreateLabel("- " & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblSWTTiles", "While Train"), $x, $y + 4, 100, -1, $SS_LEFT)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblSWTTiles_Info_01", "Add number of tiles from Base Edges")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSWTTiles = GUICtrlCreateInput("2", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTiles, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hLblTHadd = GUICtrlCreateLabel("- " & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "LblFullTroop", -1), $x, $y + 4, -1, 17, $SS_LEFT)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblTHadd_Info_01", "Enter how many 'Grass' 1x1 tiles the TH may be from the Base edges to be seen as a TH Outside.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblTHadd_Info_02", "Ex: (0) tiles; TH must be exactly at the edge. (4) tiles: TH may be 4 tiles farther from edges and closer to the center of the village.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblTHadd_Info_03", "If the TH is farther away then the No. of tiles set, the base will be skipped.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtTHaddTiles = GUICtrlCreateInput("2", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTiles, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hCmbAttackTHType = 0, $g_hCmbTSSelectTroop = 0, $g_hChkTSKingAttack = 0, $g_hChkTSQueenAttack = 0, $g_hChkTSWardenAttack = 0, $g_hChkTSDropCC = 0
Global $g_hChkTSLightSpell = 0, $g_hChkTSHealSpell = 0, $g_hChkTSRageSpell = 0, $g_hChkTSJumpSpell = 0, $g_hChkTSFreezeSpell = 0,$g_hChkTSPoisonSpell = 0, $g_hChkTSEarthquakeSpell = 0, $g_hChkTSHasteSpell = 0
Global $g_hLblAttackTHType = 0, $g_hLblTSSelectTroop = 0, $g_hLblTSSelectSpecialTroop = 0, $g_hPicTSKingAttack = 0, $g_hPicTSQueenAttack = 0, $g_hPicTSWardenAttack = 0, $g_hPicTSDropCC = 0
Global $g_hPicTSLightSpell = 0, $g_hPicTSHealSpell = 0, $g_hPicTSRageSpell = 0, $g_hPicTSJumpSpell = 0, $g_hPicTSFreezeSpell = 0, $g_hPicTSPoisonSpell = 0, $g_hPicTSEarthquakeSpell = 0, $g_hPicTSHasteSpell = 0
Func CreateAttackSearchTHSnipeAttack()
Local $sTxtTip
Local $x = 25, $y = 40
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Group_01", -1), $x - 20, $y - 15, $g_iSizeWGrpTab4, $g_iSizeHGrpTab4)
$x -= 15
$g_hLblAttackTHType = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "LblAttackType", "Attack Type") & ":", $x, $y, 135, 18, $SS_LEFT)
$y += 15
$g_hCmbAttackTHType = GUICtrlCreateCombo("", $x, $y, 128, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "CmbTHSnipeBeforeScript_Info_01", -1))
GUICtrlSetOnEvent(-1, "cmbAttackTHType")
LoadThSnipeAttacks()
$y += 25
$g_hLblTSSelectTroop = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "LblSelectTroop", "Only drop these troops") & ":", $x, $y, 135, 18,$SS_LEFT)
$y += 15
$g_hCmbTSSelectTroop = GUICtrlCreateCombo("", $x, $y, 128, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_02", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_03", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_04", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_05", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_06", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_07", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_08", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_09", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_10", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_11", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_01", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Info_01", -1))
$y += 25
$g_hLblTSSelectSpecialTroop = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "LblSelectSpecialTroop", "Special troops to use") & ":", $x, $y, 135, 18, $SS_LEFT)
$y += 18
$g_hPicTSKingAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-King_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSKingAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSQueenAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Queen_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSQueenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSWardenAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Warden_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSWardenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicTSDropCC = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnCC, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Clan Castle_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSDropCC = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSLightSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Light_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSLightSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSHealSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Healing_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSHealSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicTSRageSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Rage_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSRageSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSJumpSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Jump_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSJumpSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSFreezeSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Freeze_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSFreezeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicTSPoisonSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Poison_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSPoisonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSEarthquakeSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Earthquake_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSEarthquakeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSHasteSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Haste_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSHasteSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkTSActivateCamps2 = 0, $g_hTxtTSArmyCamps2 = 0
Global $g_hGrpTSEndBattle = 0, $g_hLblTSArmyCamps2 = 0
Func CreateAttackSearchTHSnipeEndBattle()
Local $x = 10, $y = 45
$g_hGrpTSEndBattle = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "Group_01", -1), $x - 5, $y - 20, $g_iSizeWGrpTab4, $g_iSizeHGrpTab4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblSwitch_DB_Attack_at_END", "Switch DB Attack at END") & ":", $x, $y, 143, 18, $SS_LEFT)
$y += 15
$g_hChkTSActivateCamps2 = GUICtrlCreateCheckbox("", $x + 2, $y + 3, 16, 16)
GUICtrlSetOnEvent(-1, "chkTSActivateCamps2")
$g_hLblTSArmyCamps2 = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "LblCamps", "Camps") & " >=", $x + 20, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtTSArmyCamps2 = GUICtrlCreateInput("50", $x + 75, $y, 35, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "TxtArmyCamps2_Info_01", "Set the % Army camps before activate this option"))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateLabel("%", $x + 115, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 26
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_THSNIPE_TAB = 0, $g_hGUI_THSNIPE_TAB_ITEM1 = 0, $g_hGUI_THSNIPE_TAB_ITEM2 = 0, $g_hGUI_THSNIPE_TAB_ITEM3 = 0
Func CreateAttackSearchTHSnipe()
$g_hGUI_THSNIPE = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_SEARCH)
GUISwitch($g_hGUI_THSNIPE)
$g_hGUI_THSNIPE_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_THSNIPE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_01", -1))
CreateAttackSearchTHSnipeSearch()
$g_hGUI_THSNIPE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_02", -1))
CreateAttackSearchTHSnipeAttack()
$g_hGUI_THSNIPE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_03", -1))
CreateAttackSearchTHSnipeEndBattle()
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_BULLY = 0
Global $g_hTxtATBullyMode = 0, $g_hCmbBullyMaxTH = 0, $g_hRadBullyUseDBAttack = 0, $g_hRadBullyUseLBAttack = 0
Global $g_hGrpBullyAtkCombo = 0, $g_hLblBullyMode = 0, $g_hLblATBullyMode = 0
Global $g_ahPicBullyMaxTH[13]
Func CreateAttackSearchBully()
$g_hGUI_BULLY = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_SEARCH)
GUISwitch($g_hGUI_BULLY)
Local $sTxtTip = ""
Local $x = 20, $y = 130 - 105
$g_hGrpBullyAtkCombo = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "Group_01", "Bully Attack Combo"), $x - 20, $y - 20, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3 - 6)
$y -= 5
$x -= 10
$g_hLblBullyMode = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "LblBullyMode", "In Bully Mode, ALL bases that meet the TH level requirement below will be attacked."), $x - 5, $y + 3, 209, 30, $SS_LEFT)
$y += 35
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "LblSearch", "Enable Bully after"), $x, $y + 3)
$g_hTxtATBullyMode = GUICtrlCreateInput("150", $x + 95, $y, 35, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 3)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "LblSearch_Info_01", "TH Bully: No. of searches to wait before activating."))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "search(es).", "search(es)."), $x + 135, $y + 5, -1, -1)
$y += 25
$g_hLblATBullyMode = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "LblATBullyMode", "Max TH level") & ":", $x - 5, $y + 3, 90, -1, $SS_RIGHT)
$g_hCmbBullyMaxTH = GUICtrlCreateCombo("", $x + 85, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "CmbBullyMaxTH_Info_01", "TH Bully: Max. Townhall level to bully.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "4-6|7|8|9|10|11|12", "4-6")
GUICtrlSetOnEvent(-1, "CmbBullyMaxTH")
$g_ahPicBullyMaxTH[6] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV06, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_SHOW)
$g_ahPicBullyMaxTH[7] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV07, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicBullyMaxTH[8] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV08, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicBullyMaxTH[9] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV09, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicBullyMaxTH[10] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV10, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicBullyMaxTH[11] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV11, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahPicBullyMaxTH[12] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV12, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 24
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "LblWhenFound", "When found, Attack with settings from") & ":", $x + 10, $y, -1, -1, $SS_RIGHT)
$y += 14
$g_hRadBullyUseDBAttack = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "RadBullyUseDBAttack", "DeadBase Atk."), $x + 20, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "RadBullyUseDBAttack_Info_01", "Use Dead Base attack settings when attacking a TH Bully match."))
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hRadBullyUseLBAttack = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "RadBullyUseLBAttack", "Active Base Atk."), $x + 115, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "RadBullyUseLBAttack_Info_01", "Use Active Base attack settings when attacking a TH Bully match."))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_ATTACKOPTION = 0
Global $g_hChkSearchReduction = 0, $g_hTxtSearchReduceCount = 0, $g_hTxtSearchReduceGold = 0, $g_hTxtSearchReduceElixir = 0, $g_hTxtSearchReduceGoldPlusElixir = 0, $g_hTxtSearchReduceDark = 0, $g_hTxtSearchReduceTrophy = 0
Global $g_hSldVSDelay = 0, $g_hSldMaxVSDelay = 0
Global $g_hChkAttackNow = 0, $g_hCmbAttackNowDelay = 0, $g_hChkRestartSearchLimit = 0, $g_hTxtRestartSearchlimit = 0, $g_hChkAlertSearch = 0
Global $g_hLblVSDelay = 0, $g_hLblTextVSDelay = 0, $g_hLblMaxVSDelay = 0, $g_hLblTextMaxVSDelay = 0, $g_hLblAttackNow = 0, $g_hLblAttackNowSec = 0
Func CreateAttackSearchOptionsSearch()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "Group_01", "Search Reduction"), $x - 20, $y - 20, 223, 165)
$x -= 13
$g_hChkSearchReduction = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkSearchReduction", "Enable Search Reduction"), $x, $y - 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkSearchReduction_Info_01", "Check this if you want the search values to automatically be lowered after a certain amount of searches."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkSearchReduction")
$y += 15
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceCount", "Reduce targets every"), $x, $y + 3, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceCount_Info_01", "Enter the No. of searches to wait before each reduction occurs.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceCount = GUICtrlCreateInput("20", $x + 115, $y + 2, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "search(es).", -1), $x + 160, $y + 3, -1, -1)
$y += 21
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceGold", "- Reduce Gold"), $x, $y + 3, -1, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceGold_Info_01", "Lower value for Gold by this amount on each step.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceGold = GUICtrlCreateInput("2000", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceElixir", "- Reduce Elixir"), $x, $y + 3, -1, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceElixir_Info_01", "Lower value for Elixir by this amount on each step.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceElixir = GUICtrlCreateInput("2000", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceGoldPlusElixir", "- Reduce Gold + Elixir"), $x, $y + 3, -1, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceGoldPlusElixir_Info_01", "Lower total sum for G+E by this amount on each step.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceGoldPlusElixir = GUICtrlCreateInput("4000", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 160, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel("+", $x + 176, $y + 1, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 182, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceDark", "- Reduce Dark Elixir"), $x, $y + 3, -1, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceDark_Info_01", "Lower value for Dark Elixir by this amount on each step.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceDark = GUICtrlCreateInput("100", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 3)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceTrophy", "- Reduce Tropies"), $x, $y + 3, -1, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceTrophy_Info_01", "Lower value for Trophies by this amount on each step.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceTrophy = GUICtrlCreateInput("2", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 212
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "Group_02", "Village Search Delay"), $x - 20, $y - 20, 223, 72)
$x += 20
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblMinVSDelay_Info_01", "Use this slider to change the time to wait between Next clicks when searching for a Village to Attack.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblMinVSDelay_Info_02", "This might compensate for Out of Sync errors on some PC's.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblMinVSDelay_Info_03", "NO GUARANTEES! This will not always have the same results!")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Mini", "Min"), $x - 20, $y - 2, 25, 15, $SS_RIGHT)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblVSDelay = GUICtrlCreateLabel("0", $x + 7, $y - 2, 12, 15, $SS_RIGHT)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTextVSDelay = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "seconds", "seconds"), $x + 23, $y - 2, -1, -1)
$g_hSldVSDelay = GUICtrlCreateSlider($x + 70, $y - 4, 105, 25, BITOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-1, 1)
GUICtrlSetLimit(-1, 12, 0)
GUICtrlSetData(-1, 1)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetOnEvent(-1, "sldVSDelay")
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Maxi", "Max"), $x - 20, $y - 2, 25, 15, $SS_RIGHT)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblMaxVSDelay_Info_01", "Enable random village search delay value by setting") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblMaxVSDelay_Info_02", "bottom Max slide value higher than the top minimum slide")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblMaxVSDelay = GUICtrlCreateLabel("0", $x + 7, $y - 2, 12, 15, $SS_RIGHT)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTextMaxVSDelay = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "seconds", -1), $x + 23, $y - 2, 45, -1)
$g_hSldMaxVSDelay = GUICtrlCreateSlider($x + 70, $y - 4, 105, 25, BITOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-1, 1)
GUICtrlSetLimit(-1, 15, 0)
GUICtrlSetData(-1, 4)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetOnEvent(-1, "sldMaxVSDelay")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 253
$y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "Group_03", "Search Options"), $x - 20, $y - 20, 189, 165)
$x -= 5
$g_hChkAttackNow = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkAttackNow", "Attack Now! option."), $x - 5, $y - 4, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkAttackNow_Info_01", "Check this if you want the option to have an 'Attack Now!' button next to") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkAttackNow_Info_02", "the Start and Pause buttons to bypass the dead base or all base search values.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkAttackNow_Info_03", "The Attack Now! button will only appear when searching for villages to Attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkAttackNow")
$g_hLblAttackNow = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblAttackNow", "Add") & ":", $x + 10, $y + 20, 27, -1, $SS_RIGHT)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblAttackNow_Info_01", "Add this amount of reaction time to slow down the search.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hCmbAttackNowDelay = GUICtrlCreateCombo("", $x + 45, $y + 17, 35, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "0|1|2|3|4|5", "3")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblAttackNowSec = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 85, $y + 20, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 49
$g_hChkRestartSearchLimit = GUICtrlCreateCheckbox( GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkRestartSearchLimit", "Restart every") & ":", $x - 5, $y - 8, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkRestartSearchLimit_Info_01", "Return To Base after x searches and restart to search enemy villages.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkRestartSearchLimit")
$g_hTxtRestartSearchlimit = GUICtrlCreateInput("50", $x + 15, $y + 15, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "search(es).", -1), $x + 47, $y + 17, -1, -1)
$y += 45
$g_hChkAlertSearch = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkAlertSearch", "Alert me when Village found"), $x - 5, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkAlertSearch_Info_01", "Check this if you want an Audio alarm & a Balloon Tip when a Base to attack is found."))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hRadAutoQueenAbility = 0, $g_hRadAutoKingAbility = 0, $g_hRadAutoWardenAbility = 0
Global $g_hRadManQueenAbility = 0, $g_hRadManKingAbility = 0, $g_hRadManWardenAbility = 0
Global $g_hTxtManQueenAbility = 0, $g_hTxtManKingAbility = 0, $g_hTxtManWardenAbility = 0
Global $g_hRadBothQueenAbility = 0, $g_hRadBothKingAbility = 0, $g_hRadBothWardenAbility = 0
Global $g_hChkAttackPlannerEnable = 0, $g_hChkAttackPlannerCloseCoC = 0, $g_hChkAttackPlannerCloseAll = 0, $g_hChkAttackPlannerSuspendComputer = 0, $g_hChkAttackPlannerRandom = 0, $g_hCmbAttackPlannerRandom = 0, $g_hChkAttackPlannerDayLimit = 0, $g_hCmbAttackPlannerDayMin = 0, $g_hCmbAttackPlannerDayMax = 0
Global $g_ahChkAttackWeekdays[7] = [0, 0, 0, 0, 0, 0, 0], $g_ahChkAttackHours[24] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hLbAttackPlannerRandom = 0, $g_hLbAttackPlannerDayLimit = 0, $g_ahChkAttackWeekdaysE = 0, $g_ahChkAttackHoursE1 = 0, $g_ahChkAttackHoursE2 = 0
Global $g_hChkDropCCHoursEnable = 0, $g_ahChkDropCCHours[24] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
GLobal $g_hLblDropCChour = 0, $g_ahLblDropCChoursE = 0
GLobal $g_hLblDropCChours[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahChkDropCCHoursE1 = 0, $g_ahChkDropCCHoursE2 = 0
Func CreateAttackSearchOptionsAttack()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "Group_01", "Hero Abilities"), $x - 20, $y - 20, $g_iSizeWGrpTab4, 95)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x, $y, 22, 22)
GUIStartGroup()
$x += 30
$g_hRadAutoQueenAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities", "Auto activate (red zone)"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities_Info_01", "Activate the Ability when the Hero becomes weak.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities_Info_02", "Heroes are checked and activated individually.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
$x += 145
$g_hRadManQueenAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities", "Timed after") & ":", $x , $y , -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities_Info_01", "Activate the Ability on a timer.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities_Info_02", "All Heroes are activated at the same time.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hTxtManQueenAbility = GUICtrlCreateInput("9", $x + 80, $y + 3, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "TxtManAbilities_Info_01", "Set the time in seconds for Timed Activation of Hero Abilities.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 115, $y + 4, -1, -1)
$x += 145
$g_hRadBothQueenAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadBothAbilities_Info_01", "Check Both"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadBothAbilities_Info_02", "Activate the Ability when Hero becomes weak or when timer runs out")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
Local $x = 25, $y = 69
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x, $y, 22, 22)
GUIStartGroup()
$x += 30
$g_hRadAutoKingAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities", "Auto activate (red zone)"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities_Info_01", "Activate the Ability when the Hero becomes weak.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities_Info_02", "Heroes are checked and activated individually.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
$x += 145
$g_hRadManKingAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities", "Timed after") & ":", $x , $y , -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities_Info_01", "Activate the Ability on a timer.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities_Info_02", "All Heroes are activated at the same time.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hTxtManKingAbility = GUICtrlCreateInput("9", $x + 80, $y + 3, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "TxtManAbilities_Info_01", "Set the time in seconds for Timed Activation of Hero Abilities.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 115, $y + 4, -1, -1)
$x += 145
$g_hRadBothKingAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadBothAbilities_Info_01", "Check Both"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadBothAbilities_Info_02", "Activate the Ability when Hero becomes weak or when timer runs out")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
Local $x = 25, $y = 95
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x, $y , 22, 22)
GUIStartGroup()
$x += 30
$g_hRadAutoWardenAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities", "Auto activate (red zone)"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities_Info_01", "Activate the Ability when the Hero becomes weak.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities_Info_02", "Heroes are checked and activated individually.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
$x += 145
$g_hRadManWardenAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities", "Timed after") & ":", $x , $y , -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities_Info_01", "Activate the Ability on a timer.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities_Info_02", "All Heroes are activated at the same time.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hTxtManWardenAbility = GUICtrlCreateInput("9", $x + 80, $y + 3, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "TxtManAbilities_Info_01", "Set the time in seconds for Timed Activation of Hero Abilities.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 115, $y + 4, -1, -1)
$x += 145
$g_hRadBothWardenAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadBothAbilities_Info_01", "Check Both"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadBothAbilities_Info_02", "Activate the Ability when Hero becomes weak or when timer runs out")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 25, $y = 145
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "Group_02", "Attack Schedule"), $x - 20, $y - 20, $g_iSizeWGrpTab4, 138)
$x -= 5
$g_hChkAttackPlannerEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerEnable", "Enable Schedule"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerEnable_Info_01", "This option will allow you to schedule attack times") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerEnable_Info_02", "Bot continues to run and will attack only when schedule allows"))
GUICtrlSetOnEvent(-1, "chkAttackPlannerEnable")
$g_hChkAttackPlannerCloseCoC = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerCloseCoC", "Close CoC"), $x, $y + 14, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerCloseCoC_Info_01", "This option will close CoC app when not scheduled to Search & Attack!") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlanner_Info_01", "Bot Continues to run and will restart when schedule allows"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerCloseCoC")
$g_hChkAttackPlannerCloseAll = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerCloseAll", "Close emulator"), $x, $y + 33, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerCloseAll_Info_01", "This option will close emulator when not scheduled to Search & Attack!") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlanner_Info_01",-1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerCloseAll")
$g_hChkAttackPlannerSuspendComputer = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerSuspendComputer", "Suspend Computer"), $x, $y + 52, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerSuspendComputer_Info_01", "This option will suspend computer when not scheduled to Search & Attack!") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlanner_Info_01",-1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerSuspendComputer")
$g_hChkAttackPlannerRandom = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerRandom", "Random Disable"), $x, $y + 71, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerRandom_Info_01", "This option will randomly stop attacking") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlanner_Info_01",-1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerRandom")
$g_hCmbAttackPlannerRandom = GUICtrlCreateCombo("", $x + 110, $y + 69, 37, 16, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerRandom_Info_02", "Select number of hours to stop attacking"))
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20", "4")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbAttackPlannerRandom")
$g_hLbAttackPlannerRandom = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "hrs", "hrs"), $x + 148, $y + 73, -1,-1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkAttackPlannerDayLimit = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerDayLimit", "Daily Limit"), $x, $y + 90, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerDayLimit_Info_01", "Will randomly stop attacking when exceed random number of attacks between range selected") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlanner_Info_01",-1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerDayLimit")
$g_hCmbAttackPlannerDayMin = GUICtrlCreateInput("12", $x + 100, $y + 92, 37, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "TxtMinLbAttackPlannerDayLimit_Info_01", "Enter minimum number of attacks allowed per day"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "cmbAttackPlannerDayMin")
$g_hLbAttackPlannerDayLimit = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "LbAttackPlannerDayLimit", "to"), $x + 142, $y + 94, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hCmbAttackPlannerDayMax = GUICtrlCreateInput("15", $x + 157, $y + 94, 37, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "TxtMaxLbAttackPlannerDayLimit_Info_01", "Enter maximum number of attacks allowed per day"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "cmbAttackPlannerDayMax")
$x += 198
$y -= 5
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Day", -1) & ":", $x, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Su", -1), $x + 30, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Sunday", -1))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Mo", -1), $x + 46, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Monday", -1))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Tu", -1), $x + 63, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Tuesday", -1))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "We", -1), $x + 79, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Wednesday", -1))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Th", -1), $x + 99, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Thursday", -1))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Fr", -1), $x + 117, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Friday", -1))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Sa", -1), $x + 133, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Saturday", -1))
GUICtrlCreateLabel("X", $x + 155, $y+1, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
$y += 13
$g_ahChkAttackWeekdays[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_ahChkAttackWeekdays[1] = GUICtrlCreateCheckbox("", $x + 47, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_ahChkAttackWeekdays[2] = GUICtrlCreateCheckbox("", $x + 64, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_ahChkAttackWeekdays[3] = GUICtrlCreateCheckbox("", $x + 81, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_ahChkAttackWeekdays[4] = GUICtrlCreateCheckbox("", $x + 99, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_ahChkAttackWeekdays[5] = GUICtrlCreateCheckbox("", $x + 117, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_ahChkAttackWeekdays[6] = GUICtrlCreateCheckbox("", $x + 133, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_ahChkAttackWeekdaysE = GUICtrlCreateCheckbox("", $x + 151, $y, 15, 15, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkattackWeekDaysE")
$x -= 25
$y += 17
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Hour", "Hour") & ":", $x, $y, -1, 15)
$sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", "Only during these hours of each day")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel("X", $x + 214, $y + 1, 11, 11)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 15
$g_ahChkAttackHours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahChkAttackHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkattackHoursE1")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "AM", "AM"), $x + 10, $y)
$y += 15
$sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
$g_ahChkAttackHours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkattackHoursE2")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "PM", "PM"), $x + 10, $y)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 25, $y = 290
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "Group_03", "ClanCastle"), $x - 20, $y - 20, $g_iSizeWGrpTab4, 102)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCC, $x, $y + 8, 64, 64)
$y -= 8
$g_hChkDropCCHoursEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkDropCCHoursEnable", "Enable CC Drop Schedule" ), $x + 70, $y, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkDropCCHoursEnable_Info_01", "Use schedule to define when dropping CC is allowed, \r\n CC is always dropped when schedule is not enabled"))
GUICtrlSetOnEvent(-1, "chkDropCCHoursEnable")
$x += 188
$y += 20
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1), $x + 8, $y)
$y += 14
$x -= 21
$g_hLblDropCChour = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Hour", -1) & ":", $x, $y, -1, 15)
Local $sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblDropCChours[0] = GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
$g_hLblDropCChours[1] = GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
$g_hLblDropCChours[2] = GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
$g_hLblDropCChours[3] = GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
$g_hLblDropCChours[4] = GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
$g_hLblDropCChours[5] = GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
$g_hLblDropCChours[6] = GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
$g_hLblDropCChours[7] = GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
$g_hLblDropCChours[8] = GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
$g_hLblDropCChours[9] = GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
$g_hLblDropCChours[10] = GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
$g_hLblDropCChours[11] = GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
$g_ahLblDropCChoursE = GUICtrlCreateLabel("X", $x + 213, $y + 2, 11, 11)
$y += 15
$g_ahChkDropCCHours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
$sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED )
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkDropCCHoursE1")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "AM", -1), $x + 10, $y)
$y += 15
$sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
$g_ahChkDropCCHours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED )
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkDropCCHoursE2")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "PM", -1), $x + 10, $y)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkSmartLightSpell = 0, $g_hChkSmartEQSpell = 0, $g_hChkNoobZap = 0, $g_hChkSmartZapDB = 0, $g_hChkSmartZapSaveHeroes = 0, $g_hTxtSmartZapMinDE = 0, $g_hTxtSmartExpectedDE = 0, $g_hChkDebugSmartZap = 0, $g_hChkSmartZapFTW = 0
Global $g_hLblSmartUseLSpell = 0, $g_hLblSmartUseEQSpell = 0, $g_hLblSmartZap = 0, $g_hLblNoobZap = 0, $g_hLblSmartLightningUsed = 0, $g_hLblSmartEarthQuakeUsed = 0
Func CreateAttackNewSmartZap()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "Group_01", "SmartZap/NoobZap"), $x - 20, $y - 20, $g_iSizeWGrpTab4, $g_iSizeHGrpTab4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblUse_This_Spell_to_Zap", "Use This Spell to Zap Dark Drills"), $x + 20, $y, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnNewSmartZap, $x - 10, $y, 25, 25)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x + 45, $y + 20, 25, 25)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthQuakeSpell, $x + 125, $y + 20, 25, 25)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x - 10, $y + 90, 25, 25)
$y += 50
$g_hLblSmartUseLSpell = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartUseLSpell", "Use LSpells"), $x + 27, $y + 15, -1, -1)
GUICtrlSetOnEvent(-1, "chkSmartLightSpell")
GUICtrlSetState(-1,$GUI_HIDE)
$g_hChkSmartLightSpell = GUICtrlCreateCheckbox("", $x + 51, $y - 3, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartUseLSpell_Info_01", "Check this to drop Lightning Spells on top of Dark Elixir Drills.") & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartUseLSpell_Info_02", "Remember to go to the tab 'troops' and put the maximum capacity") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartUseLSpell_Info_03", "of your spell factory and the number of spells so that the bot can function perfectly."))
GUICtrlSetOnEvent(-1, "chkSmartLightSpell")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hLblSmartUseEQSpell = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartUseEQSpell", "Use EQSpell"), $x + 105, $y + 15, -1, -1)
GUICtrlSetOnEvent(-1, "chkEarthQuakeZap")
GUICtrlSetState(-1,$GUI_HIDE)
$g_hChkSmartEQSpell = GUICtrlCreateCheckbox("", $x + 131, $y - 3, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartUseEQSpell_Info_01", "Check this to drop EarthQuake Castle Spell on any Dark Elixir Drill"))
GUICtrlSetOnEvent(-1, "chkEarthQuakeZap")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hChkNoobZap = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkNoobZap", "Use NoobZap"), $x + 20 + 2, $y + 35, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkNoobZap_Info_01", "Check this to drop lightning spells on any Dark Elixir Drills"))
GUICtrlSetOnEvent(-1, "chkNoobZap")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hChkSmartZapDB = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkSmartZapDB", "Only Zap Drills in Dead Bases"), $x + 20 + 2, $y + 55, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkSmartZapDB_Info_01", "This will only SmartZap a Dead Base (Recommended)"))
GUICtrlSetOnEvent(-1, "chkSmartZapDB")
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkSmartZapSaveHeroes = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkSmartZapSaveHeroes", "TH Snipe Not Zap if Heroes Deployed"), $x + 20 + 2, $y + 75, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkSmartZapSaveHeroes_Info_01", "This will stop SmartZap from zapping a base on a Town Hall Snipe if your Heroes were deployed"))
GUICtrlSetOnEvent(-1, "chkSmartZapSaveHeroes")
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkSmartZapFTW = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkSmartZapFTW", "Strike For The Win"), $x + 20 + 2, $y + 95, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkSmartZapFTW_Info_01", "SmartZap/NoobZap will try to reach 50% Destruction to get the win.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkSmartZapFTW_Info_02", "It will not zap, if one Star is already reached, or if there is no chance to win."))
GUICtrlSetOnEvent(-1, "chkSmartZapFTW")
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$y -= 55
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 200 + 9, $y + 11, 24, 24)
GUICtrlCreateGroup("", $x + 199, $y - 1, 192, 106)
$g_hLblSmartZap = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartZap", "Min. amount of Dark Elixir") & ":", $x + 160 + 79, $y + 12, -1, -1)
$g_hTxtSmartZapMinDE = GUICtrlCreateInput("350", $x + 289, $y + 32, 90, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartZap_Info_01", "Set the Value of the minimum amount of Dark Elixir in the Drills"))
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "txtMinDark")
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 200 + 9, $y + 57, 24, 24)
$g_hLblNoobZap = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblNoobZap", "Expected gain of Dark Drills") & ":", $x + 160 + 79, $y + 58, -1, -1)
$g_hTxtSmartExpectedDE = GUICtrlCreateInput("320", $x + 289, $y + 78, 90, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblNoobZap_Info_01", "Set value for expected gain every dark drill") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblNoobZap_Info_02", "NoobZap will be stopped if the last zap gained less DE than expected"))
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "txtExpectedDE")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkShareAttack = 0, $g_hLblShareMinLoot = 0, $g_hTxtShareMinGold = 0, $g_hTxtShareMinElixir = 0, $g_hTxtShareMinDark = 0, $g_hTxtShareMessage = 0, $g_hChkTakeLootSS = 0, $g_hChkScreenshotLootInfo = 0
Global $g_hLblShareMinGold = 0, $g_hLblShareMinElixir = 0, $g_hLblShareMinDark = 0
Func CreateAttackSearchOptionsEndBattle()
Local $x = 20, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "Group_01", "Share Replay"), $x - 15, $y - 20, $g_iSizeWGrpTab4, 204)
$g_hChkShareAttack = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "ChkShareAttack", "Share Replays in your clan's chat."), $x, $y - 7, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "ChkShareAttack_Info_01", "Check this to share your battle replay in the clan chat."))
GUICtrlSetOnEvent(-1, "chkShareAttack")
$x -= 15
$y -= 2
$y -=5
$y += 25
$g_hLblShareMinLoot = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "LblShareMinLoot", "When Loot Gained") & ":", $x + 20, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblShareMinGold = GUICtrlCreateLabel(">", $x + 112, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtShareMinGold = GUICtrlCreateInput("300000", $x + 120, $y - 2, 61, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "TxtShareMinGold_Info_01", "Only Share Replay when the battle loot is more than this amount of Gold."))
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 182, $y, 16, 16)
$y += 22
$g_hLblShareMinElixir = GUICtrlCreateLabel(">", $x + 112, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtShareMinElixir = GUICtrlCreateInput("300000", $x + 120, $y - 2, 61, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "TxtShareMinElixir_Info_01", "Only Share Replay when the battle loot is more than this amount of Elixir."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 182, $y, 16, 16)
$y += 22
$g_hLblShareMinDark = GUICtrlCreateLabel(">", $x + 112, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtShareMinDark = GUICtrlCreateInput("0", $x + 120, $y - 2, 61, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "TxtShareMinDark_Info_01", "Only Share Replay when the battle loot is more than this amount of Dark Elixir."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 5)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 182, $y, 16, 16)
$y += 25
$x += 5
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "LblRandomMessage", "Use a random message from this list") & ":", $x, $y - 2, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 27
$g_hTxtShareMessage = GUICtrlCreateEdit("", $x, $y - 10, 205, 72, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "ListShareMessage_Item_01", "Nice\r\nGood\r\nThanks \r\nWowwww")))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "ListShareMessage_Info_01", "Message to send with the Share Replay"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 20
$y += 100
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "Group_02", "Take Loot Snapshot"), $x - 15, $y - 20, $g_iSizeWGrpTab4, 67)
$g_hChkTakeLootSS = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "Group_02", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "ChkTakeLootSS_Info_01", "Check this if you want to save a Loot snapshot of the Village that was attacked."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkTakeLootSS")
$y += 18
$g_hChkScreenshotLootInfo = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "ChkScreenshotLootInfo", "Include loot info in filename"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "ChkScreenshotLootInfo_Info_01", "Include loot info in the screenshot filename"))
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkTrophyRange = 0, $g_hTxtDropTrophy = 0, $g_hTxtMaxTrophy = 0, $g_hChkTrophyHeroes = 0, $g_hCmbTrophyHeroesPriority = 0, $g_hChkTrophyAtkDead = 0, $g_hTxtDropTrophyArmyMin = 0
Global $g_hPicMinTrophies[$eLeagueCount] = [0,0,0,0,0,0,0,0,0], $g_hLblMinTrophies = 0
Global $g_hPicMaxTrophies[$eLeagueCount] = [0,0,0,0,0,0,0,0,0], $g_hLblMaxTrophies = 0
Global $g_hLblTrophyHeroesPriority = 0, $g_hLblDropTrophyArmyMin = 0, $g_hLblDropTrophyArmyPercent = 0
Func CreateAttackSearchOptionsTrophySettings()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "Group_01", "Trophy Settings"), $x - 20, $y - 20, $g_iSizeWGrpTab4, $g_iSizeHGrpTab4)
$x += 25
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x - 15, $y, 64, 64, $BS_ICON)
$x += 50
$g_hChkTrophyRange = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "ChkTrophyRange", "Trophy range") & ":", $x + 20, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkTrophyRange")
$g_hTxtDropTrophy = GUICtrlCreateInput("5000", $x + 110, $y, 35, -1, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 4)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "TxtDropTrophy_Info_01", "MIN: The Bot will drop trophies until below this value."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "TxtDropTrophy")
$g_hPicMinTrophies[$eLeagueUnranked] = _GUICtrlCreateIcon($g_sLibIconPath, $eUnranked, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_SHOW)
$g_hPicMinTrophies[$eLeagueBronze] = _GUICtrlCreateIcon($g_sLibIconPath, $eBronze, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMinTrophies[$eLeagueSilver] = _GUICtrlCreateIcon($g_sLibIconPath, $eSilver, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMinTrophies[$eLeagueGold] = _GUICtrlCreateIcon($g_sLibIconPath, $eGold, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMinTrophies[$eLeagueCrystal] = _GUICtrlCreateIcon($g_sLibIconPath, $eCrystal, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMinTrophies[$eLeagueMaster] = _GUICtrlCreateIcon($g_sLibIconPath, $eMaster, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMinTrophies[$eLeagueChampion] = _GUICtrlCreateIcon($g_sLibIconPath, $eChampion, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMinTrophies[$eLeagueTitan] = _GUICtrlCreateIcon($g_sLibIconPath, $eTitan, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMinTrophies[$eLeagueLegend] = _GUICtrlCreateIcon($g_sLibIconPath, $eLegend, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hLblMinTrophies = GUICtrlCreateLabel("", $x + 133, $y - 15, 17, 17, $SS_CENTER)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateLabel("-", $x + 148, $y + 4, -1, -1)
$g_hTxtMaxTrophy = GUICtrlCreateInput("5000", $x + 155, $y, 35, -1, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 4)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "TxtMaxTrophy_Info_01", "MAX: The Bot will drop trophies if your trophy count is greater than this value."))
GuiCtrlSetState(-1,$GUI_DISABLE)
GUICtrlSetOnEvent(-1, "TxtMaxTrophy")
$g_hPicMaxTrophies[$eLeagueUnranked] = _GUICtrlCreateIcon($g_sLibIconPath, $eUnranked, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_SHOW)
$g_hPicMaxTrophies[$eLeagueBronze] = _GUICtrlCreateIcon($g_sLibIconPath, $eBronze, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMaxTrophies[$eLeagueSilver] = _GUICtrlCreateIcon($g_sLibIconPath, $eSilver, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMaxTrophies[$eLeagueGold] = _GUICtrlCreateIcon($g_sLibIconPath, $eGold, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMaxTrophies[$eLeagueCrystal] = _GUICtrlCreateIcon($g_sLibIconPath, $eCrystal, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMaxTrophies[$eLeagueMaster] = _GUICtrlCreateIcon($g_sLibIconPath, $eMaster, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMaxTrophies[$eLeagueChampion] = _GUICtrlCreateIcon($g_sLibIconPath, $eChampion, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMaxTrophies[$eLeagueTitan] = _GUICtrlCreateIcon($g_sLibIconPath, $eTitan, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMaxTrophies[$eLeagueLegend] = _GUICtrlCreateIcon($g_sLibIconPath, $eLegend, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hLblMaxTrophies = GUICtrlCreateLabel("", $x + 178, $y - 15, 17, 17, $SS_CENTER)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
$y += 24
$x += 20
$g_hChkTrophyHeroes = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "ChkTrophyHeroes", "Use Heroes To Drop Trophies"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "ChkTrophyHeroes_Info_01", "Use Heroes to drop Trophies if Heroes are available."))
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkTrophyHeroes")
$y += 25
$g_hLblTrophyHeroesPriority = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "LblTrophyHeroesPriority", "Priority Hero to Use") & ":", $x + 16, $y, 110, -1)
$g_hCmbTrophyHeroesPriority = GUICtrlCreateCombo("", $x + 125, $y - 4 , 170, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "LblTrophyHeroesPriority_Info_01", "Set the order on which Hero the Bot drops first when available."))
Local $txtPriorityConnector = ">"
Local $txtPriorityDefault = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1)
Local $txtPriorityList = "" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1) & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1) & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & "|" & ""
If $g_bDebugSetlog Then SetDebugLog($txtPriorityDefault)
If $g_bDebugSetlog Then SetDebugLog($txtPriorityList)
GUICtrlSetData(-1, $txtPriorityList , $txtPriorityDefault)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$g_hChkTrophyAtkDead = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "ChkTrophyAtkDead", "Attack Dead Bases During Drop"), $x, $y + 2, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "ChkTrophyAtkDead_Info_01", "Attack a Deadbase found on the first search while dropping Trophies."))
GUICtrlSetOnEvent(-1, "chkTrophyAtkDead")
GUICtrlSetState(-1,$GUI_DISABLE)
$y += 24
$g_hLblDropTrophyArmyMin = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "LblDropTrophyArmyMin", "Wait until Army Camp are at least") & " " & ChrW(8805), $x + 16, $y + 6, 200, -1, $SS_LEFT)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "LblDropTrophyArmyMin_Info_01", "Enter the percent of full army required for dead base attack before starting trophy drop.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtDropTrophyArmyMin = GUICtrlCreateInput("70", $x + 215, $y + 2, 27, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDropTrophyArmyPercent = GUICtrlCreateLabel("%", $x + 245, $y + 6, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_ATTACKOPTION_TAB = 0, $g_hGUI_ATTACKOPTION_TAB_ITEM1 = 0, $g_hGUI_ATTACKOPTION_TAB_ITEM2 = 0, $g_hGUI_ATTACKOPTION_TAB_ITEM3 = 0, $g_hGUI_ATTACKOPTION_TAB_ITEM4 = 0, $g_hGUI_ATTACKOPTION_TAB_ITEM5 = 0
Func CreateAttackSearchOptions()
$g_hGUI_ATTACKOPTION = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_SEARCH)
GUISwitch($g_hGUI_ATTACKOPTION)
$g_hGUI_ATTACKOPTION_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_ATTACKOPTION_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_01", -1))
CreateAttackSearchOptionsSearch()
$g_hGUI_ATTACKOPTION_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_02", -1))
CreateAttackSearchOptionsAttack()
$g_hGUI_ATTACKOPTION_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_05_STab_01", "SmartZap"))
CreateAttackNewSmartZap()
$g_hGUI_ATTACKOPTION_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_03", -1))
CreateAttackSearchOptionsEndBattle()
$g_hGUI_ATTACKOPTION_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_05_STab_02", "Trophy Settings"))
CreateAttackSearchOptionsTrophySettings()
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_SEARCH_TAB = 0, $g_hGUI_SEARCH_TAB_ITEM1 = 0, $g_hGUI_SEARCH_TAB_ITEM2 = 0, $g_hGUI_SEARCH_TAB_ITEM3 = 0, $g_hGUI_SEARCH_TAB_ITEM4 = 0, $g_hGUI_SEARCH_TAB_ITEM5 = 0
Global $g_hChkDeadbase = 0, $g_hChkActivebase = 0, $g_hChkTHSnipe = 0, $g_hChkBully = 0
Global $g_hLblDeadbaseDisabled = 0, $g_hLblActivebaseDisabled = 0, $g_hLblTHSnipeDisabled = 0, $g_hLblBullyDisabled = 0
Func CreateAttackSearch()
$g_hGUI_SEARCH = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_ATTACK)
Local $x = 82
$g_hChkDeadbase = GUICtrlCreateCheckbox("", $x, 6, 13, 13)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "DBcheck")
$g_hChkActivebase = GUICtrlCreateCheckbox("", $x + 100, 4, 13, 13)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "Abcheck")
$g_hChkTHSnipe = GUICtrlCreateCheckbox("", $x + 190, 4, 13, 13)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "TScheck")
$g_hChkBully = GUICtrlCreateCheckbox("", $x + 260, 4, 13, 13)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "Bullycheck")
CreateAttackSearchDeadBase()
CreateAttackSearchActiveBase()
CreateAttackSearchTHSnipe()
CreateAttackSearchBully()
CreateAttackSearchOptions()
GUISwitch($g_hGUI_SEARCH)
$g_hGUI_SEARCH_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_SEARCH_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_01", "DeadBase") & "    ")
$g_hLblDeadbaseDisabled = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_01", "Note: This Strategy is disabled, tick the checkmark on the") & " " & GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_01", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_02", "tab to enable it!"), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hGUI_SEARCH_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_02", "ActiveBase") & "    ")
$g_hLblActivebaseDisabled = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_01", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_02", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_02", -1), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hGUI_SEARCH_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_03", "TH Snipe") & "    ")
$g_hLblTHSnipeDisabled = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_01", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_03", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_02", -1), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hGUI_SEARCH_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_04", "Bully") & "    ")
$g_hLblBullyDisabled = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_01", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_04", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_02", -1), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hGUI_SEARCH_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_05", "Options"))
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_STRATEGIES = 0
Global $g_hGUI_STRATEGIES_TAB = 0, $g_hGUI_STRATEGIES_TAB_ITEM1 = 0, $g_hGUI_STRATEGIES_TAB_ITEM2 = 0
Global $g_hCmbPresetList = 0, $g_hTxtPresetMessage = 0, $g_hLblLoadPresetMessage = 0, $g_hBtnGUIPresetLoadConf = 0, $g_hChkDeleteConf = 0, $g_hBtnGUIPresetDeleteConf = 0, $g_hBtnStrategyFolder = 0, $g_hTxtPresetSaveFilename = 0, $g_hTxtSavePresetMessage = 0, $g_hBtnGUIPresetSaveConf = 0
Func CreateAttackStrategies()
$g_hGUI_STRATEGIES = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_ATTACK)
GUISwitch($g_hGUI_STRATEGIES)
Local $xStart = 5, $yStart = 25
$g_hGUI_STRATEGIES_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_STRATEGIES_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_03_STab_01", "Load Strategy"))
Local $x = $xStart, $y = $yStart
$g_hCmbPresetList = GUICtrlCreateCombo("", $x, $y, 200, 300, $WS_VSCROLL)
GUICtrlSetOnEvent(-1, "PresetLoadConfigInfo")
$x += 205
$g_hTxtPresetMessage = GUICtrlCreateEdit("", $x, $y, 225, 250, BitOR($ES_WANTRETURN, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
Local $loadmessage = GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "LblLoadPresetMessage", "LOAD PRECONFIGURED SETTINGS.\n\n- Load ALL Train Army Tab Settings\n- Load ALL Search && Attack Tab Settings\n\n- EXCEPT: Share Replay Settings\n- EXCEPT: Take Loot Snapshot Settings\n- EXCEPT: Gem Boost Settings")
$g_hLblLoadPresetMessage = GUICtrlCreateLabel(StringReplace($loadmessage, "\n", @crlf ), $x + 15, $y + 25, 400)
$x += 5
$y += 255
$g_hBtnGUIPresetLoadConf = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "BtnGUIPresetLoadConf", "Load Configuration"), $x, $y, 130, 20)
GUICtrlSetOnEvent(-1, "PresetLoadConf")
GUICtrlSetState(-1, $GUI_HIDE)
$x += 145
$g_hChkDeleteConf = GUICtrlCreateCheckbox("", $x, $y + 2, 15, 15)
GUICtrlSetOnEvent(-1, "chkCheckDeleteConf")
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnGUIPresetDeleteConf = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "BtnGUIPresetDeleteConf", "Delete"), $x + 15, $y, 60, 20)
GUICtrlSetOnEvent(-1, "PresetDeleteConf")
GUICtrlSetState(-1, $GUI_HIDE + $GUI_DISABLE)
$g_hBtnStrategyFolder = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "BtnStrategyFolder", "Open Strategy folder"), $xStart + 40, $y + 40, 120, 30)
GUICtrlSetOnEvent(-1, "btnStrategyFolder")
$g_hGUI_STRATEGIES_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_03_STab_02", "Save Strategy"))
$x = $xStart
$y = $yStart
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "LblSaveFilename", "Strategy file name") & ":", $x, $y + 4, 200, 25, $SS_RIGHT)
$x += 205
$g_hTxtPresetSaveFilename = GUICtrlCreateInput("strategy " & @YEAR & "-" & @MON & "-" & @MDAY & " " & @HOUR & "." & @MIN & "." & @SEC, $x, $y, 200, 25)
$x = $xStart
$y += 30
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "LblSaveFilenameNote", "Notes") & ":" , $x, $y + 4, 200, 25, $SS_RIGHT)
Local $savemessage = GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "LblSavePresetMessage", "SAVE SETTINGS\n--------------------------------------\nSave ALL:\n- Train Army Tab Settings\n- Search && Attack Tab Settings\n\nExcept:\n- Share Replay Settings\n- Take Loot Snapshot Settings\n- Gem Boost Settings\n--------------------------------------")
GUICtrlCreateLabel(StringReplace($savemessage, "\n", @crlf), $x + 15, $y + 4 + 25, 280)
$x += 205
$g_hTxtSavePresetMessage = GUICtrlCreateEdit("", $x, $y, 223, 230, BitOR($ES_WANTRETURN, $ES_AUTOVSCROLL))
$y += 235
$g_hBtnGUIPresetSaveConf = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "BtnGUIPresetSaveConf", "Save Configuration"), $x + 13, $y, 200, 20)
GUICtrlSetOnEvent(-1, "PresetSaveConf")
GUICtrlCreateTabItem("")
EndFunc
Func LoadTranslatedDropOrderList()
Global $g_asDropOrderList = ["", "Barbarians", "Archers", "Giants", "Goblins", "Wall Breakers", "Balloons", "Wizards", "Healers", "Dragons", "Pekkas", "Baby Dragons", "Miners", "Electro Dragons", "Minions", "Hog Riders", "Valkyries", "Golems", "Witches", "Lava Hounds", "Bowlers", "Clan Castle", "Heroes"]
EndFunc
Global $g_hChkCustomDropOrderEnable = 0
Global $g_ahCmbDropOrder[$eDropOrderCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahImgDropOrder[$eDropOrderCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hBtnDropOrderSet = 0, $g_ahImgDropOrderSet = 0
Global $g_hBtnRemoveDropOrder = 0
Func CreateAttackTab()
$g_hGUI_ATTACK = _GUICreate("", $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hFrmBotEx)
CreateAttackTroops()
CreateAttackSearch()
CreateAttackStrategies()
GUISwitch($g_hGUI_ATTACK)
$g_hGUI_ATTACK_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_ATTACK_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_01", "Train Army"))
$g_hGUI_ATTACK_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02", "Search && Attack"))
$g_hGUI_ATTACK_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_03", "Strategies"))
CreateDropOrderGUI()
GUICtrlCreateTabItem("")
EndFunc
Func CreateDropOrderGUI()
$g_hGUI_DropOrder = _GUICreate(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "GUI_DropOrder", "Attack Custom Dropping Order"), 322, 428, -1, -1, $WS_BORDER, $WS_EX_CONTROLPARENT)
SetDefaultDropOrderGroup(False)
LoadTranslatedDropOrderList()
Local $x = 25, $y = 25
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Group_03", "Custom Dropping Order"), $x - 20, $y - 20, 308, 365)
$x += 10
$y += 20
$g_hChkCustomDropOrderEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkCustomDropOrderEnable", "Enable Custom Dropping Order"), $x - 13, $y - 22, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkCustomDropOrderEnable_Info_01", "Enable to select a custom troops dropping order") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkCustomDropOrderEnable_Info_02", "Will not have effect on CSV Scripted Attack! It's only for Standard Attack.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkCustomDropOrderEnable_Info_03", "For Live and Dead Bases"))
GUICtrlSetOnEvent(-1, "chkDropOrder")
Local $sComboData = ""
For $j = 0 To UBound($g_asDropOrderList) - 1
$sComboData &= $g_asDropOrderList[$j] & "|"
Next
Local $g_hTxtDropOrder = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "TxtDropOrder", "Enter sequence order for drop of troop #")
$y += 5
For $p = 0 To $eDropOrderCount - 1
If $p < 11 Then
GUICtrlCreateLabel($p + 1 & ":", $x - 19, $y + 3, -1, 18)
$g_ahCmbDropOrder[$p] = GUICtrlCreateCombo("", $x, $y, 94, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "GUIDropOrder")
GUICtrlSetData(-1, $sComboData, "")
_GUICtrlSetTip(-1, $g_hTxtDropOrder & $p + 1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahImgDropOrder[$p] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnOptions, $x + 96, $y + 1, 18, 18)
$y += 25
Else
If $p = 11 Then
$x += 128
$y = 49
EndIf
GUICtrlCreateLabel($p + 1 & ":", $x - 5, $y + 4, -1, 18)
$g_ahCmbDropOrder[$p] = GUICtrlCreateCombo("", $x + 20, $y, 94, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "GUIDropOrder")
GUICtrlSetData(-1, $sComboData, "")
_GUICtrlSetTip(-1, $g_hTxtDropOrder & $p + 1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahImgDropOrder[$p] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnOptions, $x + 120, $y + 1, 18, 18)
$y += 25
EndIf
Next
$x = 25
$y = 335
$g_hBtnDropOrderSet = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnDropOrderSet", "Apply New Order"), $x, $y, 100, 25)
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_ENABLE))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnDropOrderSet_Info_01", "Push button when finished selecting custom troops dropping order") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnDropOrderSet_Info_02", "When not all troop slots are filled, will use random troop order in empty slots!"))
GUICtrlSetOnEvent(-1, "BtnDropOrderSet")
$g_ahImgDropOrderSet = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSilverStar, $x + 104, $y + 4, 18, 18)
$x += 150
$g_hBtnRemoveDropOrder = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnRemoveDropOrder", "Empty Drop List"), $x, $y, 118, 25)
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnRemoveDropOrder_Info_01", "Push button to remove all troops from list and start over"))
GUICtrlSetOnEvent(-1, "BtnRemoveDropOrder")
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $g_hBtnClose = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnClose", "Close"), 229, 373, 85, 25)
GUICtrlSetOnEvent(-1, "CloseCustomDropOrder")
EndFunc
Global $g_hGUI_BOT = 0, $g_hGUI_LOG_SA = 0
Global $g_hCmbGUILanguage = 0
Global $g_hChkDisableSplash = 0, $g_hChkForMBRUpdates = 0, $g_hChkDeleteLogs = 0, $g_hTxtDeleteLogsDays = 0, $g_hChkDeleteTemp = 0, $g_hTxtDeleteTempDays = 0, $g_hChkDeleteLoots = 0, $g_hTxtDeleteLootsDays = 0
Global $g_hChkAutostart = 0, $g_hTxtAutostartDelay = 0, $g_hChkCheckGameLanguage = 0, $g_hChkAutoAlign = 0, $g_hTxtAlignOffsetX = 0, $g_hTxtAlignOffsetY = 0, $g_hCmbAlignmentOptions = 0
Global $g_hTxtGlobalActiveBotsAllowed = 0, $g_hTxtGlobalThreads = 0, $g_hTxtThreads = 0
Global $g_hChkBotCustomTitleBarClick = 0, $g_hChkBotAutoSlideClick = 0, $g_hChkHideWhenMinimized = 0, $g_hChkUseRandomClick = 0, $g_hChkScreenshotType = 0, $g_hChkScreenshotHideName = 0, $g_hTxtTimeAnotherDevice = 0
Global $g_hChkSinglePBTForced = 0, $g_hTxtSinglePBTimeForced = 0, $g_hTxtPBTimeForcedExit = 0, $g_hChkFixClanCastle = 0, $g_hChkAutoResume = 0, $g_hTxtAutoResumeTime = 0, $g_hChkDisableNotifications = 0
Func CreateBotOptions()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_01", "GUI Language"), $x - 20, $y - 20, 210, 47)
$y -= 2
$g_hCmbGUILanguage = _GUICtrlComboBoxEx_Create($g_hGUI_BOT, "", $x - 8, $y, 185, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(_GUICtrlComboBoxEx_GetComboControl($g_hCmbGUILanguage), GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbGUILanguage_Info_01", "Use this to switch to a different GUI language"), Default, Default, Default, False)
LoadLanguagesComboBox()
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 54
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_02", "When Bot Loads"), $x - 20, $y - 20, 210, 120)
$y -= 4
$g_hChkDisableSplash = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDisableSplash", "Disable Splash Screen"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDisableSplash_Info_01", "Disables the splash screen on startup."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 20
$g_hChkForMBRUpdates = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkForMBRUpdates", "Check for Updates"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkForMBRUpdates_Info_01", "Check if you are running the latest version of the bot."))
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 20
$g_hChkDeleteLogs = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDeleteLogs", "Delete Log Files")& ":", $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDeleteLogs_Info_01", "Delete log files older than this specified No. of days.")
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDeleteLogs")
$g_hTxtDeleteLogsDays = GUICtrlCreateInput("2", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "days", "days"), $x + 150, $y + 4, 27, 15)
$y += 20
$g_hChkDeleteTemp = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDeleteTemp", "Delete Temp Files") & ":", $x, $y, -1, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDeleteTemp_Info_01", "Delete temp files older than this specified No. of days."))
GUICtrlSetOnEvent(-1, "chkDeleteTemp")
$g_hTxtDeleteTempDays = GUICtrlCreateInput("5", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "days", -1), $x + 150, $y + 4, 27, 15)
$y += 20
$g_hChkDeleteLoots = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDeleteLoots", "Delete Loot Images") & ":", $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDeleteLoots_Info_01", "Delete loot image files older than this specified No. of days.")
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDeleteLoots")
$g_hTxtDeleteLootsDays = GUICtrlCreateInput("2", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "days", -1), $x + 150, $y + 4, 27, 15)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 48
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_03", "When Bot Starts"), $x - 20, $y - 20, 210, 112)
$y -= 5
$g_hChkAutostart = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutostart", "Auto START after") & ":", $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutostart_Info_01", "Auto START the Bot after this No. of seconds."))
GUICtrlSetOnEvent(-1, "chkAutostart")
$g_hTxtAutostartDelay = GUICtrlCreateInput("10", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 150, $y + 4, 27, 18)
$y += 22
$g_hChkCheckGameLanguage = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkCheckGameLanguage", "Check Game Language (EN)"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkCheckGameLanguage_Info_01", "Check if the Game is set to the correct language (Must be set to English)."))
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 22
$g_hChkAutoAlign = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutoAlign", "Auto Align"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutoAlign_Info_01", "Reposition/Align Android Emulator and BOT windows on the screen.")
GUICtrlSetOnEvent(-1, "chkDisposeWindows")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblAlignOffsetX", "Offset") & ":", $x + 85, $y + 4, -1, -1)
$g_hTxtAlignOffsetX = GUICtrlCreateInput("", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "TxtAlignOffsetX_Info_01", "Offset horizontal pixels between Android Emulator and BOT windows.")
$g_hTxtAlignOffsetY= GUICtrlCreateInput("", $x + 150, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "TxtAlignOffsetY_Info_01", "Offset vertical pixels between Android Emulator and BOT windows.")
$y += 23
$g_hCmbAlignmentOptions = GUICtrlCreateCombo("", $x, $y, 175, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_01", "0,0: Android Emulator-Bot") & "|" & GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_02", "0,0: Bot-Android Emulator") & "|" & GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_03", "SNAP: Bot TopRight to Android") &"|" & GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_04", "SNAP: Bot TopLeft to Android") & "|" & GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_05", "SNAP: Bot BottomRight to Android") & "|" & GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_06", "SNAP: Bot BottomLeft to Android") & "|" & GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_07", "DOCK: Android into Bot"), GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_07", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Info_01", "0,0: Reposition Android Emulator screen to position 0,0 on windows desktop and align Bot window right or left to it.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Info_02", "SNAP: Only reorder windows, Align Bot window to Android Emulator window at Top Right, Top Left, Bottom Right or Bottom Left.\r\n" & "DOCK: Integrate Android Screen into bot window."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 52
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_08", "Processor/Thread Advanced"), $x - 20, $y - 20, 210, 85)
$y -= 2
$g_hTxtGlobalActiveBotsAllowed = GUICtrlCreateInput($g_iGlobalActiveBotsAllowed, $x, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "TxtGlobalActiveBotsAllowed_Info_01", "When running multiple bots, specify how many can run at the same time.\r\nThis reduces your CPU utilization significantly.\r\nHalf of available logical processors is a good number.\r\nThis configuration is shared across all profiles/instances and a restart of all bots is required (close all, wait, and start all again!).")
GUICtrlSetOnEvent(-1, "txtGlobalActiveBotsAllowed")
GUICtrlSetLimit(-1, 2)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblGlobalActiveBotsAllowed_Info_01", "Bots can run at the same time"), $x + 30, $y + 3)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
$g_hTxtGlobalThreads = GUICtrlCreateInput($g_iGlobalThreads, $x, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "TxtGlobalThreads_Info_01", "When running multiple bots, specify how many global threads for image processing tasks can run at the same time.\r\nThis reduces your CPU utilization significantly.\r\nHalf of available logical processors is a good number.\r\nThis configuration is shared across all profiles/instances and a restart of all bots is required (close all, wait, and start all again!).")
GUICtrlSetOnEvent(-1, "txtGlobalThreads")
GUICtrlSetLimit(-1, 2)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblGlobalThreads_Info_01", "Image Threads for all bots"), $x + 30, $y + 3)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
$g_hTxtThreads = GUICtrlCreateInput($g_iThreads, $x, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "TxtThreads_Info_01", "When images are processed, multiple threads are used. Here you specifiy how many threads this bot can use.\r\nLess threads reduce your CPU utilization significantly.\r\nHalf of available logical processors is a good number. Use 0 for all available. Global threads setting has priority.")
GUICtrlSetOnEvent(-1, "txtThreads")
GUICtrlSetLimit(-1, 2)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblThreads_Info_01", "Image Threads for this bot"), $x + 30, $y + 3)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 240, $y = 45, $yGroup = $y
Local $hGroup = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_04", "Advanced"), $x - 20, $y - 20, 225, 140)
$g_hChkBotCustomTitleBarClick = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkBotCustomTitleBarClick", "My Bot design Title Bar"), $x, $y, -1, -1)
If BitAND($g_iBotDesignFlags, 1) Then GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkBotCustomTitleBarClick")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkBotCustomTitleBarClick_Info_01", "Enable optimized My Bot Window Title Bar and\r\nthin Window Border (restart of bot is required)"))
$y += 19
$g_hChkBotAutoSlideClick = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkBotAutoSlideClick", "Auto Slide when docked"), $x, $y, -1, -1)
If BitAND($g_iBotDesignFlags, 1) = 0 Then GUICtrlSetState(-1, $GUI_DISABLE)
If BitAND($g_iBotDesignFlags, 2) Then GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkBotAutoSlideClick")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkBotAutoSlideClick_Info_01", "Enable auto sliding when Android is docked\r\non bot window activation/deactivation"))
$y += 19
$g_hChkHideWhenMinimized = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkHideWhenMinimized", "Hide when minimized"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkHideWhenMinimized")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkHideWhenMinimized_Info_01", "Hide bot window in taskbar when minimized.\r\nUse trayicon 'Show bot' to display bot window again."))
$y += 19
$g_hChkAutoResume = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutoResume", "Auto resume Bot after") & ":", $x, $y, -1, -1)
_GUICtrlSetTip(-1,GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutoResume_Info_01", "This will auto resume your bot after x minutes"))
GUICtrlSetOnEvent(-1, "chkAutoResume")
$g_hTxtAutoResumeTime = GUICtrlCreateInput("5",$x + 132, $y + 2, 30, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "min.", -1), $x + 167, $y + 4, -1, -1)
$y += 19
$g_hChkDisableNotifications = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDisableNotifications", "Disable Notifications"), $x, $y, -1, -1)
_GUICtrlSetTip(-1,GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDisableNotifications_Info_01", "Disable Notifications sent by the Bot"))
GUICtrlSetOnEvent(-1, "chkDisableNotifications")
$y += 19
$g_hChkUseRandomClick = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkUseRandomClick", "Random Click"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkUseRandomClick")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_05", "Photo Screenshot Options"), $x - 20, $y - 17, 225, 60)
$g_hChkScreenshotType = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkScreenshotType", "Make in PNG format"), $x, $y, -1, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkScreenshotType")
$y += 19
$g_hChkScreenshotHideName = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkScreenshotHideName", "Hide Village and Clan Castle Name"), $x, $y, -1, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkScreenshotHideName")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 48
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_06", "Remote Device"), $x - 20, $y - 20 , 225, 42)
$y -= 5
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblTimeAnotherDevice", "When 'Another Device' wait") & ":", $x - 10, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblTimeAnotherDevice_Info_01", "Enter the time to wait (in Minutes) before the Bot reconnects when another device took control.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtTimeAnotherDevice = GUICtrlCreateInput("2", $x + 132, $y, 30, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "min.", -1), $x + 167, $y + 2, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 51
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_07", "Other Options"), $x - 20, $y - 20, 225, 85)
$g_hChkSinglePBTForced = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkSinglePBTForced", "Force Single PB logoff"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkSinglePBTForced")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkSinglePBTForced_Info_01", "This forces bot to exit CoC only one time prior to normal start of PB"))
$g_hTxtSinglePBTimeForced = GUICtrlCreateInput("18", $x + 132, $y + 2, 30, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "TxtSinglePBTimeForced_Info_01", "Type in number of minutes to keep CoC closed. Set to 15 minimum to reset PB timer!"))
GUICtrlSetOnEvent(-1, "txtSinglePBTimeForced")
GUICtrlSetLimit(-1, 3)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "min.", -1), $x + 167, $y + 4, -1, -1)
$y += 20
GUICtrlCreateLabel( GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblPBTimeForcedExit", "Subtract time for early PB exit"), $x - 10, $y + 3)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblPBTimeForcedExit_Info_01", "Type in number of minutes to quit CoC early! Setting below 10 minutes may not function!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtPBTimeForcedExit = GUICtrlCreateInput("16", $x + 132, $y, 30, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "txtSinglePBTimeForced")
GUICtrlSetLimit(-1, 3)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "min.", -1), $x + 167, $y + 3, -1, -1)
$y += 20
$g_hChkFixClanCastle = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkFixClanCastle", "Force Clan Castle Detection"), $x, $y + 2, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkFixClanCastle_Info_01", "If clan Castle it is undetected and it is NOT placed in the last slot, force bot to consider the undetected slot as Clan Castle"))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hCmbCOCDistributors = 0, $g_hCmbAndroidBackgroundMode = 0, $g_hCmbSuspendAndroid = 0, $g_hChkAndroidAdbClickDragScript = 0, $g_hBtnAndroidAdbShell = 0, $g_hBtnAndroidHome = 0, $g_hBtnAndroidBack = 0, $g_hTxtAndroidRebootHours = 0, $g_hChkAndroidCloseWithBot = 0
Func CreateBotAndroid()
Local $x = 25, $y = 45, $y2, $w = 240, $h = 50, $sTxtTip
GUICtrlCreateGroup(GetTranslatedFileIni("MBR Distributors", "Group_01", "Distributors"), $x - 20, $y - 20, $w, $h)
$y -= 2
$g_hCmbCOCDistributors = GUICtrlCreateCombo("", $x - 8, $y, $w - 25, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Distributors", "CmbCOCDistributors_Info_01", "Allow bot to launch COC based on the distribution chosen"))
GUICtrlSetOnEvent(-1, "cmbCOCDistributors")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += $h + 5
$y2 = $y
$w = $g_iSizeWGrpTab2 - 2
$h = 121
GUICtrlCreateGroup(GetTranslatedFileIni("Android", "Android_Options", "Android Options"), $x - 20, $y - 20, $w, $h)
GUICtrlCreateLabel(GetTranslatedFileIni("Android", "LblBackgroundMode", "Screencapture Background Mode"), $x - 8, $y + 5, 180, 22, $SS_RIGHT)
$g_hCmbAndroidBackgroundMode = GUICtrlCreateCombo("", $x - 8 + 180 + 5, $y, 200, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("Android", "CmbBackgroundMode", "Default|Use WinAPI (need Android DirectX)|Use ADB screencap"))
_GUICtrlSetTip(-1, GetTranslatedFileIni("Android", "CmbBackgroundMode_Info", 'Control how the Android screenshot is taken in background mode.\nDefault chooses WinAPI or screencap based on Android Emulator.\nInfo: WinAPI is faster than screencap, but screencap always works,\neven if screen is off (we call that the "True Background Mode")!'))
_GUICtrlComboBox_SetCurSel(-1, $g_iAndroidBackgroundMode)
GUICtrlSetOnEvent(-1, "cmbAndroidBackgroundMode")
$y += 25
$g_hChkAndroidAdbClickDragScript = GUICtrlCreateCheckbox(GetTranslatedFileIni("Android", "ChkAdbClickDragScript", "Use script for accurate Click && Drag"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("Android", "ChkAdbClickDragScript_Info", "Use Android specific script file for Click & Drag.\r\nIf unchecked use more compatible 'input swipe'."))
GUICtrlSetState(-1,(($g_bAndroidAdbClickDragScript) ?($GUI_CHECKED) :($GUI_UNCHECKED)))
$y += 25
$g_hChkAndroidCloseWithBot = GUICtrlCreateCheckbox(GetTranslatedFileIni("Android", "ChkAndroidCloseWithBot", "Close Android with bot"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("Android", "ChkAndroidCloseWithBot_Info", "Close also Android Emulator when bot exists."))
GUICtrlSetState(-1,(($g_bAndroidCloseWithBot) ?($GUI_CHECKED) :($GUI_UNCHECKED)))
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("Android", "LblAndroidRebootHours", "Reboot Android in") & ":", $x + 17, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("Android", "LblAndroidRebootHours_Info", "Enter hours when Android will be automatically rebooted after specified run-time.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtAndroidRebootHours = GUICtrlCreateInput($g_iAndroidRebootHours, $x + 177, $y + 1, 30, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "hrs", -1), $x + 212, $y + 2, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y = $y2 + $h + 5
$w = $g_iSizeWGrpTab2 - 2
$h = 50
GUICtrlCreateGroup(GetTranslatedFileIni("MBR Distributors", "Group_02", "Advanced Android Options"), $x - 20, $y - 20, $w, $h)
$y -= 2
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Distributors", "LblAdvanced_Android_Options", "Suspend/Resume Android"), $x - 8, $y + 5, 180, 22, $SS_RIGHT)
$g_hCmbSuspendAndroid = GUICtrlCreateCombo("", $x - 8 + 180 + 5, $y, 200, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR Distributors", "CmbSuspendAndroid_Item_01", "Disabled|Only during Search/Attack|For every Image processing call"))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Distributors", "CmbSuspendAndroid_Info_01", 'Specify if Android will be suspended for brief time only during search and attack or\r\nfor every ImgLoc/Image processing call. If you experience more frequent network issues\r\ntry to use "Only during Search/Attack" option or disable this feature.'))
_GUICtrlComboBox_SetCurSel(-1, AndroidSuspendFlagsToIndex($g_iAndroidSuspendModeFlags))
GUICtrlSetOnEvent(-1, "cmbSuspendAndroid")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += $h + 5
$y2 = $y
$w = 240
$h = 80
GUICtrlCreateGroup(GetTranslatedFileIni("Android Control", "Group_03", "Android Control"), $x - 20, $y - 20, $w, $h)
$y -= 2
$g_hBtnAndroidAdbShell = GUICtrlCreateButton(GetTranslatedFileIni("Android Control", "BtnAndroidAdbShell", "Start ADB Shell in new Console Window"), $x - 8, $y, 220, 25)
GUICtrlSetOnEvent(-1, "OpenAdbShell")
$y += 30
$g_hBtnAndroidHome = GUICtrlCreateButton(GetTranslatedFileIni("Android Control", "BtnAndroidHome", "Send Home"), $x - 8, $y, 105, 25)
GUICtrlSetOnEvent(-1, "AndroidHomeButton")
$g_hBtnAndroidBack = GUICtrlCreateButton(GetTranslatedFileIni("Android Control", "BtnAndroidBack", "Send Back"), $x - 8 + 115, $y, 105, 25)
GUICtrlSetOnEvent(-1, "AndroidBackButton")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25 + 240 + 10 + 30
$y = $y2
$w = 125
$h = 80
GUICtrlCreateGroup(GetTranslatedFileIni("Android Control", "Group_04", "Install Play Store Apps"), $x - 20, $y - 20, $w, $h)
$y -= 2
GUICtrlCreateButton(GetTranslatedFileIni("Android Control", "BtnPlayStoreGame", "Clash of Clans"), $x - 8, $y, 100, 25)
GUICtrlSetOnEvent(-1, "OpenPlayStoreGame")
$y += 30
GUICtrlCreateButton(GetTranslatedFileIni("Android Control", "BtnPlayStoreNovaLauncher", "Nova Launcher"), $x - 8, $y, 100, 25)
GUICtrlSetOnEvent(-1, "OpenPlayStoreNovaLauncher")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 130
$x -= 60
GUICtrlCreateLabel("Command line Help ?", $x - 20, $y - 20, 220, 24, $SS_RIGHT)
GUICtrlSetOnEvent(-1, "ShowCommandLineHelp")
GUICtrlSetCursor(-1, 0)
GUICtrlSetFont(-1, 8.5, $FW_BOLD)
_GUICtrlSetTip(-1, "Click here to get help about command line and option for MyBot.run!")
GUICtrlSetColor(-1, $COLOR_NAVY)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkDebugSetlog = 0, $g_hChkDebugAndroid = 0, $g_hChkDebugClick = 0, $g_hChkDebugOCR = 0, $g_hChkDebugImageSave = 0, $g_hChkdebugBuildingPos = 0, $g_hChkdebugTrain = 0, $g_hChkDebugOCRDonate = 0
Global $g_hChkdebugAttackCSV = 0, $g_hChkMakeIMGCSV = 0, $g_hChkDebugDisableZoomout = 0, $g_hChkDebugDisableVillageCentering = 0, $g_hChkDebugDeadbaseImage = 0, $g_hChkDebugFunc = 0
Global $g_hBtnTestTrain = 0, $g_hBtnTestDonateCC = 0, $g_hBtnTestRequestCC = 0, $g_hBtnTestSendText = 0, $g_hBtnTestAttackBar = 0, $g_hBtnTestClickDrag = 0, $g_hBtnTestImage = 0
Global $g_hBtnTestVillageSize = 0, $g_hBtnTestDeadBase = 0, $g_hBtnTestTHimgloc = 0, $g_hBtnTestTrainsimgloc = 0, $g_hBtnTestQuickTrainsimgloc = 0, $g_hTxtTestFindButton = 0
Global $g_hBtnTestFindButton = 0, $g_hBtnTestDeadBaseFolder = 0, $g_hBtnTestCleanYard = 0, $g_hBtnTestAttackCSV = 0, $g_hBtnTestimglocTroopBar = 0, $g_hBtnTestBuildingLocation = 0
Global $g_hBtnTestConfigSave = 0, $g_hBtnTestConfigApply = 0, $g_hBtnTestConfigRead = 0, $g_hBtnTestOcrMemory = 0, $g_hBtnTestWeakBase = 0, $g_hBtnTestClickAway = 0, $g_hBtnTestAutoUpgrade = 0
Global $g_hBtnTestUpgradeWindow = 0, $g_hBtnTestSmartWait = 0, $g_hBtnConsoleWindow = 0
Func CreateBotDebug()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "Group_01", "Debug"), $x - 20, $y - 20, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2)
$g_hChkDebugSetlog = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugSetlog", "Messages"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugSetlog_Info _01", "Debug: Enables debug SetLog messages in code for Troubleshooting."))
$y += 20
$g_hChkDebugAndroid = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugAndroid", "Android"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugAndroid_Info _01", "Debug: Enables additional log debug messages for Android operations."))
$y += 20
$g_hChkDebugClick = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugClick", "Click"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugClick_Info _01", "Debug: Write the clicked (x,y) coordinates to the log."))
$y += 20
$g_hChkDebugFunc = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugFunc", "Functions"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugFunc_Info _01", "Debug: Enables debug function times and call hierarchy."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugOCR = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugOCR", "OCR"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugOCR_Info _01", "Debug: Enables Saving OCR images for troubleshooting."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugImageSave = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugImageSave", "Images"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugImageSave_Info _01", "Debug: Enables Saving images for troubleshooting."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkdebugBuildingPos = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkdebugBuildingPos", "Buildings"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkdebugBuildingPos_Info _01", "Debug: Enables showing positions of buildings in log."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkdebugTrain = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkdebugTrain", "Training"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkdebugTrain_Info _01", "Debug: Enables showing debug during training."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugOCRDonate = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugOCRDonate", "Online debug donations"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugOCRDonate_Info _01", "Debug: make ocr of donations and simulate only donate but no donate any troop"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkdebugAttackCSV = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkdebugAttackCSV", "Attack CSV"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkdebugAttackCSV_Info _01", "Debug: Generates special CSV parse log files"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkMakeIMGCSV = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkMakeIMGCSV", "Attack CSV Image"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkMakeIMGCSV_Info _01", "Debug: Enables saving clean and location marked up images of bases attacked by CSV scripts"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugDisableZoomout = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugDisableZoomout", "Disable Zoomout"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugDisableZoomout_Info _01", "Debug: Disables zoomout of village."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugDisableVillageCentering = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugDisableVillageCentering", "Disable Village Centering"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugDisableVillageCentering_Info _01", "Debug: Disables centering of village."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugDeadbaseImage = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugDeadbaseImage", "Deadbase Image save"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugDeadbaseImage_Info _01", "Debug: Saves images of skipped deadbase villages."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugSmartZap = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugSmartZap", "Debug SmartZap"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugSmartZap_Info _01", "Use it to debug SmartZap"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
Local $x = 300
$y = 40
Local $yNext = 30
$g_hBtnTestTrain = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestTrain", "Test Train"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestDonateCC = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestDonateCC", "Test Donate"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestRequestCC = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestRequestCC", "Test Request"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestAttackBar = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestAttackBar", "Test Attack Bar"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestClickDrag = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestClickDrag", "Test Click Drag"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestImage = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestImage", "Test Image"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestVillageSize = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestVillageSize", "Test Village Size"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestDeadBase = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestDeadBase", "Test Dead Base"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestTHimgloc = GUICtrlCreateButton("imgloc TH", $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestTrainsimgloc = GUICtrlCreateButton("New Train Test", $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestQuickTrainsimgloc = GUICtrlCreateButton("Quick Train Test", $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestOcrMemory = GUICtrlCreateButton("OCR Memory Test", $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestSmartWait = GUICtrlCreateButton("Smart Wait Test", $x, $y, 140, 25)
$x -= 145
$g_hTxtTestFindButton = GUICtrlCreateInput("BoostOne", $x - 90, $y + 3, 85, 20)
$g_hBtnTestFindButton = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "TestFindButton", "Test Find Button"), $x, $y, 140, 25)
$y -= $yNext
$g_hBtnTestDeadBaseFolder = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestDeadBaseFolder", "Test Dead Base Folder"), $x, $y, 140, 25)
$g_hBtnTestCleanYard = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestCleanYard", "Test Clean Yard"), $x - 145, $y, 140, 25)
$y -= $yNext
$g_hBtnTestAttackCSV = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestAttackCSV", "Test Attack CSV"), $x, $y, 140, 25)
$g_hBtnTestBuildingLocation = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestBuildingLocation", "Find Building"), $x - 145, $y, 140, 25)
$y -= $yNext
$g_hBtnTestimglocTroopBar = GUICtrlCreateButton("IMGLOC ATTACKBAR", $x, $y, 140, 25)
$y -= $yNext
$g_hBtnTestConfigSave = GUICtrlCreateButton("Config Save", $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestConfigApply = GUICtrlCreateButton("Config Apply", $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestConfigRead = GUICtrlCreateButton("Config Read", $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestSendText = GUICtrlCreateButton("Send Text", $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestWeakBase = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "TestWeakBase", "Test Weak Base"), $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestClickAway = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "TestClickAway", "Test Click Away"), $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestAutoUpgrade = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "TestAutoUpgrade", "Test Auto Upgrade"), $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestUpgradeWindow = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "TestUpgradeWindow", "Test Upgrade Window"), $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnConsoleWindow = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ConsoleWindow", "Show/hide Console"), $x + 20, $y, 120, 25)
$y -= $yNext
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hCmbProfile = 0, $g_hTxtVillageName = 0, $g_hBtnAddProfile = 0, $g_hBtnConfirmAddProfile = 0, $g_hBtnConfirmRenameProfile = 0, $g_hBtnDeleteProfile = 0, $g_hBtnCancelProfileChange = 0, $g_hBtnRenameProfile = 0, $g_hBtnPullSharedPrefs = 0, $g_hBtnPushSharedPrefs = 0
Global $g_hChkSwitchAcc = 0, $g_hCmbSwitchAcc = 0, $g_hChkSharedPrefs = 0, $g_hCmbTotalAccount = 0, $g_hChkSmartSwitch = 0, $g_hCmbTrainTimeToSkip = 0, $g_hChkDonateLikeCrazy = 0, $g_ahChkAccount[8], $g_ahCmbProfile[8], $g_ahChkDonate[8], $g_hRadSwitchGooglePlay = 0, $g_hRadSwitchSuperCellID = 0, $g_hRadSwitchSharedPrefs = 0
Func CreateBotProfiles()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Group_01", "Switch Profiles"), $x - 20, $y - 20, $g_iSizeWGrpTab2, 55)
$x -= 5
$g_hCmbProfile = GUICtrlCreateCombo("", $x - 3, $y + 1, 130, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "CmbProfile_Info_01", "Use this to switch to a different profile")& @CRLF & GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "CmbProfile_Info_02", "Your profiles can be found in") & ": " & @CRLF & $g_sProfilePath)
setupProfileComboBox()
PopulatePresetComboBox()
GUICtrlSetState(-1, $GUI_SHOW)
GUICtrlSetOnEvent(-1, "cmbProfile")
$g_hTxtVillageName = GUICtrlCreateInput(GetTranslatedFileIni("MBR Popups", "MyVillage", "MyVillage"), $x - 3, $y, 130, 22, $ES_AUTOHSCROLL)
GUICtrlSetLimit(-1, 100, 0)
GUICtrlSetFont(-1, 9, 400, 1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "TxtVillageName_Info_01", "Your village/profile's name"))
GUICtrlSetState(-1, $GUI_HIDE)
Static $bIconAdd = 0
If $bIconAdd = 0 Then
$bIconAdd = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconAdd, @ScriptDir & "\images\Button\iconAdd.bmp")
EndIf
Static $bIconConfirm = 0
If $bIconConfirm = 0 Then
$bIconConfirm = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconConfirm, @ScriptDir & "\images\Button\iconConfirm.bmp")
EndIf
Static $bIconDelete = 0
If $bIconDelete = 0 Then
$bIconDelete = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconDelete, @ScriptDir & "\images\Button\iconDelete.bmp")
EndIf
Static $bIconCancel = 0
If $bIconCancel = 0 Then
$bIconCancel = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconCancel, @ScriptDir & "\images\Button\iconCancel.bmp")
EndIf
Static $bIconEdit = 0
If $bIconEdit = 0 Then
$bIconEdit = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconEdit, @ScriptDir & "\images\Button\iconEdit.bmp")
EndIf
Static $bIconPush = 0
If $bIconPush = 0 Then
$bIconPush = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconPush, @ScriptDir & "\images\Button\iconPush.bmp")
EndIf
Static $bIconPull = 0
If $bIconPull = 0 Then
$bIconPull = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconPull, @ScriptDir & "\images\Button\iconPull.bmp")
EndIf
$g_hBtnAddProfile = GUICtrlCreateButton("", $x + 135, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnAddProfile, $bIconAdd, 4)
GUICtrlSetOnEvent(-1, "btnAddConfirm")
GUICtrlSetState(-1, $GUI_SHOW)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnAddProfile_Info_01", "Add New Profile"))
$g_hBtnConfirmAddProfile = GUICtrlCreateButton("", $x + 135, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnConfirmAddProfile, $bIconConfirm, 4)
GUICtrlSetOnEvent(-1, "btnAddConfirm")
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnConfirmAddProfile_Info_01", "Confirm"))
$g_hBtnConfirmRenameProfile = GUICtrlCreateButton("", $x + 135, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnConfirmRenameProfile, $bIconConfirm, 4)
GUICtrlSetOnEvent(-1, "btnRenameConfirm")
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnConfirmAddProfile_Info_01", -1))
$g_hBtnDeleteProfile = GUICtrlCreateButton("", $x + 164, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnDeleteProfile, $bIconDelete, 4)
GUICtrlSetOnEvent(-1, "btnDeleteCancel")
GUICtrlSetState(-1, $GUI_SHOW)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnDeleteProfile_Info_01", "Delete Profile"))
$g_hBtnCancelProfileChange = GUICtrlCreateButton("", $x + 164, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnCancelProfileChange, $bIconCancel, 4)
GUICtrlSetOnEvent(-1, "btnDeleteCancel")
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnCancelProfileChange_Info_01", "Cancel"))
$g_hBtnRenameProfile = GUICtrlCreateButton("", $x + 194, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnRenameProfile, $bIconEdit, 4)
GUICtrlSetOnEvent(-1, "btnRenameConfirm")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnRenameProfile_Info_01", "Rename Profile"))
$g_hBtnPullSharedPrefs = GUICtrlCreateButton("", $x + 224, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnPullSharedPrefs, $bIconPull, 4)
GUICtrlSetOnEvent(-1, "btnPullSharedPrefs")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnPullSharedPrefs_Info_01", "Pull CoC shared_prefs folder"))
$g_hBtnPushSharedPrefs = GUICtrlCreateButton("", $x + 254, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnPushSharedPrefs, $bIconPush, 4)
GUICtrlSetOnEvent(-1, "btnPushSharedPrefs")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnPushSharedPrefs_Info_01", "Push CoC shared_prefs folder"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 25, $y = 105
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Group_02", "Switch Accounts"), $x - 20, $y - 20, $g_iSizeWGrpTab2, $g_iSizeHGrpTab4)
$x -= 8
$g_hCmbSwitchAcc = GUICtrlCreateCombo("", $x, $y, 175, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
Local $s = "No Switch Accounts Group"
For $i = 1 To UBound($g_ahChkAccount)
$s &= "|Switch Accounts Group " & $i
Next
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "CmbSwitchAcc", $s), "No Switch Accounts Group")
GUICtrlSetOnEvent(-1, "cmbSwitchAcc")
$y += 25
$g_hChkSwitchAcc = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "ChkSwitchAcc", "Enable Switch Accounts"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkSwitchAcc")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "ChkSwitchAcc_Info_01", "Enable or disable current selected Switch Accounts Group"))
$g_hCmbTotalAccount = GUICtrlCreateCombo("", $x + 345, $y - 1, 77, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "2 accounts|3 accounts|4 accounts|5 accounts|6 accounts|7 accounts|8 accounts", "2 accounts")
GUICtrlSetOnEvent(-1, "cmbTotalAcc")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "CmbTotalAccount", "Total CoC Accounts") & ": ", $x + 220, $y + 4, -1, -1)
$g_hRadSwitchGooglePlay = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "RadSwitchGooglePlay", "Google Play"), $x + 185, $y - 30, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "RadSwitchGooglePlay_Info_01", "Only support for all Google Play accounts"))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkAccSwitchMode")
$g_hRadSwitchSuperCellID = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "RadSwitchSuperCellID", "SuperCell ID"), $x + 265, $y - 30, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "RadSwitchSuperCellID_Info_01", "Only support for all SuperCell ID accounts"))
GUICtrlSetOnEvent(-1, "chkAccSwitchMode")
$g_hRadSwitchSharedPrefs = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "RadSwitchSharedPrefs", "Shared_prefs"), $x + 345, $y - 30, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "RadSwitchSharedPrefs_Info_01", "Support for Google Play and SuperCell ID accounts"))
GUICtrlSetOnEvent(-1, "chkAccSwitchMode")
$y += 23
$g_hChkSmartSwitch = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "ChkSmartSwitch", "Smart switch"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "ChkSmartSwitch_Info_01", "Switch to account with the shortest remain training time"))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkSmartSwitch")
$g_hChkDonateLikeCrazy = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "DonateLikeCrazy", "Donate like Crazy"), $x + 100, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "DonateLikeCrazy_Info_01", "Enable it allows account switching in the order: Donate - Shortest Active - Donate - Shortest Active  - Donate...!"))
GUICtrlSetOnEvent(-1, "chkSmartSwitch")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "CmbTrainTime", "Skip switch if train time") & " <", $x + 220, $y + 4, -1, -1)
$g_hCmbTrainTimeToSkip = GUICtrlCreateCombo("", $x + 345, $y - 1, 77, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0 minute|1 minute|2 minutes|3 minutes|4 minutes|5 minutes|6 minutes|7 minutes|8 minutes|9 minutes", "1 minute")
$y += 23
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Description", "Using Switch Accounts requires that not more Google Accounts are registered in Android than configured here. " & "Maximum of 8 Google/CoC Accounts is supported."), $x, $y, $g_iSizeWGrpTab2 - 20, 42, $SS_CENTER)
$y += 29
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Label_01", "Accounts"), $x - 5, $y, 60, -1, $SS_CENTER)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Label_02", "Profile name"), $x + 82, $y, 70, -1, $SS_CENTER)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Label_03", "Donate only"), $x + 170, $y, 60, -1, $SS_CENTER)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Label_04", "SwitchAcc log"), $x + 285, $y, -1, -1, $SS_CENTER)
$y += 14
GUICtrlCreateGraphic($x, $y, 422, 1, $SS_GRAYRECT)
$y += 7
For $i = 0 To UBound($g_ahChkAccount) - 1
$g_ahChkAccount[$i] = GUICtrlCreateCheckbox("Acc " & $i + 1 & ".", $x, $y +($i) * 25, -1, -1)
GUICtrlSetOnEvent(-1, "chkAccountX")
$g_ahCmbProfile[$i] = GUICtrlCreateCombo("", $x + 65, $y +($i) * 25, 110, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "cmbSwitchAccProfileX")
GUICtrlSetData(-1, _GUICtrlComboBox_GetList($g_hCmbProfile))
$g_ahChkDonate[$i] = GUICtrlCreateCheckbox("", $x + 190, $y +($i) * 25 - 3, -1, 25)
Next
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_STATS = 0, $g_hGUI_STATS_TAB = 0, $g_hGUI_STATS_TAB_ITEM1 = 0, $g_hGUI_STATS_TAB_ITEM2 = 0, $g_hGUI_STATS_TAB_ITEM3 = 0, $g_hGUI_STATS_TAB_ITEM4 = 0, $g_hGUI_STATS_TAB_ITEM5 = 0
Global $btnResetStats = 0
Global $g_ahPicTHLevels[13], $g_hLblTHLevels = 0
Global $g_ahPicLeague[$eLeagueCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0], $g_hLblLeague = 0
Global $g_ahLblStatsStartedWith[$eLootCount] = [0, 0, 0, 0], $g_ahLblStatsGainPerHour[$eLootCount] = [0, 0, 0, 0]
Global $g_ahLblStatsTotalGain[$eLootCount] = [0, 0, 0, 0], $g_ahLblStatsLastAttack[$eLootCount] = [0, 0, 0, 0]
Global $g_ahLblStatsBonusLast[$eLootCount] = [0, 0, 0, 0], $g_ahLblStatsTop[$eLootCount] = [0, 0, 0, 0]
Global $g_hPicResultDEStart = 0, $g_hLblStatsSZRev1 = 0, $g_hLblStatsSZRev2 = 0, $g_hPicHourlyStatsDark = 0, $g_hPicDarkLoot = 0, $g_hPicDarkLastAttack = 0
Global $g_hLblResultRuntime = 0, $g_hLblNbrOfOoS = 0, $g_hLblResultVillagesAttacked = 0, $g_hLblResultVillagesSkipped = 0, $g_hLblResultTrophiesDropped = 0
Global $g_hLblSearchCost = 0, $g_hLblTrainCostElixir = 0, $g_hLblTrainCostDElixir = 0, $g_hLblGoldFromMines = 0, $g_hLblElixirFromCollectors = 0, $g_hLblDElixirFromDrills = 0
Global $g_hLblWallGoldMake = 0, $g_hLblWallElixirMake = 0, $g_hLblNbrOfBuildingUpgGold = 0, $g_hLblNbrOfBuildingUpgElixir = 0, $g_hLblNbrOfHeroUpg = 0
Global $g_hLblWallUpgCostGold = 0, $g_hLblWallUpgCostElixir = 0, $g_hLblBuildingUpgCostGold = 0, $g_hLblBuildingUpgCostElixir = 0, $g_hLblHeroUpgCost = 0
Global $g_hLblAttacked[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblTotalGoldGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblTotalElixirGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblTotalDElixirGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblTotalTrophyGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblNbrOfTSSuccess = 0, $g_hLblNbrOfTSFailed = 0
Global $g_hLblNbrOfDetectedMines[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblNbrOfDetectedCollectors[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblNbrOfDetectedDrills[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblSmartZap = 0, $g_hLblSmartLightningUsed = 0, $g_hLblSmartEarthQuakeUsed = 0
Global $g_hLblDonTroop[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hLblDonSpell[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hLblTotalTroopsQ = 0, $g_hLblTotalTroopsXP = 0, $g_hLblTotalSpellsQ = 0, $g_hLblTotalSpellsXP = 0
Global $g_ahGrpVillageAcc[8], $g_ahLblTroopsTime[8]
Global $g_ahLblResultGoldNowAcc[8], $g_ahLblResultElixirNowAcc[8], $g_ahLblResultDENowAcc[8], $g_ahLblResultTrophyNowAcc[8], $g_ahLblResultBuilderNowAcc[8], $g_ahLblResultGemNowAcc[8], $g_ahLblResultAttacked[8], $g_ahLblPersonalBreak[8]
Global $g_ahLblHourlyStatsGoldAcc[8], $g_ahLblHourlyStatsElixirAcc[8], $g_ahLblHourlyStatsDarkAcc[8], $g_ahLblHourlyStatsTrophyAcc[8]
Func CreateBotStats()
GUISwitch($g_hGUI_STATS)
$g_hGUI_STATS_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$btnResetStats = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "BtnResetStats", "Reset Stats"), 375, 0, 60, 20)
GUICtrlSetOnEvent(-1, "btnResetStats")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hGUI_STATS_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_05_STab_01", "Gain"))
CreateGainSubTab()
$g_hGUI_STATS_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_05_STab_02", "Misc"))
CreateMiscSubTab()
$g_hGUI_STATS_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_05_STab_03", "Attacks"))
CreateAttacksSubTab()
$g_hGUI_STATS_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_05_STab_04", "Donations"))
CreateDonationsSubTab()
$g_hGUI_STATS_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_05_STab_05", "Multi Stats"))
CreateMultiStatsSubTab()
GUICtrlCreateTabItem("")
EndFunc
Func CreateGainSubTab()
Local $sTxtTip = ""
Local $xStart = 25, $yStart = 45
Local $x = $xStart, $y = $yStart
GUICtrlCreatePic(@ScriptDir & "\images\Stats\Stats001.jpg", $x - 18, $y - 20, 426, 80)
$x = $xStart + 276
$y = $yStart - 14
$g_ahPicTHLevels[4] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV04, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[5] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV05, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[6] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV06, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[7] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV07, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[8] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV08, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[9] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV09, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[10] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV10, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[11] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV11, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[12] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV12, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "LblTownhall", "TownHall"), $x - 11, $y, -1, -1, $SS_CENTER)
$g_hLblTHLevels = GUICtrlCreateLabel("", $x + 38, $y + 53, 17, 17, $SS_CENTER)
GUICtrlSetFont($g_hLblTHLevels, 11, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 340
$y = $yStart - 14
$g_ahPicLeague[$eLeagueUnranked] = _GUICtrlCreateIcon($g_sLibIconPath, $eUnranked, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_SHOW)
$g_ahPicLeague[$eLeagueBronze] = _GUICtrlCreateIcon($g_sLibIconPath, $eBronze, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicLeague[$eLeagueSilver] = _GUICtrlCreateIcon($g_sLibIconPath, $eSilver, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicLeague[$eLeagueGold] = _GUICtrlCreateIcon($g_sLibIconPath, $eGold, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicLeague[$eLeagueCrystal] = _GUICtrlCreateIcon($g_sLibIconPath, $eCrystal, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicLeague[$eLeagueMaster] = _GUICtrlCreateIcon($g_sLibIconPath, $eMaster, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicLeague[$eLeagueChampion] = _GUICtrlCreateIcon($g_sLibIconPath, $eChampion, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicLeague[$eLeagueTitan] = _GUICtrlCreateIcon($g_sLibIconPath, $eTitan, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicLeague[$eLeagueLegend] = _GUICtrlCreateIcon($g_sLibIconPath, $eLegend, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLeague", "League"), $x + 3, $y, -1, -1, $SS_CENTER)
$g_hLblLeague = GUICtrlCreateLabel("", $x + 43, $y + 53, 17, 17, $SS_CENTER)
GUICtrlSetFont(-1, 11, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 100
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStats", "Stats"), $x - 20, $y - 32, 87, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblGold", "Gold"), $x - 18 + 85, $y - 32, 95, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblElixir", "Elixir"), $x - 18 +(60 * 3), $y - 32, 75, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDarkE", "DarkE"), $x - 23 +(65 * 4), $y - 32, 90, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTrophy", "Trophy"), $x - 23 +(70 * 5), $y - 32, 75, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStartedWith", "Started with") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsStartedWith_Info_01", "The amount of Gold you had when the bot started.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsStartedWith[$eLootGold] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsStartedWith_Info_02", "The amount of Elixir you had when the bot started.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsStartedWith[$eLootElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
$g_hPicResultDEStart = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsStartedWith_Info_03", "The amount of Dark Elixir you had when the bot started.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsStartedWith[$eLootDarkElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsStartedWith_Info_04", "The amount of Trophies you had when the bot started.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsStartedWith[$eLootTrophy] = GUICtrlCreateLabel("0", $x - 18 + 5, $y - 12, 60, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 125
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblGainPerHour", "Gain per Hour") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsGainPerHour_Info_01", "Gold gain per hour")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsGainPerHour[$eLootGold] = GUICtrlCreateLabel("0/h", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsGainPerHour_Info_02", "Elixir gain per hour")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsGainPerHour[$eLootElixir] = GUICtrlCreateLabel("0/h", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
$g_hPicHourlyStatsDark = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsGainPerHour_Info_03", "Dark Elixir gain per hour")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsGainPerHour[$eLootDarkElixir] = GUICtrlCreateLabel("0/h", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsGainPerHour_Info_04", "Trophy gain per hour")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsGainPerHour[$eLootTrophy] = GUICtrlCreateLabel("0/h", $x - 18 + 5, $y - 12, 60, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 150
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTotalGain", "Total Gain") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTotalGain_Info_01", "The total amount of Gold you gained or lost while the Bot is running.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTotalGain_Info_02", "(This includes manual spending of resources on upgrade of buildings)")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTotalGain[$eLootGold] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTotalGain_Info_03", "The total amount of Elixir you gained or lost while the Bot is running.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTotalGain_Info_02", "(This includes manual spending of resources on upgrade of buildings)")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTotalGain[$eLootElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
$g_hPicDarkLoot = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTotalGain_Info_04", "The total amount of Dark Elixir you gained or lost while the Bot is running.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTotalGain_Info_02", "(This includes manual spending of resources on upgrade of buildings)")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTotalGain[$eLootDarkElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTotalGain_Info_05", "The amount of Trophies you gained or lost while the Bot is running.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTotalGain[$eLootTrophy] = GUICtrlCreateLabel("0", $x - 18 + 5, $y - 12, 60, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 195
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLastAttack", "Last Attack") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsLastAttack_Info_01", "The amount of Gold you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsLastAttack[$eLootGold] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsLastAttack_Info_02", "The amount of Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsLastAttack[$eLootElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
$g_hPicDarkLastAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsLastAttack_Info_03", "The amount of Dark Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsLastAttack[$eLootDarkElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsLastAttack_Info_04", "The amount of Trophies you gained or lost on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsLastAttack[$eLootTrophy] = GUICtrlCreateLabel("0", $x - 18 + 5, $y - 12, 60, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 220
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLeagueBonus", "League Bonus") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsBonusLast_Info_01", "The amount of Bonus Gold you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsBonusLast[$eLootGold] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsBonusLast_Info_02", "The amount of Bonus Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsBonusLast[$eLootElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsBonusLast_Info_03", "The amount of Bonus Dark Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsBonusLast[$eLootDarkElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 265
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTopLoot", "Top Loot") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTop_Info_01","Top Gold gained")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTop[$eLootGold] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTop_Info_02", "Top Elixir gained")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTop[$eLootElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTop_Info_03", "Top Dark gained")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTop[$eLootDarkElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTop_Info_04", "Top Trophy gained")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTop[$eLootTrophy] = GUICtrlCreateLabel("0", $x - 18 + 5, $y - 12, 60, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateMiscSubTab()
Local $sTxtTip = ""
Local $xStart = 25, $yStart = 45
Local $x = $xStart + 3, $y = $yStart + 20
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblRun", "Run"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblCost-Collect", "Cost && Collect"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
$x -= 10
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblRuntime_Info_01", "The total Running Time of the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblRuntime", "Runtime") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblResultRuntime = GUICtrlCreateLabel("00:00:00", $x + 35, $y + 2, 150, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnRecycle, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblNbr-of-OoS_Info_01", "The number of Out of Sync error occurred")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblNbr-of-OoS", "Nbr of OoS") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfOoS = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblAttacked_Info_01", "The No. of Villages that were attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblAttacked", "Attacked") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblResultVillagesAttacked = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgX, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblSkipped_Info_01", "The No. of Villages that were skipped during search by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblSkipped", "Skipped")& ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblResultVillagesSkipped = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDropped_Info_01", "The amount of Trophies dropped by the Bot due to Trophy Settings (on Misc Tab).")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDropped", "Dropped") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblResultTrophiesDropped = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 180
$y = $yStart + 25
$y -= 15
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMagnifier, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblSearch-Cost_Info_01", "Search cost for skipping villages in gold")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblSearch-Cost", "Search Cost") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblSearchCost = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnArcher, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTrain-Cost-Elixir_Info_01", "Elixir spent for training Barrack Troops")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTrain-Cost-Elixir", "Train Cost Elixir") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTrainCostElixir = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMinion, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTrain-Cost-DElixir_Info_01", "Dark Elixir spent for training Dark Barrack Troops")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTrain-Cost-DElixir", "Train Cost DElixir") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTrainCostDElixir = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblGold-collected_Info_01", "Gold gained by collecting mines")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblGold-collected", "Gold collected") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblGoldFromMines = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblElixir-collected_Info_01", "Elixir gained by collecting collectors")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblElixir-collected", "Elixir collected") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblElixirFromCollectors = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDElixir-collected_Info_01", "Dark Elixir gained by collecting drills")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDElixir-collected", "DElixir collected") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblDElixirFromDrills = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 5
$y = $yStart + 165
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblUpgrades-Made", "Upgrades Made"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblUpgrade-Costs", "Upgrade Costs"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$x -= 10
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallGold, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-by-Gold_Info_01", "The No. of Walls upgraded by Gold.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblUpg-by-Gold", "Upg. by Gold") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblWallGoldMake = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallElixir, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-by-Elixir_Info_01", "The No. of Walls upgraded by Elixir.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblUpg-by-Elixir", "Upg. by Elixir") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblWallElixirMake = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgGold, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBuilUpg-by-Gold_Info_01", "The number of buildings upgraded using gold")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblUpg-by-Gold", "Upg. by Gold") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfBuildingUpgGold = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgElixir, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBuilUpg-by-Elixir_Info_01", "The number of buildings upgraded using elixir")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblUpg-by-Elixir", "Upg. by Elixir") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfBuildingUpgElixir = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHeroes, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblHeroesUpg_Info_01", "The number of heroes upgraded")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblHeroesUpg", "Hero Upgrade") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfHeroUpg = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 180
$y = $yStart + 165
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallGold, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-Cost-by-Gold_Info_01", "The cost of gold used by bot while upgrading walls")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-Cost-by-Gold", "Upg. Cost Gold") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblWallUpgCostGold = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallElixir, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-Cost-by-Elixir_Info_01", "The cost of elixir used by bot while upgrading walls")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-Cost-by-Elixir", "Upg. Cost Elixir") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblWallUpgCostElixir = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgGold, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBuilUpg-Cost-by-Gold_Info_01", "The cost of gold used by bot while upgrading buildings")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-Cost-by-Gold", "Upg. Cost Gold") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblBuildingUpgCostGold = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgElixir, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBuilUpg-Cost-by-Elixir_Info_01", "The cost of elixir used by bot while upgrading buildings")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-Cost-by-Elixir", "Upg. Cost Elixir") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblBuildingUpgCostElixir = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHeroes, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblheroesUpg-Cost_Info_01", "The cost of dark elixir used by bot while upgrading heroes")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblheroesUpg-Cost", "Upg. Cost DElixir") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblHeroUpgCost = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x -= 20
$y -= 85
GUICtrlCreateLabel("", $x + 28, $y - 160, 5, 300)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateAttacksSubTab()
Local $sTxtTip = ""
Local $xStart = 25, $yStart = 45
Local $x = $xStart + 3, $y = $yStart + 20
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base", "Dead Base"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLive-Base", "Live Base"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
$x -= 10
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base_Info_01", "The No. of Dead Base that were attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBase-Attacked", "Attacked") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblAttacked[$DB] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain-Gold_Info_01", "The amount of Gold gained from Dead Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain","gain") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalGoldGain[$DB] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain-Elixir_Info_01", "The amount of Elixir gained from Dead Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalElixirGain[$DB] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain-Dark_Info_01", "The amount of Dark Elixir gained from Dead Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalDElixirGain[$DB] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain-Trophies_Info_01", "The amount of Trophies gained from Dead Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalTrophyGain[$DB] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 30
$y += 25
$g_hLblNbrOfDetectedMines[$DB] = GUICtrlCreateLabel("0", $x - 18, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 6, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedCollectors[$DB] = GUICtrlCreateLabel("0", $x + 18, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 43, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedDrills[$DB] = GUICtrlCreateLabel("0", $x + 54, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 79, $y - 4, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 180
$y = $yStart + 25
$y -= 15
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLive-Base_Info_01", "The No. of Live Base that were attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBase-Attacked", "Attacked") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblAttacked[$LB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLive-Base-Gain-Gold_Info_01", "The amount of Gold gained from Live Bases attacked by the Bot")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalGoldGain[$LB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLive-Base-Gain-Elixir_Info_01", "The amount of Elixir gained from Live Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalElixirGain[$LB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLive-Base-Gain-Dark_Info_01", "The amount of Dark Elixir gained from Live Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalDElixirGain[$LB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLive-Base-Gain-Trophy_Info_01", "The amount of Trophy gained from Live Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalTrophyGain[$LB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 62
$y += 25
$g_hLblNbrOfDetectedMines[$LB] = GUICtrlCreateLabel("0", $x - 18, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 6, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedCollectors[$LB] = GUICtrlCreateLabel("0", $x + 18, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 43, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedDrills[$LB] = GUICtrlCreateLabel("0", $x + 54, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 79, $y - 4, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 5
$y = $yStart + 165
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe", "TH Snipe"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Bully", "TH Bully"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$x -= 10
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe_Info_01", "The No. of TH Snipes attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBase-Attacked", "Attacked") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblAttacked[$TS] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe-Gain-Gold_Info_01", "The amount of Gold gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalGoldGain[$TS] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe-Gain-Elixir_Info_01", "The amount of Elixir gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalElixirGain[$TS] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe-Gain-Dark_Info_01", "The amount of Dark Elixir gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalDElixirGain[$TS] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe-Gain-Trophy_Info_01", "The amount of Trophy gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalTrophyGain[$TS] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 25
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGreenLight, $x - 15, $y - 4, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe-Win_Info_01", "The number of successful TH Snipes")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfTSSuccess = GUICtrlCreateLabel("0", $x + 13, $y - 2, 25, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 50
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnRedLight, $x + 35, $y - 4, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe-Lost_Info_01", "The number of failed TH Snipe attempt")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfTSFailed = GUICtrlCreateLabel("0", $x + 63, $y - 2, 25, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 180
$y = $yStart + 165
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Bully_Info_01", "The No. of TH Bully bases that were attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBase-Attacked", "Attacked") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblAttacked[$TB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Bully-Gain-Gold_Info_01", "The amount of Gold gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalGoldGain[$TB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Bully-Gain-Elixir_Info_01", "The amount of Elixir gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalElixirGain[$TB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Bully-Gain-Dark_Info_01", "The amount of Dark Elixir gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalDElixirGain[$TB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Bully-Gain-Trophy_Info_01", "The amount of Trophy gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalTrophyGain[$TB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 64
$y += 25
$g_hLblNbrOfDetectedMines[$TB] = GUICtrlCreateLabel("0", $x - 18, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 6, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedCollectors[$TB] = GUICtrlCreateLabel("0", $x + 18, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 43, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedDrills[$TB] = GUICtrlCreateLabel("0", $x + 54, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 79, $y - 4, 16, 16)
$x -= 124
$y -= 110
GUICtrlCreateLabel("", $x + 28, $y - 160, 5, 300)
GUICtrlSetBkColor(-1, 0xC3C3C3)
$x = $xStart + 5
$y = $yStart + 310
$g_hLblStatsSZRev1 = GUICtrlCreateLabel("", $x - 20, $y - 32, 420, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$g_hLblStatsSZRev2 = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSZRev2", "Smart Zap"), $x + 155, $y - 32, 60, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$x -= 10
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x - 10, $y, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartLightningUsed_Info_01", "The amount of Lightning Spells used to zap"))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSZRev2-Used", "Used") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartLightningUsed_Info_01", -1))
$g_hLblSmartLightningUsed = GUICtrlCreateLabel("0", $x + 45, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartLightningUsed_Info_01", -1))
$x += 145
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthQuakeSpell, $x - 10, $y, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartEarthQuakeUsed_Info_01", "The amount of Earthquake Spells used to zap"))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSZRev2-Used", -1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartEarthQuakeUsed_Info_01", -1))
$g_hLblSmartEarthQuakeUsed = GUICtrlCreateLabel("0", $x + 45, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartEarthQuakeUsed_Info_01", -1))
$x += 145
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x - 10, $y -1, 18, 18)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartZap_Info_01", "The amount of Dark Elixir won while zapping"))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartZap_Info_01", -1))
$g_hLblSmartZap = GUICtrlCreateLabel("0", $x + 45, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartZap_Info_01", -1))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateDonationsSubTab()
Local $sTxtTip = ""
Local $xStart = 25, $yStart = 45
Local $x = $xStart + 3, $y = $yStart + 20
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonElixir-Troops", "Elixir Troops"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonDark-Troops", "Dark Elixir Troops"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
$x -= 10
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBarbarian, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopBarbarian] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 40, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWizard, $x + 65, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 95, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopWizard] = GUICtrlCreateLabel("0", $x + 85, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElectroDragon, $x + 145, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 175, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopElectroDragon] = GUICtrlCreateLabel("0", $x + 165, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnArcher, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopArcher] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 40, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealer, $x + 65, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 95, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopHealer] = GUICtrlCreateLabel("0", $x + 85, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGiant, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopGiant] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 40, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDragon, $x + 65, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 95, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopDragon] = GUICtrlCreateLabel("0", $x + 85, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoblin, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopGoblin] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 40, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnPekka, $x + 65, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 95, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopPekka] = GUICtrlCreateLabel("0", $x + 85, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallBreaker, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopWallBreaker] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 40, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBabyDragon, $x + 65, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 95, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopBabyDragon] = GUICtrlCreateLabel("0", $x + 85, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBalloon, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopBalloon] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 40, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMiner, $x + 65, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 95, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopMiner] = GUICtrlCreateLabel("0", $x + 85, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 232
$y = $yStart + 25
$y -= 15
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMinion, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopMinion] = GUICtrlCreateLabel("0", $x + 5, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBowler, $x + 95, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 122, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopBowler] = GUICtrlCreateLabel("0", $x + 100, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHogRider, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopHogRider] = GUICtrlCreateLabel("0", $x + 5, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnValkyrie, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopValkyrie] = GUICtrlCreateLabel("0", $x + 5, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGolem, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopGolem] = GUICtrlCreateLabel("0", $x + 5, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWitch, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopWitch] = GUICtrlCreateLabel("0", $x + 5, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLavaHound, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopLavaHound] = GUICtrlCreateLabel("0", $x + 5, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 210
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonTotal", "Total Donated") & ":", $x - 20, $y - 32, 187, 17)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$g_hLblTotalTroopsQ = GUICtrlCreateLabel("0", $x + 105, $y - 32, 70, 17, $SS_RIGHT)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonTotalXP", "Total XP") & ":", $x - 18 + 212, $y - 32, 207, 17)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$g_hLblTotalTroopsXP = GUICtrlCreateLabel("0", $x + 320, $y - 32, 70, 17, $SS_RIGHT)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$x = $xStart + 3
$y = $yStart + 235
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonElixir-Spells", "Elixir Spells"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonDark-Spells", "Dark Elixir Spells"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
$x -= 10
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellLightning] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x + 95, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 122, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellFreeze] = GUICtrlCreateLabel("0", $x + 115, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellHeal] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellRage] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellJump] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 210
$y = $yStart + 235
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellPoison] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthQuakeSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellEarthquake] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellHaste] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSkeletonSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellSkeleton] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 5
$y = $yStart + 370
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonTotal", "Total Donated") & ":", $x - 20, $y - 32, 187, 17)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$g_hLblTotalSpellsQ = GUICtrlCreateLabel("0", $x + 105, $y - 32, 70, 17, $SS_RIGHT)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonTotalXP", "Total XP") & ":", $x - 18 + 212, $y - 32, 207, 17)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$g_hLblTotalSpellsXP = GUICtrlCreateLabel("0", $x + 320, $y - 32, 70, 17, $SS_RIGHT)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$x += 155
$y -= 250
GUICtrlCreateLabel("", $x + 50, $y - 130, 5, 188)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel("", $x + 28, $y + 90, 5, 128)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateMultiStatsSubTab()
Local $x = 25, $y = 45
For $i = 0 To 7
$x = 5
$y = 27
Local $i_X = Mod($i, 2), $i_Y = Int($i / 2)
Local $delY = 17, $delY2 = 95, $delX = 60, $delX1 = 142, $delX2 = 219
$g_ahGrpVillageAcc[$i] = GUICtrlCreateGroup("", $x - 3 + $i_X * $delX2, $y + $i_Y * $delY2, 216, 90)
GUICtrlCreateGraphic($x + 130 + $i_X * $delX2, $y + $i_Y * $delY2, 70, 17, $SS_WHITERECT)
$g_ahLblTroopsTime[$i] = GUICtrlCreateLabel("", $x + 137 + $i_X * $delX2, $y + $i_Y * $delY2, 50, 16, $SS_CENTER)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_GRAY)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x + 190 + $i_X * $delX2, $y + $i_Y * $delY2, 16, 14)
$g_ahLblResultGoldNowAcc[$i] = GUICtrlCreateLabel("", $x + $i_X * $delX2, $y + $delY + $i_Y * $delY2, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + $delX + $i_X * $delX2 + 10, $y + $delY + $i_Y * $delY2, 16, 16)
$g_ahLblResultElixirNowAcc[$i] = GUICtrlCreateLabel("", $x + $i_X * $delX2, $y + $delY * 2 + $i_Y * $delY2, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + $delX + $i_X * $delX2 + 10, $y + $delY * 2 + $i_Y * $delY2, 16, 16)
$g_ahLblResultDENowAcc[$i] = GUICtrlCreateLabel("", $x + $i_X * $delX2, $y + $delY * 3 + $i_Y * $delY2, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + $delX + $i_X * $delX2 + 10, $y + $delY * 3 + $i_Y * $delY2, 16, 16)
$g_ahLblResultTrophyNowAcc[$i] = GUICtrlCreateLabel("", $x + $i_X * $delX2, $y + $delY * 4 + $i_Y * $delY2, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + $delX + $i_X * $delX2 + 10, $y + $delY * 4 + $i_Y * $delY2, 16, 16)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x + $delX1 + $i_X * $delX2 + 10, $y + $delY + $i_Y * $delY2, 16, 14)
$g_ahLblResultBuilderNowAcc[$i] = GUICtrlCreateLabel("", $x + $delX1 + 30 + $i_X * $delX2, $y + $delY + $i_Y * $delY2, 30, 17, $SS_LEFT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGem, $x + $delX1 + $i_X * $delX2 + 10, $y + $delY * 2 + $i_Y * $delY2, 16, 14)
$g_ahLblResultGemNowAcc[$i] = GUICtrlCreateLabel("", $x + $delX1 + 30 + $i_X * $delX2, $y + $delY * 2 + $i_Y * $delY2, 60, 17, $SS_LEFT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x + $delX1 + $i_X * $delX2 + 10, $y + $delY * 3 + $i_Y * $delY2, 16, 14)
$g_ahLblResultAttacked[$i] = GUICtrlCreateLabel("", $x + $delX1 + 30 + $i_X * $delX2, $y + $delY * 3 + $i_Y * $delY2, 60, 17, $SS_LEFT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnNoShield, $x + $delX1 + $i_X * $delX2 + 10, $y + $delY * 4 + $i_Y * $delY2, 16, 14)
$g_ahLblPersonalBreak[$i] = GUICtrlCreateLabel("", $x + $delX1 + 30 + $i_X * $delX2, $y + $delY * 4 + $i_Y * $delY2, 60, 17, $SS_LEFT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
$g_ahLblHourlyStatsGoldAcc[$i] = GUICtrlCreateLabel(" k/h", $x + $delX + 20 + $i_X * $delX2, $y + $delY + $i_Y * $delY2, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
$g_ahLblHourlyStatsElixirAcc[$i] = GUICtrlCreateLabel(" k/h", $x + $delX + 20 + $i_X * $delX2, $y + $delY * 2 + $i_Y * $delY2, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
$g_ahLblHourlyStatsDarkAcc[$i] = GUICtrlCreateLabel(" /h", $x + $delX + 20 + $i_X * $delX2, $y + $delY * 3 + $i_Y * $delY2, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
$g_ahLblHourlyStatsTrophyAcc[$i] = GUICtrlCreateLabel(" /h", $x + $delX + 20 + $i_X * $delX2, $y + $delY * 4 + $i_Y * $delY2, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateGroup("", -99, -99, 1, 1)
For $j = $g_ahGrpVillageAcc[$i] To $g_ahLblHourlyStatsTrophyAcc[$i]
GUICtrlSetState($j, $GUI_HIDE)
Next
Next
EndFunc
Global $g_hGUI_BOT_TAB = 0, $g_hGUI_BOT_TAB_ITEM1 = 0, $g_hGUI_BOT_TAB_ITEM2 = 0, $g_hGUI_BOT_TAB_ITEM3 = 0, $g_hGUI_BOT_TAB_ITEM4 = 0, $g_hGUI_BOT_TAB_ITEM5 = 0
Global $g_hTxtSALog = 0
Func CreateBotTab()
$g_hGUI_BOT = _GUICreate("", $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hFrmBotEx)
$g_hGUI_LOG_SA = _GUICreate("", 205, 200, 235, 225, BitOR($WS_CHILD, 0), -1, $g_hGUI_BOT)
$g_hGUI_STATS = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_BOT)
GUISwitch($g_hGUI_BOT)
$g_hGUI_BOT_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_BOT_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_01", "Options"))
CreateBotOptions()
$g_hGUI_BOT_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_02", "Android"))
CreateBotAndroid()
$g_hGUI_BOT_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_03", "Debug"))
CreateBotDebug()
$g_hGUI_BOT_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_04", "Profiles"))
CreateBotProfiles()
$g_hGUI_BOT_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_05", "Stats"))
$g_hLastControlToHide = GUICtrlCreateDummy()
ReDim $g_aiControlPrevState[$g_hLastControlToHide + 1]
CreateBotStats()
CreateBotSwitchAccLog()
GUICtrlCreateTabItem("")
EndFunc
Func CreateBotSwitchAccLog()
Local $x = 0, $y = 0
Local $activeHWnD1 = WinGetHandle("")
$g_hTxtSALog = _GUICtrlRichEdit_Create($g_hGUI_LOG_SA, "", $x, $y, 205, 200, BitOR($ES_MULTILINE, $ES_READONLY, $WS_VSCROLL, $WS_HSCROLL, $ES_UPPERCASE, $ES_AUTOHSCROLL, $ES_AUTOVSCROLL, $ES_NUMBER, 0x200), $WS_EX_STATICEDGE)
WinActivate($activeHWnD1)
EndFunc
Global $g_hGUI_ABOUT = 0
Global $g_hLblCreditsBckGrnd = 0, $g_hLblMyBotURL = 0, $g_hLblForumURL = 0
Global $g_hGUI_CommandLineHelp = 0
Func CreateAboutTab()
$g_hGUI_ABOUT = _GUICreate("", $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hFrmBotEx)
Local $sText = ""
Local $x = 18, $y = 15 + $_GUI_MAIN_TOP
$sText = "My Bot is brought to you by a worldwide team of open source" & @CRLF & "programmers and a vibrant community of forum members!"
GUICtrlCreateLabel($sText, $x + 8, $y - 10, 400, 35, $SS_CENTER)
GUICtrlSetFont(-1, 10, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_NAVY)
$y += 30
$sText = "Please visit our web forums:"
GUICtrlCreateLabel($sText, $x + 44, $y, 180, 30, $SS_CENTER)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
$g_hLblMyBotURL = GUICtrlCreateLabel("https://mybot.run/forums", $x + 223, $y, 150, 20)
GUICtrlSetCursor(-1, 0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_INFO)
$y += 22
GUICtrlCreateLabel("Credits belong to following programmers for donating their time:", $x - 5, $y, 420, 20)
GUICtrlSetFont(-1, 10, $FW_BOLD, Default, "Arial")
$y += 30
$sText = "Active developers: "
GUICtrlCreateLabel($sText, $x - 5, $y, 410, 20, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_NAVY)
$sText = "Cosote, Fliegerfaust, MMHK, TripleM"
GUICtrlCreateLabel($sText, $x + 5, $y + 15, 410, 50, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9, $FW_MEDIUM, Default, "Arial")
$y += 60
$sText = "Inactive developers: "
GUICtrlCreateLabel($sText, $x - 5, $y, 410, 20, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_NAVY)
$sText = "Boju, Codeslinger69, Ezeck0001, Hervidero, IceCube, Kaganus, MR.ViPeR, Sardo, TheRevenor, Trlopes"
GUICtrlCreateLabel($sText, $x + 5, $y + 15, 410, 50, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9, $FW_MEDIUM, Default, "Arial")
$y += 50
$sText = "Retired developers: "
GUICtrlCreateLabel($sText, $x - 5, $y, 410, 20, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_NAVY)
$sText = "Antidote, AtoZ, Barracoda, Didipe, Dinobot, DixonHill, DkEd, GkevinOD, HungLe, KnowJack, LunaEclipse, MonkeyHunter, ProMac, Safar46, Saviart, TheMaster1st, Zengzeng, and others"
GUICtrlCreateLabel($sText, $x + 5, $y + 15, 410, 50, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9, $FW_MEDIUM, Default, "Arial")
$y += 71
$sText = "Special thanks to all contributing forum members helping to make this" & @CRLF & "software better! And a special note to: @KevinM our server admin!"
GUICtrlCreateLabel($sText, $x + 14, $y, 390, 30, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $ES_CENTER), 0)
GUICtrlSetFont(-1, 9, $FW_MEDIUM, Default, "Arial")
$y += 40
$sText = "The latest release of 'My Bot' can be found at:"
GUICtrlCreateLabel($sText, $x - 5, $y, 400, 15, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 10, $FW_BOLD, Default, "Arial")
$y += 18
$g_hLblForumURL = GUICtrlCreateLabel("https://mybot.run/forums/index.php?/forum/4-official-releases/", $x + 25, $y, 450, 20)
GUICtrlSetCursor(-1, 0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_INFO)
$y = 380
$sText = "By running this program, the user accepts all responsibility that arises from the use of this software." & @CRLF & "This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even " & @CRLF & "the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General " & @CRLF & "Public License for more details. The license can be found in the main code folder location." & @CRLF & "Copyright (C) 2015-2018 MyBot.run"
GUICtrlCreateLabel($sText, $x + 1, $y, 415, 56, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT, $ES_CENTER), 0)
GUICtrlSetColor(-1, 0x000053)
GUICtrlSetFont(-1, 6.5, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
EndFunc
Func ShowCommandLineHelp()
UpdateBotTitle()
$g_hGUI_CommandLineHelp = GUICreate($g_sBotTitle & " - Command Line Help", 650, 700, -1, -1, BitOR($WS_CAPTION, $WS_POPUPWINDOW, $DS_MODALFRAME))
GUISetIcon($g_sLibIconPath, $eIcnGUI, $g_hGUI_CommandLineHelp)
Local $hRichEdit = _GUICtrlRichEdit_Create($g_hGUI_CommandLineHelp, "", 2, 0, 646, 667, $WS_VSCROLL + $ES_MULTILINE)
Local $sHelpFile = @ScriptDir & "\Help\CommandLineParameter"
If $g_sLanguage <> $g_sDefaultLanguage Then
If FileExists($sHelpFile & "_" & $g_sLanguage & ".rtf") Then
$sHelpFile &= "_" & $g_sLanguage
Else
SetDebugLog("Help file not available: " & $sHelpFile & "_" & $g_sLanguage & ".rtf")
EndIf
EndIf
_GUICtrlRichEdit_StreamFromFile($hRichEdit, $sHelpFile & ".rtf")
_GUICtrlRichEdit_SetReadOnly($hRichEdit)
_GUICtrlRichEdit_SetScrollPos($hRichEdit, 0, 0)
Local $hClose = GUICtrlCreateButton("Close", 300, 670, 50)
GUISetState(@SW_SHOW)
Local $iOpt = Opt("GUIOnEventMode", 0)
While 1
Switch GUIGetMsg()
Case $GUI_EVENT_CLOSE, $hClose
ExitLoop
EndSwitch
WEnd
GUIDelete($g_hGUI_CommandLineHelp)
Opt("GUIOnEventMode", $iOpt)
EndFunc
Func CreateMainGUI()
Local $iStyle = $WS_BORDER
If BitAND($g_iBotDesignFlags, 1) = 0 Then
$g_bCustomTitleBarActive = False
$iStyle = $WS_CAPTION
$_GUI_MAIN_TOP = 5
$_GUI_CHILD_TOP = 110 + $_GUI_MAIN_TOP
Else
$g_bCustomTitleBarActive = True
EndIf
Switch $g_iGuiMode
Case 0
Case 2
$_GUI_MAIN_WIDTH = $_MINIGUI_MAIN_WIDTH
$_GUI_MAIN_HEIGHT = $_MINIGUI_MAIN_HEIGHT
EndSwitch
$g_hFrmBot = GUICreate($g_sBotTitle, $_GUI_MAIN_WIDTH, $_GUI_MAIN_HEIGHT + $_GUI_MAIN_TOP,($g_iFrmBotPosX = $g_WIN_POS_DEFAULT ? -1 : $g_iFrmBotPosX),($g_iFrmBotPosY = $g_WIN_POS_DEFAULT ? -1 : $g_iFrmBotPosY), BitOR($WS_MINIMIZEBOX, $WS_POPUP, $WS_SYSMENU, $WS_CLIPCHILDREN, $WS_CLIPSIBLINGS, $iStyle))
If $g_iFrmBotPosX = $g_WIN_POS_DEFAULT Or $g_iFrmBotPosY = $g_WIN_POS_DEFAULT Then
Local $a = WinGetPos($g_hFrmBot)
If UBound($a) > 1 Then
$g_iFrmBotPosX = $a[0]
$g_iFrmBotPosY = $a[1]
Else
$g_iFrmBotPosX = 100
$g_iFrmBotPosY = 100
EndIf
EndIf
GUISetIcon($g_sLibIconPath, $eIcnGUI)
If $g_iGuiMode = 0 Then
UpdateBotTitle()
Return
EndIf
TraySetIcon($g_sLibIconPath, $eIcnGUI)
Opt("TrayMenuMode", 3)
Opt("TrayOnEventMode", 1)
Opt("TrayIconHide", 0)
UpdateBotTitle()
_WindowAppId($g_hFrmBot, "MyBot.run")
$g_hTiShow = TrayCreateItem(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_01", "Show bot"))
TrayItemSetOnEvent(-1, "tiShow")
$g_hTiStartStop = TrayCreateItem(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Start", "Start bot"))
GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Stop", "Stop bot")
TrayItemSetOnEvent(-1, "tiStartStop")
$g_hTiPause = TrayCreateItem(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Pause", "Pause bot"))
GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Resume", "Resume bot")
TrayItemSetState($g_hTiPause, $TRAY_DISABLE)
TrayItemSetOnEvent(-1, "btnPause")
TrayCreateItem("")
$g_hTiHide = TrayCreateItem(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_02", "Hide when minimized"))
TrayItemSetOnEvent(-1, "tiHide")
TrayCreateItem("")
$g_hTiDonate = TrayCreateItem(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_03", "Support Development"))
TrayItemSetOnEvent(-1, "tiDonate")
$g_hTiAbout = TrayCreateItem(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_04", "About"))
TrayItemSetOnEvent(-1, "tiAbout")
TrayCreateItem("")
$g_hTiExit = TrayCreateItem(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_05", "Exit"))
TrayItemSetOnEvent(-1, "tiExit")
EndFunc
Func CreateMainGUIControls($bGuiModeUpdate = False)
If Not $bGuiModeUpdate Then
Local $aBtnSize = $_GUI_MAIN_BUTTON_SIZE
GUISwitch($g_hFrmBot)
Local $sStepText
Switch $g_iGuiMode
Case 0
Return
Case 1
$sStepText = GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_01", "Loading Main GUI...")
Case 2
$sStepText = GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_01_Mini", "Loading Mini GUI...")
EndSwitch
SplashStep($sStepText)
If $g_bCustomTitleBarActive Then
$g_hFrmBotButtons = GUICreate("My Bot Title Buttons", $_GUI_MAIN_BUTTON_COUNT * $aBtnSize[0], $aBtnSize[1], $_GUI_MAIN_WIDTH - $aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT, 0, BitOR($WS_CHILD, $WS_TABSTOP), BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE,($g_bAndroidShieldPreWin8 ? 0 : $WS_EX_LAYERED)), $g_hFrmBot)
WinSetTrans($g_hFrmBotButtons, "", 254)
EndIf
$g_hFrmBotEx = GUICreate("My Bot Controls", $_GUI_MAIN_WIDTH, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP, 0, 0, BitOR($WS_CHILD, $WS_TABSTOP), 0, $g_hFrmBot)
$g_hToolTip = _GUIToolTip_Create($g_hFrmBot)
_GUIToolTip_SetMaxTipWidth($g_hToolTip, $_GUI_MAIN_WIDTH)
If $g_bCustomTitleBarActive = False Then
GUICtrlCreateLabel("", 0, 0, $_GUI_MAIN_WIDTH, $_GUI_MAIN_TOP)
GUICtrlSetOnEvent(-1, "BotMoveRequest")
GUICtrlSetBkColor(-1, $COLOR_WHITE)
Else
Local $iTitleX = 25
GUICtrlCreateLabel("", 0, 0, $iTitleX, $_GUI_MAIN_TOP)
GUICtrlSetOnEvent(-1, "BotMoveRequest")
GUICtrlSetBkColor(-1, $COLOR_WHITE)
$g_hLblBotTitle = GUICtrlCreateLabel($g_sBotTitle, $iTitleX, 0, $_GUI_MAIN_WIDTH - $_GUI_MAIN_BUTTON_COUNT * $aBtnSize[0] - 25, $_GUI_MAIN_TOP)
GUICtrlSetOnEvent(-1, "BotMoveRequest")
GUICtrlSetFont(-1, 11, 0, 0, "Segoe UI")
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetColor(-1, 0x171717)
GUISwitch($g_hFrmBotButtons)
$g_hLblBotShrink = GUICtrlCreateLabel(ChrW(0x25C4), 0, 0, $aBtnSize[0], $aBtnSize[1], $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Title", "LblBotShrink", "Shrink Bot when docked"))
GUICtrlSetFont(-1, 10)
GUICtrlSetBkColor(-1, 0xF0F0F0)
GUICtrlSetColor(-1, 0xB8B8B8)
$g_hLblBotExpand = GUICtrlCreateLabel(ChrW(0x25BA), 0, 0, $aBtnSize[0], $aBtnSize[1], $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Title", "LblBotExpand", "Expand Bot when docked"))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetFont(-1, 10)
GUICtrlSetBkColor(-1, 0xF0F0F0)
GUICtrlSetColor(-1, 0xB8B8B8)
$g_hLblBotMiniGUI = GUICtrlCreateLabel(ChrW(0x2584), $aBtnSize[0] *($_GUI_MAIN_BUTTON_COUNT - 3), 0, $aBtnSize[0], $aBtnSize[1], $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Title", "LblBotMiniGUI", "Switch to Mini Mode"))
GUICtrlSetState(-1, $g_iGuiMode = 1 ? $GUI_SHOW : $GUI_HIDE)
GUICtrlSetFont(-1, 10)
GUICtrlSetBkColor(-1, 0xF0F0F0)
GUICtrlSetColor(-1, 0xB8B8B8)
$g_hLblBotNormalGUI = GUICtrlCreateLabel(ChrW(0x2588), $aBtnSize[0] *($_GUI_MAIN_BUTTON_COUNT - 3), 0, $aBtnSize[0], $aBtnSize[1], $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Title", "LblBotNormal", "Switch to Normal Mode"))
GUICtrlSetState(-1, $g_iGuiMode = 2 ? $GUI_SHOW : $GUI_HIDE)
GUICtrlSetFont(-1, 10)
GUICtrlSetBkColor(-1, 0xF0F0F0)
GUICtrlSetColor(-1, 0xB8B8B8)
$g_hLblBotMinimize = GUICtrlCreateLabel("̶", $aBtnSize[0] *($_GUI_MAIN_BUTTON_COUNT - 2), 0, $aBtnSize[0], $aBtnSize[1], $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Title", "LblBotMinimize", "Minimize"))
GUICtrlSetFont(-1, 10)
GUICtrlSetBkColor(-1, 0xF0F0F0)
GUICtrlSetColor(-1, 0xB8B8B8)
$g_hLblBotClose = GUICtrlCreateLabel("×", $aBtnSize[0] *($_GUI_MAIN_BUTTON_COUNT - 1), 0, $aBtnSize[0], $aBtnSize[1], $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Title", "LblBotClose", "Close"))
GUICtrlSetFont(-1, 10)
GUICtrlSetBkColor(-1, 0xFF4040)
GUICtrlSetColor(-1, 0xF8F8F8)
$g_hFrmBotLogoUrlSmall = GUICreate("My Bot URL", 290, 13, 0, 0, BitOR($WS_CHILD, $WS_TABSTOP), BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE,($g_bAndroidShieldPreWin8 ? 0 : $WS_EX_LAYERED)), $g_hFrmBot)
$g_hFrmBot_URL_PIC2 = _GUICtrlCreatePic($g_sLogoUrlSmallPath, 0, 0, 290, 13)
GUICtrlSetCursor(-1, 0)
GUISwitch($g_hFrmBotEx)
GUICtrlCreateLabel("", $_GUI_MAIN_WIDTH - $_GUI_MAIN_BUTTON_COUNT * $aBtnSize[0], $aBtnSize[1], $_GUI_MAIN_BUTTON_COUNT * $aBtnSize[0], $_GUI_MAIN_TOP - $aBtnSize[1])
GUICtrlSetOnEvent(-1, "BotMoveRequest")
GUICtrlSetBkColor(-1, $COLOR_WHITE)
EndIf
$g_hFrmBot_MAIN_PIC = _GUICtrlCreatePic($g_sLogoPath, 0, $_GUI_MAIN_TOP, $_GUI_MAIN_WIDTH, 67)
GUICtrlSetOnEvent(-1, "BotMoveRequest")
$g_hFrmBot_URL_PIC = _GUICtrlCreatePic($g_sLogoUrlPath, 0, $_GUI_MAIN_TOP + 67, $_GUI_MAIN_WIDTH, 13)
GUICtrlSetCursor(-1, 0)
GUISwitch($g_hFrmBot)
$g_hFrmBotEmbeddedShieldInput = GUICtrlCreateInput("", 0, 0, -1, -1, $WS_TABSTOP)
GUICtrlSetState($g_hFrmBotEmbeddedShieldInput, $GUI_HIDE)
$g_hFrmBotBottom = GUICreate("My Bot Buttons", $_GUI_MAIN_WIDTH, $_GUI_BOTTOM_HEIGHT, 0, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP, BitOR($WS_CHILD, $WS_TABSTOP), 0, $g_hFrmBot)
GUISwitch($g_hFrmBot)
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_02", "Loading GUI Bottom..."))
GUISwitch($g_hFrmBotBottom)
CreateBottomPanel()
GUISwitch($g_hFrmBotEx)
$g_hStatusBar = _GUICtrlStatusBar_Create($g_hFrmBotBottom)
_GUICtrlStatusBar_SetSimple($g_hStatusBar)
_GUICtrlStatusBar_SetText($g_hStatusBar, "Status : Idle")
Else
GUISwitch($g_hFrmBotEx)
EndIf
If $g_iGuiMode = 2 Then
CreateLogTab($g_hFrmBotEx)
Return
EndIf
$g_hFirstControlToHide = GUICtrlCreateDummy()
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_03", "Loading Log tab..."))
CreateLogTab()
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_04", "Loading Village tab..."))
CreateVillageTab()
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_05", "Loading Attack tab..."))
CreateAttackTab()
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_06", "Loading Bot tab..."))
CreateBotTab()
If Not $bGuiModeUpdate Then DistributorsUpdateGUI()
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_07", "Loading About Us tab..."))
CreateAboutTab()
Local $sStepText = ""
Switch $g_iGuiMode
Case 1
$sStepText = GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_08", "Initializing GUI...")
Case 2
$sStepText = GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_08_Mini", "Initializing Mini GUI...")
EndSwitch
SplashStep($sStepText)
GUISwitch($g_hFrmBotEx)
$g_hTabMain = GUICtrlCreateTab(5, 85 + $_GUI_MAIN_TOP, $_GUI_MAIN_WIDTH - 9, $_GUI_MAIN_HEIGHT - 225)
$g_hTabLog = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_01", "Log"))
$g_hTabVillage = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02", "Village"))
$g_hTabAttack = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03", "Attack Plan"))
$g_hTabBot = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04", "Bot"))
$g_hTabAbout = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_05", "About Us"))
GUICtrlCreateTabItem("")
GUICtrlSetResizing(-1, $GUI_DOCKBORDERS)
Static $g_hTabMain_ImageList = 0
Static $g_hGUI_VILLAGE_TAB_ImageList = 0
Static $g_hGUI_MISC_TAB_ImageList = 0
Static $g_hGUI_DONATE_TAB_ImageList = 0
Static $g_hGUI_UPGRADE_TAB_ImageList = 0
Static $g_hGUI_NOTIFY_TAB_ImageList = 0
Static $g_hGUI_ATTACK_TAB_ImageList = 0
Static $g_hGUI_TRAINARMY_TAB_ImageList = 0
Static $g_hGUI_SEARCH_TAB_ImageList = 0
Static $g_hGUI_DEADBASE_TAB_ImageList = 0
Static $g_hGUI_ACTIVEBASE_TAB_ImageList = 0
Static $g_hGUI_THSNIPE_TAB_ImageList = 0
Static $g_hGUI_ATTACKOPTION_TAB_ImageList = 0
Static $g_hGUI_STRATEGIES_TAB_ImageList = 0
Static $g_hGUI_BOT_TAB_ImageList = 0
Static $g_hGUI_STATS_TAB_ImageList = 0
Bind_ImageList($g_hTabMain, $g_hTabMain_ImageList)
Bind_ImageList($g_hGUI_VILLAGE_TAB, $g_hGUI_VILLAGE_TAB_ImageList)
Bind_ImageList($g_hGUI_MISC_TAB, $g_hGUI_MISC_TAB_ImageList)
Bind_ImageList($g_hGUI_DONATE_TAB, $g_hGUI_DONATE_TAB_ImageList)
Bind_ImageList($g_hGUI_UPGRADE_TAB, $g_hGUI_UPGRADE_TAB_ImageList)
Bind_ImageList($g_hGUI_NOTIFY_TAB, $g_hGUI_NOTIFY_TAB_ImageList)
Bind_ImageList($g_hGUI_ATTACK_TAB, $g_hGUI_ATTACK_TAB_ImageList)
Bind_ImageList($g_hGUI_TRAINARMY_TAB, $g_hGUI_TRAINARMY_TAB_ImageList)
Bind_ImageList($g_hGUI_SEARCH_TAB, $g_hGUI_SEARCH_TAB_ImageList)
Bind_ImageList($g_hGUI_DEADBASE_TAB, $g_hGUI_DEADBASE_TAB_ImageList)
Bind_ImageList($g_hGUI_ACTIVEBASE_TAB, $g_hGUI_ACTIVEBASE_TAB_ImageList)
Bind_ImageList($g_hGUI_THSNIPE_TAB, $g_hGUI_THSNIPE_TAB_ImageList)
Bind_ImageList($g_hGUI_ATTACKOPTION_TAB, $g_hGUI_ATTACKOPTION_TAB_ImageList)
Bind_ImageList($g_hGUI_STRATEGIES_TAB, $g_hGUI_STRATEGIES_TAB_ImageList)
Bind_ImageList($g_hGUI_BOT_TAB, $g_hGUI_BOT_TAB_ImageList)
Bind_ImageList($g_hGUI_STATS_TAB, $g_hGUI_STATS_TAB_ImageList)
GUICtrlSetState($g_hTabLog, $GUI_SHOW)
tabMain()
cmbLog()
SetDebugLog("$g_hFrmBot=" & $g_hFrmBot, Default, True)
SetDebugLog("$g_hFrmBotEx=" & $g_hFrmBotEx, Default, True)
SetDebugLog("$g_hFrmBotBottom=" & $g_hFrmBotBottom, Default, True)
SetDebugLog("$g_hFrmBotEmbeddedShield=" & $g_hFrmBotEmbeddedShield, Default, True)
SetDebugLog("$g_hFrmBotEmbeddedShieldInput=" & $g_hFrmBotEmbeddedShieldInput, Default, True)
SetDebugLog("$g_hFrmBotEmbeddedGraphics=" & $g_hFrmBotEmbeddedGraphics, Default, True)
EndFunc
Func ShowMainGUI()
If $g_iGuiMode = 0 Then Return
CheckDpiAwareness(False, $g_bBotLaunchOption_ForceDpiAware, True)
If Not $g_bNoFocusTampering Then
GUISetState(@SW_SHOW, $g_hFrmBot)
Else
GUISetState(@SW_SHOW, $g_hFrmBot)
EndIf
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotButtons)
If $g_hFrmBotEx Then GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotEx)
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotBottom)
CheckBotShrinkExpandButton()
GUISwitch($g_hFrmBotEx)
$g_bFrmBotMinimized = False
Local $p = WinGetPos($g_hFrmBot)
$g_aFrmBotPosInit[0] = $p[0]
$g_aFrmBotPosInit[1] = $p[1]
$g_aFrmBotPosInit[2] = $p[2]
$g_aFrmBotPosInit[3] = $p[3]
$g_aFrmBotPosInit[4] = _WinAPI_GetClientWidth($g_hFrmBot)
$g_aFrmBotPosInit[5] = _WinAPI_GetClientHeight($g_hFrmBot)
$g_aFrmBotPosInit[6] = ControlGetPos($g_hFrmBot, "", $g_hFrmBotEx)[3]
EndFunc
Func UpdateMainGUI()
If $g_hLibMyBot <> -1 Then
GUICtrlSetState($g_hBtnStart, $GUI_ENABLE)
If $g_iTownHallLevel > 2 Then
GUICtrlSetState($g_hBtnSearchMode, $GUI_ENABLE)
EndIf
EndIf
EndFunc
Func CheckDpiAwareness($bCheckOnlyIfAlreadyAware = False, $bForceDpiAware = False, $bForceDpiAware2 = False)
Static $sbDpiAware = False
Static $sbDpiAlreadyChecked = False
If $bCheckOnlyIfAlreadyAware = True Then Return $sbDpiAware
Local $bDpiAware = False
Local $bChanged = False
If $sbDpiAlreadyChecked = True Or(Not IsBotLaunched() And $bForceDpiAware2 = False) Then Return $bChanged
If $g_iDpiAwarenessMode <> 0 And RegRead("HKCU\Control Panel\Desktop\WindowMetrics", "AppliedDPI") <> 96 Then
$bDpiAware = $bForceDpiAware = True Or $g_bChkBackgroundMode = False Or($g_bAndroidAdbScreencap = False And GetProcessDpiAwareness(GetAndroidPid()))
$bChanged = $bDpiAware And Not $sbDpiAware
If $bChanged Then
$sbDpiAware = True
Local $bWasEmbedded = AndroidEmbedded()
If $bWasEmbedded Then AndroidEmbed(False)
If $g_bCustomTitleBarActive = False Then
Local $g_iDpiAwarenessYcomp = _WinAPI_GetSystemMetrics($SM_CYCAPTION)
Local $aResult = DllCall("user32.dll", "boolean", "SetProcessDPIAware")
$g_aFrmBotPosInit[7] = _WinAPI_GetSystemMetrics($SM_CYCAPTION) - $g_iDpiAwarenessYcomp
SetDebugLog("Enabled DPI Awareness, height compensation: " & $g_aFrmBotPosInit[7])
Else
Local $aResult = DllCall("user32.dll", "boolean", "SetProcessDPIAware")
EndIf
SetDebugLog("SetProcessDPIAware called: " & @error &((UBound($aResult) = 0) ?("") :(", " & $aResult[0])))
If $bWasEmbedded Then AndroidEmbed(True)
EndIf
EndIf
Return $bChanged
EndFunc
Func GetProcessDpiAwareness($iPid)
$iPid = ProcessExists($iPid)
If $iPid = 0 Then
Return SetError(1, 0, 0)
EndIf
Local $hProcess
If _WinAPI_GetVersion() >= 6.0 Then
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_LIMITED_INFORMATION, 0, $iPid)
Else
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_INFORMATION, 0, $iPid)
EndIf
If @error Then
Return SetError(2, 0, 0)
EndIf
Local $aResult = DllCall("user32.dll", "boolean", "GetProcessDpiAwarenessInternal", "handle", $hProcess, "ulong*", 0)
_WinAPI_CloseHandle($hProcess)
If @error Or UBound($aResult) < 3 Then Return SetError(3, 0, 0)
Local $iDpiAwareness = $aResult[2]
Return $iDpiAwareness
EndFunc
Func _GUICreate($title, $width, $height, $left = -1, $top = -1, $style = -1, $exStyle = -1, $parent = 0)
Local $h = GUICreate($title, $width, $height, $left, $top, $style, $exStyle, $parent)
Local $key = String($h)
Local $obj = $h
$g_oGuiNotInMini.Add($key, $obj)
Return $h
EndFunc
Func _GUICtrlCreateIcon($filename, $iconName, $left, $top, $width = 32, $height = 32, $style = -1, $exStyle = -1)
Static $s_hLibIcon = 0
Local $hLib
If $filename = $g_sLibIconPath Then
If $s_hLibIcon = 0 Then
$s_hLibIcon = _WinAPI_LoadLibraryEx($filename, $LOAD_LIBRARY_AS_DATAFILE)
EndIf
$hLib = $s_hLibIcon
Else
$hLib = _WinAPI_LoadLibraryEx($filename, $LOAD_LIBRARY_AS_DATAFILE)
EndIf
Local $hIcon = _WinAPI_LoadImage($hLib, $iconName, $IMAGE_ICON, $width, $height, $LR_DEFAULTCOLOR)
If $hLib <> $s_hLibIcon Then
_WinAPI_FreeLibrary($hLib)
EndIf
Local $hBmp = _WinAPI_Create32BitHBITMAP($hIcon, False, True)
Local $controlID = GUICtrlCreatePic("", $left, $top, $width, $height, $style, $exStyle)
_WinAPI_DeleteObject(GUICtrlSendMsg($controlID, $STM_SETIMAGE, 0, $hBmp))
_WinAPI_DeleteObject($hBmp)
Local $aIconData = [$width, $height]
$g_oCtrlIconData("Icon:" & GUICtrlGetHandle($controlID)) = $aIconData
Return $controlID
EndFunc
Func _GUICtrlSetImage($controlID, $filename, $iconName = -1, $iconType = 1)
Local $aIconData = $g_oCtrlIconData("Icon:" & GUICtrlGetHandle($controlID))
If IsArray($aIconData) = 0 Then
Return GUICtrlSetImage($controlID, $filename, $iconName, $iconType)
EndIf
Static $s_hLibIcon = 0
Local $hLib
If $filename = $g_sLibIconPath Then
If $s_hLibIcon = 0 Then
$s_hLibIcon = _WinAPI_LoadLibraryEx($filename, $LOAD_LIBRARY_AS_DATAFILE)
EndIf
$hLib = $s_hLibIcon
Else
$hLib = _WinAPI_LoadLibraryEx($filename, $LOAD_LIBRARY_AS_DATAFILE)
EndIf
If $hLib = 0 Then Return 0
Local $width = $aIconData[0], $height = $aIconData[1]
Local $hIcon = _WinAPI_LoadImage($hLib, $iconName, $IMAGE_ICON, $width, $height, $LR_DEFAULTCOLOR)
If $hLib <> $s_hLibIcon Then
_WinAPI_FreeLibrary($hLib)
EndIf
If $hIcon = 0 Then Return 0
Local $hBmp = _WinAPI_Create32BitHBITMAP($hIcon, False, True)
If $hBmp = 0 Then Return 0
_WinAPI_DeleteObject(GUICtrlSendMsg($controlID, $STM_SETIMAGE, 0, 0))
GUICtrlSendMsg($controlID, $STM_SETIMAGE, 0, $hBmp)
_WinAPI_InvalidateRect(GUICtrlGetHandle($controlID), 0, False)
_WinAPI_DeleteObject($hBmp)
Return 1
EndFunc
Func GUICtrlGetBkColor($hWnd)
If Not IsHWnd($hWnd) Then
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
Local $hDC = _WinAPI_GetDC($hWnd)
Local $iColor = _WinAPI_GetPixel($hDC, 0, 0)
_WinAPI_ReleaseDC($hWnd, $hDC)
Return $iColor
EndFunc
Global $g_bRedrawBotWindow[3] = [True, False, False]
Global $g_hFrmBot_WNDPROC = 0
Global $g_hFrmBot_WNDPROC_ptr = 0
Global $g_aGroupSearchDB = "", $groupHerosDB = "", $groupSearchAB = "", $groupHerosAB = "", $groupSpellsDB = "", $groupSpellsAB = "", $groupSearchTS = ""
Global $g_aGroupAttackDB = "", $g_aGroupAttackDBSpell = "", $groupIMGAttackDB = "", $groupIMGAttackDBSpell = "", $groupAttackAB = "", $groupAttackABSpell = "", $groupIMGAttackAB = "", $groupIMGAttackABSpell = "", $groupAttackTS = "", $groupAttackTSSpell = "", $groupIMGAttackTS = "", $groupIMGAttackTSSpell = ""
Global $g_aGroupListPicMinTrophy = "", $g_aGroupListPicMaxTrophy = ""
Global $g_aGroupEndBattleDB = "", $groupEndBattkeAB = "", $groupKingSleeping = "", $groupQueenSleeping = "", $groupWardenSleeping = "", $groupCloseWhileTraining = "", $grpTrainTroops = "", $grpCookSpell = ""
Global $g_aGroupLightning = "", $groupHeal = "", $groupRage = "", $groupJumpSpell = "", $groupFreeze = "", $groupClone = "", $groupIcnLightning = "", $groupIcnHeal = "", $groupIcnRage = "", $groupIcnJumpSpell = "", $groupIcnFreeze = "", $groupIcnClone = ""
Global $g_aGroupPoison = "", $groupEarthquake = "", $groupHaste = "", $groupSkeleton = "", $groupIcnPoison = "", $groupIcnEarthquake = "", $groupIcnHaste = "", $groupIcnSkeleton = "", $groupListSpells = ""
Global $g_aGroupListTHLevels = ""
Global $g_aGroupListPicDBMaxTH = ""
Global $g_aGroupListPicABMaxTH = ""
Global $g_aGroupListPicBullyMaxTH = ""
Global $g_aGroupLeague = ""
Global $aTabControlsVillage, $aTabControlsMisc, $aTabControlsDonate, $aTabControlsUpgrade, $aTabControlsNotify
Global $aTabControlsAttack, $aTabControlsArmy, $aTabControlsSearch, $aTabControlsDeadbase, $aTabControlsActivebase, $aTabControlsTHSnipe, $aTabControlsAttackOptions
Global $aTabControlsStrategies, $aTabControlsBot, $aTabControlsStats
Global $oAlwaysEnabledControls = ObjCreate("Scripting.Dictionary")
Func InitializeControlVariables()
$g_aGroupSearchDB = $g_hGrpDBFilter&"#"&$g_hCmbDBMeetGE&"#"&$g_hTxtDBMinGold&"#"&$g_hPicDBMinGold&"#"&$g_hTxtDBMinElixir&"#"&$g_hPicDBMinElixir&"#"& $g_hTxtDBMinGoldPlusElixir&"#"&$g_hPicDBMinGPEGold&"#"&$g_hChkDBMeetDE&"#"&$g_hTxtDBMinDarkElixir&"#"&$g_hPicDBMinDarkElixir&"#"&$g_hChkDBMeetTrophy&"#"& $g_hTxtDBMinTrophy&"#"&$g_hTxtDBMaxTrophy&"#"&$g_hPicDBMinTrophies&"#"&$g_hChkDBMeetTH&"#"&$g_hCmbDBTH&"#"&$g_hChkDBMeetTHO&"#"& $g_ahChkMeetOne[$DB]&"#"& $g_ahChkMaxMortar[$DB]&"#"&$g_ahCmbWeakMortar[$DB]&"#"&$g_ahPicWeakMortar[$DB]&"#"&$g_ahChkMaxWizTower[$DB]&"#"&$g_ahCmbWeakWizTower[$DB]&"#"& $g_ahPicWeakWizTower[$DB]&"#"& $g_ahChkMaxXBow[$DB]&"#"&$g_ahCmbWeakXBow[$DB]&"#"&$g_ahPicWeakXBow[$DB]&"#"&$g_ahChkMaxInferno[$DB]&"#"&$g_ahCmbWeakInferno[$DB]&"#"& $g_ahPicWeakInferno[$DB]&"#"&$g_ahChkMaxEagle[$DB]&"#"&$g_ahCmbWeakEagle[$DB]&"#"&$g_ahPicWeakEagle[$DB]
$groupHerosDB = $g_hPicDBHeroesWait&"#"&$g_hTxtDBHeroesWait&"#"&$g_hChkDBKingWait&"#"&$g_hChkDBQueenWait&"#"&$g_hChkDBWardenWait&"#"&$g_hPicDBKingWait&"#"& $g_hPicDBQueenWait&"#"&$g_hPicDBWardenWait&"#"&$g_hChkDBNotWaitHeroes
$groupSearchAB = $g_hGrpABFilter&"#"&$g_hCmbABMeetGE&"#"&$g_hTxtABMinGold&"#"&$g_hPicABMinGold&"#"&$g_hTxtABMinElixir&"#"&$g_hPicABMinElixir&"#"& $g_hTxtABMinGoldPlusElixir&"#"&$g_hPicABMinGPEGold&"#"&$g_hChkABMeetDE&"#"&$g_hTxtABMinDarkElixir&"#"& $g_hPicABMinDarkElixir&"#"&$g_hChkABMeetTrophy&"#"& $g_hTxtABMinTrophy&"#"&$g_hTxtABMaxTrophy&"#"&$g_hPicABMinTrophies&"#"&$g_hChkABMeetTH&"#"&$g_hCmbABTH&"#"&$g_hChkABMeetTHO&"#"& $g_ahChkMeetOne[$LB]&"#"& $g_ahChkMaxMortar[$LB]&"#"&$g_ahCmbWeakMortar[$LB]&"#"&$g_ahPicWeakMortar[$LB]&"#"&$g_ahChkMaxWizTower[$LB]&"#"&$g_ahCmbWeakWizTower[$LB]&"#"& $g_ahPicWeakWizTower[$LB]&"#"&$g_ahChkMaxXBow[$LB]&"#"&$g_ahCmbWeakXBow[$LB]&"#"&$g_ahPicWeakXBow[$LB]&"#"&$g_ahChkMaxInferno[$LB]&"#"& $g_ahCmbWeakInferno[$LB]&"#"&$g_ahPicWeakInferno[$LB]&"#"&$g_ahChkMaxEagle[$LB]&"#"&$g_ahCmbWeakEagle[$LB]&"#"&$g_ahPicWeakEagle[$LB]
$groupHerosAB = $g_hPicABHeroesWait&"#"&$g_hTxtABHeroesWait&"#"&$g_hChkABKingWait&"#"&$g_hChkABQueenWait&"#"&$g_hChkABWardenWait&"#"&$g_hPicABKingWait&"#"& $g_hPicABQueenWait&"#"&$g_hPicABWardenWait&"#"&$g_hChkABNotWaitHeroes
$groupSpellsDB = $g_hChkDBSpellsWait&"#"&$g_hPicDBLightSpellWait&"#"&$g_hPicDBHealSpellWait&"#"&$g_hPicDBRageSpellWait&"#"&$g_hPicDBJumpSpellWait&"#"& $g_hPicDBFreezeSpellWait&"#"&$g_hPicDBPoisonSpellWait&"#"&$g_hPicDBEarthquakeSpellWait&"#"&$g_hPicDBHasteSpellWait
$groupSpellsAB = $g_hChkABSpellsWait&"#"&$g_hPicABLightSpellWait&"#"&$g_hPicABHealSpellWait&"#"&$g_hPicABRageSpellWait&"#"&$g_hPicABJumpSpellWait&"#"& $g_hPicABFreezeSpellWait&"#"&$g_hPicABPoisonSpellWait&"#"&$g_hPicABEarthquakeSpellWait&"#"&$g_hPicABHasteSpellWait
$groupSearchTS = $g_hGrpTSFilter&"#"&$g_hCmbTSMeetGE&"#"&$g_hTxtTSMinGold&"#"&$g_hPicTSMinGold&"#"&$g_hTxtTSMinElixir&"#"&$g_hPicTSMinElixir&"#"& $g_hTxtTSMinGoldPlusElixir&"#"&$g_hPicTSMinGPEGold&"#"&$g_hChkTSMeetDE&"#"&$g_hTxtTSMinDarkElixir&"#"&$g_hPicTSMinDarkElixir&"#"& $g_hLblAddTiles&"#"&$g_hLblAddTiles2&"#"&$g_hLblSWTTiles&"#"&$g_hTxtSWTTiles&"#"&$g_hLblTHadd&"#"&$g_hTxtTHaddTiles
$g_aGroupAttackDB = $g_hCmbDBAlgorithm&"#"&$g_hCmbDBSelectTroop&"#"&$g_hChkDBKingAttack&"#"&$g_hChkDBQueenAttack&"#"&$g_hChkDBWardenAttack&"#"&$g_hChkDBDropCC&"#"& $g_hChkDBLightSpell&"#"&$g_hChkDBHealSpell&"#"&$g_hChkDBRageSpell&"#"&$g_hChkDBJumpSpell&"#"&$g_hChkDBFreezeSpell&"#"&$g_hChkDBCloneSpell&"#"& $g_hChkDBPoisonSpell&"#"&$g_hChkDBEarthquakeSpell&"#"&$g_hChkDBHasteSpell&"#"&$g_hChkDBSkeletonSpell
$g_aGroupAttackDBSpell = $g_hChkDBLightSpell&"#"&$g_hChkDBHealSpell&"#"&$g_hChkDBRageSpell&"#"&$g_hChkDBJumpSpell&"#"&$g_hChkDBFreezeSpell&"#"&$g_hChkDBCloneSpell&"#"& $g_hChkDBPoisonSpell&"#"&$g_hChkDBEarthquakeSpell&"#"&$g_hChkDBHasteSpell&"#"&$g_hChkDBSkeletonSpell
$groupIMGAttackDB = $g_hPicDBKingAttack&"#"&$g_hPicDBQueenAttack&"#"&$g_hPicDBWardenAttack&"#"&$g_hPicDBDropCC&"#"& $g_hPicDBLightSpell&"#"&$g_hPicDBHealSpell&"#"&$g_hPicDBRageSpell&"#"&$g_hPicDBJumpSpell&"#"&$g_hPicDBFreezeSpell&"#"&$g_hPicDBCloneSpell&"#"& $g_hPicDBPoisonSpell&"#"&$g_hPicDBEarthquakeSpell&"#"&$g_hPicDBHasteSpell&"#"&$g_hPicDBSkeletonSpell
$groupIMGAttackDBSpell = $g_hPicDBLightSpell&"#"&$g_hPicDBHealSpell&"#"&$g_hPicDBRageSpell&"#"&$g_hPicDBJumpSpell&"#"&$g_hPicDBFreezeSpell&"#"&$g_hPicDBCloneSpell&"#"& $g_hPicDBPoisonSpell&"#"&$g_hPicDBEarthquakeSpell&"#"&$g_hPicDBHasteSpell&"#"&$g_hPicDBSkeletonSpell
$groupAttackAB = $g_hCmbDBAlgorithm&"#"&$g_hCmbABSelectTroop&"#"&$g_hChkABKingAttack&"#"&$g_hChkABQueenAttack&"#"&$g_hChkABWardenAttack&"#"&$g_hChkABDropCC&"#"& $g_hChkABLightSpell&"#"&$g_hChkABHealSpell&"#"&$g_hChkABRageSpell&"#"&$g_hChkABJumpSpell&"#"&$g_hChkABFreezeSpell&"#"&$g_hChkABCloneSpell&"#"& $g_hChkABPoisonSpell&"#"&$g_hChkABEarthquakeSpell&"#"&$g_hChkABHasteSpell&"#"&$g_hChkABSkeletonSpell
$groupAttackABSpell = $g_hChkABLightSpell&"#"&$g_hChkABHealSpell&"#"&$g_hChkABRageSpell&"#"&$g_hChkABJumpSpell&"#"&$g_hChkABFreezeSpell&"#"&$g_hChkABCloneSpell&"#"& $g_hChkABPoisonSpell&"#"&$g_hChkABEarthquakeSpell&"#"&$g_hChkABHasteSpell&"#"&$g_hChkABSkeletonSpell
$groupIMGAttackAB = $g_hPicABKingAttack&"#"&$g_hPicABQueenAttack&"#"&$g_hPicABWardenAttack&"#"&$g_hPicABDropCC&"#"& $g_hPicABLightSpell&"#"&$g_hPicABHealSpell&"#"&$g_hPicABRageSpell&"#"&$g_hPicABJumpSpell&"#"&$g_hPicABFreezeSpell&"#"&$g_hPicABCloneSpell&"#"& $g_hPicABPoisonSpell&"#"&$g_hPicABEarthquakeSpell&"#"&$g_hPicABHasteSpell&"#"&$g_hPicABSkeletonSpell
$groupIMGAttackABSpell = $g_hPicABLightSpell&"#"&$g_hPicABHealSpell&"#"&$g_hPicABRageSpell&"#"&$g_hPicABJumpSpell&"#"&$g_hPicABFreezeSpell&"#"&$g_hPicABCloneSpell&"#"& $g_hPicABPoisonSpell&"#"&$g_hPicABEarthquakeSpell&"#"&$g_hPicABHasteSpell&"#"&$g_hPicABSkeletonSpell
$groupAttackTS = $g_hGrpABAttack&"#"&$g_hLblAttackTHType&"#"&$g_hCmbAttackTHType&"#"&$g_hLblTSSelectTroop&"#"&$g_hCmbTSSelectTroop&"#"& $g_hLblTSSelectSpecialTroop&"#"&$g_hChkTSKingAttack&"#"&$g_hChkTSQueenAttack&"#"&$g_hChkTSWardenAttack&"#"&$g_hChkTSDropCC&"#"&$g_hChkTSLightSpell&"#"& $g_hChkTSHealSpell&"#"&$g_hChkTSRageSpell&"#"&$g_hChkTSJumpSpell&"#"&$g_hChkTSFreezeSpell&"#"&$g_hChkTSPoisonSpell&"#"&$g_hChkTSEarthquakeSpell&"#"& $g_hChkTSHasteSpell
$groupAttackTSSpell = $g_hChkTSLightSpell&"#"&$g_hChkTSHealSpell&"#"&$g_hChkTSRageSpell&"#"&$g_hChkTSJumpSpell&"#"&$g_hChkTSFreezeSpell&"#"& $g_hChkTSPoisonSpell&"#"&$g_hChkTSEarthquakeSpell&"#"&$g_hChkTSHasteSpell
$groupIMGAttackTS = $g_hPicTSKingAttack&"#"&$g_hPicTSQueenAttack&"#"&$g_hPicTSWardenAttack&"#"&$g_hPicTSDropCC&"#"&$g_hPicTSLightSpell&"#"& $g_hPicTSHealSpell&"#"&$g_hPicTSRageSpell&"#"&$g_hPicTSJumpSpell&"#"&$g_hPicTSFreezeSpell&"#"&$g_hPicTSPoisonSpell&"#"&$g_hPicTSEarthquakeSpell&"#"& $g_hPicTSHasteSpell
$groupIMGAttackTSSpell = $g_hPicTSLightSpell&"#"&$g_hPicTSHealSpell&"#"&$g_hPicTSRageSpell&"#"&$g_hPicTSJumpSpell&"#"&$g_hPicTSFreezeSpell&"#"& $g_hPicTSPoisonSpell&"#"&$g_hPicTSEarthquakeSpell&"#"&$g_hPicTSHasteSpell
$g_aGroupListPicMinTrophy = $g_hPicMinTrophies[$eLeagueUnranked]&"#"&$g_hPicMinTrophies[$eLeagueBronze]&"#"&$g_hPicMinTrophies[$eLeagueSilver]&"#"&$g_hPicMinTrophies[$eLeagueGold] &"#"& $g_hPicMinTrophies[$eLeagueCrystal]&"#"&$g_hPicMinTrophies[$eLeagueMaster]&"#"&$g_hPicMinTrophies[$eLeagueChampion]&"#"&$g_hPicMinTrophies[$eLeagueTitan]&"#"& $g_hPicMinTrophies[$eLeagueLegend]
$g_aGroupListPicMaxTrophy = $g_hPicMaxTrophies[$eLeagueUnranked]&"#"&$g_hPicMaxTrophies[$eLeagueBronze]&"#"&$g_hPicMaxTrophies[$eLeagueSilver]&"#"&$g_hPicMaxTrophies[$eLeagueGold] &"#"& $g_hPicMaxTrophies[$eLeagueCrystal]&"#"&$g_hPicMaxTrophies[$eLeagueMaster]&"#"&$g_hPicMaxTrophies[$eLeagueChampion]&"#"&$g_hPicMaxTrophies[$eLeagueTitan]&"#"& $g_hPicMaxTrophies[$eLeagueLegend]
$g_aGroupEndBattleDB = $g_hGrpDBEndBattle&"#"&$g_hChkStopAtkDBNoLoot1&"#"&$g_hLblStopAtkDBNoLoot1a&"#"&$g_hTxtStopAtkDBNoLoot1&"#"&$g_hLblStopAtkDBNoLoot1b&"#"& $g_hChkStopAtkDBNoLoot2&"#"&$g_hChkStopAtkDBNoLoot2&"#"&$g_hLblStopAtkDBNoLoot2a&"#"&$g_hTxtStopAtkDBNoLoot2&"#"&$g_hLblStopAtkDBNoLoot2b&"#"& $g_hLblDBMinRerourcesAtk2&"#"&$g_hTxtDBMinGoldStopAtk2&"#"&$g_hPicDBMinGoldStopAtk2&"#"&$g_hTxtDBMinElixirStopAtk2&"#"&$g_hPicDBMinElixirStopAtk2&"#"& $g_hTxtDBMinDarkElixirStopAtk2&"#"&$g_hPicDBMinDarkElixirStopAtk2&"#"&$g_hChkDBEndNoResources&"#"&$g_hChkDBEndOneStar&"#"&$g_hChkDBEndTwoStars
$groupEndBattkeAB = $g_hGrpABEndBattle&"#"&$g_hChkStopAtkABNoLoot1&"#"&$g_hLblABTimeStopAtka&"#"&$g_hTxtStopAtkABNoLoot1&"#"&$g_hLblABTimeStopAtk&"#"& $g_hChkStopAtkABNoLoot2&"#"&$g_hChkStopAtkABNoLoot2&"#"&$g_hLblABTimeStopAtk2a&"#"&$g_hTxtStopAtkABNoLoot2&"#"&$g_hLblABTimeStopAtk2&"#"& $g_hLblABMinRerourcesAtk2&"#"&$g_hTxtABMinGoldStopAtk2&"#"&$g_hPicABMinGoldStopAtk2&"#"&$g_hTxtABMinElixirStopAtk2&"#"&$g_hPicABMinElixirStopAtk2&"#"& $g_hTxtABMinDarkElixirStopAtk2&"#"&$g_hPicABMinDarkElixirStopAtk2&"#"&$g_hChkABEndNoResources&"#"&$g_hChkABEndOneStar&"#"&$g_hChkABEndTwoStars
$groupKingSleeping = $g_hPicDBKingSleepWait&"#"&$g_hPicABKingSleepWait&"#"&$g_hPicChkKingSleepWait
$groupQueenSleeping = $g_hPicDBQueenSleepWait&"#"&$g_hPicABQueenSleepWait&"#"&$g_hPicChkQueenSleepWait
$groupWardenSleeping = $g_hPicDBWardenSleepWait&"#"&$g_hPicABWardenSleepWait&"#"&$g_hPicChkWardenSleepWait
$groupCloseWhileTraining = $g_hChkCloseWithoutShield&"#"&$g_hChkCloseEmulator&"#"&$g_hChkSuspendComputer&"#"&$g_hPicCloseWaitTrain&"#"&$g_hChkRandomClose&"#"&$g_hPicCloseWaitStop&"#"& $g_hRdoCloseWaitExact&"#"&$g_hPicCloseWaitExact&"#"&$g_hRdoCloseWaitRandom&"#"&$g_hCmbCloseWaitRdmPercent&"#"&$g_hLblCloseWaitRdmPercent
$grpTrainTroops = $g_ahTxtTrainArmyTroopCount[$eTroopBarbarian]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopArcher]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopGiant]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopGoblin]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopWallBreaker]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopBalloon]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopWizard]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopHealer]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopDragon]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopPekka]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopBabyDragon]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopMiner]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopMinion]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopHogRider]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopValkyrie]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopGolem]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopWitch]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopLavaHound]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopBowler]
$grpCookSpell = $g_ahTxtTrainArmySpellCount[$eSpellLightning]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellHeal]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellRage]&"#"& $g_ahTxtTrainArmySpellCount[$eSpellJump]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellFreeze]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellClone]&"#"& $g_ahTxtTrainArmySpellCount[$eSpellPoison]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellEarthquake]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellHaste]&"#"& $g_ahTxtTrainArmySpellCount[$eSpellSkeleton]
$g_aGroupLightning = $g_ahPicTrainArmySpell[$eSpellLightning]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellLightning]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellLightning]
$groupHeal = $g_ahPicTrainArmySpell[$eSpellHeal]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellHeal]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellHeal]
$groupRage = $g_ahPicTrainArmySpell[$eSpellRage]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellRage]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellRage]
$groupJumpSpell = $g_ahPicTrainArmySpell[$eSpellJump]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellJump]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellJump]
$groupFreeze = $g_ahPicTrainArmySpell[$eSpellFreeze]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellFreeze]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellFreeze]
$groupClone = $g_ahPicTrainArmySpell[$eSpellClone]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellClone]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellClone]
$groupIcnLightning = $g_ahPicTrainArmySpell[$eSpellLightning]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellLightning]
$groupIcnHeal = $g_ahPicTrainArmySpell[$eSpellHeal]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellHeal]
$groupIcnRage = $g_ahPicTrainArmySpell[$eSpellRage]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellRage]
$groupIcnJumpSpell = $g_ahPicTrainArmySpell[$eSpellJump]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellJump]
$groupIcnFreeze = $g_ahPicTrainArmySpell[$eSpellFreeze]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellFreeze]
$groupIcnClone = $g_ahPicTrainArmySpell[$eSpellClone]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellClone]
$g_aGroupPoison = $g_ahPicTrainArmySpell[$eSpellPoison]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellPoison]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellPoison]
$groupEarthquake = $g_ahPicTrainArmySpell[$eSpellEarthquake]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellEarthquake]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellEarthquake]
$groupHaste = $g_ahPicTrainArmySpell[$eSpellHaste]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellHaste]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellHaste]
$groupSkeleton = $g_ahPicTrainArmySpell[$eSpellSkeleton]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellSkeleton]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellSkeleton]
$groupIcnPoison = $g_ahPicTrainArmySpell[$eSpellPoison]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellPoison]
$groupIcnEarthquake = $g_ahPicTrainArmySpell[$eSpellEarthquake]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellEarthquake]
$groupIcnHaste = $g_ahPicTrainArmySpell[$eSpellHaste]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellHaste]
$groupIcnSkeleton = $g_ahPicTrainArmySpell[$eSpellSkeleton]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellSkeleton]
$groupListSpells = $g_aGroupLightning&"#"&$groupHeal&"#"&$groupRage&"#"&$groupJumpSpell&"#"&$groupFreeze&"#"&$groupClone&"#"&$g_aGroupPoison&"#"& $groupEarthquake&"#"&$groupHaste&"#"&$groupSkeleton
$g_aGroupListTHLevels = $g_ahPicTHLevels[4]&"#"&$g_ahPicTHLevels[5]&"#"&$g_ahPicTHLevels[6]&"#"&$g_ahPicTHLevels[7]&"#"&$g_ahPicTHLevels[8]&"#"& $g_ahPicTHLevels[9]&"#"&$g_ahPicTHLevels[10]&"#"&$g_ahPicTHLevels[11]&"#"&$g_ahPicTHLevels[12]
$g_aGroupListPicDBMaxTH = $g_ahPicDBMaxTH[6]&"#"&$g_ahPicDBMaxTH[7]&"#"&$g_ahPicDBMaxTH[8]&"#"& $g_ahPicDBMaxTH[9]&"#"&$g_ahPicDBMaxTH[10]&"#"&$g_ahPicDBMaxTH[11] & "#" & $g_ahPicDBMaxTH[12]
$g_aGroupListPicABMaxTH = $g_ahPicABMaxTH[6]&"#"&$g_ahPicABMaxTH[7]&"#"&$g_ahPicABMaxTH[8]&"#"& $g_ahPicABMaxTH[9]&"#"&$g_ahPicABMaxTH[10]&"#"&$g_ahPicABMaxTH[11] & "#" & $g_ahPicABMaxTH[12]
$g_aGroupListPicBullyMaxTH = $g_ahPicBullyMaxTH[6]&"#"&$g_ahPicBullyMaxTH[7]&"#"&$g_ahPicBullyMaxTH[8]&"#"& $g_ahPicBullyMaxTH[9]&"#"&$g_ahPicBullyMaxTH[10]&"#"&$g_ahPicBullyMaxTH[11] & "#" & $g_ahPicBullyMaxTH[12]
$g_aGroupLeague = $g_ahPicLeague[$eLeagueUnranked]&"#"&$g_ahPicLeague[$eLeagueBronze]&"#"&$g_ahPicLeague[$eLeagueSilver]&"#"&$g_ahPicLeague[$eLeagueGold] &"#"& $g_ahPicLeague[$eLeagueCrystal]&"#"&$g_ahPicLeague[$eLeagueMaster]&"#"&$g_ahPicLeague[$eLeagueChampion]&"#"&$g_ahPicLeague[$eLeagueTitan]&"#"& $g_ahPicLeague[$eLeagueLegend]
Dim $aTabControlsVillage = [$g_hGUI_VILLAGE_TAB, $g_hGUI_VILLAGE_TAB_ITEM1, $g_hGUI_VILLAGE_TAB_ITEM2, $g_hGUI_VILLAGE_TAB_ITEM3, $g_hGUI_VILLAGE_TAB_ITEM4, $g_hGUI_VILLAGE_TAB_ITEM5]
Dim $aTabControlsMisc = [$g_hGUI_MISC_TAB, $g_hGUI_MISC_TAB_ITEM1, $g_hGUI_MISC_TAB_ITEM2]
Dim $aTabControlsDonate = [$g_hGUI_DONATE_TAB, $g_hGUI_DONATE_TAB_ITEM1, $g_hGUI_DONATE_TAB_ITEM2, $g_hGUI_DONATE_TAB_ITEM3]
Dim $aTabControlsUpgrade = [$g_hGUI_UPGRADE_TAB, $g_hGUI_UPGRADE_TAB_ITEM1, $g_hGUI_UPGRADE_TAB_ITEM2, $g_hGUI_UPGRADE_TAB_ITEM3, $g_hGUI_UPGRADE_TAB_ITEM4, $g_hGUI_UPGRADE_TAB_ITEM5]
Dim $aTabControlsNotify = [$g_hGUI_NOTIFY_TAB, $g_hGUI_NOTIFY_TAB_ITEM2, $g_hGUI_NOTIFY_TAB_ITEM6]
Dim $aTabControlsAttack = [$g_hGUI_ATTACK_TAB, $g_hGUI_ATTACK_TAB_ITEM1, $g_hGUI_ATTACK_TAB_ITEM2, $g_hGUI_ATTACK_TAB_ITEM3]
Dim $aTabControlsArmy = [$g_hGUI_TRAINARMY_TAB, $g_hGUI_TRAINARMY_TAB_ITEM1, $g_hGUI_TRAINARMY_TAB_ITEM2, $g_hGUI_TRAINARMY_TAB_ITEM3, $g_hGUI_TRAINARMY_TAB_ITEM4]
Dim $aTabControlsSearch = [$g_hGUI_SEARCH_TAB, $g_hGUI_SEARCH_TAB_ITEM1, $g_hGUI_SEARCH_TAB_ITEM2, $g_hGUI_SEARCH_TAB_ITEM3, $g_hGUI_SEARCH_TAB_ITEM4, $g_hGUI_SEARCH_TAB_ITEM5]
Dim $aTabControlsDeadbase = [$g_hGUI_DEADBASE_TAB, $g_hGUI_DEADBASE_TAB_ITEM1, $g_hGUI_DEADBASE_TAB_ITEM2, $g_hGUI_DEADBASE_TAB_ITEM3, $g_hGUI_DEADBASE_TAB_ITEM4]
Dim $aTabControlsActivebase = [$g_hGUI_ACTIVEBASE_TAB, $g_hGUI_ACTIVEBASE_TAB_ITEM1, $g_hGUI_ACTIVEBASE_TAB_ITEM2, $g_hGUI_ACTIVEBASE_TAB_ITEM3]
Dim $aTabControlsTHSnipe = [$g_hGUI_THSNIPE_TAB, $g_hGUI_THSNIPE_TAB_ITEM1, $g_hGUI_THSNIPE_TAB_ITEM2, $g_hGUI_THSNIPE_TAB_ITEM3]
Dim $aTabControlsAttackOptions = [$g_hGUI_ATTACKOPTION_TAB, $g_hGUI_ATTACKOPTION_TAB_ITEM1, $g_hGUI_ATTACKOPTION_TAB_ITEM2, $g_hGUI_ATTACKOPTION_TAB_ITEM3, $g_hGUI_ATTACKOPTION_TAB_ITEM4, $g_hGUI_ATTACKOPTION_TAB_ITEM5]
Dim $aTabControlsStrategies = [$g_hGUI_STRATEGIES_TAB, $g_hGUI_STRATEGIES_TAB_ITEM1, $g_hGUI_STRATEGIES_TAB_ITEM2]
Dim $aTabControlsBot = [$g_hGUI_BOT_TAB, $g_hGUI_BOT_TAB_ITEM1, $g_hGUI_BOT_TAB_ITEM2, $g_hGUI_BOT_TAB_ITEM3, $g_hGUI_BOT_TAB_ITEM4, $g_hGUI_BOT_TAB_ITEM5]
Dim $aTabControlsStats = [$g_hGUI_STATS_TAB, $g_hGUI_STATS_TAB_ITEM1, $g_hGUI_STATS_TAB_ITEM2, $g_hGUI_STATS_TAB_ITEM3, $g_hGUI_STATS_TAB_ITEM4, $g_hGUI_STATS_TAB_ITEM5]
$oAlwaysEnabledControls($g_hChkHideWhenMinimized) = 1
$oAlwaysEnabledControls($g_hChkDebugSetlog) = 1
$oAlwaysEnabledControls($g_hChkDebugAndroid) = 1
$oAlwaysEnabledControls($g_hChkDebugClick) = 1
$oAlwaysEnabledControls($g_hChkDebugFunc) = 1
$oAlwaysEnabledControls($g_hChkDebugDisableZoomout) = 1
$oAlwaysEnabledControls($g_hChkDebugDisableVillageCentering) = 1
$oAlwaysEnabledControls($g_hChkDebugDeadbaseImage) = 1
$oAlwaysEnabledControls($g_hChkDebugOCR) = 1
$oAlwaysEnabledControls($g_hChkDebugImageSave) = 1
$oAlwaysEnabledControls($g_hChkdebugBuildingPos) = 1
$oAlwaysEnabledControls($g_hChkdebugTrain) = 1
$oAlwaysEnabledControls($g_hChkDebugOCRDonate) = 1
$oAlwaysEnabledControls($g_hChkDebugSmartZap) = 1
$oAlwaysEnabledControls($g_hBtnTestTrain) = 1
$oAlwaysEnabledControls($g_hBtnTestDonateCC) = 1
$oAlwaysEnabledControls($g_hBtnTestRequestCC) = 1
$oAlwaysEnabledControls($g_hBtnTestSendText) = 1
$oAlwaysEnabledControls($g_hBtnTestAttackBar) = 1
$oAlwaysEnabledControls($g_hBtnTestClickDrag) = 1
$oAlwaysEnabledControls($g_hBtnTestImage) = 1
$oAlwaysEnabledControls($g_hBtnTestVillageSize) = 1
$oAlwaysEnabledControls($g_hBtnTestDeadBase) = 1
$oAlwaysEnabledControls($g_hBtnTestDeadBaseFolder) = 1
$oAlwaysEnabledControls($g_hBtnTestTHimgloc) = 1
$oAlwaysEnabledControls($g_hBtnTestimglocTroopBar) = 1
$oAlwaysEnabledControls($g_hBtnTestQuickTrainsimgloc) = 1
$oAlwaysEnabledControls($g_hChkdebugAttackCSV) = 1
$oAlwaysEnabledControls($g_hChkMakeIMGCSV) = 1
$oAlwaysEnabledControls($g_hBtnTestAttackCSV) = 1
$oAlwaysEnabledControls($g_hBtnTestBuildingLocation) = 1
$oAlwaysEnabledControls($g_hBtnTestFindButton) = 1
$oAlwaysEnabledControls($g_hTxtTestFindButton) = 1
$oAlwaysEnabledControls($g_hBtnTestCleanYard) = 1
$oAlwaysEnabledControls($g_hLblSmartLightningUsed) = 1
$oAlwaysEnabledControls($g_hLblSmartZap) = 1
$oAlwaysEnabledControls($g_hLblSmartEarthQuakeUsed) = 1
$oAlwaysEnabledControls($g_hBtnTestConfigSave) = 1
$oAlwaysEnabledControls($g_hBtnTestConfigRead) = 1
$oAlwaysEnabledControls($g_hBtnTestConfigApply) = 1
$oAlwaysEnabledControls($g_hBtnTestWeakBase) = 1
$oAlwaysEnabledControls($g_hBtnConsoleWindow) = 1
$oAlwaysEnabledControls($g_hBtnAndroidAdbShell) = 1
$oAlwaysEnabledControls($g_hBtnAndroidHome) = 1
$oAlwaysEnabledControls($g_hBtnAndroidBack) = 1
$oAlwaysEnabledControls($g_hBtnMakeScreenshot) = 1
$oAlwaysEnabledControls($g_hDivider) = 1
$oAlwaysEnabledControls($g_hTabMain) = 1
$oAlwaysEnabledControls($g_hTabLog) = 1
$oAlwaysEnabledControls($g_hTabVillage) = 1
$oAlwaysEnabledControls($g_hTabAttack) = 1
$oAlwaysEnabledControls($g_hTabBot) = 1
$oAlwaysEnabledControls($g_hTabAbout) = 1
For $i in $aTabControlsVillage
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsMisc
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsDonate
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsUpgrade
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsNotify
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsAttack
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsArmy
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsSearch
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsDeadbase
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsActivebase
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsTHSnipe
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsAttackOptions
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsStrategies
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsBot
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsStats
$oAlwaysEnabledControls($i) = 1
Next
EndFunc
Global $g_aFrmBotBottomCtrlState, $g_hFrmBotEmbeddedShield = 0, $g_hFrmBotEmbeddedMouse = 0, $g_hFrmBotEmbeddedGraphics = 0
Func Initiate()
WinGetAndroidHandle()
If $g_hAndroidWindow <> 0 And($g_bAndroidBackgroundLaunched = True Or AndroidControlAvailable()) Then
SetLogCentered(" " & $g_sBotTitle & " Powered by MyBot.run ", "~", $COLOR_DEBUG)
Local $Compiled = @ScriptName &(@Compiled ? " Executable" : " Script")
SetLog($Compiled & " running on " & @OSVersion & " " & @OSServicePack & " " & @OSArch)
If Not $g_bSearchMode Then
SetLogCentered(" Bot Start ", Default, $COLOR_SUCCESS)
Else
SetLogCentered(" Search Mode Start ", Default, $COLOR_SUCCESS)
EndIf
SetLogCentered("  Current Profile: " & $g_sProfileCurrentName & " ", "-", $COLOR_INFO)
If $g_bDebugSetlog Or $g_bDebugOcr Or $g_bDebugRedArea Or $g_bDevMode Or $g_bDebugImageSave Or $g_bDebugBuildingPos Or $g_bDebugOCRdonate Or $g_bDebugAttackCSV Or $g_bDebugAndroid Then
SetLogCentered(" Warning Debug Mode Enabled! ", "-", $COLOR_ERROR)
SetLog("      SetLog : " & $g_bDebugSetlog, $COLOR_ERROR, "Lucida Console", 8)
SetLog("     Android : " & $g_bDebugAndroid, $COLOR_ERROR, "Lucida Console", 8)
SetLog("         OCR : " & $g_bDebugOcr, $COLOR_ERROR, "Lucida Console", 8)
SetLog("     RedArea : " & $g_bDebugRedArea, $COLOR_ERROR, "Lucida Console", 8)
SetLog("   ImageSave : " & $g_bDebugImageSave, $COLOR_ERROR, "Lucida Console", 8)
SetLog(" BuildingPos : " & $g_bDebugBuildingPos, $COLOR_ERROR, "Lucida Console", 8)
SetLog("   OCRDonate : " & $g_bDebugOCRdonate, $COLOR_ERROR, "Lucida Console", 8)
SetLog("   AttackCSV : " & $g_bDebugAttackCSV, $COLOR_ERROR, "Lucida Console", 8)
SetLogCentered(" Warning Debug Mode Enabled! ", "-", $COLOR_ERROR)
EndIf
$g_bFirstStart = True
$g_bInitiateSwitchAcc = True
If $g_bNotifyDeleteAllPushesOnStart Then _DeletePush()
If Not $g_bSearchMode Then
$g_hTimerSinceStarted = __TimerInit()
EndIf
AndroidBotStartEvent()
If Not $g_bRunState Then Return
If Not $g_bSearchMode Then
If $g_bRestarted Then
$g_bRestarted = False
IniWrite($g_sProfileConfigPath, "general", "Restarted", 0)
PushMsg("Restarted")
EndIf
EndIf
If Not $g_bRunState Then Return
AndroidShield("Initiate", True)
checkMainScreen()
If Not $g_bRunState Then Return
ZoomOut()
If Not $g_bRunState Then Return
If Not $g_bSearchMode Then
BotDetectFirstTime()
If Not $g_bRunState Then Return
If $g_bCheckGameLanguage Then TestLanguage()
If Not $g_bRunState Then Return
runBot()
EndIf
Else
SetLog("Not in Game!", $COLOR_ERROR)
btnStop()
EndIf
EndFunc
Func InitiateLayout()
Local $AdjustScreenIfNecessarry = True
WinGetAndroidHandle()
Local $BSsize = getAndroidPos()
If IsArray($BSsize) Then
Local $BSx = $BSsize[2]
Local $BSy = $BSsize[3]
SetDebugLog("InitiateLayout: " & $g_sAndroidTitle & " Android-ClientSize: " & $BSx & " x " & $BSy, $COLOR_INFO)
If Not CheckScreenAndroid($BSx, $BSy) Then
If $AdjustScreenIfNecessarry = True Then
Local $MsgRet = $IDOK
If $MsgRet = $IDOK Then
Return RebootAndroidSetScreen()
EndIf
Else
SetLog("Cannot use " & $g_sAndroidEmulator & ".", $COLOR_ERROR)
SetLog("Please set its screen size manually to " & $g_iAndroidClientWidth & " x " & $g_iAndroidClientHeight, $COLOR_ERROR)
btnStop()
Return False
EndIf
EndIf
DisposeWindows()
Return True
EndIf
Return False
EndFunc
Func chkBackground()
If IsDeclared("g_hChkBackgroundMode") Then
UpdateChkBackground()
AndroidToFront(Default, "chkBackground")
EndIf
EndFunc
Func UpdateChkBackground()
If GUICtrlRead($g_hChkBackgroundMode) = $GUI_CHECKED Then
$g_bChkBackgroundMode = True
updateBtnHideState($GUI_ENABLE)
Else
$g_bChkBackgroundMode = False
updateBtnHideState($GUI_DISABLE)
EndIf
If CheckDpiAwareness() Then
EndIf
EndFunc
Func IsStopped()
If $g_bRunState Then Return False
If $g_bRestart Then Return True
Return False
EndFunc
Func btnStart()
EnableControls($g_hFrmBotBottom, False, $g_aFrmBotBottomCtrlState)
Local $bRunNow = $g_iBotAction <> $eBotNoAction
If $bRunNow Then
BotStart()
Else
$g_iBotAction = $eBotStart
EndIf
$g_iActualTrainSkip = 0
EndFunc
Func btnStop()
If $g_bRunState Then
EnableControls($g_hFrmBotBottom, False, $g_aFrmBotBottomCtrlState)
$g_bRunState = False
EndIf
$g_iBotAction = $eBotStop
EndFunc
Func btnSearchMode()
EnableControls($g_hFrmBotBottom, False, $g_aFrmBotBottomCtrlState)
Local $bRunNow = $g_iBotAction <> $eBotNoAction
If $bRunNow Then
BotSearchMode()
Else
$g_iBotAction = $eBotSearchMode
EndIf
EndFunc
Func btnPause($bRunNow = True)
TogglePause()
EndFunc
Func btnResume()
TogglePause()
EndFunc
Func btnAttackNowDB()
If $g_bRunState Then
$g_bBtnAttackNowPressed = True
$g_iMatchMode = $DB
EndIf
EndFunc
Func btnAttackNowLB()
If $g_bRunState Then
$g_bBtnAttackNowPressed = True
$g_iMatchMode = $LB
EndIf
EndFunc
Func btnAttackNowTS()
If $g_bRunState Then
$g_bBtnAttackNowPressed = True
$g_iMatchMode = $TS
EndIf
EndFunc
Func reHide()
WinGetAndroidHandle()
If $g_bIsHidden And $g_hAndroidWindow <> 0 And Not $g_bAndroidEmbedded Then
SetDebugLog("Hide " & $g_sAndroidEmulator & " Window after restart")
Local $Result = HideAndroidWindow(True, Default, Default, "reHide")
updateBtnHideState()
Return $Result
EndIf
Return 0
EndFunc
Func updateBtnHideState($newState = $GUI_ENABLE)
If $g_hBtnHide = 0 Then Return
Local $hideState = GUICtrlGetState($g_hBtnHide)
Local $newHideState =($g_bAndroidEmbedded = True ? $GUI_DISABLE : $newState)
If $hideState <> $newHideState Then GUICtrlSetState($g_hBtnHide, $newHideState)
Local $sText
If $g_bIsHidden Then
$sText = GetTranslatedFileIni("MBR GUI Control Bottom", "Func_btnHide_False", "Show")
Else
$sText = GetTranslatedFileIni("MBR GUI Control Bottom", "Func_btnHide_True", "Hide")
EndIf
If GUICtrlRead($g_hBtnHide) <> $sText Then
GUICtrlSetData($g_hBtnHide, $sText)
EndIf
EndFunc
Func btnHide()
$g_bIsHidden = Not $g_bIsHidden
HideAndroidWindow($g_bIsHidden, Default, Default, "btnHide")
updateBtnHideState()
EndFunc
Func updateBtnEmbed()
If $g_hBtnEmbed = 0 Then Return False
UpdateFrmBotStyle()
Local $state = GUICtrlGetState($g_hBtnEmbed)
If $g_hAndroidWindow = 0 Or $g_bAndroidBackgroundLaunched = True Or $g_bAndroidEmbed = False Or $g_iGuiMode <> 1 Then
If $state <> $GUI_DISABLE Then GUICtrlSetState($g_hBtnEmbed, $GUI_DISABLE)
updateBtnHideState()
Return False
EndIf
Local $text = GUICtrlRead($g_hBtnEmbed)
Local $newText
If $g_bAndroidEmbedded Then
$newText = GetTranslatedFileIni("MBR GUI Control Bottom", "Func_AndroidEmbedded_False", "Undock")
Else
$newText = GetTranslatedFileIni("MBR GUI Control Bottom", "Func_AndroidEmbedded_True", "Dock")
EndIf
If $text <> $newText Then GUICtrlSetData($g_hBtnEmbed, $newText)
If $state <> $GUI_ENABLE Then GUICtrlSetState($g_hBtnEmbed, $GUI_ENABLE)
updateBtnHideState()
Return True
EndFunc
Func btnEmbed()
ResumeAndroid()
WinGetAndroidHandle()
WinGetPos($g_hAndroidWindow)
If @error <> 0 Then Return SetError(0, 0, 0)
AndroidEmbed(Not $g_bAndroidEmbedded)
EndFunc
Func btnMakeScreenshot()
If $g_bRunState Then
$g_bMakeScreenshotNow = True
Else
If $g_bScreenshotPNGFormat = False Then
MakeScreenshot($g_sProfileTempPath, "jpg")
Else
MakeScreenshot($g_sProfileTempPath, "png")
EndIf
EndIf
EndFunc
Func GetFont()
Local $i, $sText = "", $DefaultFont
$DefaultFont = __EMB_GetDefaultFont()
For $i = 0 To UBound($DefaultFont) - 1
$sText &= " $DefaultFont[" & $i & "]= " & $DefaultFont[$i] & ", "
Next
SetLog($sText, $COLOR_DEBUG)
EndFunc
Func btnVillageStat($source = "")
If $g_iFirstRun = 0 And $g_bRunState And Not $g_bBotPaused Then SetTime(True)
If GUICtrlGetState($g_hLblResultGoldNow) = $GUI_ENABLE + $GUI_SHOW Then
GUICtrlSetState($g_hLblResultGoldNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultElixirNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultDENow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultTrophyNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultBuilderNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultGemNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultGoldHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultElixirHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultDEHourNow, $GUI_ENABLE + $GUI_SHOW)
If $g_iFirstRun = 0 Or $source = "UpdateStats" Then
GUICtrlSetState($g_hLblResultRuntimeNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultAttackedHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultSkippedHourNow, $GUI_ENABLE + $GUI_SHOW)
EndIf
GUICtrlSetState($g_hPicResultTrophyNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultBuilderNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultGemNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultRuntimeNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hPicResultAttackedHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hPicResultSkippedHourNow, $GUI_ENABLE + $GUI_SHOW)
Else
GUICtrlSetState($g_hLblResultGoldNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultElixirNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultDENow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultTrophyNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultBuilderNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultGemNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultGoldHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultElixirHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultDEHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultRuntimeNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultAttackedHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultSkippedHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultTrophyNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hPicResultBuilderNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hPicResultGemNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hPicResultRuntimeNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultAttackedHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultSkippedHourNow, $GUI_ENABLE + $GUI_HIDE)
EndIf
EndFunc
Func EnableGuiControls($bOptimizedRedraw = True)
Return ToggleGuiControls(True, $bOptimizedRedraw)
EndFunc
Func DisableGuiControls($bOptimizedRedraw = True)
Return ToggleGuiControls(False, $bOptimizedRedraw)
EndFunc
Func ToggleGuiControls($bEnabled, $bOptimizedRedraw = True)
$g_bGuiControlsEnabled = $bEnabled
If $g_iGuiMode <> 1 Then Return
If $bOptimizedRedraw Then Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "ToggleGuiControls")
If Not $bEnabled Then
SetDebugLog("Disable GUI Controls")
Else
SetDebugLog("Enable GUI Controls")
EndIf
$g_bGUIControlDisabled = True
For $i = $g_hFirstControlToHide To $g_hLastControlToHide
If IsAlwaysEnabledControl($i) Then ContinueLoop
If $g_bNotifyPBEnable And $i = $g_hBtnNotifyDeleteMessages Then ContinueLoop
If Not $bEnabled Then
$g_aiControlPrevState[$i] = BitAND(GUICtrlGetState($i), $GUI_ENABLE)
If $g_aiControlPrevState[$i] Then GUICtrlSetState($i, $GUI_DISABLE)
Else
If $g_aiControlPrevState[$i] Then GUICtrlSetState($i, $g_aiControlPrevState[$i])
EndIf
Next
If Not $bEnabled Then
ControlDisable("", "", $g_hCmbGUILanguage)
Else
ControlEnable("", "", $g_hCmbGUILanguage)
EndIf
$g_bGUIControlDisabled = False
If $bOptimizedRedraw Then SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "ToggleGuiControls")
EndFunc
Func btnAtkLogClear()
_GUICtrlRichEdit_SetText($g_hTxtAtkLog, "")
AtkLogHead()
EndFunc
Func btnAtkLogCopyClipboard()
Local $text = _GUICtrlRichEdit_GetText($g_hTxtAtkLog)
$text = StringReplace($text, @CR, @CRLF)
ClipPut($text)
EndFunc
Func cmbLog()
Local $x = 0, $y = 0, $w = $_GUI_MAIN_WIDTH - 20, $h = $_GUI_MAIN_HEIGHT - 490 + Int($g_iFrmBotAddH / 2)
If($g_iLogDividerY > $h + Int($h / 2) + $y And $g_iLogDividerY < $h * 2 + $g_iLogDividerHeight + $y) Or $g_iLogDividerY > $h * 2 + $g_iLogDividerHeight + $y Then $g_iLogDividerY = $h + Int($h / 2) + $y
If($g_iLogDividerY < Int($h / 2) + $y And $g_iLogDividerY > 0) Or $g_iLogDividerY < 0 Then $g_iLogDividerY = Int($h / 2)
_SendMessage($g_hTxtLog, $WM_SETREDRAW, False, 0)
_WINAPI_EnableWindow($g_hTxtLog, False)
_SendMessage($g_hTxtAtkLog, $WM_SETREDRAW, False, 0)
_WINAPI_EnableWindow($g_hTxtAtkLog, False)
Switch _GUICtrlComboBox_GetCurSel($g_hCmbLogDividerOption)
Case 0
ControlShow($g_hGUI_LOG, "", $g_hDivider)
ControlMove($g_hGUI_LOG, "", $g_hDivider, $x, $g_iLogDividerY - $y, $w, $g_iLogDividerHeight)
ControlShow($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, $g_iLogDividerY - $y)
ControlShow($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $g_iLogDividerY + $g_iLogDividerHeight, $w,($h * 2) -($g_iLogDividerY - $y))
Case 1
ControlShow($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, $h)
$y += $h
ControlHide($g_hGUI_LOG, "", $g_hDivider)
$y += $g_iLogDividerHeight
ControlShow($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $y, $w, $h)
Case 2
ControlShow($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, $h +($h / 2))
$y += $h +($h / 2) + $g_iLogDividerHeight
ControlHide($g_hGUI_LOG, "", $g_hDivider)
ControlShow($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $y, $w, $h -($h / 2))
Case 3
ControlShow($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, $h -($h / 2))
$y +=($h / 2) + $g_iLogDividerHeight
ControlHide($g_hGUI_LOG, "", $g_hDivider)
ControlShow($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $y, $w, $h +($h / 2))
Case 4
ControlShow($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, $h * 2 + $g_iLogDividerHeight)
ControlHide($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $y + $h * 2 + $g_iLogDividerHeight, $w, 0)
ControlHide($g_hGUI_LOG, "", $g_hDivider)
Case 5
ControlHide($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, 0)
ControlShow($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $y, $w, $h * 2 + $g_iLogDividerHeight)
ControlHide($g_hGUI_LOG, "", $g_hDivider)
EndSwitch
_SendMessage($g_hTxtLog, $WM_SETREDRAW, True, 0)
_WINAPI_EnableWindow($g_hTxtLog, True)
_SendMessage($g_hTxtAtkLog, $WM_SETREDRAW, True, 0)
_WINAPI_EnableWindow($g_hTxtAtkLog, True)
CheckRedrawControls(True, "cmbLog")
EndFunc
Func MoveDivider()
Local $PPos = ControlGetPos($g_hFrmBot, "", $g_hGUI_LOG)
Local $TPos = ControlGetPos($g_hGUI_LOG, "", $g_hTxtLog)
Local $BPos = ControlGetPos($g_hGUI_LOG, "", $g_hTxtAtkLog)
Local $logAndDividerX = $TPos[0] - $PPos[0]
Local $logAndDividerWidth = $TPos[2]
Local $totalLogsHeight = $TPos[3] + $BPos[3]
Local $minVisibleHeight = Ceiling($totalLogsHeight / 4)
Local $snapToMinMax = Ceiling($minVisibleHeight / 3)
Local $halfDividerTopHeight = Ceiling($g_iLogDividerHeight / 2)
Local $halfDividerBottomHeight = Floor($g_iLogDividerHeight / 2)
Local $startLogsY = $TPos[1] - $_GUI_CHILD_TOP
Local $endLogsY = $BPos[1] - $_GUI_CHILD_TOP + $BPos[3]
Do
Local $pos = GUIGetCursorInfo($g_hGUI_LOG)
Local $clickY = $pos[1]
If $clickY - $halfDividerTopHeight <= $startLogsY + $snapToMinMax Then
$clickY = $startLogsY + $halfDividerTopHeight
ElseIf $clickY + $halfDividerBottomHeight >= $endLogsY - $snapToMinMax Then
$clickY = $endLogsY - $halfDividerBottomHeight
ElseIf $clickY - $halfDividerTopHeight > $startLogsY + $snapToMinMax And $clickY - $halfDividerTopHeight <= $startLogsY + $minVisibleHeight Then
$clickY = $startLogsY + $minVisibleHeight + $halfDividerTopHeight
ElseIf $clickY + $halfDividerBottomHeight < $endLogsY - $snapToMinMax And $clickY + $halfDividerBottomHeight >= $endLogsY - $minVisibleHeight Then
$clickY = $endLogsY - $minVisibleHeight - $halfDividerBottomHeight
EndIf
$g_iLogDividerY = $clickY - $halfDividerTopHeight
ControlMove($g_hGUI_LOG, "", $g_hDivider, $logAndDividerX, $g_iLogDividerY, $logAndDividerWidth, $g_iLogDividerHeight)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $logAndDividerX, $startLogsY, $logAndDividerWidth, $clickY - $startLogsY - $halfDividerTopHeight)
If $endLogsY -($clickY + $halfDividerBottomHeight) < 0 Then
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $logAndDividerX, $endLogsY, $logAndDividerWidth, 0)
Else
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $logAndDividerX, $clickY + $halfDividerBottomHeight, $logAndDividerWidth, $endLogsY - $clickY - $halfDividerBottomHeight)
EndIf
_WinAPI_UpdateWindow(WinGetHandle($g_hGUI_LOG))
Until $pos[2] = 0
_GUICtrlRichEdit_SetSel($g_hTxtLog, - 1, -1)
_GUICtrlRichEdit_SetSel($g_hTxtAtkLog, - 1, -1)
SetDebugLog("MoveDivider exit", Default, True)
EndFunc
Func chkUseQTrain()
If GUICtrlRead($g_hChkUseQuickTrain) = $GUI_CHECKED Then
_GUI_Value_STATE("ENABLE", $g_ahChkArmy[0] & "#" & $g_ahChkArmy[1] & "#" & $g_ahChkArmy[2])
chkQuickTrainCombo()
_GUI_Value_STATE("DISABLE", $grpTrainTroops)
_GUI_Value_STATE("DISABLE", $grpCookSpell)
GUICtrlSetData($g_hLblTotalTimeCamp, " 0s")
GUICtrlSetData($g_hLblTotalTimeSpell, " 0s")
GUICtrlSetData($g_hLblElixirCostCamp, "0")
GUICtrlSetData($g_hLblDarkCostCamp, "0")
GUICtrlSetData($g_hLblElixirCostSpell, "0")
GUICtrlSetData($g_hLblDarkCostSpell, "0")
Else
_GUI_Value_STATE("DISABLE", $g_ahChkArmy[0] & "#" & $g_ahChkArmy[1] & "#" & $g_ahChkArmy[2])
_GUI_Value_STATE("ENABLE", $grpTrainTroops)
_GUI_Value_STATE("ENABLE", $grpCookSpell)
lblTotalCountTroop1()
TotalSpellCountClick()
EndIf
EndFunc
Func chkQuickTrainCombo()
If GUICtrlRead($g_ahChkArmy[0]) = $GUI_UNCHECKED And GUICtrlRead($g_ahChkArmy[1]) = $GUI_UNCHECKED And GUICtrlRead($g_ahChkArmy[2]) = $GUI_UNCHECKED Then
GUICtrlSetState($g_ahChkArmy[0], $GUI_CHECKED)
ToolTip("QuickTrainCombo: " & @CRLF & "At least 1 Army Check is required! Default Army 1.")
Sleep(2000)
ToolTip('')
EndIf
EndFunc
Func SetComboTroopComp()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "SetComboTroopComp")
Local $ArmyCampTemp = 0
If GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED Then
$ArmyCampTemp = Floor(GUICtrlRead($g_hTxtTotalCampForced) * GUICtrlRead($g_hTxtFullTroop) / 100)
Else
$ArmyCampTemp = Floor($g_iTotalCampSpace * GUICtrlRead($g_hTxtFullTroop) / 100)
EndIf
lblTotalCountTroop1()
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "SetComboTroopComp")
EndFunc
Func chkTotalCampForced()
GUICtrlSetState($g_hTxtTotalCampForced, GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func lblTotalCountTroop1()
Local $TotalTroopsToTrain = 0
Local $ArmyCampTemp = 0
If GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED Then
$ArmyCampTemp = Floor(GUICtrlRead($g_hTxtTotalCampForced) * GUICtrlRead($g_hTxtFullTroop) / 100)
Else
$ArmyCampTemp = Floor($g_iTotalCampSpace * GUICtrlRead($g_hTxtFullTroop) / 100)
EndIf
For $i = 0 To $eTroopCount - 1
Local $iCount = GUICtrlRead($g_ahTxtTrainArmyTroopCount[$i])
If $iCount > 0 Then
$TotalTroopsToTrain += $iCount * $g_aiTroopSpace[$i]
Else
GUICtrlSetData($g_ahTxtTrainArmyTroopCount[$i], 0)
EndIf
Next
GUICtrlSetData($g_hLblCountTotal, String($TotalTroopsToTrain))
If GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED And GUICtrlRead($g_hLblCountTotal) = GUICtrlRead($g_hTxtTotalCampForced) Then
GUICtrlSetBkColor($g_hLblCountTotal, $COLOR_MONEYGREEN)
ElseIf GUICtrlRead($g_hLblCountTotal) = $ArmyCampTemp Then
GUICtrlSetBkColor($g_hLblCountTotal, $COLOR_MONEYGREEN)
ElseIf GUICtrlRead($g_hLblCountTotal) > $ArmyCampTemp / 2 And GUICtrlRead($g_hLblCountTotal) < $ArmyCampTemp Then
GUICtrlSetBkColor($g_hLblCountTotal, $COLOR_ORANGE)
Else
GUICtrlSetBkColor($g_hLblCountTotal, $COLOR_RED)
EndIf
Local $fPctOfForced = Floor((GUICtrlRead($g_hLblCountTotal) / GUICtrlRead($g_hTxtTotalCampForced)) * 100)
Local $fPctOfCalculated = Floor((GUICtrlRead($g_hLblCountTotal) / $ArmyCampTemp) * 100)
If GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED Then
GUICtrlSetData($g_hCalTotalTroops, $fPctOfForced < 1 ?(GUICtrlRead($g_hLblCountTotal) > 0 ? 1 : 0) : $fPctOfForced)
Else
GUICtrlSetData($g_hCalTotalTroops, $fPctOfCalculated < 1 ?(GUICtrlRead($g_hLblCountTotal) > 0 ? 1 : 0) : $fPctOfCalculated)
EndIf
If GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED And GUICtrlRead($g_hLblCountTotal) > GUICtrlRead($g_hTxtTotalCampForced) Then
GUICtrlSetState($g_hLblTotalProgress, $GUI_SHOW)
ElseIf GUICtrlRead($g_hLblCountTotal) > $ArmyCampTemp Then
GUICtrlSetState($g_hLblTotalProgress, $GUI_SHOW)
Else
GUICtrlSetState($g_hLblTotalProgress, $GUI_HIDE)
EndIf
lblTotalCountTroop2()
EndFunc
Func lblTotalCountTroop2()
Local $TotalTotalTimeTroop = 0
Local $NbrOfBarrack = 4
Local $NbrOfDarkBarrack = 2
For $i = $eTroopBarbarian To $eTroopElectroDragon
Local $NbrOfTroop = GUICtrlRead($g_ahTxtTrainArmyTroopCount[$i])
Local $LevOfTroop = $g_aiTrainArmyTroopLevel[$i]
If $NbrOfTroop > 0 And $LevOfTroop > 0 Then
If IsInt($NbrOfTroop / $NbrOfBarrack) = 1 Then
$TotalTotalTimeTroop +=($NbrOfTroop / $NbrOfBarrack) * $g_aiTroopTrainTime[$i]
Else
$TotalTotalTimeTroop +=(Ceiling($NbrOfTroop / $NbrOfBarrack)) * $g_aiTroopTrainTime[$i]
$TotalTotalTimeTroop +=((Ceiling($NbrOfTroop / $NbrOfBarrack) - 1) -(Floor($NbrOfTroop / $NbrOfBarrack))) * $g_aiTroopTrainTime[$i]
EndIf
EndIf
Next
For $i = $eTroopMinion To $eTroopBowler
Local $NbrOfTroop = GUICtrlRead($g_ahTxtTrainArmyTroopCount[$i])
Local $LevOfTroop = $g_aiTrainArmyTroopLevel[$i]
If $NbrOfTroop > 0 And $LevOfTroop > 0 Then
If IsInt($NbrOfTroop / $NbrOfDarkBarrack) = 1 Then
$TotalTotalTimeTroop +=($NbrOfTroop / $NbrOfDarkBarrack) * $g_aiTroopTrainTime[$i]
Else
$TotalTotalTimeTroop +=(Ceiling($NbrOfTroop / $NbrOfDarkBarrack)) * $g_aiTroopTrainTime[$i]
$TotalTotalTimeTroop +=((Ceiling($NbrOfTroop / $NbrOfDarkBarrack) - 1) -(Floor($NbrOfTroop / $NbrOfDarkBarrack))) * $g_aiTroopTrainTime[$i]
EndIf
EndIf
Next
$TotalTotalTimeTroop = CalculTimeTo($TotalTotalTimeTroop)
GUICtrlSetData($g_hLblTotalTimeCamp, $TotalTotalTimeTroop)
CalCostCamp()
EndFunc
Func lblTotalCountSpell2()
Local $iTotalTotalTimeSpell = 0
$g_iTotalTrainSpaceSpell = 0
For $i = 0 To $eSpellCount - 1
$g_iTotalTrainSpaceSpell += $g_aiArmyCompSpells[$i] * $g_aiSpellSpace[$i]
$iTotalTotalTimeSpell += $g_aiArmyCompSpells[$i] * $g_aiSpellTrainTime[$i]
Next
For $i = 0 To $eSpellCount - 1
GUICtrlSetBkColor($g_ahTxtTrainArmySpellCount[$i], $g_iTotalTrainSpaceSpell <= GUICtrlRead($g_hTxtTotalCountSpell) ? $COLOR_WHITE : $COLOR_RED)
Next
GUICtrlSetData($g_hLblTotalTimeSpell, CalculTimeTo($iTotalTotalTimeSpell))
CalCostSpell()
EndFunc
Func TotalSpellCountClick()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "TotalSpellCountClick")
_GUI_Value_STATE("HIDE", $groupListSpells)
$g_iTownHallLevel = Int($g_iTownHallLevel)
If $g_iTownHallLevel > 4 Or $g_iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellLightning] > 0 ? $g_aGroupLightning : $groupIcnLightning)
Else
For $i = 0 To $eSpellCount - 1
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$i], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$i], 0)
Next
GUICtrlSetData($g_hTxtTotalCountSpell, 0)
EndIf
If $g_iTownHallLevel > 5 Or $g_iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellHeal] > 0 ? $groupHeal : $groupIcnHeal)
Else
For $i = $eSpellRage To $eSpellSkeleton
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$i], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$i], 0)
Next
EndIf
If $g_iTownHallLevel > 6 Or $g_iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellRage] > 0 ? $groupRage : $groupIcnRage)
Else
For $i = $eSpellJump To $eSpellSkeleton
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$i], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$i], 0)
Next
EndIf
If $g_iTownHallLevel > 7 Or $g_iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellPoison] > 0 ? $g_aGroupPoison : $groupIcnPoison)
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellEarthquake] > 0 ? $groupEarthquake : $groupIcnEarthquake)
Else
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellJump], 0)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellFreeze], 0)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellClone], 0)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellHaste], 0)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellSkeleton], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellJump], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellFreeze], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellClone], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellHaste], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellSkeleton], 0)
EndIf
If $g_iTownHallLevel > 8 Or $g_iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellJump] > 0 ? $groupJumpSpell : $groupIcnJumpSpell)
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellFreeze] > 0 ? $groupFreeze : $groupIcnFreeze)
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellHaste] > 0 ? $groupHaste : $groupIcnHaste)
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellSkeleton] > 0 ? $groupSkeleton : $groupIcnSkeleton)
Else
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellClone], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellClone], 0)
EndIf
If $g_iTownHallLevel > 9 Or $g_iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellClone] > 0 ? $groupClone : $groupIcnClone)
EndIf
lblTotalCountSpell2()
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "TotalSpellCountClick")
EndFunc
Func chkBoostBarracksHoursE1()
If GUICtrlRead($g_hChkBoostBarracksHoursE1) = $GUI_CHECKED And GUICtrlRead($g_hChkBoostBarracksHours[0]) = $GUI_CHECKED Then
For $i = 0 To 11
GUICtrlSetState($g_hChkBoostBarracksHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 0 To 11
GUICtrlSetState($g_hChkBoostBarracksHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_hChkBoostBarracksHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkBoostBarracksHoursE2()
If GUICtrlRead($g_hChkBoostBarracksHoursE2) = $GUI_CHECKED And GUICtrlRead($g_hChkBoostBarracksHours[12]) = $GUI_CHECKED Then
For $i = 12 To 23
GUICtrlSetState($g_hChkBoostBarracksHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 12 To 23
GUICtrlSetState($g_hChkBoostBarracksHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_hChkBoostBarracksHoursE2, $GUI_UNCHECKED)
EndFunc
Func chkCloseWaitEnable()
If GUICtrlRead($g_hChkCloseWhileTraining) = $GUI_CHECKED Then
$g_bCloseWhileTrainingEnable = True
_GUI_Value_STATE("ENABLE", $groupCloseWhileTraining)
_GUI_Value_STATE("ENABLE", $g_hLblCloseWaitingTroops & "#" & $g_hCmbMinimumTimeClose & "#" & $g_hLblSymbolWaiting & "#" & $g_hLblWaitingInMinutes)
Else
$g_bCloseWhileTrainingEnable = False
_GUI_Value_STATE("DISABLE", $groupCloseWhileTraining)
_GUI_Value_STATE("DISABLE", $g_hLblCloseWaitingTroops & "#" & $g_hCmbMinimumTimeClose & "#" & $g_hLblSymbolWaiting & "#" & $g_hLblWaitingInMinutes)
EndIf
If GUICtrlRead($g_hChkRandomClose) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkCloseEmulator, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkSuspendComputer, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
Else
If GUICtrlRead($g_hChkCloseWhileTraining) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkCloseEmulator, $GUI_ENABLE)
GUICtrlSetState($g_hChkSuspendComputer, $GUI_ENABLE)
EndIf
EndIf
EndFunc
Func chkCloseWaitTrain()
$g_bCloseWithoutShield =(GUICtrlRead($g_hChkCloseWithoutShield) = $GUI_CHECKED)
EndFunc
Func btnCloseWaitStop()
$g_bCloseEmulator =(GUICtrlRead($g_hChkCloseEmulator) = $GUI_CHECKED)
EndFunc
Func btnCloseWaitSuspendComputer()
$g_bSuspendComputer =(GUICtrlRead($g_hChkSuspendComputer) = $GUI_CHECKED)
EndFunc
Func btnCloseWaitStopRandom()
If GUICtrlRead($g_hChkRandomClose) = $GUI_CHECKED Then
$g_bCloseRandom = True
$g_bCloseEmulator = False
$g_bSuspendComputer = False
GUICtrlSetState($g_hChkCloseEmulator, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkSuspendComputer, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
Else
$g_bCloseRandom = False
If GUICtrlRead($g_hChkCloseWhileTraining) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkCloseEmulator, $GUI_ENABLE)
GUICtrlSetState($g_hChkSuspendComputer, $GUI_ENABLE)
EndIf
EndIf
EndFunc
Func btnCloseWaitRandom()
If GUICtrlRead($g_hRdoCloseWaitExact) = $GUI_CHECKED Then
$g_bCloseExactTime = True
$g_bCloseRandomTime = False
GUICtrlSetState($g_hCmbCloseWaitRdmPercent, $GUI_DISABLE)
ElseIf GUICtrlRead($g_hRdoCloseWaitRandom) = $GUI_CHECKED Then
$g_bCloseExactTime = False
$g_bCloseRandomTime = True
If GUICtrlRead($g_hChkCloseWhileTraining) = $GUI_CHECKED Then GUICtrlSetState($g_hCmbCloseWaitRdmPercent, $GUI_ENABLE)
Else
$g_bCloseExactTime = False
$g_bCloseRandomTime = False
GUICtrlSetState($g_hCmbCloseWaitRdmPercent, $GUI_DISABLE)
EndIf
EndFunc
Func sldTrainITDelay()
$g_iTrainClickDelay = GUICtrlRead($g_hSldTrainITDelay)
GUICtrlSetData($g_hLblTrainITDelayTime, $g_iTrainClickDelay & " ms")
EndFunc
Func chkTroopOrder2()
chkTroopOrder()
EndFunc
Func chkTroopOrder($bSetLog = True)
If GUICtrlRead($g_hChkCustomTrainOrderEnable) = $GUI_CHECKED Then
$g_bCustomTrainOrderEnable = True
GUICtrlSetState($g_hBtnTroopOrderSet, $GUI_ENABLE)
GUICtrlSetState($g_hBtnRemoveTroops, $GUI_ENABLE)
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
GUICtrlSetState($g_ahCmbTroopOrder[$i], $GUI_ENABLE)
Next
If IsUseCustomTroopOrder() = True Then _GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnRedLight)
Else
$g_bCustomTrainOrderEnable = False
GUICtrlSetState($g_hBtnTroopOrderSet, $GUI_DISABLE)
GUICtrlSetState($g_hBtnRemoveTroops, $GUI_DISABLE)
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
GUICtrlSetState($g_ahCmbTroopOrder[$i], $GUI_DISABLE)
Next
SetDefaultTroopGroup($bSetLog)
If($bSetLog Or $g_bDebugSetlogTrain) And $g_bCustomTrainOrderEnable Then
Local $sNewTrainList = ""
For $i = 0 To $eTroopCount - 1
$sNewTrainList &= $g_asTroopShortNames[$g_aiTrainOrder[$i]] & ", "
Next
$sNewTrainList = StringTrimRight($sNewTrainList, 2)
SetLog("Current train order= " & $sNewTrainList, $COLOR_INFO)
EndIf
EndIf
EndFunc
Func chkSpellsOrder()
If GUICtrlRead($g_hChkCustomBrewOrderEnable) = $GUI_CHECKED Then
$g_bCustomBrewOrderEnable = True
For $i = 0 To UBound($g_ahCmbSpellsOrder) - 1
GUICtrlSetState($g_ahCmbSpellsOrder[$i], $GUI_ENABLE)
Next
GUICtrlSetState($g_hBtnRemoveSpells, $GUI_ENABLE)
GUICtrlSetState($g_hBtnSpellsOrderSet, $GUI_ENABLE)
If IsUseCustomSpellsOrder() = True Then _GUICtrlSetImage($g_ahImgSpellsOrderSet, $g_sLibIconPath, $eIcnRedLight)
Else
$g_bCustomBrewOrderEnable = False
For $i = 0 To UBound($g_ahCmbSpellsOrder) - 1
GUICtrlSetState($g_ahCmbSpellsOrder[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_hBtnRemoveSpells, $GUI_DISABLE)
GUICtrlSetState($g_hBtnSpellsOrderSet, $GUI_DISABLE)
SetDefaultSpellsGroup(False)
EndIf
EndFunc
Func GUISpellsOrder()
Local $bDuplicate = False
Local $iGUI_CtrlId = @GUI_CtrlId
Local $iCtrlIdImage = $iGUI_CtrlId + 1
Local $iSpellsIndex = _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) + 1
_GUICtrlSetImage($iCtrlIdImage, $g_sLibIconPath, $g_aiSpellsOrderIcon[$iSpellsIndex])
For $i = 0 To UBound($g_ahCmbSpellsOrder) - 1
If $iGUI_CtrlId = $g_ahCmbSpellsOrder[$i] Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) = _GUICtrlComboBox_GetCurSel($g_ahCmbSpellsOrder[$i]) Then
_GUICtrlSetImage($g_ahImgSpellsOrder[$i], $g_sLibIconPath, $eIcnOptions)
_GUICtrlComboBox_SetCurSel($g_ahCmbSpellsOrder[$i], -1)
GUISetState()
$bDuplicate = True
EndIf
Next
If $bDuplicate Then
GUICtrlSetState($g_hBtnSpellsOrderSet, $GUI_DISABLE)
Return
Else
GUICtrlSetState($g_hBtnSpellsOrderSet, $GUI_ENABLE)
_GUICtrlSetImage($g_ahImgSpellsOrderSet, $g_sLibIconPath, $eIcnRedLight)
EndIf
EndFunc
Func BtnRemoveSpells()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "BtnRemoveSpells")
Local $sComboData = ""
For $j = 0 To UBound($g_asSpellsOrderList) - 1
$sComboData &= $g_asSpellsOrderList[$j] & "|"
Next
For $i = 0 To $eSpellCount - 1
$g_aiCmbCustomBrewOrder[$i] = -1
_GUICtrlComboBox_ResetContent($g_ahCmbSpellsOrder[$i])
GUICtrlSetData($g_ahCmbSpellsOrder[$i], $sComboData, "")
_GUICtrlSetImage($g_ahImgSpellsOrder[$i], $g_sLibIconPath, $eIcnOptions)
Next
_GUICtrlSetImage($g_ahImgSpellsOrderSet, $g_sLibIconPath, $eIcnSilverStar)
SetDefaultSpellsGroup(False)
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "BtnRemoveSpells")
EndFunc
Func GUITrainOrder()
Local $bDuplicate = False
Local $iGUI_CtrlId = @GUI_CtrlId
Local $iCtrlIdImage = $iGUI_CtrlId + 1
Local $iTroopIndex = _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) + 1
_GUICtrlSetImage($iCtrlIdImage, $g_sLibIconPath, $g_aiTroopOrderIcon[$iTroopIndex])
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
If $iGUI_CtrlId = $g_ahCmbTroopOrder[$i] Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) = _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$i]) Then
_GUICtrlSetImage($g_ahImgTroopOrder[$i], $g_sLibIconPath, $eIcnOptions)
_GUICtrlComboBox_SetCurSel($g_ahCmbTroopOrder[$i], -1)
GUISetState()
$bDuplicate = True
EndIf
Next
If $bDuplicate Then
GUICtrlSetState($g_hBtnTroopOrderSet, $GUI_DISABLE)
Return
Else
GUICtrlSetState($g_hBtnTroopOrderSet, $GUI_ENABLE)
_GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnRedLight)
EndIf
EndFunc
Func BtnRemoveTroops()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "BtnRemoveTroops")
Local $sComboData = ""
For $j = 0 To UBound($g_asTroopOrderList) - 1
$sComboData &= $g_asTroopOrderList[$j] & "|"
Next
For $i = $eTroopBarbarian To $eTroopCount - 1
$g_aiCmbCustomTrainOrder[$i] = -1
_GUICtrlComboBox_ResetContent($g_ahCmbTroopOrder[$i])
GUICtrlSetData($g_ahCmbTroopOrder[$i], $sComboData, "")
_GUICtrlSetImage($g_ahImgTroopOrder[$i], $g_sLibIconPath, $eIcnOptions)
Next
_GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnSilverStar)
SetDefaultTroopGroup(False)
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "BtnRemoveTroops")
EndFunc
Func BtnSpellsOrderSet()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "BtnSpellsOrderSet")
Local $bReady = True
Local $sNewTrainList = ""
Local $bMissingTroop = False
Local $aiBrewOrder[$eSpellCount] = [ $eSpellLightning, $eSpellHeal, $eSpellRage, $eSpellJump, $eSpellFreeze, $eSpellClone, $eSpellPoison, $eSpellEarthquake, $eSpellHaste, $eSpellSkeleton]
For $i = 0 To UBound($g_ahCmbSpellsOrder) - 1
For $j = 0 To UBound($g_ahCmbSpellsOrder) - 1
If $i = $j Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($g_ahCmbSpellsOrder[$i]) <> -1 And  _GUICtrlComboBox_GetCurSel($g_ahCmbSpellsOrder[$i]) = _GUICtrlComboBox_GetCurSel($g_ahCmbSpellsOrder[$j]) Then
_GUICtrlComboBox_SetCurSel($g_ahCmbSpellsOrder[$j], -1)
_GUICtrlSetImage($g_ahImgSpellsOrder[$j], $g_sLibIconPath, $eIcnOptions)
$bReady = False
Else
GUICtrlSetColor($g_ahCmbSpellsOrder[$j], $COLOR_BLACK)
EndIf
Next
$g_aiCmbCustomBrewOrder[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbSpellsOrder[$i])
If $g_aiCmbCustomBrewOrder[$i] = -1 Then $bMissingTroop = True
Next
If $bReady And $bMissingTroop Then
For $i = 0 To UBound($g_aiCmbCustomBrewOrder) - 1
For $j = 0 To UBound($aiBrewOrder) - 1
If $g_aiCmbCustomBrewOrder[$i] = $j Then
$aiBrewOrder[$j] = -1
ExitLoop
EndIf
Next
Next
_ArrayShuffle($aiBrewOrder)
For $i = 0 To UBound($g_aiCmbCustomBrewOrder) - 1
If $g_aiCmbCustomBrewOrder[$i] = -1 Then
For $j = 0 To UBound($aiBrewOrder) - 1
If $aiBrewOrder[$j] <> -1 Then
$g_aiCmbCustomBrewOrder[$i] = $aiBrewOrder[$j]
_GUICtrlComboBox_SetCurSel($g_ahCmbSpellsOrder[$i], $aiBrewOrder[$j])
_GUICtrlSetImage($g_ahImgSpellsOrder[$i], $g_sLibIconPath, $g_aiSpellsOrderIcon[$g_aiCmbCustomBrewOrder[$i] + 1])
$aiBrewOrder[$j] = -1
ExitLoop
EndIf
Next
EndIf
Next
EndIf
If $bReady Then
ChangeSpellsBrewOrder()
If @error Then
Switch @error
Case 1
SetLog("Code problem, can not continue till fixed!", $COLOR_ERROR)
Case 2
SetLog("Bad Combobox selections, please fix!", $COLOR_ERROR)
Case 3
SetLog("Unable to Change Spells Brew Order due bad change count!", $COLOR_ERROR)
Case Else
SetLog("Monkey ate bad banana, something wrong with ChangeSpellsBrewOrder() code!", $COLOR_ERROR)
EndSwitch
_GUICtrlSetImage($g_ahImgSpellsOrderSet, $g_sLibIconPath, $eIcnRedLight)
Else
SetLog("Spells Brew order changed successfully!", $COLOR_SUCCESS)
For $i = 0 To $eSpellCount - 1
$sNewTrainList &= $g_asSpellShortNames[$g_aiBrewOrder[$i]] & ", "
Next
$sNewTrainList = StringTrimRight($sNewTrainList, 2)
SetLog("Spells Brew order= " & $sNewTrainList, $COLOR_INFO)
EndIf
Else
SetLog("Must use all Spells and No duplicate troop names!", $COLOR_ERROR)
_GUICtrlSetImage($g_ahImgSpellsOrderSet, $g_sLibIconPath, $eIcnRedLight)
EndIf
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "BtnSpellsOrderSet")
EndFunc
Func BtnTroopOrderSet()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "BtnTroopOrderSet")
Local $bReady = True
Local $sNewTrainList = ""
Local $bMissingTroop = False
Local $aiUsedTroop[$eTroopCount] = [ $eTroopBarbarian, $eTroopArcher, $eTroopGiant, $eTroopGoblin, $eTroopWallBreaker, $eTroopBalloon, $eTroopWizard, $eTroopHealer, $eTroopDragon, $eTroopPekka, $eTroopBabyDragon, $eTroopMiner, $eTroopElectroDragon, $eTroopMinion, $eTroopHogRider, $eTroopValkyrie, $eTroopGolem, $eTroopWitch, $eTroopLavaHound, $eTroopBowler]
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
For $j = 0 To UBound($g_ahCmbTroopOrder) - 1
If $i = $j Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$i]) <> -1 And  _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$i]) = _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$j]) Then
_GUICtrlComboBox_SetCurSel($g_ahCmbTroopOrder[$j], -1)
_GUICtrlSetImage($g_ahImgTroopOrder[$j], $g_sLibIconPath, $eIcnOptions)
$bReady = False
Else
GUICtrlSetColor($g_ahCmbTroopOrder[$j], $COLOR_BLACK)
EndIf
Next
$g_aiCmbCustomTrainOrder[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$i])
If $g_aiCmbCustomTrainOrder[$i] = -1 Then $bMissingTroop = True
Next
If $bReady And $bMissingTroop Then
For $i = 0 To UBound($g_aiCmbCustomTrainOrder) - 1
For $j = 0 To UBound($aiUsedTroop) - 1
If $g_aiCmbCustomTrainOrder[$i] = $j Then
$aiUsedTroop[$j] = -1
ExitLoop
EndIf
Next
Next
_ArrayShuffle($aiUsedTroop)
For $i = 0 To UBound($g_aiCmbCustomTrainOrder) - 1
If $g_aiCmbCustomTrainOrder[$i] = -1 Then
For $j = 0 To UBound($aiUsedTroop) - 1
If $aiUsedTroop[$j] <> -1 Then
$g_aiCmbCustomTrainOrder[$i] = $aiUsedTroop[$j]
_GUICtrlComboBox_SetCurSel($g_ahCmbTroopOrder[$i], $aiUsedTroop[$j])
_GUICtrlSetImage($g_ahImgTroopOrder[$i], $g_sLibIconPath, $g_aiTroopOrderIcon[$g_aiCmbCustomTrainOrder[$i] + 1])
$aiUsedTroop[$j] = -1
ExitLoop
EndIf
Next
EndIf
Next
EndIf
If $bReady Then
ChangeTroopTrainOrder()
If @error Then
Switch @error
Case 1
SetLog("Code problem, can not continue till fixed!", $COLOR_ERROR)
Case 2
SetLog("Bad Combobox selections, please fix!", $COLOR_ERROR)
Case 3
SetLog("Unable to Change Troop Train Order due bad change count!", $COLOR_ERROR)
Case Else
SetLog("Monkey ate bad banana, something wrong with ChangeTroopTrainOrder() code!", $COLOR_ERROR)
EndSwitch
_GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnRedLight)
Else
SetLog("Troop training order changed successfully!", $COLOR_SUCCESS)
For $i = 0 To $eTroopCount - 1
$sNewTrainList &= $g_asTroopShortNames[$g_aiTrainOrder[$i]] & ", "
Next
$sNewTrainList = StringTrimRight($sNewTrainList, 2)
SetLog("Troop train order= " & $sNewTrainList, $COLOR_INFO)
EndIf
Else
SetLog("Must use all troops and No duplicate troop names!", $COLOR_ERROR)
_GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnRedLight)
EndIf
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "BtnTroopOrderSet")
EndFunc
Func ChangeSpellsBrewOrder()
If $g_bDebugSetlog Or $g_bDebugSetlogTrain Then SetLog("Begin Func ChangeSpellsBrewOrder()", $COLOR_DEBUG)
Local $NewTroopOrder[$eSpellCount]
Local $iUpdateCount = 0
If Not IsUseCustomSpellsOrder() Then
SetError(2, 0, False)
Return
EndIf
For $i = 0 To UBound($g_ahCmbSpellsOrder) - 1
Local $sComboText = GUICtrlRead($g_ahCmbSpellsOrder[$i])
For $j = 0 To UBound($g_asSpellsOrderList) - 1
If $sComboText = $g_asSpellsOrderList[$j] Then
$NewTroopOrder[$i] = $j - 1
$iUpdateCount += 1
ExitLoop
EndIf
Next
Next
If $iUpdateCount = $eSpellCount Then
For $i = 0 To $eSpellCount - 1
$g_aiBrewOrder[$i] = $NewTroopOrder[$i]
Next
_GUICtrlSetImage($g_ahImgSpellsOrderSet, $g_sLibIconPath, $eIcnGreenLight)
Else
SetLog($iUpdateCount & "|" & $eSpellCount & " - Error - Bad Spells assignment in ChangeSpellsBrewOrder()", $COLOR_ERROR)
SetError(3, 0, False)
Return
EndIf
Return True
EndFunc
Func ChangeTroopTrainOrder()
If $g_bDebugSetlog Or $g_bDebugSetlogTrain Then SetLog("Begin Func ChangeTroopTrainOrder()", $COLOR_DEBUG)
Local $NewTroopOrder[$eTroopCount]
Local $iUpdateCount = 0
If Not IsUseCustomTroopOrder() Then
SetError(2, 0, False)
Return
EndIf
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
Local $sComboText = GUICtrlRead($g_ahCmbTroopOrder[$i])
For $j = 0 To UBound($g_asTroopOrderList) - 1
If $sComboText = $g_asTroopOrderList[$j] Then
$NewTroopOrder[$i] = $j - 1
$iUpdateCount += 1
ExitLoop
EndIf
Next
Next
If $iUpdateCount = $eTroopCount Then
For $i = 0 To $eTroopCount - 1
$g_aiTrainOrder[$i] = $NewTroopOrder[$i]
Next
_GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnGreenLight)
Else
SetLog($iUpdateCount & "|" & $eTroopCount & " - Error - Bad troop assignment in ChangeTroopTrainOrder()", $COLOR_ERROR)
SetError(3, 0, False)
Return
EndIf
Return True
EndFunc
Func SetDefaultTroopGroup($bSetLog = True)
For $i = 0 To $eTroopCount - 1
$g_aiTrainOrder[$i] = $i
Next
If($bSetLog Or $g_bDebugSetlogTrain) And $g_bCustomTrainOrderEnable Then SetLog("Default troop training order set", $COLOR_SUCCESS)
EndFunc
Func SetDefaultSpellsGroup($bSetLog = True)
For $i = 0 To $eSpellCount - 1
$g_aiBrewOrder[$i] = $i
Next
If($bSetLog Or $g_bDebugSetlogTrain) And $g_bCustomTrainOrderEnable Then SetLog("Default Spells Brew order set", $COLOR_SUCCESS)
EndFunc
Func IsUseCustomSpellsOrder()
For $i = 0 To UBound($g_aiCmbCustomBrewOrder) - 1
If $g_aiCmbCustomBrewOrder[$i] = -1 Then
If $g_bDebugSetlogTrain And $g_bCustomBrewOrderEnable Then SetLog("Custom Spell order not used...", $COLOR_DEBUG)
Return False
EndIf
Next
If $g_bDebugSetlogTrain And $g_bCustomBrewOrderEnable Then SetLog("Custom Spell order used...", $COLOR_DEBUG)
Return True
EndFunc
Func IsUseCustomTroopOrder()
For $i = 0 To UBound($g_aiCmbCustomTrainOrder) - 1
If $g_aiCmbCustomTrainOrder[$i] = -1 Then
If $g_bDebugSetlogTrain And $g_bCustomTrainOrderEnable Then SetLog("Custom train order not used...", $COLOR_DEBUG)
Return False
EndIf
Next
If $g_bDebugSetlogTrain And $g_bCustomTrainOrderEnable Then SetLog("Custom train order used...", $COLOR_DEBUG)
Return True
EndFunc
Func LevUpDownTroop($iTroopIndex, $NoChangeLev = True)
Local $MaxLev = $g_aiTroopCostPerLevel[$iTroopIndex][0]
Local $TempLev = 0
If $NoChangeLev Then
If _IsPressed("10") Or _IsPressed("02") Then
$TempLev = $g_aiTrainArmyTroopLevel[$iTroopIndex] - 1
Else
$TempLev = $g_aiTrainArmyTroopLevel[$iTroopIndex] + 1
EndIf
Else
$TempLev = $g_aiTrainArmyTroopLevel[$iTroopIndex]
EndIf
Local $hLevel = $g_ahLblTrainArmyTroopLevel[$iTroopIndex]
Local $hCount = $g_ahTxtTrainArmyTroopCount[$iTroopIndex]
If $TempLev > $MaxLev Or $TempLev = 0 Then
$TempLev = 0
GUICtrlSetData($hCount, 0)
$g_aiArmyCompTroops[$iTroopIndex] = 0
If IsGUICtrlHidden($hCount) = False Then GUICtrlSetState($hCount, $GUI_HIDE)
If $NoChangeLev Then lblTotalCountTroop1()
ElseIf $TempLev < 0 Then
$TempLev = $MaxLev
If IsGUICtrlHidden($hCount) Then GUICtrlSetState($hCount, $GUI_SHOW)
ElseIf $TempLev > 0 And $TempLev <= $MaxLev And IsGUICtrlHidden($hCount) Then
GUICtrlSetState($hCount, $GUI_SHOW)
EndIf
$g_aiTrainArmyTroopLevel[$iTroopIndex] = $TempLev
Local $iColor =($TempLev = $MaxLev ? $COLOR_YELLOW : $COLOR_WHITE)
GUICtrlSetData($hLevel, $TempLev)
If GUICtrlGetBkColor($hLevel) <> $iColor Then GUICtrlSetBkColor($hLevel, $iColor)
EndFunc
Func LevUpDownSpell($iSpellIndex, $NoChangeLev = True)
Local $MaxLev = $g_aiSpellCostPerLevel[$iSpellIndex][0]
Local $TempLev = 0
If $NoChangeLev Then
If _IsPressed("10") Or _IsPressed("02") Then
$TempLev = $g_aiTrainArmySpellLevel[$iSpellIndex] - 1
Else
$TempLev = $g_aiTrainArmySpellLevel[$iSpellIndex] + 1
EndIf
Else
$TempLev = $g_aiTrainArmySpellLevel[$iSpellIndex]
EndIf
Local $hLevel = $g_ahLblTrainArmySpellLevel[$iSpellIndex]
Local $hCount = $g_ahTxtTrainArmySpellCount[$iSpellIndex]
If $TempLev > $MaxLev Or $TempLev = 0 Then
$TempLev = 0
GUICtrlSetData($hCount, 0)
$g_aiArmyCompSpells[$iSpellIndex] = 0
If IsGUICtrlHidden($hCount) = False Then GUICtrlSetState($hCount, $GUI_HIDE)
If $NoChangeLev Then lblTotalCountSpell2()
ElseIf $TempLev < 0 Then
$TempLev = $MaxLev
If IsGUICtrlHidden($hCount) Then GUICtrlSetState($hCount, $GUI_SHOW)
ElseIf $TempLev > 0 And $TempLev <= $MaxLev And IsGUICtrlHidden($hCount) Then
GUICtrlSetState($hCount, $GUI_SHOW)
EndIf
$g_aiTrainArmySpellLevel[$iSpellIndex] = $TempLev
Local $iColor =($TempLev = $MaxLev ? $COLOR_YELLOW : $COLOR_WHITE)
GUICtrlSetData($hLevel, $TempLev)
If GUICtrlGetBkColor($hLevel) <> $iColor Then GUICtrlSetBkColor($hLevel, $iColor)
EndFunc
Func TrainTroopLevelClick()
If $g_bRunState = True Then Return
Local $iTroop = -1
For $i = 0 To $eTroopCount - 1
If @GUI_CtrlId = $g_ahPicTrainArmyTroop[$i] Then
$iTroop = $i
ExitLoop
EndIf
Next
If $iTroop = -1 Then Return
While _IsPressed(01)
LevUpDownTroop($iTroop)
Sleep($DELAYLVUP)
lblTotalCountTroop2()
WEnd
EndFunc
Func TrainSpellLevelClick()
If $g_bRunState = True Then Return
Local $iSpell = -1
For $i = 0 To $eSpellCount - 1
If @GUI_CtrlId = $g_ahPicTrainArmySpell[$i] Then
$iSpell = $i
ExitLoop
EndIf
Next
If $iSpell = -1 Then Return
While _IsPressed(01)
LevUpDownSpell($iSpell)
Sleep($DELAYLVUP)
lblTotalCountSpell2()
WEnd
EndFunc
Func CalCostCamp()
Local $iElixirCostCamp = 0, $iDarkCostCamp = 0
For $i = $eTroopBarbarian To $eTroopElectroDragon
$iElixirCostCamp += $g_aiArmyCompTroops[$i] * $g_aiTroopCostPerLevel[$i][$g_aiTrainArmyTroopLevel[$i]]
Next
For $i = $eTroopMinion To $eTroopBowler
$iDarkCostCamp += $g_aiArmyCompTroops[$i] * $g_aiTroopCostPerLevel[$i][$g_aiTrainArmyTroopLevel[$i]]
Next
GUICtrlSetData($g_hLblElixirCostCamp, _NumberFormat($iElixirCostCamp, True))
GUICtrlSetData($g_hLblDarkCostCamp, _NumberFormat($iDarkCostCamp, True))
EndFunc
Func CalCostSpell()
Local $iElixirCostSpell = 0, $iDarkCostSpell = 0
For $i = $eSpellLightning To $eSpellClone
$iElixirCostSpell += $g_aiArmyCompSpells[$i] * $g_aiSpellCostPerLevel[$i][$g_aiTrainArmySpellLevel[$i]]
Next
For $i = $eSpellPoison To $eSpellSkeleton
$iDarkCostSpell += $g_aiArmyCompSpells[$i] * $g_aiSpellCostPerLevel[$i][$g_aiTrainArmySpellLevel[$i]]
Next
GUICtrlSetData($g_hLblElixirCostSpell, _NumberFormat($iElixirCostSpell, True))
GUICtrlSetData($g_hLblDarkCostSpell, _NumberFormat($iDarkCostSpell, True))
EndFunc
Func CalculTimeTo($TotalTotalTime)
Local $HourToTrain = 0
Local $MinToTrain = 0
Local $SecToTrain = 0
Local $TotalTotalTimeTo
If $TotalTotalTime >= 3600 Then
$HourToTrain = Int($TotalTotalTime / 3600)
$MinToTrain = Int(($TotalTotalTime - $HourToTrain * 3600) / 60)
$SecToTrain = $TotalTotalTime - $HourToTrain * 3600 - $MinToTrain * 60
$TotalTotalTimeTo = " " & $HourToTrain & "h " & $MinToTrain & "m " & $SecToTrain & "s"
ElseIf $TotalTotalTime < 3600 And $TotalTotalTime >= 60 Then
$MinToTrain = Int(($TotalTotalTime - $HourToTrain * 3600) / 60)
$SecToTrain = $TotalTotalTime - $HourToTrain * 3600 - $MinToTrain * 60
$TotalTotalTimeTo = " " & $MinToTrain & "m " & $SecToTrain & "s"
Else
$SecToTrain = $TotalTotalTime
$TotalTotalTimeTo = " " & $SecToTrain & "s"
EndIf
Return $TotalTotalTimeTo
EndFunc
Func Removecamp()
For $T = 0 To $eTroopCount - 1
$g_aiArmyCompTroops[$T] = 0
GUICtrlSetData($g_ahTxtTrainArmyTroopCount[$T], 0)
Next
For $S = 0 To $eSpellCount - 1
$g_aiArmyCompSpells[$S] = 0
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$S], $g_aiArmyCompSpells[$S])
Next
GUICtrlSetData($g_hLblTotalTimeCamp, " 0s")
GUICtrlSetData($g_hLblTotalTimeSpell, " 0s")
GUICtrlSetData($g_hLblElixirCostCamp, "0")
GUICtrlSetData($g_hLblDarkCostCamp, "0")
GUICtrlSetData($g_hLblElixirCostSpell, "0")
GUICtrlSetData($g_hLblDarkCostSpell, "0")
GUICtrlSetData($g_hLblCountTotal, 0)
EndFunc
Func TrainTroopCountEdit()
For $i = 0 To $eTroopCount - 1
If @GUI_CtrlId = $g_ahTxtTrainArmyTroopCount[$i] Then
$g_aiArmyCompTroops[$i] = GUICtrlRead($g_ahTxtTrainArmyTroopCount[$i])
lblTotalCountTroop1()
Return
EndIf
Next
EndFunc
Func TrainSpellCountEdit()
For $i = 0 To $eSpellCount - 1
If @GUI_CtrlId = $g_ahTxtTrainArmySpellCount[$i] Then
$g_aiArmyCompSpells[$i] = GUICtrlRead($g_ahTxtTrainArmySpellCount[$i])
lblTotalCountSpell2()
Return
EndIf
Next
EndFunc
Func chkAddDelayIdlePhaseEnable()
$g_bTrainAddRandomDelayEnable =(GUICtrlRead($g_hChkTrainAddRandomDelayEnable) = $GUI_CHECKED)
For $i = $g_hLblAddDelayIdlePhaseBetween To $g_hLblAddDelayIdlePhaseSec
GUICtrlSetState($i, $g_bTrainAddRandomDelayEnable ? $GUI_ENABLE : $GUI_DISABLE)
Next
EndFunc
Func chkRequestCCHours()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "chkRequestCCHours")
If GUICtrlRead($g_hChkRequestTroopsEnable) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtRequestCC, $GUI_SHOW + $GUI_ENABLE)
For $i = $g_hLblRequestCChour To $g_hLblRequestCCHoursPM
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
GUICtrlSetState($g_hTxtRequestCC, $GUI_SHOW + $GUI_DISABLE)
For $i = $g_hLblRequestCChour To $g_hLblRequestCCHoursPM
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
SetRedrawBotWindowControls($bWasRedraw, $g_hGrpRequestCC, "chkRequestCCHours")
EndFunc
Func chkRequestCCHoursE1()
If GUICtrlRead($g_hChkRequestCCHoursE1) = $GUI_CHECKED And GUICtrlRead($g_ahChkRequestCCHours[0]) = $GUI_CHECKED Then
For $i = 0 To 11
GUICtrlSetState($g_ahChkRequestCCHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 0 To 11
GUICtrlSetState($g_ahChkRequestCCHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_hChkRequestCCHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkRequestCCHoursE2()
If GUICtrlRead($g_hChkRequestCCHoursE2) = $GUI_CHECKED And GUICtrlRead($g_ahChkRequestCCHours[12]) = $GUI_CHECKED Then
For $i = 12 To 23
GUICtrlSetState($g_ahChkRequestCCHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 12 To 23
GUICtrlSetState($g_ahChkRequestCCHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_hChkRequestCCHoursE2, $GUI_UNCHECKED)
EndFunc
Func chkDonateHours()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "chkDonateHours")
If GUICtrlRead($g_hChkDonateHoursEnable) = $GUI_CHECKED Then
For $i = $g_hLblDonateCChour To $g_hLblDonateHoursPM
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $g_hLblDonateCChour To $g_hLblDonateHoursPM
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
SetRedrawBotWindowControls($bWasRedraw, $g_hGrpDonateCC, "chkDonateHours")
EndFunc
Func chkDonateHoursE1()
If GUICtrlRead($g_ahChkDonateHoursE1) = $GUI_CHECKED And GUICtrlRead($g_ahChkDonateHours[0]) = $GUI_CHECKED Then
For $i = 0 To 11
GUICtrlSetState($g_ahChkDonateHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 0 To 11
GUICtrlSetState($g_ahChkDonateHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_ahChkDonateHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkDonateHoursE2()
If GUICtrlRead($g_ahChkDonateHoursE2) = $GUI_CHECKED And GUICtrlRead($g_ahChkDonateHours[12]) = $GUI_CHECKED Then
For $i = 12 To 23
GUICtrlSetState($g_ahChkDonateHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 12 To 23
GUICtrlSetState($g_ahChkDonateHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_ahChkDonateHoursE2, $GUI_UNCHECKED)
EndFunc
Func cmbDBGoldElixir()
If _GUICtrlComboBox_GetCurSel($g_hCmbDBMeetGE) < 2 Then
GUICtrlSetState($g_hTxtDBMinGold, $GUI_SHOW)
GUICtrlSetState($g_hPicDBMinGold, $GUI_SHOW)
GUICtrlSetState($g_hTxtDBMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicDBMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hTxtDBMinGoldPlusElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicDBMinGPEGold, $GUI_HIDE)
Else
GUICtrlSetState($g_hTxtDBMinGold, $GUI_HIDE)
GUICtrlSetState($g_hPicDBMinGold, $GUI_HIDE)
GUICtrlSetState($g_hTxtDBMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicDBMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hTxtDBMinGoldPlusElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicDBMinGPEGold, $GUI_SHOW)
EndIf
EndFunc
Func chkDBMeetDE()
_GUICtrlEdit_SetReadOnly($g_hTxtDBMinDarkElixir, GUICtrlRead($g_hChkDBMeetDE) = $GUI_CHECKED ? False : True)
EndFunc
Func chkDBMeetTrophy()
_GUICtrlEdit_SetReadOnly($g_hTxtDBMinTrophy, GUICtrlRead($g_hChkDBMeetTrophy) = $GUI_CHECKED ? False : True)
_GUICtrlEdit_SetReadOnly($g_hTxtDBMaxTrophy, GUICtrlRead($g_hChkDBMeetTrophy) = $GUI_CHECKED ? False : True)
EndFunc
Func chkDBMeetTH()
GUICtrlSetState($g_hCmbDBTH, GUICtrlRead($g_hChkDBMeetTH) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkDBWeakBase()
GUICtrlSetState($g_ahCmbWeakMortar[$DB], GUICtrlRead($g_ahChkMaxMortar[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakWizTower[$DB], GUICtrlRead($g_ahChkMaxWizTower[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakAirDefense[$DB], GUICtrlRead($g_ahChkMaxAirDefense[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakXBow[$DB], GUICtrlRead($g_ahChkMaxXBow[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakInferno[$DB], GUICtrlRead($g_ahChkMaxInferno[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakEagle[$DB], GUICtrlRead($g_ahChkMaxEagle[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func cmbABGoldElixir()
If _GUICtrlComboBox_GetCurSel($g_hCmbABMeetGE) < 2 Then
GUICtrlSetState($g_hTxtABMinGold, $GUI_SHOW)
GUICtrlSetState($g_hPicABMinGold, $GUI_SHOW)
GUICtrlSetState($g_hTxtABMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicABMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hTxtABMinGoldPlusElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicABMinGPEGold, $GUI_HIDE)
Else
GUICtrlSetState($g_hTxtABMinGold, $GUI_HIDE)
GUICtrlSetState($g_hPicABMinGold, $GUI_HIDE)
GUICtrlSetState($g_hTxtABMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicABMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hTxtABMinGoldPlusElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicABMinGPEGold, $GUI_SHOW)
EndIf
EndFunc
Func chkABMeetDE()
_GUICtrlEdit_SetReadOnly($g_hTxtABMinDarkElixir, GUICtrlRead($g_hChkABMeetDE) = $GUI_CHECKED ? False : True)
EndFunc
Func chkABMeetTrophy()
_GUICtrlEdit_SetReadOnly($g_hTxtABMinTrophy, GUICtrlRead($g_hChkABMeetTrophy) = $GUI_CHECKED ? False : True)
_GUICtrlEdit_SetReadOnly($g_hTxtABMaxTrophy, GUICtrlRead($g_hChkABMeetTrophy) = $GUI_CHECKED ? False : True)
EndFunc
Func chkABMeetTH()
GUICtrlSetState($g_hCmbABTH, GUICtrlRead($g_hChkABMeetTH) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkABWeakBase()
GUICtrlSetState($g_ahCmbWeakMortar[$LB], GUICtrlRead($g_ahChkMaxMortar[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakWizTower[$LB], GUICtrlRead($g_ahChkMaxWizTower[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakAirDefense[$LB], GUICtrlRead($g_ahChkMaxAirDefense[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakXBow[$LB], GUICtrlRead($g_ahChkMaxXBow[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakInferno[$LB], GUICtrlRead($g_ahChkMaxInferno[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakEagle[$LB], GUICtrlRead($g_ahChkMaxEagle[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkRestartSearchLimit()
GUICtrlSetState($g_hTxtRestartSearchlimit, GUICtrlRead($g_hChkRestartSearchLimit) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func btnConfigureCollectors()
EndFunc
Func btnConfigureReduction()
EndFunc
Func btnConfigureTHBully()
EndFunc
Func btnConfigureDBWeakBase()
EndFunc
Func btnConfigureABWeakBase()
EndFunc
Func chkDBActivateSearches()
If GUICtrlRead($g_hChkDBActivateSearches) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtDBSearchesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblDBSearches, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBSearchesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtDBSearchesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDBSearches, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBSearchesMax, $GUI_DISABLE)
EndIf
dbCheckall()
EndFunc
Func chkDBActivateTropies()
If GUICtrlRead($g_hChkDBActivateTropies) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtDBTropiesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblDBTropies, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBTropiesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtDBTropiesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDBTropies, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBTropiesMax, $GUI_DISABLE)
EndIf
dbCheckall()
EndFunc
Func chkDBActivateCamps()
If GUICtrlRead($g_hChkDBActivateCamps) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblDBArmyCamps, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBArmyCamps, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblDBArmyCamps, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBArmyCamps, $GUI_DISABLE)
EndIf
dbCheckall()
EndFunc
Func EnableSearchPanels($mode)
Switch $mode
Case $DB
If GUICtrlRead($g_hChkDBActivateSearches) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBActivateTropies) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBActivateCamps) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBKingWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBQueenWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBWardenWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBNotWaitHeroes) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBSpellsWait) = $GUI_CHECKED Then
_GUI_Value_STATE("SHOW", $groupHerosDB)
_GUI_Value_STATE("SHOW", $g_aGroupSearchDB)
_GUI_Value_STATE("SHOW", $groupSpellsDB)
cmbDBGoldElixir()
Else
_GUI_Value_STATE("HIDE", $groupHerosDB)
_GUI_Value_STATE("HIDE", $g_aGroupSearchDB)
_GUI_Value_STATE("HIDE", $groupSpellsDB)
EndIf
Case $LB
If GUICtrlRead($g_hChkABActivateSearches) = $GUI_CHECKED Or GUICtrlRead($g_hChkABActivateTropies) = $GUI_CHECKED Or GUICtrlRead($g_hChkABActivateCamps) = $GUI_CHECKED Or GUICtrlRead($g_hChkABKingWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkABQueenWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkABWardenWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkABNotWaitHeroes) = $GUI_CHECKED Or GUICtrlRead($g_hChkABSpellsWait) = $GUI_CHECKED Then
_GUI_Value_STATE("SHOW", $groupHerosAB)
_GUI_Value_STATE("SHOW", $groupSearchAB)
_GUI_Value_STATE("SHOW", $groupSpellsAB)
cmbABGoldElixir()
Else
_GUI_Value_STATE("HIDE", $groupHerosAB)
_GUI_Value_STATE("HIDE", $groupSearchAB)
_GUI_Value_STATE("HIDE", $groupSpellsAB)
EndIf
Case $TS
If GUICtrlRead($g_hChkTSActivateSearches) = $GUI_CHECKED Or GUICtrlRead($g_hChkTSActivateTropies) = $GUI_CHECKED Or GUICtrlRead($g_hChkTSActivateCamps) = $GUI_CHECKED Then
_GUI_Value_STATE("SHOW", $groupSearchTS)
cmbTSGoldElixir()
Else
_GUI_Value_STATE("HIDE", $groupSearchTS)
EndIf
EndSwitch
EndFunc
Func chkABActivateSearches()
If GUICtrlRead($g_hChkABActivateSearches) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtABSearchesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblABSearches, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABSearchesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtABSearchesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblABSearches, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABSearchesMax, $GUI_DISABLE)
EndIf
abCheckall()
EndFunc
Func chkABActivateTropies()
If GUICtrlRead($g_hChkABActivateTropies) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtABTropiesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblABTropies, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABTropiesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtABTropiesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblABTropies, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABTropiesMax, $GUI_DISABLE)
EndIf
abCheckall()
EndFunc
Func chkABActivateCamps()
If GUICtrlRead($g_hChkABActivateCamps) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblABArmyCamps, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABArmyCamps, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblABArmyCamps, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABArmyCamps, $GUI_DISABLE)
EndIf
abCheckall()
EndFunc
Func chkTSActivateSearches()
If GUICtrlRead($g_hChkTSActivateSearches) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtTSSearchesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblTSSearches, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTSSearchesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtTSSearchesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblTSSearches, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTSSearchesMax, $GUI_DISABLE)
EndIf
tsCheckall()
EndFunc
Func chkTSActivateTropies()
If GUICtrlRead($g_hChkTSActivateTropies) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtTSTropiesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblTSTropies, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTSTropiesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtTSTropiesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblTSTropies, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTSTropiesMax, $GUI_DISABLE)
EndIf
tsCheckAll()
EndFunc
Func chkTSActivateCamps()
If GUICtrlRead($g_hChkTSActivateCamps) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblTSArmyCamps, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTSArmyCamps, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblTSArmyCamps, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTSArmyCamps, $GUI_DISABLE)
EndIf
tsCheckAll()
EndFunc
Func chkDBKingWait()
If $g_iTownHallLevel > 6 Or $g_iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkDBKingWait) = $GUI_CHECKED Then
If $g_bUpgradeKingEnable = False Then
GUICtrlSetState($g_hChkDBKingAttack, $GUI_CHECKED)
Else
GUICtrlSetState($g_hChkDBKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $g_bUpgradeKingEnable = False Then
GUICtrlSetState($g_hChkDBKingWait, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkDBKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($g_hChkDBKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkDBKingAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkDBQueenWait()
If $g_iTownHallLevel > 8 Or $g_iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkDBQueenWait) = $GUI_CHECKED Then
If $g_bUpgradeQueenEnable = False Then
GUICtrlSetState($g_hChkDBQueenAttack, $GUI_CHECKED)
Else
GUICtrlSetState($g_hChkDBQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $g_bUpgradeQueenEnable = False Then
GUICtrlSetState($g_hChkDBQueenWait, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkDBQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($g_hChkDBQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkDBQueenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkDBWardenWait()
If $g_iTownHallLevel > 10 Or $g_iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkDBWardenWait) = $GUI_CHECKED Then
If $g_bUpgradeWardenEnable = False Then
GUICtrlSetState($g_hChkDBWardenAttack, $GUI_CHECKED)
GUICtrlSetState($g_hPicDBWardenWait, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkDBWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $g_bUpgradeWardenEnable = False Then
GUICtrlSetState($g_hChkDBWardenWait, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkDBWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($g_hChkDBWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkDBWardenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkABKingWait()
If $g_iTownHallLevel > 6 Or $g_iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkABKingWait) = $GUI_CHECKED Then
If $g_bUpgradeKingEnable = False Then
GUICtrlSetState($g_hChkABKingAttack, $GUI_CHECKED)
Else
GUICtrlSetState($g_hChkABKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $g_bUpgradeKingEnable = False Then
GUICtrlSetState($g_hChkABKingWait, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkABKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($g_hChkABKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkABKingAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkABQueenWait()
If $g_iTownHallLevel > 8 Or $g_iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkABQueenWait) = $GUI_CHECKED Then
If $g_bUpgradeQueenEnable = False Then
GUICtrlSetState($g_hChkABQueenAttack, $GUI_CHECKED)
Else
GUICtrlSetState($g_hChkABQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $g_bUpgradeQueenEnable = False Then
GUICtrlSetState($g_hChkABQueenWait, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkABQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($g_hChkABQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkABQueenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkABWardenWait()
If $g_iTownHallLevel > 10 Or $g_iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkABWardenWait) = $GUI_CHECKED Then
If $g_bUpgradeWardenEnable = False Then
GUICtrlSetState($g_hChkABWardenAttack, $GUI_CHECKED)
Else
GUICtrlSetState($g_hChkABWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $g_bUpgradeWardenEnable = False Then
GUICtrlSetState($g_hChkABWardenWait, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkABWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($g_hChkABWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkABWardenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkDBWaitForCCSpell()
If GUICtrlRead($g_hChkDBWaitForCastleSpell) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbDBWaitForCastleSpell, $GUI_ENABLE)
cmbDBWaitForCCSpell()
Else
GUICtrlSetState($g_hCmbDBWaitForCastleSpell, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBWaitForCastleSpell, $GUI_DISABLE)
GUICtrlSetState($g_hCmbDBWaitForCastleSpell2, $GUI_DISABLE)
EndIf
EndFunc
Func chkABWaitForCCSpell()
If GUICtrlRead($g_hChkABWaitForCastleSpell) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbABWaitForCastleSpell, $GUI_ENABLE)
cmbABWaitForCCSpell()
Else
GUICtrlSetState($g_hCmbABWaitForCastleSpell, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABWaitForCastleSpell, $GUI_DISABLE)
GUICtrlSetState($g_hCmbABWaitForCastleSpell2, $GUI_DISABLE)
EndIf
EndFunc
Func cmbDBWaitForCCSpell()
Local $iSpellSelection = _GUICtrlComboBox_GetCurSel($g_hCmbDBWaitForCastleSpell)
If $iSpellSelection > 0 And $iSpellSelection < 6 Then
GUICtrlSetState($g_hCmbDBWaitForCastleSpell2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBWaitForCastleSpell, $GUI_DISABLE)
Else
GUICtrlSetState($g_hCmbDBWaitForCastleSpell2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBWaitForCastleSpell, $GUI_ENABLE)
EndIf
EndFunc
Func cmbABWaitForCCSpell()
Local $iSpellSelection = _GUICtrlComboBox_GetCurSel($g_hCmbABWaitForCastleSpell)
If $iSpellSelection > 0 And $iSpellSelection < 6 Then
GUICtrlSetState($g_hCmbABWaitForCastleSpell2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABWaitForCastleSpell, $GUI_DISABLE)
Else
GUICtrlSetState($g_hCmbABWaitForCastleSpell2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABWaitForCastleSpell, $GUI_ENABLE)
EndIf
EndFunc
Func chkDBSpellsWait()
If $g_iTownHallLevel > 4 Or $g_iTownHallLevel = 0 Then
For $i = $g_hPicDBLightSpellWait To $g_hPicDBHasteSpellWait
GUICtrlSetState($i, $GUI_ENABLE)
Next
If GUICtrlRead($g_hChkDBSpellsWait) = $GUI_CHECKED Then
$g_abSearchSpellsWaitEnable[$DB] = True
chkSpellWaitError()
If @error Then
GUICtrlSetState($g_hChkDBSpellsWait, $GUI_UNCHECKED)
$g_abSearchSpellsWaitEnable[$DB] = False
SetLog("Wait for Spells disabled due training count error", $COLOR_ERROR)
EndIf
Else
$g_abSearchSpellsWaitEnable[$DB] = False
EndIf
Else
GUICtrlSetState($g_hChkDBSpellsWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
For $i = $g_hPicDBLightSpellWait To $g_hPicDBHasteSpellWait
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkABSpellsWait()
If $g_iTownHallLevel > 4 Or $g_iTownHallLevel = 0 Then
For $i = $g_hPicABLightSpellWait To $g_hPicABHasteSpellWait
GUICtrlSetState($i, $GUI_ENABLE)
Next
If GUICtrlRead($g_hChkABSpellsWait) = $GUI_CHECKED Then
$g_abSearchSpellsWaitEnable[$LB] = True
chkSpellWaitError()
If @error Then
GUICtrlSetState($g_hChkABSpellsWait, $GUI_UNCHECKED)
$g_abSearchSpellsWaitEnable[$LB] = False
SetLog("Wait for Spells disabled due training count error", $COLOR_ERROR)
EndIf
Else
$g_abSearchSpellsWaitEnable[$LB] = False
EndIf
Else
GUICtrlSetState($g_hChkABSpellsWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
For $i = $g_hPicABLightSpellWait To $g_hPicABHasteSpellWait
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkSpellWaitError()
Local Static $bHaveBeenWarned = False
Local $bErrorCondition = False
Local $sErrorText, $sText, $MsgBox1, $MsgBox2, $MsgBox3
If $g_iTotalTrainSpaceSpell > GUICtrlRead($g_hTxtTotalCountSpell) Then
$sErrorText = GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_ErrorText_01", "Total number of trained spells exceeds total set in GUI!") & @CRLF & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_ErrorText_02", "Reduce number of trained spells,") & @CRLF & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_ErrorText_03", "OR ELSE BOT WILL NEVER ATTACK!!") & @CRLF
$bErrorCondition = True
Else
Return
EndIf
If $bHaveBeenWarned = True And $bErrorCondition = True Then
SetError(1)
Return
ElseIf $bErrorCondition = False Then
Return
EndIf
Local $iCount = 0
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xE00000, 0xFFFF00, 12, "Comic Sans MS", 480)
$sText = $sErrorText & @CRLF & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_01", "Click YES to close this warning message") & @CRLF
$MsgBox1 = _ExtMsgBox(48, GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_02", "YES, I Understand Warning|No"), GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_03", "Wait for Spells Warning!"), $sText, 30, $g_hFrmBot)
Switch $MsgBox1
Case 1
$bHaveBeenWarned = True
ExitLoop
Case Else
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xFFFF00 , 0xE00000, 12, "Comic Sans MS", 480)
$stext = GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_04", "Sorry, must understand warning and click Yes!") & @CRLF
$MsgBox2 = _ExtMsgBox(16, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_07", "User Input Error"), $stext, 15, $g_hFrmBot)
If $iCount = 1 And $MsgBox1 = 9 And $MsgBox2 = 9 Then ExitLoop
EndSwitch
$iCount += 1
If $iCount > 2 Then
$sText = GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_08", "CONGRATULATIONS!!") & @CRLF & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_09", "You found the secret message in Bot!") & @CRLF & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_10", "Can you find the randomly selected button to close this message?") & @CRLF & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_11", "HaHaHaHa...") & @CRLF & @CRLF & @CRLF
Local $sFunnyText = $sText
Local $iControl = 0
$iCount = 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 480)
While 1
$MsgBox3 = _ExtMsgBox(128, "1|2|3|4|5|6|7", GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_12", "You are a WINNER!!"), $sFunnyText, 900, $g_hFrmBot)
If @error Then SetLog("_ExtMsgBox error: " & @error, $COLOR_ERROR)
If $iCount > 7 And Int($MsgBox3) = Random(1,8,1) Then
ExitLoop
Else
If $iCount <= 7 Then
$iControl = $iCount
Else
$iControl = $MsgBox3
EndIf
Switch $iControl
Case 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x61FF00, 0x020028, 12, "Arial", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_01", "Sorry not that button!") & @CRLF
Case 2
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xDC00FF, 0x011E00, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_02", "Donate ??5000 to MyBot.run while you wait 15 minutes for this to time out?") & @CRLF
Case 3
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x000000, 0xFFFFFF, 12, "Tahoma", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_03", "Having trouble finding the exit button?") & @CRLF
Case 4
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x4800FF, 0xD800FF, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_04", "This is fun, can we keep going all day?") & @CRLF
Case 5
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Times New Roman", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_05", "Try four more times, you have to get lucky sooner or later!") & @CRLF
Case 6
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x00FFED, 0x010051, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_06", "Do you have a Banana? This code monkey is Hungry!") & @CRLF
Case 7
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xFF6600, 0x013000, 12, "Lucida Console", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_07", "Maybe try hitting same button till you and Mr. Random pick same?") & @CRLF
Case 0
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x000000, 0xFFFFFF, 12, "Tahoma", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_08", "Sorry, can not 'escape' from this!") & @CRLF
Case Else
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_09", "Program error! Programmers can ruin a good joke.") & @CRLF
ExitLoop 2
EndSwitch
$iCount += 1
EndIf
WEnd
EndIf
WEnd
If $bErrorCondition = True Then
SetError(1)
Return
EndIf
EndFunc
Func CmbDBTH()
_GUI_Value_STATE("HIDE", $g_aGroupListPicDBMaxTH)
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($g_hCmbDBTH) + 6
GUICtrlSetState($g_ahPicDBMaxTH[$iCmbValue], $GUI_SHOW)
EndFunc
Func CmbABTH()
_GUI_Value_STATE("HIDE", $g_aGroupListPicABMaxTH)
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($g_hCmbABTH) + 6
GUICtrlSetState($g_ahPicABMaxTH[$iCmbValue], $GUI_SHOW)
EndFunc
Func CmbBullyMaxTH()
_GUI_Value_STATE("HIDE", $g_aGroupListPicBullyMaxTH)
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($g_hCmbBullyMaxTH) + 6
GUICtrlSetState($g_ahPicBullyMaxTH[$iCmbValue], $GUI_SHOW)
EndFunc
Func dbCheckAll()
If BitAND(GUICtrlRead($g_hChkDBActivateSearches), GUICtrlRead($g_hChkDBActivateTropies), GUICtrlRead($g_hChkDBActivateCamps), GUICtrlRead($g_hChkDBSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkDeadbase, $GUI_UNCHECKED)
Else
GUICtrlSetState($g_hChkDeadbase, $GUI_CHECKED)
EndIf
tabSEARCH()
EndFunc
Func abCheckAll()
If BitAND(GUICtrlRead($g_hChkABActivateSearches), GUICtrlRead($g_hChkABActivateTropies), GUICtrlRead($g_hChkABActivateCamps), GUICtrlRead($g_hChkABSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkActivebase, $GUI_UNCHECKED)
Else
GUICtrlSetState($g_hChkActivebase, $GUI_CHECKED)
EndIf
tabSEARCH()
EndFunc
Func tsCheckAll()
If BitAND(GUICtrlRead($g_hChkTSActivateSearches), GUICtrlRead($g_hChkTSActivateTropies), GUICtrlRead($g_hChkTSActivateCamps)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkTHSnipe, $GUI_UNCHECKED)
Else
GUICtrlSetState($g_hChkTHSnipe, $GUI_CHECKED)
EndIf
tabSEARCH()
EndFunc
Func chkNotWaitHeroes()
If $g_abAttackTypeEnable[$DB] Then $g_iSearchNotWaitHeroesEnable = $g_aiSearchNotWaitHeroesEnable[$DB]
If $g_abAttackTypeEnable[$LB] Then
If $g_iSearchNotWaitHeroesEnable <> 0 Then $g_iSearchNotWaitHeroesEnable = $g_aiSearchNotWaitHeroesEnable[$LB]
EndIf
EndFunc
Func btnMilkingOptions()
EndFunc
Func btnDBAttackConfigure()
Switch _GUICtrlComboBox_GetCurSel($g_hCmbDBAlgorithm)
Case 0
Case 1
Case 2
EndSwitch
EndFunc
Func btnABAttackConfigure()
Switch _GUICtrlComboBox_GetCurSel($g_hCmbDBAlgorithm)
Case 0
Case 1
EndSwitch
EndFunc
Func cmbDBAlgorithm()
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($g_hCmbDBAlgorithm)
_GUI_Value_STATE(($iCmbValue = 1 Or $iCmbValue = 2) ? "SHOW" : "HIDE", $g_aGroupAttackDBSpell & "#" & $groupIMGAttackDBSpell)
If BitAND(GUICtrlGetState($g_hGUI_DEADBASE), $GUI_SHOW) And GUICtrlRead($g_hGUI_DEADBASE_TAB) = 1 Then
Select
Case $iCmbValue = 0
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_MILKING)
Case $iCmbValue = 1
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_MILKING)
Case $iCmbValue = 2
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DEADBASE_ATTACK_MILKING)
Case Else
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_MILKING)
EndSelect
EndIf
EndFunc
Func cmbABAlgorithm()
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($g_hcmbABAlgorithm)
_GUI_Value_STATE($iCmbValue = 1 ? "SHOW" : "HIDE", $groupAttackABSpell & "#" & $groupIMGAttackABSpell)
If BitAND(GUICtrlGetState($g_hGUI_ACTIVEBASE), $GUI_SHOW) And GUICtrlRead($g_hGUI_ACTIVEBASE_TAB) = 1 Then
Select
Case $iCmbValue = 0
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
Case $iCmbValue = 1
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
Case Else
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
EndSelect
EndIf
EndFunc
Func chkAttackNow()
If GUICtrlRead($g_hChkAttackNow) = $GUI_CHECKED Then
$g_bSearchAttackNowEnable = True
GUICtrlSetState($g_hLblAttackNow, $GUI_ENABLE)
GUICtrlSetState($g_hLblAttackNowSec, $GUI_ENABLE)
GUICtrlSetState($g_hCmbAttackNowDelay, $GUI_ENABLE)
GUICtrlSetState($g_hCmbAttackNowDelay, $GUI_ENABLE)
Else
$g_bSearchAttackNowEnable = False
GUICtrlSetState($g_hLblAttackNow, $GUI_DISABLE)
GUICtrlSetState($g_hLblAttackNowSec, $GUI_DISABLE)
GUICtrlSetState($g_hCmbAttackNowDelay, $GUI_DISABLE)
EndIf
EndFunc
Func LoadThSnipeAttacks()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sTHSnipeAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbAttackTHType)
GUICtrlSetData($g_hCmbAttackTHType, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbAttackTHType, _GUICtrlComboBox_FindStringExact($g_hCmbAttackTHType, $g_sAtkTSType))
EndFunc
Func LoadDBSnipeAttacks()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sTHSnipeAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbTHSnipeBeforeDBScript)
GUICtrlSetData($g_hCmbTHSnipeBeforeDBScript, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeDBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeDBScript, $g_iTHSnipeBeforeTiles[$DB]))
EndFunc
Func LoadABSnipeAttacks()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sTHSnipeAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbTHSnipeBeforeLBScript)
GUICtrlSetData($g_hCmbTHSnipeBeforeLBScript, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeLBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeLBScript, $g_iTHSnipeBeforeScript[$LB]))
EndFunc
Func cmbAttackTHType()
Local $arrayattack = _GUICtrlComboBox_GetListArray($g_hCmbAttackTHType)
$g_sAtkTSType = $arrayattack[_GUICtrlComboBox_GetCurSel($g_hCmbAttackTHType) + 1]
EndFunc
Func btnTestTHcsv()
AttackTHParseCSV(True)
EndFunc
Func cmbTSGoldElixir()
If _GUICtrlComboBox_GetCurSel($g_hCmbTSMeetGE) < 2 Then
GUICtrlSetState($g_hTxtTSMinGold, $GUI_SHOW)
GUICtrlSetState($g_hPicTSMinGold, $GUI_SHOW)
GUICtrlSetState($g_hTxtTSMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicTSMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hTxtTSMinGoldPlusElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicTSMinGPEGold, $GUI_HIDE)
Else
GUICtrlSetState($g_hTxtTSMinGold, $GUI_HIDE)
GUICtrlSetState($g_hPicTSMinGold, $GUI_HIDE)
GUICtrlSetState($g_hTxtTSMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicTSMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hTxtTSMinGoldPlusElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicTSMinGPEGold, $GUI_SHOW)
EndIf
EndFunc
Func chkTHSnipeBeforeDBEnable()
If GUICtrlRead($g_hChkTHSnipeBeforeDBEnable) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblTHSnipeBeforeDBTiles, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTHSnipeBeforeDBTiles, $GUI_ENABLE)
GUICtrlSetState($g_hCmbTHSnipeBeforeDBScript, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblTHSnipeBeforeDBTiles, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTHSnipeBeforeDBTiles, $GUI_DISABLE)
GUICtrlSetState($g_hCmbTHSnipeBeforeDBScript, $GUI_DISABLE)
EndIf
EndFunc
Func chkTHSnipeBeforeLBEnable()
If GUICtrlRead($g_hChkTHSnipeBeforeLBEnable) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblTHSnipeBeforeLBTiles, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTHSnipeBeforeLBTiles, $GUI_ENABLE)
GUICtrlSetState($g_hCmbTHSnipeBeforeLBScript, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblTHSnipeBeforeLBTiles, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTHSnipeBeforeLBTiles, $GUI_DISABLE)
GUICtrlSetState($g_hCmbTHSnipeBeforeLBScript, $GUI_DISABLE)
EndIf
EndFunc
Func radHerosApply()
GUICtrlSetState($g_hRadAutoQueenAbility, $g_iActivateQueen = 0 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRadManQueenAbility, $g_iActivateQueen = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRadBothQueenAbility, $g_iActivateQueen = 2 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtManQueenAbility,($g_iDelayActivateQueen / 1000))
GUICtrlSetState($g_hRadAutoKingAbility, $g_iActivateKing = 0 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRadManKingAbility, $g_iActivateKing = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRadBothKingAbility, $g_iActivateKing = 2 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtManKingAbility,($g_iDelayActivateKing / 1000))
GUICtrlSetState($g_hRadAutoWardenAbility, $g_iActivateWarden = 0 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRadManWardenAbility, $g_iActivateWarden = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRadBothWardenAbility, $g_iActivateWarden = 2 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtManWardenAbility,($g_iDelayActivateWarden / 1000))
EndFunc
Func chkattackHoursE1()
If GUICtrlRead($g_ahChkAttackHoursE1) = $GUI_CHECKED And IschkattackHoursE1() Then
For $i = 0 To 11
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 0 To 11
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_ahChkAttackHoursE1, $GUI_UNCHECKED)
EndFunc
Func IschkattackHoursE1()
For $i = 0 To 11
If GUICtrlRead($g_ahChkAttackHours[$i]) = $GUI_CHECKED Then Return True
Next
Return False
EndFunc
Func chkattackHoursE2()
If GUICtrlRead($g_ahChkAttackHoursE2) = $GUI_CHECKED And IschkattackHoursE2() Then
For $i = 12 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 12 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_ahChkAttackHoursE2, $GUI_UNCHECKED)
EndFunc
Func IschkattackHoursE2()
For $i = 12 To 23
If GUICtrlRead($g_ahChkAttackHours[$i]) = $GUI_CHECKED Then Return True
Next
Return False
EndFunc
Func chkattackWeekDaysE()
If GUICtrlRead($g_ahChkAttackWeekdaysE) = $GUI_CHECKED And IschkAttackWeekdays() Then
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_UNCHECKED)
Next
Else
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_ahChkAttackWeekdaysE, $GUI_UNCHECKED)
EndFunc
Func IschkAttackWeekdays()
For $i = 0 To 6
If GUICtrlRead($g_ahChkAttackWeekdays[$i]) = $GUI_CHECKED Then Return True
Next
Return False
EndFunc
Func chkAttackPlannerEnable()
If GUICtrlRead($g_hChkAttackPlannerEnable) = $GUI_CHECKED Then
$g_bAttackPlannerEnable = True
If GUICtrlRead($g_hChkAttackPlannerCloseAll) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkAttackPlannerCloseAll, $GUI_ENABLE)
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, $GUI_ENABLE)
GUICtrlSetState($g_hChkAttackPlannerSuspendComputer, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkAttackPlannerCloseAll, $GUI_ENABLE)
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
GUICtrlSetState($g_hChkAttackPlannerRandom, $GUI_ENABLE)
GUICtrlSetState($g_hChkAttackPlannerDayLimit, $GUI_ENABLE)
chkAttackPlannerDayLimit()
cmbAttackPlannerRandom()
If GUICtrlRead($g_hChkAttackPlannerRandom) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbAttackPlannerRandom, $GUI_ENABLE)
GUICtrlSetState($g_hLbAttackPlannerRandom, $GUI_ENABLE)
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackWeekdaysE, $GUI_DISABLE)
For $i = 0 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackHoursE1, $GUI_DISABLE)
GUICtrlSetState($g_ahChkAttackHoursE2, $GUI_DISABLE)
Else
GUICtrlSetState($g_hCmbAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($g_hLbAttackPlannerRandom, $GUI_DISABLE)
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_ENABLE)
Next
GUICtrlSetState($g_ahChkAttackWeekdaysE, $GUI_ENABLE)
For $i = 0 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_ENABLE)
Next
GUICtrlSetState($g_ahChkAttackHoursE1, $GUI_ENABLE)
GUICtrlSetState($g_ahChkAttackHoursE2, $GUI_ENABLE)
EndIf
Else
$g_bAttackPlannerEnable = False
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, $GUI_DISABLE)
GUICtrlSetState($g_hChkAttackPlannerSuspendComputer, $GUI_DISABLE)
GUICtrlSetState($g_hChkAttackPlannerCloseAll, $GUI_DISABLE)
GUICtrlSetState($g_hChkAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($g_hCmbAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($g_hLbAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($g_hChkAttackPlannerDayLimit, $GUI_DISABLE)
GUICtrlSetState($g_hCmbAttackPlannerDayMin, $GUI_DISABLE)
GUICtrlSetState($g_hCmbAttackPlannerDayMax, $GUI_DISABLE)
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackWeekdaysE, $GUI_DISABLE)
For $i = 0 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackHoursE2, $GUI_DISABLE)
EndIf
EndFunc
Func chkAttackPlannerCloseCoC()
If GUICtrlRead($g_hChkAttackPlannerCloseCoC) = $GUI_CHECKED Then
$g_bAttackPlannerCloseCoC = True
Else
$g_bAttackPlannerCloseCoC = False
EndIf
EndFunc
Func chkAttackPlannerSuspendComputer()
If GUICtrlRead($g_hChkAttackPlannerSuspendComputer) = $GUI_CHECKED Then
$g_bAttackPlannerSuspendComputer = True
Else
$g_bAttackPlannerSuspendComputer = False
EndIf
EndFunc
Func chkAttackPlannerCloseAll()
If GUICtrlRead($g_hChkAttackPlannerCloseAll) = $GUI_CHECKED Then
$g_bAttackPlannerCloseAll = True
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
Else
$g_bAttackPlannerCloseAll = False
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, $GUI_ENABLE)
EndIf
EndFunc
Func chkAttackPlannerRandom()
If GUICtrlRead($g_hChkAttackPlannerRandom) = $GUI_CHECKED Then
$g_bAttackPlannerRandomEnable = True
GUICtrlSetState($g_hCmbAttackPlannerRandom, $GUI_ENABLE)
GUICtrlSetState($g_hLbAttackPlannerRandom, $GUI_ENABLE)
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackWeekdaysE, $GUI_DISABLE)
For $i = 0 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackHoursE1, $GUI_DISABLE)
GUICtrlSetState($g_ahChkAttackHoursE2, $GUI_DISABLE)
Else
$g_bAttackPlannerRandomEnable = False
chkAttackPlannerEnable()
EndIf
EndFunc
Func cmbAttackPlannerRandom()
$g_iAttackPlannerRandomTime = Int(_GUICtrlComboBox_GetCurSel($g_hCmbAttackPlannerRandom))
GUICtrlSetData($g_hLbAttackPlannerRandom, $g_iAttackPlannerRandomTime > 0 ? GetTranslatedFileIni("MBR Global GUI Design", "hrs", -1) : GetTranslatedFileIni("MBR Global GUI Design", "hr", -1))
EndFunc
Func chkAttackPlannerDayLimit()
If GUICtrlRead($g_hChkAttackPlannerDayLimit) = $GUI_CHECKED Then
$g_bAttackPlannerDayLimit = True
GUICtrlSetState($g_hCmbAttackPlannerDayMin, $GUI_ENABLE)
GUICtrlSetState($g_hLbAttackPlannerDayLimit, $GUI_ENABLE)
GUICtrlSetState($g_hCmbAttackPlannerDayMax, $GUI_ENABLE)
Else
$g_bAttackPlannerDayLimit = False
GUICtrlSetState($g_hCmbAttackPlannerDayMin, $GUI_DISABLE)
GUICtrlSetState($g_hLbAttackPlannerDayLimit, $GUI_DISABLE)
GUICtrlSetState($g_hCmbAttackPlannerDayMax, $GUI_DISABLE)
EndIf
_cmbAttackPlannerDayLimit()
EndFunc
Func cmbAttackPlannerDayMin()
If Int(GUICtrlRead($g_hCmbAttackPlannerDayMax)) < Int(GUICtrlRead($g_hCmbAttackPlannerDayMin)) Then
GUICtrlSetData($g_hCmbAttackPlannerDayMin, GUICtrlRead($g_hCmbAttackPlannerDayMax))
EndIf
$g_iAttackPlannerDayMin = Int(GUICtrlRead($g_hCmbAttackPlannerDayMin))
_cmbAttackPlannerDayLimit()
EndFunc
Func cmbAttackPlannerDayMax()
If Int(GUICtrlRead($g_hCmbAttackPlannerDayMax)) < Int(GUICtrlRead($g_hCmbAttackPlannerDayMin)) Then
GUICtrlSetData($g_hCmbAttackPlannerDayMax, GUICtrlRead($g_hCmbAttackPlannerDayMin))
EndIf
$g_iAttackPlannerDayMax = Int(GUICtrlRead($g_hCmbAttackPlannerDayMax))
_cmbAttackPlannerDayLimit()
EndFunc
Func _cmbAttackPlannerDayLimit()
Switch Int(GUICtrlRead($g_hCmbAttackPlannerDayMin))
Case 0 To 15
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMin, $COLOR_MONEYGREEN)
Case 16 To 20
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMin, $COLOR_YELLOW)
Case 21 To 999
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMin, $COLOR_RED)
EndSwitch
Switch Int(GUICtrlRead($g_hCmbAttackPlannerDayMax))
Case 0 To 15
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMax, $COLOR_MONEYGREEN)
Case 16 To 25
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMax, $COLOR_YELLOW)
Case 26 To 999
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMax, $COLOR_RED)
EndSwitch
EndFunc
Func chkDropCCHoursEnable()
Local $bChk = GUICtrlRead($g_hChkDropCCHoursEnable) = $GUI_CHECKED
$g_bPlannedDropCCHoursEnable =($bChk ? 1 : 0)
For $i = 0 To 23
GUICtrlSetState($g_ahChkDropCCHours[$i], $bChk ? $GUI_ENABLE : $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkDropCCHoursE1, $bChk ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahChkDropCCHoursE2, $bChk ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkDropCCHoursE1()
Local $bChk = GUICtrlRead($g_ahChkDropCCHoursE1) = $GUI_CHECKED And GUICtrlRead($g_ahChkDropCCHours[0]) = $GUI_CHECKED
For $i = 0 To 11
GUICtrlSetState($g_ahChkDropCCHours[$i], $bChk ? $GUI_UNCHECKED : $GUI_CHECKED)
Next
Sleep(300)
GUICtrlSetState($g_ahChkDropCCHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkDropCCHoursE2()
Local $bChk = GUICtrlRead($g_ahChkDropCCHoursE2) = $GUI_CHECKED And GUICtrlRead($g_ahChkDropCCHours[12]) = $GUI_CHECKED
For $i = 12 To 23
GUICtrlSetState($g_ahChkDropCCHours[$i], $bChk ? $GUI_UNCHECKED : $GUI_CHECKED)
Next
Sleep(300)
GUICtrlSetState($g_ahChkDropCCHoursE2, $GUI_UNCHECKED)
EndFunc
Func chkShareAttack()
If GUICtrlRead($g_hChkShareAttack) = $GUI_CHECKED Then
For $i = $g_hLblShareMinLoot To $g_hTxtShareMessage
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $g_hLblShareMinLoot To $g_hTxtShareMessage
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkSearchReduction()
If GUICtrlRead($g_hChkSearchReduction) = $GUI_CHECKED Then
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceCount, False)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceGold, False)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceElixir, False)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceGoldPlusElixir, False)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceDark, False)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceTrophy, False)
Else
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceCount, True)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceGold, True)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceGoldPlusElixir, True)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceElixir, True)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceDark, True)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceTrophy, True)
EndIf
EndFunc
Func sldMaxVSDelay()
$g_iSearchDelayMax = GUICtrlRead($g_hSldMaxVSDelay)
GUICtrlSetData($g_hLblMaxVSDelay, $g_iSearchDelayMax)
If $g_iSearchDelayMax < $g_iSearchDelayMin Then
GUICtrlSetData($g_hLblVSDelay, $g_iSearchDelayMax)
GUICtrlSetData($g_hSldVSDelay, $g_iSearchDelayMax)
$g_iSearchDelayMin = $g_iSearchDelayMax
EndIf
If $g_iSearchDelayMin = 1 Then
GUICtrlSetData($g_hLblTextVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "second", "second"))
Else
GUICtrlSetData($g_hLblTextVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "seconds", "seconds"))
EndIf
If $g_iSearchDelayMax = 1 Then
GUICtrlSetData($g_hLblTextMaxVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "second", "second"))
Else
GUICtrlSetData($g_hLblTextMaxVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "seconds", "seconds"))
EndIf
EndFunc
Func sldVSDelay()
$g_iSearchDelayMin = GUICtrlRead($g_hSldVSDelay)
GUICtrlSetData($g_hLblVSDelay, $g_iSearchDelayMin)
If $g_iSearchDelayMin > $g_iSearchDelayMax Then
GUICtrlSetData($g_hLblMaxVSDelay, $g_iSearchDelayMin)
GUICtrlSetData($g_hSldMaxVSDelay, $g_iSearchDelayMin)
$g_iSearchDelayMax = $g_iSearchDelayMin
EndIf
If $g_iSearchDelayMin = 1 Then
GUICtrlSetData($g_hLblTextVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "second", "second"))
Else
GUICtrlSetData($g_hLblTextVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "seconds", "seconds"))
EndIf
If $g_iSearchDelayMax = 1 Then
GUICtrlSetData($g_hLblTextMaxVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "second", "second"))
Else
GUICtrlSetData($g_hLblTextMaxVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "seconds", "seconds"))
EndIf
EndFunc
Func dbCheck()
$g_abAttackTypeEnable[$DB] =(GUICtrlRead($g_hChkDeadbase) = $GUI_CHECKED)
If IsBotLaunched() Then _GUICtrlTab_SetCurFocus($g_hGUI_SEARCH_TAB, 0)
If BitAND(GUICtrlRead($g_hChkDBActivateSearches), GUICtrlRead($g_hChkDBActivateTropies), GUICtrlRead($g_hChkDBActivateCamps), GUICtrlRead($g_hChkDBSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkDBActivateSearches, $GUI_CHECKED)
chkDBActivateSearches()
Else
tabSEARCH()
EndIf
EndFunc
Func abCheck()
$g_abAttackTypeEnable[$LB] =(GUICtrlRead($g_hChkActivebase) = $GUI_CHECKED)
If IsBotLaunched() Then _GUICtrlTab_SetCurFocus($g_hGUI_SEARCH_TAB, 1)
If BitAND(GUICtrlRead($g_hChkABActivateSearches), GUICtrlRead($g_hChkABActivateTropies), GUICtrlRead($g_hChkABActivateCamps), GUICtrlRead($g_hChkABSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkABActivateSearches, $GUI_CHECKED)
chkABActivateSearches()
Else
tabSEARCH()
EndIf
EndFunc
Func tsCheck()
$g_abAttackTypeEnable[$TS] =(GUICtrlRead($g_hChkTHSnipe) = $GUI_CHECKED)
If IsBotLaunched() Then _GUICtrlTab_SetCurFocus($g_hGUI_SEARCH_TAB, 2)
If BitAND(GUICtrlRead($g_hChkTSActivateSearches), GUICtrlRead($g_hChkTSActivateTropies), GUICtrlRead($g_hChkTSActivateCamps)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkTSActivateSearches, $GUI_CHECKED)
chkTSActivateSearches()
Else
tabSEARCH()
EndIf
EndFunc
Func bullyCheck()
$g_abAttackTypeEnable[$TB] =(GUICtrlRead($g_hChkBully) = $GUI_CHECKED)
If IsBotLaunched() Then _GUICtrlTab_SetCurFocus($g_hGUI_SEARCH_TAB, 3)
tabSEARCH()
EndFunc
Func CustomDropOrder()
GUICtrlSetState($g_hBtnCustomDropOrderDB, $GUI_DISABLE)
GUICtrlSetState($g_hBtnCustomDropOrderAB, $GUI_DISABLE)
GUISetState(@SW_SHOW, $g_hGUI_DropOrder)
EndFunc
Func CloseCustomDropOrder()
GUISetState(@SW_HIDE, $g_hGUI_DropOrder)
GUICtrlSetState($g_hBtnCustomDropOrderDB, $GUI_ENABLE)
GUICtrlSetState($g_hBtnCustomDropOrderAB, $GUI_ENABLE)
EndFunc
Func chkDropOrder()
If GUICtrlRead($g_hChkCustomDropOrderEnable) = $GUI_CHECKED Then
$g_bCustomDropOrderEnable = True
GUICtrlSetBkColor($g_hBtnCustomDropOrderDB, $COLOR_GREEN)
GUICtrlSetBkColor($g_hBtnCustomDropOrderAB, $COLOR_GREEN)
GUICtrlSetState($g_hBtnDropOrderSet, $GUI_ENABLE)
GUICtrlSetState($g_hBtnRemoveDropOrder, $GUI_ENABLE)
For $i = 0 To UBound($g_ahCmbDropOrder) - 1
GUICtrlSetState($g_ahCmbDropOrder[$i], $GUI_ENABLE)
Next
If IsUseCustomDropOrder() = True Then _GUICtrlSetImage($g_ahImgDropOrderSet, $g_sLibIconPath, $eIcnRedLight)
Else
$g_bCustomDropOrderEnable = False
GUICtrlSetBkColor($g_hBtnCustomDropOrderDB, $COLOR_RED)
GUICtrlSetBkColor($g_hBtnCustomDropOrderAB, $COLOR_RED)
GUICtrlSetState($g_hBtnDropOrderSet, $GUI_DISABLE)
GUICtrlSetState($g_hBtnRemoveDropOrder, $GUI_DISABLE)
For $i = 0 To UBound($g_ahCmbDropOrder) - 1
GUICtrlSetState($g_ahCmbDropOrder[$i], $GUI_DISABLE)
Next
SetDefaultDropOrderGroup(False)
EndIf
EndFunc
Func GUIDropOrder()
Local $bDuplicate = False
Local $iGUI_CtrlId = @GUI_CtrlId
Local $iCtrlIdImage = $iGUI_CtrlId + 1
Local $iDropIndex = _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) + 1
_GUICtrlSetImage($iCtrlIdImage, $g_sLibIconPath, $g_aiDropOrderIcon[$iDropIndex])
For $i = 0 To UBound($g_ahCmbDropOrder) - 1
If $iGUI_CtrlId = $g_ahCmbDropOrder[$i] Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) = _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$i]) Then
_GUICtrlSetImage($g_ahImgDropOrder[$i], $g_sLibIconPath, $eIcnOptions)
_GUICtrlComboBox_SetCurSel($g_ahCmbDropOrder[$i], -1)
GUISetState()
$bDuplicate = True
EndIf
Next
If $bDuplicate Then
GUICtrlSetState($g_hBtnDropOrderSet, $GUI_ENABLE)
Return
Else
GUICtrlSetState($g_hBtnDropOrderSet, $GUI_ENABLE)
_GUICtrlSetImage($g_ahImgDropOrderSet, $g_sLibIconPath, $eIcnRedLight)
EndIf
EndFunc
Func BtnRemoveDropOrder()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "BtnRemoveDropOrder")
Local $sComboData = ""
For $j = 0 To UBound($g_asDropOrderList) - 1
$sComboData &= $g_asDropOrderList[$j] & "|"
Next
For $i = 0 To $eDropOrderCount - 1
$g_aiCmbCustomDropOrder[$i] = -1
_GUICtrlComboBox_ResetContent($g_aiCmbCustomDropOrder[$i])
GUICtrlSetData($g_ahCmbDropOrder[$i], $sComboData, "")
_GUICtrlSetImage($g_ahImgDropOrder[$i], $g_sLibIconPath, $eIcnOptions)
Next
_GUICtrlSetImage($g_ahImgDropOrderSet, $g_sLibIconPath, $eIcnSilverStar)
SetDefaultDropOrderGroup(False)
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "BtnRemoveDropOrder")
EndFunc
Func BtnDropOrderSet()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "BtnDropOrderSet")
Local $bReady = True
Local $sNewDropList = ""
Local $bMissingDrop = False
Local $aiDropOrder[$eDropOrderCount] = [ $eTroopBarbarianS, $eTroopArcherS, $eTroopGiantS, $eTroopGoblinS, $eTroopWallBreakerS, $eTroopBalloonS, $eTroopWizardS, $eTroopHealerS, $eTroopDragonS, $eTroopPekkaS, $eTroopBabyDragonS, $eTroopMinerS, $eTroopElectroDragonS, $eTroopMinionS, $eTroopHogRiderS, $eTroopValkyrieS, $eTroopGolemS, $eTroopWitchS, $eTroopLavaHoundS, $eTroopBowlerS, $eHeroeS, $eCCS]
For $i = 0 To UBound($g_ahCmbDropOrder) - 1
For $j = 0 To UBound($g_ahCmbDropOrder) - 1
If $i = $j Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$i]) <> -1 And  _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$i]) = _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$j]) Then
_GUICtrlComboBox_SetCurSel($g_ahCmbDropOrder[$j], -1)
_GUICtrlSetImage($g_ahImgDropOrder[$j], $g_sLibIconPath, $eIcnOptions)
$bReady = False
Else
GUICtrlSetColor($g_ahCmbDropOrder[$j], $COLOR_BLACK)
EndIf
Next
$g_aiCmbCustomDropOrder[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$i])
If $g_aiCmbCustomDropOrder[$i] = -1 Then $bMissingDrop = True
Next
If $bReady And $bMissingDrop Then
For $i = 0 To UBound($g_aiCmbCustomDropOrder) - 1
For $j = 0 To UBound($aiDropOrder) - 1
If $g_aiCmbCustomDropOrder[$i] = $j Then
$aiDropOrder[$j] = -1
ExitLoop
EndIf
Next
Next
_ArrayShuffle($aiDropOrder)
For $i = 0 To UBound($g_aiCmbCustomDropOrder) - 1
If $g_aiCmbCustomDropOrder[$i] = -1 Then
For $j = 0 To UBound($aiDropOrder) - 1
If $aiDropOrder[$j] <> -1 Then
$g_aiCmbCustomDropOrder[$i] = $aiDropOrder[$j]
_GUICtrlComboBox_SetCurSel($g_ahCmbDropOrder[$i], $aiDropOrder[$j])
_GUICtrlSetImage($g_ahImgDropOrder[$i], $g_sLibIconPath, $g_aiDropOrderIcon[$g_aiCmbCustomDropOrder[$i] + 1])
$aiDropOrder[$j] = -1
ExitLoop
EndIf
Next
EndIf
Next
EndIf
If $bReady Then
ChangeDropOrder()
If @error Then
Switch @error
Case 1
SetLog("Code problem, can not continue till fixed!", $COLOR_ERROR)
Case 2
SetLog("Bad Combobox selections, please fix!", $COLOR_ERROR)
Case 3
SetLog("Unable to Change Troop Drop Order due bad change count!", $COLOR_ERROR)
Case Else
SetLog("Monkey ate bad banana, something wrong with ChangeTroopDropOrder() code!", $COLOR_ERROR)
EndSwitch
_GUICtrlSetImage($g_ahImgDropOrderSet, $g_sLibIconPath, $eIcnRedLight)
Else
SetLog("Troop droping order changed successfully!", $COLOR_SUCCESS)
For $i = 0 To $eDropOrderCount - 1
$sNewDropList &= $g_asDropOrderNames[$g_aiCmbCustomDropOrder[$i]] & ", "
Next
$sNewDropList = StringTrimRight($sNewDropList, 2)
SetLog("Troops Dropping Order= " & $sNewDropList, $COLOR_INFO)
EndIf
Else
SetLog("Must use all troops and No duplicate troop names!", $COLOR_ERROR)
_GUICtrlSetImage($g_ahImgDropOrderSet, $g_sLibIconPath, $eIcnRedLight)
EndIf
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "BtnDropOrderSet")
EndFunc
Func IsUseCustomDropOrder()
For $i = 0 To UBound($g_aiCmbCustomDropOrder) - 1
If $g_aiCmbCustomDropOrder[$i] = -1 Then
Return False
EndIf
Next
Return True
EndFunc
Func ChangeDropOrder()
If $g_bDebugSetlog Then SetDebugLog("Begin Func ChangeDropOrder()", $COLOR_DEBUG)
Local $NewDropOrder[$eDropOrderCount]
Local $iUpdateCount = 0
If Not IsUseCustomDropOrder() Then
SetError(2, 0, False)
Return
EndIf
For $i = 0 To UBound($g_ahCmbDropOrder) - 1
Local $sComboText = GUICtrlRead($g_ahCmbDropOrder[$i])
For $j = 0 To UBound($g_asDropOrderList) - 1
If $sComboText = $g_asDropOrderList[$j] Then
$NewDropOrder[$i] = $j - 1
$iUpdateCount += 1
ExitLoop
EndIf
Next
Next
If $iUpdateCount = $eDropOrderCount Then
For $i = 0 To $eDropOrderCount - 1
$g_aiCmbCustomDropOrder[$i] = $NewDropOrder[$i]
Next
_GUICtrlSetImage($g_ahImgDropOrderSet, $g_sLibIconPath, $eIcnGreenLight)
Else
SetLog($iUpdateCount & "|" & $eDropOrderCount & " - Error - Bad troop assignment in ChangeTroopDropOrder()", $COLOR_ERROR)
Return
EndIf
Return True
EndFunc
Func SetDefaultDropOrderGroup($bSetLog = True)
For $i = 0 To $eDropOrderCount - 1
$g_aiDropOrder[$i] = $i
Next
If $bSetLog And $g_bCustomDropOrderEnable Then SetLog("Default drop order set", $COLOR_SUCCESS)
EndFunc
Func chkStopAtkDBNoLoot1()
If GUICtrlRead($g_hChkStopAtkDBNoLoot1) = $GUI_CHECKED Then
$g_abStopAtkNoLoot1Enable[$DB] = True
GUICtrlSetState($g_hTxtStopAtkDBNoLoot1, $GUI_ENABLE)
GUICtrlSetState($g_hLblStopAtkDBNoLoot1b, $GUI_ENABLE)
Else
$g_abStopAtkNoLoot1Enable[$DB] = False
GUICtrlSetState($g_hTxtStopAtkDBNoLoot1, $GUI_DISABLE)
GUICtrlSetState($g_hLblStopAtkDBNoLoot1b, $GUI_DISABLE)
EndIf
EndFunc
Func chkStopAtkDBNoLoot2()
If GUICtrlRead($g_hChkStopAtkDBNoLoot2) = $GUI_CHECKED Then
$g_abStopAtkNoLoot2Enable[$DB] = True
GUICtrlSetState($g_hTxtStopAtkDBNoLoot2, $GUI_ENABLE)
GUICtrlSetState($g_hLblStopAtkDBNoLoot2b, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBMinGoldStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBMinElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBMinDarkElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hLblDBMinRerourcesAtk2, $GUI_ENABLE)
Else
$g_abStopAtkNoLoot2Enable[$DB] = False
GUICtrlSetState($g_hTxtStopAtkDBNoLoot2, $GUI_DISABLE)
GUICtrlSetState($g_hLblStopAtkDBNoLoot2b, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBMinGoldStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBMinElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBMinDarkElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hLblDBMinRerourcesAtk2, $GUI_DISABLE)
EndIf
EndFunc
Func chkStopAtkABNoLoot1()
If GUICtrlRead($g_hChkStopAtkABNoLoot1) = $GUI_CHECKED Then
$g_abStopAtkNoLoot1Enable[$LB] = True
GUICtrlSetState($g_hTxtStopAtkABNoLoot1, $GUI_ENABLE)
GUICtrlSetState($g_hLblABTimeStopAtk, $GUI_ENABLE)
Else
$g_abStopAtkNoLoot1Enable[$LB] = False
GUICtrlSetState($g_hTxtStopAtkABNoLoot1, $GUI_DISABLE)
GUICtrlSetState($g_hLblABTimeStopAtk, $GUI_DISABLE)
EndIf
EndFunc
Func chkStopAtkABNoLoot2()
If GUICtrlRead($g_hChkStopAtkABNoLoot2) = $GUI_CHECKED Then
$g_abStopAtkNoLoot2Enable[$LB] = True
GUICtrlSetState($g_hTxtStopAtkABNoLoot2, $GUI_ENABLE)
GUICtrlSetState($g_hLblABTimeStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABMinGoldStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABMinElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABMinDarkElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hLblABMinRerourcesAtk2, $GUI_ENABLE)
Else
$g_abStopAtkNoLoot2Enable[$LB] = False
GUICtrlSetState($g_hTxtStopAtkABNoLoot2, $GUI_DISABLE)
GUICtrlSetState($g_hLblABTimeStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABMinGoldStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABMinElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABMinDarkElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hLblABMinRerourcesAtk2, $GUI_DISABLE)
EndIf
EndFunc
Func chkDBEndPercentHigher()
If GUICtrlRead($g_hChkDBEndPercentHigher) = $GUI_CHECKED Then
$g_abStopAtkPctHigherEnable[$DB] = True
GUICtrlSetState($g_hTxtDBPercentHigher, $GUI_ENABLE)
GUICtrlSetState($g_hLblDBPercentHigherSec, $GUI_ENABLE)
Else
$g_abStopAtkPctHigherEnable[$DB] = False
GUICtrlSetState($g_hTxtDBPercentHigher, $GUI_DISABLE)
GUICtrlSetState($g_hLblDBPercentHigherSec, $GUI_DISABLE)
EndIf
EndFunc
Func chkDBEndPercentChange()
If GUICtrlRead($g_hChkDBEndPercentChange) = $GUI_CHECKED Then
$g_abStopAtkPctNoChangeEnable[$DB] = True
GUICtrlSetState($g_hTxtDBPercentChange, $GUI_ENABLE)
GUICtrlSetState($g_hLblDBPercentChangeSec, $GUI_ENABLE)
Else
$g_abStopAtkPctNoChangeEnable[$DB] = False
GUICtrlSetState($g_hTxtDBPercentChange, $GUI_DISABLE)
GUICtrlSetState($g_hLblDBPercentChangeSec, $GUI_DISABLE)
EndIf
EndFunc
Func chkABEndPercentHigher()
If GUICtrlRead($g_hChkABEndPercentHigher) = $GUI_CHECKED Then
$g_abStopAtkPctHigherEnable[$LB] = True
GUICtrlSetState($g_hTxtABPercentHigher, $GUI_ENABLE)
GUICtrlSetState($g_hLblABPercentHigherSec, $GUI_ENABLE)
Else
$g_abStopAtkPctHigherEnable[$LB] = False
GUICtrlSetState($g_hTxtABPercentHigher, $GUI_DISABLE)
GUICtrlSetState($g_hLblABPercentHigherSec, $GUI_DISABLE)
EndIf
EndFunc
Func chkABEndPercentChange()
If GUICtrlRead($g_hChkABEndPercentChange) = $GUI_CHECKED Then
$g_abStopAtkPctNoChangeEnable[$LB] = True
GUICtrlSetState($g_hTxtABPercentChange, $GUI_ENABLE)
GUICtrlSetState($g_hLblABPercentChangeSec, $GUI_ENABLE)
Else
$g_abStopAtkPctNoChangeEnable[$LB] = False
GUICtrlSetState($g_hTxtABPercentChange, $GUI_DISABLE)
GUICtrlSetState($g_hLblABPercentChangeSec, $GUI_DISABLE)
EndIf
EndFunc
Func chkDESideEB()
If GUICtrlRead($g_hChkDESideEB) = $GUI_CHECKED Then
For $i = $g_hTxtDELowEndMin To $g_hLblDEEndAq
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $g_hTxtDELowEndMin To $g_hLblDEEndAq
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkTSMeetDE()
_GUICtrlEdit_SetReadOnly($g_hTxtTSMinDarkElixir, GUICtrlRead($g_hChkTSMeetDE) = $GUI_CHECKED ? False : True)
EndFunc
Func btnConfigureReplayShare()
EndFunc
Func chkTakeLootSS()
GUICtrlSetState($g_hChkScreenshotLootInfo, GUICtrlRead($g_hChkTakeLootSS) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkTSActivateCamps2()
If GUICtrlRead($g_hChkTSActivateCamps2) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblTSArmyCamps2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTSArmyCamps2, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblTSArmyCamps2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTSArmyCamps2, $GUI_DISABLE)
EndIf
EndFunc
Func chkSmartLightSpell()
If GUICtrlRead($g_hChkSmartLightSpell) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkSmartZapDB, $GUI_ENABLE)
GUICtrlSetState($g_hChkSmartZapSaveHeroes, $GUI_ENABLE)
GUICtrlSetState($g_hChkSmartZapFTW, $GUI_ENABLE)
GUICtrlSetState($g_hChkNoobZap, $GUI_ENABLE)
GUICtrlSetState($g_hChkSmartEQSpell, $GUI_ENABLE)
GUICtrlSetState($g_hLblSmartUseLSpell, $GUI_SHOW)
If GUICtrlRead($g_hChkNoobZap) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtSmartZapMinDE, $GUI_ENABLE)
GUICtrlSetState($g_hTxtSmartExpectedDE, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtSmartZapMinDE, $GUI_DISABLE)
GUICtrlSetState($g_hTxtSmartExpectedDE, $GUI_DISABLE)
EndIf
$g_bSmartZapEnable = True
Else
GUICtrlSetState($g_hChkSmartZapDB, $GUI_DISABLE)
GUICtrlSetState($g_hChkSmartZapSaveHeroes, $GUI_DISABLE)
GUICtrlSetState($g_hChkSmartZapFTW, $GUI_DISABLE)
GUICtrlSetState($g_hTxtSmartZapMinDE, $GUI_DISABLE)
GUICtrlSetState($g_hChkNoobZap, $GUI_DISABLE)
GUICtrlSetState($g_hChkSmartEQSpell, $GUI_DISABLE)
GUICtrlSetState($g_hLblSmartUseLSpell, $GUI_HIDE)
GUICtrlSetState($g_hTxtSmartExpectedDE, $GUI_DISABLE)
$g_bSmartZapEnable = False
EndIf
EndFunc
Func chkNoobZap()
If GUICtrlRead($g_hChkNoobZap) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtSmartZapMinDE, $GUI_ENABLE)
GUICtrlSetState($g_hTxtSmartExpectedDE, $GUI_ENABLE)
$g_bNoobZap = True
Else
GUICtrlSetState($g_hTxtSmartZapMinDE, $GUI_DISABLE)
GUICtrlSetState($g_hTxtSmartExpectedDE, $GUI_DISABLE)
$g_bNoobZap = False
EndIf
EndFunc
Func chkEarthQuakeZap()
If GUICtrlRead($g_hChkSmartEQSpell) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblSmartUseEQSpell, $GUI_SHOW)
$g_bEarthQuakeZap = True
Else
GUICtrlSetState($g_hLblSmartUseEQSpell, $GUI_HIDE)
$g_bEarthQuakeZap = False
EndIf
EndFunc
Func chkSmartZapDB()
$g_bSmartZapDB =(GUICtrlRead($g_hChkSmartZapDB) = $GUI_CHECKED)
EndFunc
Func chkSmartZapFTW()
$g_bSmartZapFTW =(GUICtrlRead($g_hChkSmartZapFTW) = $GUI_CHECKED)
EndFunc
Func chkSmartZapSaveHeroes()
$g_bSmartZapSaveHeroes =(GUICtrlRead($g_hChkSmartZapSaveHeroes) = $GUI_CHECKED)
EndFunc
Func txtMinDark()
$g_iSmartZapMinDE = GUICtrlRead($g_hTxtSmartZapMinDE)
EndFunc
Func txtExpectedDE()
$g_iSmartZapExpectedDE = GUICtrlRead($g_hTxtSmartExpectedDE)
EndFunc
Func btnLoots()
Run("Explorer.exe " & $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Loots")
EndFunc
Func btnLogs()
Run("Explorer.exe " & $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Logs")
EndFunc
Func btnResetStats()
ResetStats()
EndFunc
Func UpdateMultiStats()
Local $bEnableSwitchAcc = $g_iCmbSwitchAcc > 0
Local $iCmbTotalAcc = _GUICtrlComboBox_GetCurSel($g_hCmbTotalAccount) + 1
For $i = 0 To 7
If $bEnableSwitchAcc And $i <= $iCmbTotalAcc Then
For $j = $g_ahGrpVillageAcc[$i] To $g_ahLblHourlyStatsTrophyAcc[$i]
GUICtrlSetState($j, $GUI_SHOW)
Next
If GUICtrlRead($g_ahChkAccount[$i]) = $GUI_CHECKED Then
If GUICtrlRead($g_ahChkDonate[$i]) = $GUI_UNCHECKED Then
GUICtrlSetData($g_ahGrpVillageAcc[$i], GUICtrlRead($g_ahCmbProfile[$i]) & " (Active)")
Else
GUICtrlSetData($g_ahGrpVillageAcc[$i], GUICtrlRead($g_ahCmbProfile[$i]) & " (Donate)")
EndIf
Else
GUICtrlSetData($g_ahGrpVillageAcc[$i], GUICtrlRead($g_ahCmbProfile[$i]) & " (Idle)")
EndIf
Else
For $j = $g_ahGrpVillageAcc[$i] To $g_ahLblHourlyStatsTrophyAcc[$i]
GUICtrlSetState($j, $GUI_HIDE)
Next
EndIf
Next
EndFunc
Func checkCollectors($log = False, $showLabel = True)
Local $anyCollectorsEnabled = 0
For $i = 6 To 12
If $g_abCollectorLevelEnabled[$i] Then
$anyCollectorsEnabled = 1
ExitLoop
EndIf
Next
If $anyCollectorsEnabled = 0 Then
If $showLabel Then GUICtrlSetState($g_hLblCollectorWarning, $GUI_SHOW)
If $log Then
SetLog("Warning: Dead base is enabled, but no collectors are selected!", $COLOR_ERROR)
SetLog("Dead base will never be found!", $COLOR_ERROR)
SetLog("Select some in Attack Plan-Search&Attack-DeadBase-Collectors", $COLOR_ERROR)
Return False
EndIf
ElseIf $anyCollectorsEnabled = 1 Then
If $showLabel Then GUICtrlSetState($g_hLblCollectorWarning, $GUI_HIDE)
Return True
EndIf
Return False
EndFunc
Func chkDBCollector()
For $i = 6 To 12
If $g_ahChkDBCollectorLevel[$i] = @GUI_CtrlId Then
If $i = 6 Then
$g_abCollectorLevelEnabled[6] = False
GUICtrlSetState($g_ahCmbDBCollectorLevel[6], $GUI_DISABLE)
Else
$g_abCollectorLevelEnabled[$i] =(GUICtrlRead($g_ahChkDBCollectorLevel[$i]) = $GUI_CHECKED ? True : False)
GUICtrlSetState($g_ahCmbDBCollectorLevel[$i], GUICtrlRead($g_ahChkDBCollectorLevel[$i]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndIf
ExitLoop
EndIf
Next
checkCollectors()
EndFunc
Func cmbDBCollector()
For $i = 6 To 12
If $g_ahCmbDBCollectorLevel[$i] = @GUI_CtrlId Then
$g_aiCollectorLevelFill[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbDBCollectorLevel[$i])
ExitLoop
EndIf
Next
EndFunc
Func sldCollectorTolerance()
$g_iCollectorToleranceOffset = GUICtrlRead($g_hSldCollectorTolerance)
EndFunc
Func cmbMinCollectorMatches()
$g_iCollectorMatchesMin = _GUICtrlComboBox_GetCurSel($g_hCmbMinCollectorMatches) + 1
EndFunc
Func chkAtkGoldMines()
If GUICtrlRead($g_hChkAtkGoldMines) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbAtkGoldMinesLevel, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbAtkGoldMinesLevel, $GUI_DISABLE)
EndIf
EndFunc
Func chkAtkDarkDrills()
If GUICtrlRead($g_hChkAtkDarkDrills) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbAtkDarkDrillsLevel, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbAtkDarkDrillsLevel, $GUI_DISABLE)
EndIf
EndFunc
Func chkAttackMinesifGold()
If GUICtrlRead($g_hChkAttackMinesIfGold) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtAttackMinesIfGold, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtAttackMinesIfGold, $GUI_DISABLE)
EndIf
EndFunc
Func chkAttackMinesifelixir()
If GUICtrlRead($g_hChkAttackMinesIfElixir) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtAttackMinesIfElixir, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtAttackMinesIfElixir, $GUI_DISABLE)
EndIf
EndFunc
Func chkAttackMinesifdarkElixir()
If GUICtrlRead($g_hChkAttackMinesIfDarkElixir) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtAttackMinesIfDarkElixir, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtAttackMinesIfDarkElixir, $GUI_DISABLE)
EndIf
EndFunc
Func chkMilkFarmForcetolerance()
If GUICtrlRead($g_hChkMilkFarmForceTolerance) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtMilkFarmForceToleranceNormal, $GUI_ENABLE)
GUICtrlSetState($g_hTxtMilkFarmForceToleranceBoosted, $GUI_ENABLE)
GUICtrlSetState($g_hTxtMilkFarmForceToleranceDestroyed, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtMilkFarmForceToleranceNormal, $GUI_DISABLE)
GUICtrlSetState($g_hTxtMilkFarmForceToleranceBoosted, $GUI_DISABLE)
GUICtrlSetState($g_hTxtMilkFarmForceToleranceDestroyed, $GUI_DISABLE)
EndIf
EndFunc
Func chkMilkAfterAttackTHSnipe()
If GUICtrlRead($g_hChkMilkAfterAttackTHSnipe) = $GUI_CHECKED Then
For $i = $g_hGrpSnipeOutsideTHAtEnd To $g_hGrpDeploy - 1
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $g_hGrpSnipeOutsideTHAtEnd To $g_hGrpDeploy - 1
If $i <> $g_hChkMilkAfterAttackTHSnipe Then GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func PopulateComboMilkingCSVScriptsFiles()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sCSVAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbMilkingCSVScriptName)
GUICtrlSetData($g_hCmbMilkingCSVScriptName, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbMilkingCSVScriptName, _GUICtrlComboBox_FindStringExact($g_hCmbMilkingCSVScriptName, ""))
GUICtrlSetData($g_hLblMilkingCSVNotesScript, "")
EndFunc
Func PopulateCmbMilkSnipeAlgorithm()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sTHSnipeAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbMilkSnipeAlgorithm)
GUICtrlSetData($g_hCmbMilkSnipeAlgorithm, $output)
EndFunc
Func chkRandomSpeedAtkAB()
If GUICtrlRead($g_hChkRandomSpeedAtkAB) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbStandardUnitDelayAB, $GUI_DISABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayAB, $GUI_DISABLE)
Else
GUICtrlSetState($g_hCmbStandardUnitDelayAB, $GUI_ENABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayAB, $GUI_ENABLE)
EndIf
EndFunc
Func chkSmartAttackRedAreaAB()
If GUICtrlRead($g_hChkSmartAttackRedAreaAB) = $GUI_CHECKED Then
$g_abAttackStdSmartAttack[$LB] = 1
For $i = $g_hLblSmartDeployAB To $g_hPicAttackNearDarkElixirDrillAB
GUICtrlSetState($i, $GUI_SHOW)
Next
Else
$g_abAttackStdSmartAttack[$LB] = 0
For $i = $g_hLblSmartDeployAB To $g_hPicAttackNearDarkElixirDrillAB
GUICtrlSetState($i, $GUI_HIDE)
Next
EndIf
EndFunc
Func chkRandomSpeedAtkDB()
If GUICtrlRead($g_hChkRandomSpeedAtkDB) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbStandardUnitDelayDB, $GUI_DISABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayDB, $GUI_DISABLE)
Else
GUICtrlSetState($g_hCmbStandardUnitDelayDB, $GUI_ENABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayDB, $GUI_ENABLE)
EndIf
EndFunc
Func chkSmartAttackRedAreaDB()
If GUICtrlRead($g_hChkSmartAttackRedAreaDB) = $GUI_CHECKED Then
$g_abAttackStdSmartAttack[$DB] = 1
For $i = $g_hLblSmartDeployDB To $g_hPicAttackNearDarkElixirDrillDB
GUICtrlSetState($i, $GUI_SHOW)
Next
Else
$g_abAttackStdSmartAttack[$DB] = 0
For $i = $g_hLblSmartDeployDB To $g_hPicAttackNearDarkElixirDrillDB
GUICtrlSetState($i, $GUI_HIDE)
Next
EndIf
EndFunc
Func PopulateComboScriptsFilesDB()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sCSVAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbScriptNameDB)
GUICtrlSetData($g_hCmbScriptNameDB, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameDB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameDB, ""))
GUICtrlSetData($g_hLblNotesScriptDB, "")
EndFunc
Func PopulateComboScriptsFilesAB()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sCSVAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbScriptNameAB)
GUICtrlSetData($g_hCmbScriptNameAB, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameAB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameAB, ""))
GUICtrlSetData($g_hLblNotesScriptAB, "")
EndFunc
Func cmbScriptNameDB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameDB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB) + 1]
Local $f, $result = ""
Local $tempvect, $line, $t
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
$f = FileOpen($g_sCSVAttacksPath & "\" & $filename & ".csv", 0)
While 1
$line = FileReadLine($f)
If @error = -1 Then ExitLoop
$tempvect = StringSplit($line, "|", 2)
If UBound($tempvect) >= 2 Then
If StringStripWS(StringUpper($tempvect[0]), 2) = "NOTE" Then $result &= $tempvect[1] & @CRLF
EndIf
WEnd
FileClose($f)
EndIf
GUICtrlSetData($g_hLblNotesScriptDB, $result)
EndFunc
Func cmbScriptNameAB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameAB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB) + 1]
Local $f, $result = ""
Local $tempvect, $line, $t
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
$f = FileOpen($g_sCSVAttacksPath & "\" & $filename & ".csv", 0)
While 1
$line = FileReadLine($f)
If @error = -1 Then ExitLoop
$tempvect = StringSplit($line, "|", 2)
If UBound($tempvect) >= 2 Then
If StringStripWS(StringUpper($tempvect[0]), 2) = "NOTE" Then $result &= $tempvect[1] & @CRLF
EndIf
WEnd
FileClose($f)
EndIf
GUICtrlSetData($g_hLblNotesScriptAB, $result)
EndFunc
Func UpdateComboScriptNameDB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameDB, $indexofscript, $scriptname)
PopulateComboScriptsFilesDB()
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameDB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameDB, $scriptname))
cmbScriptNameDB()
EndFunc
Func UpdateComboScriptNameAB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameAB, $indexofscript, $scriptname)
PopulateComboScriptsFilesAB()
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameAB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameAB, $scriptname))
cmbScriptNameAB()
EndFunc
Func EditScriptDB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameDB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB) + 1]
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
ShellExecute("notepad.exe", $g_sCSVAttacksPath & "\" & $filename & ".csv")
EndIf
EndFunc
Func EditScriptAB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameAB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB) + 1]
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
ShellExecute("notepad.exe", $g_sCSVAttacksPath & "\" & $filename & ".csv")
EndIf
EndFunc
Func AttackCSVAssignDefaultScriptName()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sCSVAttacksPath & "\*.csv")
Dim $output = ""
$NewFile = FileFindNextFile($FileSearch)
If @error Then $output = ""
$output = StringLeft($NewFile, StringLen($NewFile) - 4)
FileClose($FileSearch)
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameDB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameDB, $output))
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameAB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameAB, $output))
cmbScriptNameDB()
cmbScriptNameAB()
EndFunc
Local $temp1 = GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Create", "Create New Script File"), $temp2 = GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_New_0", "New Script Filename")
Local $temp3 = GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_File-exists", "File exists, please input a new name"), $temp4 = GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Error", "An error occurred when creating the file.")
Local $temp1 = 0, $temp2 = 0, $temp3 = 0, $temp4 = 0
Func NewScriptDB()
Local $filenameScript = InputBox(GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Create", -1), GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_New_0", -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($g_sCSVAttacksPath & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_File-exists", -1))
Else
Local $hFileOpen = FileOpen($g_sCSVAttacksPath & "\" & $filenameScript & ".csv", $FO_APPEND)
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Error", -1))
Return False
Else
FileClose($hFileOpen)
$g_sAttackScrScriptName[$DB] = $filenameScript
UpdateComboScriptNameDB()
UpdateComboScriptNameAB()
EndIf
EndIf
EndIf
EndFunc
Func NewScriptAB()
Local $filenameScript = InputBox(GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Create", -1), GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_New_0", -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($g_sCSVAttacksPath & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_File-exists", -1))
Else
Local $hFileOpen = FileOpen($g_sCSVAttacksPath & "\" & $filenameScript & ".csv", $FO_APPEND)
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Error", -1))
Return False
Else
FileClose($hFileOpen)
$g_sAttackScrScriptName[$LB] = $filenameScript
UpdateComboScriptNameAB()
UpdateComboScriptNameDB()
EndIf
EndIf
EndIf
EndFunc
Local $temp1 = GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Copy_0", "Copy to New Script File"), $temp2 = GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Copy_1", "Copy"), $temp3 = GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_New_1", "to New Script Filename")
Local $temp1 = 0, $temp2 = 0, $temp3 = 0
Func DuplicateScriptDB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameDB, $indexofscript, $scriptname)
$g_sAttackScrScriptName[$DB] = $scriptname
Local $filenameScript = InputBox(GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Copy_0", -1), GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Copy_1", -1) & ": <" & $g_sAttackScrScriptName[$DB] & ">" & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_New_1", -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($g_sCSVAttacksPath & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_File-exists", -1))
Else
Local $hFileOpen = FileCopy($g_sCSVAttacksPath & "\" & $g_sAttackScrScriptName[$DB] & ".csv", $g_sCSVAttacksPath & "\" & $filenameScript & ".csv")
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Error", -1))
Return False
Else
FileClose($hFileOpen)
$g_sAttackScrScriptName[$DB] = $filenameScript
UpdateComboScriptNameDB()
UpdateComboScriptNameAB()
EndIf
EndIf
EndIf
EndFunc
Func DuplicateScriptAB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameAB, $indexofscript, $scriptname)
$g_sAttackScrScriptName[$LB] = $scriptname
Local $filenameScript = InputBox(GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Copy_0", -1), GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Copy_1", -1) & ": <" & $g_sAttackScrScriptName[$LB] & ">" & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_New_1", -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($g_sCSVAttacksPath & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_File-exists", -1))
Else
Local $hFileOpen = FileCopy($g_sCSVAttacksPath & "\" & $g_sAttackScrScriptName[$LB] & ".csv", $g_sCSVAttacksPath & "\" & $filenameScript & ".csv")
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Error", -1))
Return False
Else
FileClose($hFileOpen)
$g_sAttackScrScriptName[$LB] = $filenameScript
UpdateComboScriptNameAB()
UpdateComboScriptNameDB()
EndIf
EndIf
EndIf
EndFunc
Func ApplyScriptDB()
Local $iApply = 0
Local $aiCSVTroops[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $aiCSVSpells[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $aiCSVHeros[$eHeroCount][2] = [[0, 0], [0, 0], [0, 0]]
Local $iCSVRedlineRoutineItem = 0, $iCSVDroplineEdgeItem = 0
Local $sCSVCCReq = ""
Local $aTemp = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameDB)
Local $sFilename = $aTemp[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB) + 1]
SetLog("CSV settings apply starts: " & $sFilename, $COLOR_INFO)
$iApply = ParseAttackCSV_Settings_variables($aiCSVTroops, $aiCSVSpells, $aiCSVHeros, $iCSVRedlineRoutineItem, $iCSVDroplineEdgeItem, $sCSVCCReq, $sFilename)
If Not $iApply Then
SetLog("CSV settings apply failed", $COLOR_ERROR)
Return
EndIf
$iApply = 0
For $i = 0 To UBound($aiCSVTroops) - 1
If $aiCSVTroops[$i] > 0 Then $iApply += 1
Next
For $i = 0 To UBound($aiCSVSpells) - 1
If $aiCSVSpells[$i] > 0 Then $iApply += 1
Next
If $iApply > 0 Then
For $t = 0 To UBound($aiCSVTroops) - 1
If $aiCSVTroops[$t] > 0 And $g_aiTrainArmyTroopLevel[$t] = 0 Then $g_aiTrainArmyTroopLevel[$t] = 1
Next
$g_aiArmyCompTroops = $aiCSVTroops
For $s = 0 To UBound($aiCSVSpells) - 1
If $aiCSVSpells[$s] > 0 And $g_aiTrainArmySpellLevel[$s] = 0 Then $g_aiTrainArmySpellLevel[$s] = 1
Next
$g_aiArmyCompSpells = $aiCSVSpells
ApplyConfig_600_52_2("Read")
SetComboTroopComp()
lblTotalCountSpell2()
SetLog("CSV Train settings applied", $COLOR_SUCCESS)
EndIf
$iApply = 0
For $i = 0 To UBound($aiCSVHeros) - 1
If $aiCSVHeros[$i][0] > 0 Then $iApply += 1
Next
If $iApply > 0 Then
For $h = 0 To UBound($aiCSVHeros) - 1
If $aiCSVHeros[$h][0] > 0 Then
Switch $h
Case $eHeroBarbarianKing
$g_iActivateKing = $aiCSVHeros[$h][0] - 1
$g_iDelayActivateKing = $aiCSVHeros[$h][1]
Case $eHeroArcherQueen
$g_iActivateQueen = $aiCSVHeros[$h][0] - 1
$g_iDelayActivateQueen = $aiCSVHeros[$h][1]
Case $eHeroGrandWarden
$g_iActivateWarden = $aiCSVHeros[$h][0] - 1
$g_iDelayActivateWarden = $aiCSVHeros[$h][1]
EndSwitch
EndIf
Next
radHerosApply()
SetLog("CSV Hero Ability settings applied", $COLOR_SUCCESS)
GUICtrlSetState($g_hChkDBKingAttack, $aiCSVHeros[$eHeroBarbarianKing][0] > 0 ? $GUI_CHECKED : GUICtrlGetState($g_hChkDBKingAttack))
GUICtrlSetState($g_hChkDBQueenAttack, $aiCSVHeros[$eHeroArcherQueen][0] > 0 ? $GUI_CHECKED : GUICtrlGetState($g_hChkDBQueenAttack))
GUICtrlSetState($g_hChkDBWardenAttack, $aiCSVHeros[$eHeroGrandWarden][0] > 0 ? $GUI_CHECKED : GUICtrlGetState($g_hChkDBWardenAttack))
SetLog("CSV 'Attack with' Hero settings applied", $COLOR_SUCCESS)
EndIf
If $sCSVCCReq <> "" Then
GUICtrlSetState($g_hChkDBDropCC, $GUI_CHECKED)
SetLog("CSV 'Attack with' CC settings applied", $COLOR_SUCCESS)
EndIf
$iApply = 0
Local $ahChkDBSpell = StringSplit($g_aGroupAttackDBSpell, "#", 2)
If IsArray($ahChkDBSpell) Then
For $i = 0 To UBound($ahChkDBSpell) - 1
GUICtrlSetState($ahChkDBSpell[$i], $aiCSVSpells[$i] > 0 ? $GUI_CHECKED : $GUI_UNCHECKED)
If $aiCSVSpells[$i] > 0 Then $iApply += 1
Next
If $iApply > 0 Then SetLog("CSV 'Attack with' Spell settings applied", $COLOR_SUCCESS)
EndIf
If $iCSVRedlineRoutineItem > 0 And $iCSVRedlineRoutineItem <= _GUICtrlComboBox_GetCount($g_hCmbScriptRedlineImplDB) + 1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbScriptRedlineImplDB, $iCSVRedlineRoutineItem - 1)
cmbScriptRedlineImplDB()
SetLog("CSV Red Line settings applied", $COLOR_SUCCESS)
Else
If $iCSVRedlineRoutineItem <> 0 Then SetLog("CSV Red Line settings out of bounds", $COLOR_ERROR)
EndIf
If $iCSVDroplineEdgeItem > 0 And $iCSVDroplineEdgeItem <= _GUICtrlComboBox_GetCount($g_hCmbScriptDroplineDB) + 1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbScriptDroplineDB, $iCSVDroplineEdgeItem - 1)
cmbScriptDroplineDB()
SetLog("CSV Drop Line settings applied", $COLOR_SUCCESS)
Else
If $iCSVDroplineEdgeItem <> 0 Then SetLog("CSV Drop Line settings out of bounds", $COLOR_ERROR)
EndIf
If $sCSVCCReq <> "" Then
$g_bRequestTroopsEnable = True
$g_sRequestTroopsText = $sCSVCCReq
ApplyConfig_600_11("Read")
SetLog("CSV CC Request settings applied", $COLOR_SUCCESS)
EndIf
EndFunc
Func ApplyScriptAB()
Local $iApply = 0
Local $aiCSVTroops[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $aiCSVSpells[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $aiCSVHeros[$eHeroCount][2] = [[0, 0], [0, 0], [0, 0]]
Local $iCSVRedlineRoutineItem = 0, $iCSVDroplineEdgeItem = 0
Local $sCSVCCReq = ""
Local $aTemp = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameAB)
Local $sFilename = $aTemp[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB) + 1]
SetLog("CSV settings apply starts: " & $sFilename, $COLOR_INFO)
$iApply = ParseAttackCSV_Settings_variables($aiCSVTroops, $aiCSVSpells, $aiCSVHeros, $iCSVRedlineRoutineItem, $iCSVDroplineEdgeItem, $sCSVCCReq, $sFilename)
If Not $iApply Then
SetLog("CSV settings apply failed", $COLOR_ERROR)
Return
EndIf
$iApply = 0
For $i = 0 To UBound($aiCSVTroops) - 1
If $aiCSVTroops[$i] > 0 Then $iApply += 1
Next
For $i = 0 To UBound($aiCSVSpells) - 1
If $aiCSVSpells[$i] > 0 Then $iApply += 1
Next
If $iApply > 0 Then
For $t = 0 To UBound($aiCSVTroops) - 1
If $aiCSVTroops[$t] > 0 And $g_aiTrainArmyTroopLevel[$t] = 0 Then $g_aiTrainArmyTroopLevel[$t] = 1
Next
$g_aiArmyCompTroops = $aiCSVTroops
For $s = 0 To UBound($aiCSVSpells) - 1
If $aiCSVSpells[$s] > 0 And $g_aiTrainArmySpellLevel[$s] = 0 Then $g_aiTrainArmySpellLevel[$s] = 1
Next
$g_aiArmyCompSpells = $aiCSVSpells
ApplyConfig_600_52_2("Read")
SetComboTroopComp()
lblTotalCountSpell2()
SetLog("CSV Train settings applied", $COLOR_SUCCESS)
EndIf
$iApply = 0
For $i = 0 To UBound($aiCSVHeros) - 1
If $aiCSVHeros[$i][0] > 0 Then $iApply += 1
Next
If $iApply > 0 Then
For $h = 0 To UBound($aiCSVHeros) - 1
If $aiCSVHeros[$h][0] > 0 Then
Switch $h
Case $eHeroBarbarianKing
$g_iActivateKing = $aiCSVHeros[$h][0] - 1
$g_iDelayActivateKing = $aiCSVHeros[$h][1]
Case $eHeroArcherQueen
$g_iActivateQueen = $aiCSVHeros[$h][0] - 1
$g_iDelayActivateQueen = $aiCSVHeros[$h][1]
Case $eHeroGrandWarden
$g_iActivateWarden = $aiCSVHeros[$h][0] - 1
$g_iDelayActivateWarden = $aiCSVHeros[$h][1]
EndSwitch
EndIf
Next
radHerosApply()
SetLog("CSV Hero Ability settings applied", $COLOR_SUCCESS)
GUICtrlSetState($g_hChkABKingAttack, $aiCSVHeros[$eHeroBarbarianKing][0] > 0 ? $GUI_CHECKED : GUICtrlGetState($g_hChkABKingAttack))
GUICtrlSetState($g_hChkABQueenAttack, $aiCSVHeros[$eHeroArcherQueen][0] > 0 ? $GUI_CHECKED : GUICtrlGetState($g_hChkABQueenAttack))
GUICtrlSetState($g_hChkABWardenAttack, $aiCSVHeros[$eHeroGrandWarden][0] > 0 ? $GUI_CHECKED : GUICtrlGetState($g_hChkABWardenAttack))
SetLog("CSV 'Attack with' Hero settings applied", $COLOR_SUCCESS)
EndIf
If $sCSVCCReq <> "" Then
GUICtrlSetState($g_hChkABDropCC, $GUI_CHECKED)
SetLog("CSV 'Attack with' CC settings applied", $COLOR_SUCCESS)
EndIf
$iApply = 0
Local $ahChkABSpell = StringSplit($GroupAttackABSpell, "#", 2)
If IsArray($ahChkABSpell) Then
For $i = 0 To UBound($ahChkABSpell) - 1
GUICtrlSetState($ahChkABSpell[$i], $aiCSVSpells[$i] > 0 ? $GUI_CHECKED : $GUI_UNCHECKED)
If $aiCSVSpells[$i] > 0 Then $iApply += 1
Next
If $iApply > 0 Then SetLog("CSV 'Attack with' Spell settings applied", $COLOR_SUCCESS)
EndIf
If $iCSVRedlineRoutineItem > 0 And $iCSVRedlineRoutineItem <= _GUICtrlComboBox_GetCount($g_hCmbScriptRedlineImplAB) + 1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbScriptRedlineImplAB, $iCSVRedlineRoutineItem - 1)
cmbScriptRedlineImplAB()
SetLog("CSV Red Line settings applied", $COLOR_SUCCESS)
Else
If $iCSVRedlineRoutineItem <> 0 Then SetLog("CSV Red Line settings out of bounds", $COLOR_ERROR)
EndIf
If $iCSVDroplineEdgeItem > 0 And $iCSVDroplineEdgeItem <= _GUICtrlComboBox_GetCount($g_hCmbScriptDroplineAB) + 1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbScriptDroplineAB, $iCSVDroplineEdgeItem - 1)
cmbScriptDroplineAB()
SetLog("CSV Drop Line settings applied", $COLOR_SUCCESS)
Else
If $iCSVDroplineEdgeItem <> 0 Then SetLog("CSV Drop Line settings out of bounds", $COLOR_ERROR)
EndIf
If $sCSVCCReq <> "" Then
$g_bRequestTroopsEnable = True
$g_sRequestTroopsText = $sCSVCCReq
ApplyConfig_600_11("Read")
SetLog("CSV CC Request settings applied", $COLOR_SUCCESS)
EndIf
EndFunc
Func cmbScriptRedlineImplDB()
$g_aiAttackScrRedlineRoutine[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptRedlineImplDB)
If $g_aiAttackScrRedlineRoutine[$DB] = 3 then
GUICtrlSetState($g_hCmbScriptDroplineDB, $GUI_HIDE)
$g_aiAttackScrDroplineEdge[$DB] = $DROPLINE_FULL_EDGE_FIXED
Else
GUICtrlSetState($g_hCmbScriptDroplineDB, $GUI_SHOW)
Endif
EndFunc
Func cmbScriptRedlineImplAB()
$g_aiAttackScrRedlineRoutine[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptRedlineImplAB)
If $g_aiAttackScrRedlineRoutine[$LB] = 3 then
GUICtrlSetState($g_hCmbScriptDroplineAB, $GUI_HIDE)
$g_aiAttackScrDroplineEdge[$LB] = $DROPLINE_FULL_EDGE_FIXED
Else
GUICtrlSetState($g_hCmbScriptDroplineAB, $GUI_SHOW)
EndIf
EndFunc
Func cmbScriptDroplineDB()
$g_aiAttackScrDroplineEdge[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptDroplineDB)
EndFunc
Func cmbScriptDroplineAB()
$g_aiAttackScrDroplineEdge[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptDroplineAB)
EndFunc
Func AttackNow()
Local $tempbRunState = $g_bRunState
$g_aiAttackAlgorithm[$LB] = 1
$g_sAttackScrScriptName[$LB] = GuiCtrlRead($g_hCmbScriptNameAB)
$g_iMatchMode = $LB
$g_bRunState = True
PrepareAttack($g_iMatchMode)
Attack()
$g_bRunState = $tempbRunState
EndFunc
Func chkUnbreakable()
If GUICtrlRead($g_hChkUnbreakable) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtUnbreakable, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMinGold, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMaxGold, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMinElixir, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMaxElixir, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMinDark, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMaxDark, $GUI_ENABLE)
$g_iUnbrkMode = 1
ElseIf GUICtrlRead($g_hChkUnbreakable) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hTxtUnbreakable, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMinGold, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMaxGold, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMinElixir, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMaxElixir, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMinDark, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMaxDark, $GUI_DISABLE)
$g_iUnbrkMode = 0
EndIf
EndFunc
Func chkPBTGenabled()
If GUICtrlRead($g_hChkNotifyPBEnable) = $GUI_CHECKED Then
$g_bNotifyPBEnable = True
GUICtrlSetState($g_hTxtNotifyPBToken, $GUI_ENABLE)
GUICtrlSetState($g_hBtnNotifyDeleteMessages, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyDeleteAllPBPushes, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyDeleteOldPBPushes, $GUI_ENABLE)
GUICtrlSetState($g_hBtnNotifyDeleteMessages, $GUI_ENABLE)
If $g_bNotifyDeletePushesOlderThan = True Then
GUICtrlSetState($g_hCmbNotifyPushHours, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbNotifyPushHours, $GUI_DISABLE)
EndIf
Else
$g_bNotifyPBEnable = False
GUICtrlSetState($g_hChkNotifyTGEnable, $GUI_ENABLE)
GUICtrlSetState($g_hTxtNotifyPBToken, $GUI_DISABLE)
GUICtrlSetState($g_hBtnNotifyDeleteMessages, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyDeleteAllPBPushes, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyDeleteOldPBPushes, $GUI_DISABLE)
GUICtrlSetState($g_hBtnNotifyDeleteMessages, $GUI_DISABLE)
GUICtrlSetState($g_hCmbNotifyPushHours, $GUI_DISABLE)
EndIf
If GUICtrlRead($g_hChkNotifyTGEnable) = $GUI_CHECKED Then
$g_bNotifyTGEnable = True
GUICtrlSetState($g_hTxtNotifyTGToken, $GUI_ENABLE)
Else
$g_bNotifyTGEnable = False
GUICtrlSetState($g_hTxtNotifyTGToken, $GUI_DISABLE)
EndIf
If $g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True Then
GUICtrlSetState($g_hChkNotifyRemote, $GUI_ENABLE)
GUICtrlSetState($g_hTxtNotifyOrigin, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertMatchFound, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertLastRaidIMG, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertUpgradeWall, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertLastRaidTXT, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertOutOfSync, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertTakeBreak, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertVillageStats, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertLastAttack, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertAnotherDevice, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertCampFull, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertBuilderIdle, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertMaintenance, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertBAN, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyBOTUpdate, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertSmartWaitTime, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkNotifyRemote, $GUI_DISABLE)
GUICtrlSetState($g_hTxtNotifyOrigin, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertMatchFound, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertLastRaidIMG, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertUpgradeWall, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertLastRaidTXT, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertOutOfSync, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertTakeBreak, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertVillageStats, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertLastAttack, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertAnotherDevice, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertCampFull, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertBuilderIdle, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertMaintenance, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertBAN, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyBOTUpdate, $GUI_DISABLE)
GUICtrlSetState($g_hCmbNotifyPushHours, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyDeleteAllPBPushes, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyDeleteOldPBPushes, $GUI_DISABLE)
GUICtrlSetState($g_hBtnNotifyDeleteMessages, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertSmartWaitTime, $GUI_DISABLE)
EndIf
EndFunc
Func chkDeleteOldPBPushes()
If GUICtrlRead($g_hChkNotifyDeleteOldPBPushes) = $GUI_CHECKED Then
$g_bNotifyDeletePushesOlderThan = True
If $g_bNotifyPBEnable Then GUICtrlSetState($g_hCmbNotifyPushHours, $GUI_ENABLE)
Else
$g_bNotifyDeletePushesOlderThan = False
GUICtrlSetState($g_hCmbNotifyPushHours, $GUI_DISABLE)
EndIf
EndFunc
Func btnDeletePBMessages()
$g_bNotifyDeleteAllPushesNow = True
EndFunc
Func NotifyHelp()
If FileExists(@ScriptDir & "\Help\NotifyHelp_" & $g_sLanguage & ".mht") Then
ShellExecute(@ScriptDir & "\Help\NotifyHelp_" & $g_sLanguage & ".mht")
ElseIf FileExists(@ScriptDir & "\Help\NotifyHelp_English.mht") Then
ShellExecute(@ScriptDir & "\Help\NotifyHelp_English.mht")
EndIf
EndFunc
Func chkNotifyHours()
Local $b = GUICtrlRead($g_hChkNotifyOnlyHours) = $GUI_CHECKED
For $i = 0 To 23
GUICtrlSetState($g_hChkNotifyhours[$i], $b ? $GUI_ENABLE : $GUI_DISABLE)
Next
_GUI_Value_STATE($b ? "ENABLE" : "DISABLE", $g_hChkNotifyOnlyWeekDays&"#"&$g_hChkNotifyhoursE1&"#"&$g_hChkNotifyhoursE2)
If $b = False Then
GUICtrlSetState($g_hChkNotifyOnlyWeekDays, $GUI_UNCHECKED)
chkNotifyWeekDays()
EndIf
EndFunc
Func chkNotifyhoursE1()
Local $b = GUICtrlRead($g_hChkNotifyhoursE1) = $GUI_CHECKED And GUICtrlRead($g_hChkNotifyhours[0]) = $GUI_CHECKED
For $i = 0 To 11
GUICtrlSetState($g_hChkNotifyhours[$i], $b ? $GUI_UNCHECKED : $GUI_CHECKED)
Next
Sleep(300)
GUICtrlSetState($g_hChkNotifyhoursE1, $GUI_UNCHECKED)
EndFunc
Func chkNotifyhoursE2()
Local $b = GUICtrlRead($g_hChkNotifyhoursE2) = $GUI_CHECKED And GUICtrlRead($g_hChkNotifyhours[12]) = $GUI_CHECKED
For $i = 12 To 23
GUICtrlSetState($g_hChkNotifyhours[$i], $b ? $GUI_UNCHECKED : $GUI_CHECKED)
Next
Sleep(300)
GUICtrlSetState($g_hChkNotifyhoursE2, $GUI_UNCHECKED)
EndFunc
Func chkNotifyWeekDays()
Local $b = GUICtrlRead($g_hChkNotifyOnlyWeekDays) = $GUI_CHECKED
For $i = 0 To 6
GUICtrlSetState($g_hChkNotifyWeekdays[$i], $b ? $GUI_ENABLE : $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkNotifyWeekdaysE, $b ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func ChkNotifyWeekdaysE()
Local $b = BitOR(GUICtrlRead($g_hChkNotifyWeekdays[0]), GUICtrlRead($g_hChkNotifyWeekdays[1]), GUICtrlRead($g_hChkNotifyWeekdays[2]), GUICtrlRead($g_hChkNotifyWeekdays[3]), GUICtrlRead($g_hChkNotifyWeekdays[4]), GUICtrlRead($g_hChkNotifyWeekdays[5]), GUICtrlRead($g_hChkNotifyWeekdays[6])) = $GUI_CHECKED
For $i = 0 To 6
GUICtrlSetState($g_hChkNotifyWeekdays[$i], $b ? $GUI_UNCHECKED : $GUI_CHECKED)
Next
Sleep(300)
GUICtrlSetState($g_ahChkNotifyWeekdaysE, $GUI_UNCHECKED)
EndFunc
Func InitTranslatedTextUpgradeTab()
GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Warning_Title", "Warning about your settings...")
GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Warning_Text", "Warning ! You selected 2 resources to ignore... That can be a problem,\r\n" & "and Auto Upgrade can be ineffective, by not launching any upgrade...\r\n" & "I recommend you to select only one resource, not more...")
GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Invalid_Title", "Invalid settings...")
GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Invalid_Text", "Warning ! You selected 3 resources to ignore... And you can't...\r\n" & "With your settings, Auto Upgrade will be completely ineffective\r\n" & "and will not launch any upgrade... You must deselect one or more\r\n" & "ignored resource.")
EndFunc
Func btnLocateUpgrades()
Local $wasRunState = $g_bRunState
$g_bRunState = True
LocateUpgrades()
$g_bRunState = $wasRunState
EndFunc
Func btnchkbxUpgrade()
For $i = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If GUICtrlRead($g_hChkUpgrade[$i]) = $GUI_CHECKED Then
$g_abBuildingUpgradeEnable[$i] = True
Else
$g_abBuildingUpgradeEnable[$i] = False
EndIf
Next
EndFunc
Func btnchkbxRepeat()
For $i = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If GUICtrlRead($g_hChkUpgradeRepeat[$i]) = $GUI_CHECKED Then
$g_abUpgradeRepeatEnable[$i] = True
Else
$g_abUpgradeRepeatEnable[$i] = False
EndIf
Next
EndFunc
Func picUpgradeTypeLocation()
Local $wasRunState = $g_bRunState
$g_bRunState = True
PureClick(1, 40, 1, 0, "#9999")
Sleep(100)
Zoomout()
Local $inum
For $inum = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If @GUI_CtrlId = $g_hPicUpgradeType[$inum] Then
Local $x = $g_avBuildingUpgrades[$inum][0]
Local $y = $g_avBuildingUpgrades[$inum][1]
Local $n = $g_avBuildingUpgrades[$inum][4]
SetDebugLog("Selecting #" & $inum + 1 & ": " & $n & ", " & $x & "/" & $y)
If isInsideDiamondXY($x, $y) Then
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1], "#9999")
Sleep(100)
If StringInStr($n, "collect", $STR_NOCASESENSEBASIC) Or StringInStr($n, "mine", $STR_NOCASESENSEBASIC) Or StringInStr($n, "drill", $STR_NOCASESENSEBASIC) Then
Click(1, 40, 1, 0, "#0999")
Sleep(100)
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1], "#9999")
EndIf
EndIf
ExitLoop
EndIf
Next
$g_bRunState = $wasRunState
EndFunc
Func btnResetUpgrade()
For $i = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If GUICtrlRead($g_hChkUpgradeRepeat[$i]) = $GUI_CHECKED Then ContinueLoop
$g_avBuildingUpgrades[$i][0] = -1
$g_avBuildingUpgrades[$i][1] = -1
$g_avBuildingUpgrades[$i][2] = -1
$g_avBuildingUpgrades[$i][3] = ""
$g_avBuildingUpgrades[$i][4] = ""
$g_avBuildingUpgrades[$i][5] = ""
$g_avBuildingUpgrades[$i][6] = ""
$g_avBuildingUpgrades[$i][7] = ""
GUICtrlSetData($g_hTxtUpgradeName[$i], "")
GUICtrlSetData($g_hTxtUpgradeLevel[$i], "")
GUICtrlSetData($g_hTxtUpgradeValue[$i], "")
GUICtrlSetData($g_hTxtUpgradeTime[$i], "")
_GUICtrlSetImage($g_hPicUpgradeType[$i], $g_sLibIconPath, $eIcnBlank)
$g_aiPicUpgradeStatus[$i] = $eIcnTroops
_GUICtrlSetImage($g_hPicUpgradeStatus[$i], $g_sLibIconPath, $g_aiPicUpgradeStatus[$i])
GUICtrlSetState($g_hChkUpgrade[$i], $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtUpgradeEndTime[$i], "")
GUICtrlSetState($g_hChkUpgradeRepeat[$i], $GUI_UNCHECKED)
Next
EndFunc
Func chkLab()
If GUICtrlRead($g_hChkAutoLabUpgrades) = $GUI_CHECKED Then
$g_bAutoLabUpgradeEnable = True
GUICtrlSetState($g_hPicLabUpgrade, $GUI_SHOW)
GUICtrlSetState($g_hLblNextUpgrade, $GUI_ENABLE)
GUICtrlSetState($g_hCmbLaboratory, $GUI_ENABLE)
_GUICtrlSetImage($g_hPicLabUpgrade, $g_sLibIconPath, $g_avLabTroops[$g_iCmbLaboratory][4])
Else
$g_bAutoLabUpgradeEnable = False
GUICtrlSetState($g_hPicLabUpgrade, $GUI_HIDE)
GUICtrlSetState($g_hLblNextUpgrade, $GUI_DISABLE)
GUICtrlSetState($g_hCmbLaboratory, $GUI_DISABLE)
_GUICtrlSetImage($g_hPicLabUpgrade, $g_sLibIconPath, $g_avLabTroops[0][4])
EndIf
LabStatusGUIUpdate()
EndFunc
Func LabStatusGUIUpdate()
If _DateIsValid($g_sLabUpgradeTime) Then
_GUICtrlSetTip($g_hBtnResetLabUpgradeTime, GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_01", "Visible Red button means that laboratory upgrade in process") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_02", "This will automatically disappear when near time for upgrade to be completed.") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_03", "If upgrade has been manually finished with gems before normal end time,") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_04", "Click red button to reset internal upgrade timer BEFORE STARTING NEW UPGRADE") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_05", "Caution - Unnecessary timer reset will force constant checks for lab status") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_06", "Troop Upgrade started") & ", " & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_07", "Will begin to check completion at:") & " " & $g_sLabUpgradeTime & @CRLF & " ")
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_SHOW)
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_ENABLE)
Else
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_HIDE)
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_DISABLE)
EndIf
EndFunc
Func cmbLab()
$g_iCmbLaboratory = _GUICtrlComboBox_GetCurSel($g_hCmbLaboratory)
_GUICtrlSetImage($g_hPicLabUpgrade, $g_sLibIconPath, $g_avLabTroops[$g_iCmbLaboratory][4])
EndFunc
Func ResetLabUpgradeTime()
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_07", "Are you 100% sure you want to reset lab upgrade timer?") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_08", "Click OK to reset") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_09", "Or Click Cancel to exit") & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_10", "Reset timer") & "|" & GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_11", "Cancel and Return"), GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_12", "Reset laboratory upgrade timer?"), $stext, 120, $g_hFrmBot)
If $g_bDebugSetlog Then SetDebugLog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
$g_sLabUpgradeTime = ""
_GUICtrlSetTip($g_hBtnResetLabUpgradeTime, GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_01", "Visible Red button means that laboratory upgrade in process") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_02", "This will automatically disappear when near time for upgrade to be completed.") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_03", "If upgrade has been manually finished with gems before normal end time,") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_04", "Click red button to reset internal upgrade timer BEFORE STARTING NEW UPGRADE") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_05", "Caution - Unnecessary timer reset will force constant checks for lab status"))
EndIf
If _DateIsValid($g_sLabUpgradeTime) Then
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_SHOW)
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_ENABLE)
Else
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_HIDE)
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_DISABLE)
EndIf
EndFunc
Func chkUpgradeKing()
If $g_iTownHallLevel > 6 Or $g_iTownHallLevel = 0 Then
GUICtrlSetState($g_hChkUpgradeKing, $GUI_ENABLE)
If GUICtrlRead($g_hChkUpgradeKing) = $GUI_CHECKED Then
$g_bUpgradeKingEnable = True
GUICtrlSetState($g_hChkDBKingWait, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABKingWait, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBKingWait, $GUI_DISABLE)
GUICtrlSetState($g_hChkABKingWait, $GUI_DISABLE)
_GUI_Value_STATE("SHOW", $groupKingSleeping)
Else
$g_bUpgradeKingEnable = False
GUICtrlSetState($g_hChkDBKingWait, $GUI_ENABLE)
GUICtrlSetState($g_hChkABKingWait, $GUI_ENABLE)
_GUI_Value_STATE("HIDE", $groupKingSleeping)
EndIf
If GUICtrlRead($g_hCmbBoostBarbarianKing) > 0 Then
GUICtrlSetState($g_hChkUpgradeKing, $GUI_DISABLE)
GUICtrlSetState($g_hChkUpgradeKing, $GUI_UNCHECKED)
$g_bUpgradeKingEnable = False
Else
GUICtrlSetState($g_hChkUpgradeKing, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkUpgradeKing, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkUpgradeQueen()
If $g_iTownHallLevel > 8 Or $g_iTownHallLevel = 0 Then
GUICtrlSetState($g_hChkUpgradeQueen, $GUI_ENABLE)
If GUICtrlRead($g_hChkUpgradeQueen) = $GUI_CHECKED Then
$g_bUpgradeQueenEnable = True
GUICtrlSetState($g_hChkDBQueenWait, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABQueenWait, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBQueenWait, $GUI_DISABLE)
GUICtrlSetState($g_hChkABQueenWait, $GUI_DISABLE)
_GUI_Value_STATE("SHOW", $groupQueenSleeping)
Else
$g_bUpgradeQueenEnable = False
GUICtrlSetState($g_hChkDBQueenWait, $GUI_ENABLE)
GUICtrlSetState($g_hChkABQueenWait, $GUI_ENABLE)
_GUI_Value_STATE("HIDE", $groupQueenSleeping)
EndIf
If GUICtrlRead($g_hCmbBoostArcherQueen) > 0 Then
GUICtrlSetState($g_hChkUpgradeQueen, $GUI_DISABLE)
GUICtrlSetState($g_hChkUpgradeQueen, $GUI_UNCHECKED)
$g_bUpgradeQueenEnable = False
Else
GUICtrlSetState($g_hChkUpgradeQueen, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkUpgradeQueen, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkUpgradeWarden()
If $g_iTownHallLevel > 10 Or $g_iTownHallLevel = 0 Then
GUICtrlSetState($g_hChkUpgradeWarden, $GUI_ENABLE)
If GUICtrlRead($g_hChkUpgradeWarden) = $GUI_CHECKED Then
$g_bUpgradeWardenEnable = True
GUICtrlSetState($g_hChkDBWardenWait, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABWardenWait, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBWardenWait, $GUI_DISABLE)
GUICtrlSetState($g_hChkABWardenWait, $GUI_DISABLE)
_GUI_Value_STATE("SHOW", $groupWardenSleeping)
Else
$g_bUpgradeWardenEnable = False
GUICtrlSetState($g_hChkDBWardenWait, $GUI_ENABLE)
GUICtrlSetState($g_hChkABWardenWait, $GUI_ENABLE)
_GUI_Value_STATE("HIDE", $groupWardenSleeping)
EndIf
If GUICtrlRead($g_hCmbBoostWarden) > 0 Then
GUICtrlSetState($g_hChkUpgradeWarden, $GUI_DISABLE)
GUICtrlSetState($g_hChkUpgradeWarden, $GUI_UNCHECKED)
$g_bUpgradeWardenEnable = False
Else
GUICtrlSetState($g_hChkUpgradeWarden, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkUpgradeWarden, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkWalls()
If GUICtrlRead($g_hChkWalls) = $GUI_CHECKED Then
$g_bAutoUpgradeWallsEnable = True
GUICtrlSetState($g_hRdoUseGold, $GUI_ENABLE)
GUICtrlSetState($g_hCmbWalls, $GUI_ENABLE)
GUICtrlSetState($g_hTxtWallMinGold, $GUI_ENABLE)
cmbWalls()
Else
$g_bAutoUpgradeWallsEnable = False
GUICtrlSetState($g_hRdoUseGold, $GUI_DISABLE)
GUICtrlSetState($g_hRdoUseElixir, $GUI_DISABLE)
GUICtrlSetState($g_hRdoUseElixirGold, $GUI_DISABLE)
GUICtrlSetState($g_hCmbWalls, $GUI_DISABLE)
GUICtrlSetState($g_hTxtWallMinGold, $GUI_DISABLE)
GUICtrlSetState($g_hTxtWallMinElixir, $GUI_DISABLE)
EndIf
EndFunc
Func chkSaveWallBldr()
$g_bUpgradeWallSaveBuilder =(GUICtrlRead($g_hChkSaveWallBldr) = $GUI_CHECKED)
EndFunc
Func cmbWalls()
$g_iCmbUpgradeWallsLevel = _GUICtrlComboBox_GetCurSel($g_hCmbWalls)
$g_iWallCost = $g_aiWallCost[$g_iCmbUpgradeWallsLevel]
GUICtrlSetData($g_hLblWallCost, _NumberFormat($g_iWallCost))
For $i = 4 To $g_iCmbUpgradeWallsLevel+5
GUICtrlSetState($g_ahWallsCurrentCount[$i], $GUI_SHOW)
GUICtrlSetState($g_ahPicWallsLevel[$i], $GUI_SHOW)
Next
For $i = $g_iCmbUpgradeWallsLevel+6 To 13
GUICtrlSetState($g_ahWallsCurrentCount[$i], $GUI_HIDE)
GUICtrlSetState($g_ahPicWallsLevel[$i], $GUI_HIDE)
Next
If $g_iCmbUpgradeWallsLevel <= 3 Then GUICtrlSetState($g_hRdoUseGold, $GUI_CHECKED)
GUICtrlSetState($g_hRdoUseElixir, $g_iCmbUpgradeWallsLevel <= 3 ? $GUI_DISABLE : $GUI_ENABLE)
GUICtrlSetState($g_hRdoUseElixirGold, $g_iCmbUpgradeWallsLevel <= 3 ? $GUI_DISABLE : $GUI_ENABLE)
GUICtrlSetState($g_hTxtWallMinElixir, $g_iCmbUpgradeWallsLevel <= 3 ? $GUI_DISABLE : $GUI_ENABLE)
EndFunc
Func btnWalls()
Local $wasRunState = $g_bRunState
$g_bRunState = True
Zoomout()
$g_iCmbUpgradeWallsLevel = _GUICtrlComboBox_GetCurSel($g_hCmbWalls)
If imglocCheckWall() Then SetLog("Hei Chef! We found the Wall!")
$g_bRunState = $wasRunState
AndroidShield("btnWalls")
EndFunc
Func chkAutoUpgrade()
If GUICtrlRead($g_hChkAutoUpgrade) = $GUI_CHECKED Then
$g_iChkAutoUpgrade = 1
For $i = $g_hLblAutoUpgrade To $g_hTxtAutoUpgradeLog
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
$g_iChkAutoUpgrade = 0
For $i = $g_hLblAutoUpgrade To $g_hTxtAutoUpgradeLog
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkResourcesToIgnore()
For $i = 0 To 2
$g_iChkResourcesToIgnore[$i] = GUICtrlRead($g_hChkResourcesToIgnore[$i]) = $GUI_CHECKED ? 1 : 0
Next
Local $iIgnoredResources = 0
For $i = 0 To 2
If $g_iChkResourcesToIgnore[$i] = 1 Then $iIgnoredResources += 1
Next
Switch $iIgnoredResources
Case 2
MsgBox(0 + 16, GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Warning_Title", "-1"), GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Warning_Text", "-1"))
Case 3
MsgBox(0 + 16, GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Invalid_Title", "-1"), GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Invalid_Text", "-1"))
EndSwitch
EndFunc
Func chkUpgradesToIgnore()
For $i = 0 To 12
$g_iChkUpgradesToIgnore[$i] = GUICtrlRead($g_hChkUpgradesToIgnore[$i]) = $GUI_CHECKED ? 1 : 0
Next
EndFunc
Global $g_aiDonIcons[21] = [$eIcnDonBarbarian, $eIcnDonArcher, $eIcnDonGiant, $eIcnDonGoblin, $eIcnDonWallBreaker, $eIcnDonBalloon, $eIcnDonWizard, $eIcnDonHealer, $eIcnDonDragon, $eIcnDonPekka, $eIcnDonBabyDragon, $eIcnDonMiner, $eIcnElectroDragon, $eIcnDonMinion, $eIcnDonHogRider, $eIcnDonValkyrie, $eIcnDonGolem, $eIcnDonWitch, $eIcnDonLavaHound, $eIcnDonBowler, $eIcnDonBlank]
Func btnDonateTroop()
For $i = 0 To $eTroopCount-1 + $g_iCustomDonateConfigs
If @GUI_CtrlId = $g_ahBtnDonateTroop[$i] Then
If GUICtrlGetState($g_ahGrpDonateTroop[$i]) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($g_ahGrpDonateTroop[$i], $g_ahTxtBlacklistTroop[$i])
EndIf
ExitLoop
EndIf
Next
EndFunc
Func btnDonateSpell()
For $i = 0 To $eSpellCount - 1
If @GUI_CtrlId = $g_ahBtnDonateSpell[$i] Then
If GUICtrlGetState($g_ahGrpDonateSpell[$i]) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($g_ahGrpDonateSpell[$i], $g_ahTxtBlacklistSpell[$i])
EndIf
ExitLoop
EndIf
Next
EndFunc
Func btnDonateBlacklist()
If GUICtrlGetState($g_hGrpDonateGeneralBlacklist) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($g_hGrpDonateGeneralBlacklist, $g_hTxtGeneralBlacklist)
EndIf
EndFunc
Func chkDonateTroop()
For $i = 0 To $eTroopCount-1 + $g_iCustomDonateConfigs
If @GUI_CtrlId = $g_ahChkDonateTroop[$i] Then
If GUICtrlRead($g_ahChkDonateTroop[$i]) = $GUI_CHECKED Then
_DonateControls($i)
Else
GUICtrlSetBkColor($g_ahLblDonateTroop[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndIf
Next
EndFunc
Func chkDonateAllTroop()
For $i = 0 To $eTroopCount-1 + $g_iCustomDonateConfigs
If @GUI_CtrlId = $g_ahChkDonateAllTroop[$i] Then
_DonateAllControls($i, GUICtrlRead($g_ahChkDonateAllTroop[$i]) = $GUI_CHECKED ? True : False)
ExitLoop
EndIf
Next
EndFunc
Func chkDonateSpell()
For $i = 0 To $eSpellCount - 1
If @GUI_CtrlId = $g_ahChkDonateSpell[$i] Then
If GUICtrlRead($g_ahChkDonateSpell[$i]) = $GUI_CHECKED Then
_DonateControlsSpell($i)
Else
GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndIf
Next
EndFunc
Func chkDonateAllSpell()
For $i = 0 To $eSpellCount - 1
If @GUI_CtrlId = $g_ahChkDonateAllSpell[$i] Then
_DonateAllControlsSpell($i, GUICtrlRead($g_ahChkDonateAllSpell[$i]) = $GUI_CHECKED ? True : False)
ExitLoop
EndIf
Next
EndFunc
Func cmbDonateCustomA()
Local $combo1 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomA[0])
Local $combo2 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomA[1])
Local $combo3 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomA[2])
_GUICtrlSetImage($g_ahPicDonateCustomA[0], $g_sLibIconPath, $g_aiDonIcons[$combo1])
_GUICtrlSetImage($g_ahPicDonateCustomA[1], $g_sLibIconPath, $g_aiDonIcons[$combo2])
_GUICtrlSetImage($g_ahPicDonateCustomA[2], $g_sLibIconPath, $g_aiDonIcons[$combo3])
EndFunc
Func cmbDonateCustomB()
Local $combo1 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomB[0])
Local $combo2 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomB[1])
Local $combo3 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomB[2])
_GUICtrlSetImage($g_ahPicDonateCustomB[0], $g_sLibIconPath, $g_aiDonIcons[$combo1])
_GUICtrlSetImage($g_ahPicDonateCustomB[1], $g_sLibIconPath, $g_aiDonIcons[$combo2])
_GUICtrlSetImage($g_ahPicDonateCustomB[2], $g_sLibIconPath, $g_aiDonIcons[$combo3])
EndFunc
Func cmbDonateCustomC()
Local $combo1 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomC[0])
Local $combo2 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomC[1])
Local $combo3 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomC[2])
_GUICtrlSetImage($g_ahPicDonateCustomC[0], $g_sLibIconPath, $g_aiDonIcons[$combo1])
_GUICtrlSetImage($g_ahPicDonateCustomC[1], $g_sLibIconPath, $g_aiDonIcons[$combo2])
_GUICtrlSetImage($g_ahPicDonateCustomC[2], $g_sLibIconPath, $g_aiDonIcons[$combo3])
EndFunc
Func cmbDonateCustomD()
Local $combo1 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomD[0])
Local $combo2 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomD[1])
Local $combo3 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomD[2])
_GUICtrlSetImage($g_ahPicDonateCustomD[0], $g_sLibIconPath, $g_aiDonIcons[$combo1])
_GUICtrlSetImage($g_ahPicDonateCustomD[1], $g_sLibIconPath, $g_aiDonIcons[$combo2])
_GUICtrlSetImage($g_ahPicDonateCustomD[2], $g_sLibIconPath, $g_aiDonIcons[$combo3])
EndFunc
Func _DonateBtn($hFirstControl, $hLastControl)
Static $hLastDonateBtn1 = -1, $hLastDonateBtn2 = -1
If $hLastDonateBtn1 = -1 Then
For $i = $g_ahGrpDonateTroop[$eTroopBarbarian] To $g_ahTxtBlacklistTroop[$eTroopBarbarian]
GUICtrlSetState($i, $GUI_HIDE)
Next
Else
For $i = $hLastDonateBtn1 To $hLastDonateBtn2
GUICtrlSetState($i, $GUI_HIDE)
Next
EndIf
$hLastDonateBtn1 = $hFirstControl
$hLastDonateBtn2 = $hLastControl
For $i = $hFirstControl To $hLastControl
GUICtrlSetState($i, $GUI_SHOW)
Next
EndFunc
Func _DonateControls($iTroopIndex)
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "_DonateControls")
For $i = 0 To $eTroopCount-1 + $g_iCustomDonateConfigs
If $i = $iTroopIndex Then
GUICtrlSetBkColor($g_ahLblDonateTroop[$i], $COLOR_ORANGE)
Else
If GUICtrlGetBkColor($g_ahLblDonateTroop[$i]) = $COLOR_NAVY Then GUICtrlSetBkColor($g_ahLblDonateTroop[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
GUICtrlSetState($g_ahChkDonateAllTroop[$i], $GUI_UNCHECKED)
If BitAND(GUICtrlGetState($g_ahTxtDonateTroop[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtDonateTroop[$i], $GUI_ENABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistTroop[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtBlacklistTroop[$i], $GUI_ENABLE)
Next
SetRedrawBotWindowControls($bWasRedraw, $g_hGUI_DONATE_TAB, "_DonateControls")
EndFunc
Func _DonateAllControls($iTroopIndex, $Set)
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "_DonateAllControls")
If $Set = True Then
For $i = 0 To $eTroopCount-1 + $g_iCustomDonateConfigs
GUICtrlSetBkColor($g_ahLblDonateTroop[$i], $i = $iTroopIndex ? $COLOR_NAVY : $GUI_BKCOLOR_TRANSPARENT)
If $i <> $iTroopIndex Then
GUICtrlSetState($g_ahChkDonateAllTroop[$i], $GUI_UNCHECKED)
EndIf
GUICtrlSetState($g_ahChkDonateTroop[$i], $GUI_UNCHECKED)
If BitAND(GUICtrlGetState($g_ahTxtDonateTroop[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_ahTxtDonateTroop[$i], $GUI_DISABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistTroop[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_ahTxtBlacklistTroop[$i], $GUI_DISABLE)
Next
If BitAND(GUICtrlGetState($g_hTxtGeneralBlacklist), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_hTxtGeneralBlacklist, $GUI_DISABLE)
Else
GUICtrlSetBkColor($g_ahLblDonateTroop[$iTroopIndex], $GUI_BKCOLOR_TRANSPARENT)
For $i = 0 To $eTroopCount - 1
If BitAND(GUICtrlGetState($g_ahTxtDonateTroop[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtDonateTroop[$i], $GUI_ENABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistTroop[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtBlacklistTroop[$i], $GUI_ENABLE)
Next
If BitAND(GUICtrlGetState($g_hTxtGeneralBlacklist), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_hTxtGeneralBlacklist, $GUI_ENABLE)
EndIf
SetRedrawBotWindowControls($bWasRedraw, $g_hGUI_DONATE_TAB, "_DonateAllControls")
EndFunc
Func _DonateControlsSpell($iSpellIndex)
For $i = 0 To $eSpellCount - 1
If $i = $iSpellIndex Then
GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $COLOR_ORANGE)
Else
If GUICtrlGetBkColor($g_ahLblDonateSpell[$i]) = $COLOR_NAVY Then GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
GUICtrlSetState($g_ahChkDonateAllSpell[$i], $GUI_UNCHECKED)
If BitAND(GUICtrlGetState($g_ahTxtDonateSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtDonateSpell[$i], $GUI_ENABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtBlacklistSpell[$i], $GUI_ENABLE)
Next
EndFunc
Func _DonateAllControlsSpell($iSpellIndex, $Set)
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "_DonateAllControlsSpell")
If $Set = True Then
For $i = 0 To $eSpellCount - 1
If $i = $iSpellIndex Then
GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $COLOR_NAVY)
Else
GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
If $i <> $iSpellIndex Then GUICtrlSetState($g_ahChkDonateAllSpell[$i], $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkDonateSpell[$i], $GUI_UNCHECKED)
If BitAND(GUICtrlGetState($g_ahTxtDonateSpell[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_ahTxtDonateSpell[$i], $GUI_DISABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistSpell[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_ahTxtBlacklistSpell[$i], $GUI_DISABLE)
Next
If BitAND(GUICtrlGetState($g_hTxtGeneralBlacklist), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_hTxtGeneralBlacklist, $GUI_DISABLE)
Else
GUICtrlSetBkColor($g_ahLblDonateSpell[$iSpellIndex], $GUI_BKCOLOR_TRANSPARENT)
For $i = 0 To $eSpellCount - 1
If BitAND(GUICtrlGetState($g_ahTxtDonateSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtDonateSpell[$i], $GUI_ENABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtBlacklistSpell[$i], $GUI_ENABLE)
Next
If BitAND(GUICtrlGetState($g_hTxtGeneralBlacklist), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_hTxtGeneralBlacklist, $GUI_ENABLE)
EndIf
SetRedrawBotWindowControls($bWasRedraw, $g_hGUI_DONATE_TAB, "_DonateAllControlsSpell")
EndFunc
Func btnFilterDonationsCC()
SetLog("open folder " & $g_sProfileDonateCapturePath, $COLOR_AQUA)
ShellExecute("explorer", $g_sProfileDonateCapturePath)
EndFunc
Func chkskipDonateNearFulLTroopsEnable()
If GUICtrlRead($g_hChkSkipDonateNearFullTroopsEnable) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtSkipDonateNearFullTroopsPercentage, $GUI_ENABLE)
GUICtrlSetState($g_hLblSkipDonateNearFullTroopsText, $GUI_ENABLE)
GUICtrlSetState($g_hLblSkipDonateNearFullTroopsText1, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtSkipDonateNearFullTroopsPercentage, $GUI_DISABLE)
GUICtrlSetState($g_hLblSkipDonateNearFullTroopsText, $GUI_DISABLE)
GUICtrlSetState($g_hLblSkipDonateNearFullTroopsText1, $GUI_DISABLE)
EndIf
EndFunc
Func chkBalanceDR()
If GUICtrlRead($g_hChkUseCCBalanced) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbCCDonated, $GUI_ENABLE)
GUICtrlSetState($g_hCmbCCReceived, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbCCDonated, $GUI_DISABLE)
GUICtrlSetState($g_hCmbCCReceived, $GUI_DISABLE)
EndIf
EndFunc
Func cmbBalanceDR()
If _GUICtrlComboBox_GetCurSel($g_hCmbCCDonated) = _GUICtrlComboBox_GetCurSel($g_hCmbCCReceived) Then
_GUICtrlComboBox_SetCurSel($g_hCmbCCDonated, 0)
_GUICtrlComboBox_SetCurSel($g_hCmbCCReceived, 0)
EndIf
EndFunc
Func Doncheck()
tabDONATE()
EndFunc
Global $aLanguageFile[1][2]
Global $hLangIcons = 0
Func LoadLanguagesComboBox()
Local $hFileSearch = FileFindFirstFile($g_sDirLanguages & "*.ini")
Local $sFilename, $sLangDisplayName = "", $iFileIndex = 0
If $hLangIcons Then _GUIImageList_Destroy($hLangIcons)
$hLangIcons = _GUIImageList_Create(16, 16, 5)
While 1
$sFilename = FileFindNextFile($hFileSearch)
If @error Then ExitLoop
ReDim $aLanguageFile[$iFileIndex + 1][3]
$aLanguageFile[$iFileIndex][0] = StringLeft($sFilename, StringLen($sFilename) - 4)
$aLanguageFile[$iFileIndex][2] = _GUIImageList_AddIcon($hLangIcons, @ScriptDir & "\lib\MBRBot.dll", Eval("e" & $aLanguageFile[$iFileIndex][0]) - 1)
$sLangDisplayName = IniRead($g_sDirLanguages & $sFilename, "Language", "DisplayName", "Unknown")
$aLanguageFile[$iFileIndex][1] = $sLangDisplayName
If $sLangDisplayName = "Unknown" Then
IniWrite($g_sDirLanguages & $sFilename, "Language", "DisplayName", StringLeft($sFilename, StringLen($sFilename) - 4))
$sLangDisplayName = IniRead($g_sDirLanguages & $sFilename, "Language", "DisplayName", "Unknown")
$aLanguageFile[$iFileIndex][1] = $sLangDisplayName
EndIf
$iFileIndex += 1
WEnd
FileClose($hFileSearch)
_GUICtrlComboBox_ResetContent($g_hCmbGUILanguage)
_GUICtrlComboBoxEx_SetImageList($g_hCmbGUILanguage, $hLangIcons)
For $i = 0 To UBound($aLanguageFile) - 1
If $aLanguageFile[$i][2] <> -1 Then
_GUICtrlComboBoxEx_AddString($g_hCmbGUILanguage, $aLanguageFile[$i][1], $aLanguageFile[$i][2], $aLanguageFile[$i][2])
Else
_GUICtrlComboBoxEx_AddString($g_hCmbGUILanguage, $aLanguageFile[$i][1], $eMissingLangIcon, $eMissingLangIcon)
EndIf
Next
_GUICtrlComboBoxEx_SetCurSel($g_hCmbGUILanguage, _GUICtrlComboBoxEx_FindStringExact($g_hCmbGUILanguage, $aLanguageFile[_ArraySearch($aLanguageFile, $g_sLanguage)][1]))
EndFunc
Func cmbLanguage()
Local $aLanguage = _GUICtrlComboBox_GetListArray($g_hCmbGUILanguage)
Local $g_sLanguageIndex = _ArraySearch($aLanguageFile, $aLanguage[_GUICtrlComboBox_GetCurSel($g_hCmbGUILanguage) + 1])
$g_sLanguage = $aLanguageFile[$g_sLanguageIndex][0]
MsgBox("", "", GetTranslatedFileIni("MBR Popups", "Func_cmbLanguage", "Restart Bot to load program with new language:") & " " & $aLanguageFile[$g_sLanguageIndex][1] & " (" & $g_sLanguage & ")")
IniWriteS($g_sProfileConfigPath, "other", "language", $g_sLanguage)
RestartBot(False, False)
EndFunc
Func chkBotCustomTitleBarClick()
Local $bChecked = GUICtrlRead($g_hChkBotCustomTitleBarClick) = $GUI_CHECKED
$g_iBotDesignFlags = BitOR(BitAND($g_iBotDesignFlags, BitNOT(1)),(($bChecked) ? 1 : 0))
GUICtrlSetState($g_hChkBotAutoSlideClick,($bChecked ? $GUI_ENABLE : $GUI_DISABLE))
EndFunc
Func chkBotAutoSlideClick()
Local $bChecked = GUICtrlRead($g_hChkBotAutoSlideClick) = $GUI_CHECKED
$g_iBotDesignFlags = BitOR(BitAND($g_iBotDesignFlags, BitNOT(2)),(($bChecked) ? 2 : 0))
EndFunc
Func chkDisableNotifications()
$g_bDisableNotifications =(GUICtrlRead($g_hChkDisableNotifications) = $GUI_CHECKED)
EndFunc
Func chkUseRandomClick()
$g_bUseRandomClick =(GUICtrlRead($g_hChkUseRandomClick) = $GUI_CHECKED)
EndFunc
Func chkHideWhenMinimized()
$g_bHideWhenMinimized =(GUICtrlRead($g_hChkHideWhenMinimized) = $GUI_CHECKED)
TrayItemSetState($g_hTiHide,($g_bHideWhenMinimized = 1 ? $TRAY_CHECKED : $TRAY_UNCHECKED))
EndFunc
Func chkScreenshotType()
$g_bScreenshotPNGFormat =(GUICtrlRead($g_hChkScreenshotType) = $GUI_CHECKED)
EndFunc
Func chkScreenshotHideName()
$g_bScreenshotHideName =(GUICtrlRead($g_hChkScreenshotHideName) = $GUI_CHECKED)
EndFunc
Func chkDeleteLogs()
GUICtrlSetState($g_hTxtDeleteLogsDays, GUICtrlRead($g_hChkDeleteLogs) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkDeleteTemp()
GUICtrlSetState($g_hTxtDeleteTempDays, GUICtrlRead($g_hChkDeleteTemp) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkDeleteLoots()
GUICtrlSetState($g_hTxtDeleteLootsDays, GUICtrlRead($g_hChkDeleteLoots) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkAutoStart()
GUICtrlSetState($g_hTxtAutostartDelay, GUICtrlRead($g_hChkAutoStart) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkDisposeWindows()
If GUICtrlRead($g_hChkAutoAlign) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbAlignmentOptions, $GUI_ENABLE)
GUICtrlSetState($g_hTxtAlignOffsetX, $GUI_ENABLE)
GUICtrlSetState($g_hTxtAlignOffsetY, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbAlignmentOptions, $GUI_DISABLE)
GUICtrlSetState($g_hTxtAlignOffsetX, $GUI_DISABLE)
GUICtrlSetState($g_hTxtAlignOffsetY, $GUI_DISABLE)
EndIf
EndFunc
Func chkSinglePBTForced()
If GUICtrlRead($g_hChkSinglePBTForced) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtSinglePBTimeForced, $GUI_ENABLE)
GUICtrlSetState($g_hTxtPBTimeForcedExit, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtSinglePBTimeForced, $GUI_DISABLE)
GUICtrlSetState($g_hTxtPBTimeForcedExit, $GUI_DISABLE)
EndIf
txtSinglePBTimeForced()
EndFunc
Func txtSinglePBTimeForced()
Switch Int(GUICtrlRead($g_hTxtSinglePBTimeForced))
Case 0 To 15
GUICtrlSetBkColor($g_hTxtSinglePBTimeForced, $COLOR_ERROR)
Case 16
GUICtrlSetBkColor($g_hTxtSinglePBTimeForced, $COLOR_YELLOW)
Case 17 To 999
GUICtrlSetBkColor($g_hTxtSinglePBTimeForced, $COLOR_MONEYGREEN)
EndSwitch
Switch Int(GUICtrlRead($g_hTxtPBTimeForcedExit))
Case 0 To 11
GUICtrlSetBkColor($g_hTxtPBTimeForcedExit, $COLOR_ERROR)
Case 12 To 14
GUICtrlSetBkColor($g_hTxtPBTimeForcedExit, $COLOR_YELLOW)
Case 15 To 999
GUICtrlSetBkColor($g_hTxtPBTimeForcedExit, $COLOR_MONEYGREEN)
EndSwitch
EndFunc
Func chkAutoResume()
GUICtrlSetState($g_hTxtAutoResumeTime, GUICtrlRead($g_hChkAutoResume) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func txtGlobalActiveBotsAllowed()
Local $iValue = Int(GUICtrlRead($g_hTxtGlobalActiveBotsAllowed))
If $iValue < 1 Then
$iValue = 1
GUICtrlSetData($g_hTxtGlobalActiveBotsAllowed, $iValue)
EndIf
If $g_iGlobalActiveBotsAllowed <> $iValue Then
SetDebugLog("Maximum of " & $g_iGlobalActiveBotsAllowed & " bots running at same time changed to " & $iValue)
$g_iGlobalActiveBotsAllowed = $iValue
SaveProfileConfig(Default, True)
EndIf
EndFunc
Func txtGlobalThreads()
Local $iValue = Int(GUICtrlRead($g_hTxtGlobalThreads))
If $g_iGlobalThreads <> $iValue Then
SetDebugLog("Threading: Using " & $g_iGlobalThreads & " threads shared across all bot instances changed to " & $iValue)
$g_iGlobalThreads = $iValue
SaveProfileConfig(Default, True)
EndIf
EndFunc
Func txtThreads()
Local $iValue = Int(GUICtrlRead($g_hTxtThreads))
If $g_iThreads <> $iValue Then
SetDebugLog("Threading: Using " & $g_iThreads & " threads for parallelism changedd to " & $iValue)
$g_iThreads = $iValue
setMaxDegreeOfParallelism($g_iThreads)
EndIf
EndFunc
Func chkSwitchAcc()
If GUICtrlRead($g_hChkSwitchAcc) = $GUI_CHECKED And aquireSwitchAccountMutex($g_iCmbSwitchAcc, False, True) Then
For $i = $g_hCmbTotalAccount To $g_ahChkDonate[7]
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
releaseSwitchAccountMutex()
For $i = $g_hCmbTotalAccount To $g_ahChkDonate[7]
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func cmbSwitchAcc()
Return _cmbSwitchAcc()
EndFunc
Func _cmbSwitchAcc($bReadSaveConfig = True)
Static $s_bActive = False
If $s_bActive Then Return
$s_bActive = True
Local $iCmbSwitchAcc = _GUICtrlComboBox_GetCurSel($g_hCmbSwitchAcc)
Local $bAcquired = aquireSwitchAccountMutex($iCmbSwitchAcc, False, True)
Local $bEnable = False
If $iCmbSwitchAcc And $bAcquired Then
$bEnable = True
Else
If $g_iCmbSwitchAcc And $iCmbSwitchAcc = 0 Then
For $i = 0 To UBound($g_ahChkDonate) - 7
If GUICtrlRead($g_ahChkAccount[$i]) = $GUI_CHECKED And GUICtrlRead($g_ahCmbProfile[$i]) = $g_sProfileCurrentName Then
SetLog("Disabled Profile " & $g_sProfileCurrentName & " in Group " & $g_iCmbSwitchAcc)
SetSwitchAccLog("Disabled Profile " & $g_sProfileCurrentName & " in Group " & $g_iCmbSwitchAcc)
GUICtrlSetState($g_ahChkAccount[$i], $GUI_UNCHECKED)
ExitLoop
EndIf
Next
EndIf
If $iCmbSwitchAcc And Not $bAcquired Then
$iCmbSwitchAcc = $g_iCmbSwitchAcc
_GUICtrlComboBox_SetCurSel($g_hCmbSwitchAcc, $iCmbSwitchAcc)
$bAcquired = aquireSwitchAccountMutex($iCmbSwitchAcc, False, True)
$bEnable = $bAcquired
EndIf
EndIf
If $bReadSaveConfig Then
If $g_iCmbSwitchAcc Then
SetLog("Save Switch Accounts Group " & $g_iCmbSwitchAcc)
SetSwitchAccLog("Save Group " & $g_iCmbSwitchAcc)
_GUICtrlComboBox_SetCurSel($g_hCmbSwitchAcc, $g_iCmbSwitchAcc)
SaveConfig_600_35_2()
_GUICtrlComboBox_SetCurSel($g_hCmbSwitchAcc, $iCmbSwitchAcc)
EndIf
$g_iCmbSwitchAcc = $iCmbSwitchAcc
If $g_iCmbSwitchAcc Then
SetLog("Read Switch Accounts Group " & $g_iCmbSwitchAcc)
SetSwitchAccLog("Read Group " & $g_iCmbSwitchAcc)
EndIf
ReadConfig_SwitchAccounts()
ApplyConfig_600_35_2("Read")
Else
$g_iCmbSwitchAcc = $iCmbSwitchAcc
EndIf
If $bEnable And GUICtrlRead($g_hChkSwitchAcc) = $GUI_UNCHECKED Then
$bEnable = False
EndIf
GUICtrlSetState($g_hChkSwitchAcc,(($bEnable Or($iCmbSwitchAcc And $bAcquired)) ? $GUI_ENABLE : $GUI_DISABLE))
For $i = $g_hCmbTotalAccount To $g_ahChkDonate[7]
GUICtrlSetState($i,(($bEnable) ? $GUI_ENABLE : $GUI_DISABLE))
Next
cmbTotalAcc()
$s_bActive = False
EndFunc
Func cmbTotalAcc()
Local $iCmbTotalAcc = _GUICtrlComboBox_GetCurSel($g_hCmbTotalAccount) + 1
For $i = 0 To 7
If $iCmbTotalAcc >= 0 And $i <= $iCmbTotalAcc Then
_GUI_Value_STATE("SHOW", $g_ahChkAccount[$i] & "#" & $g_ahCmbProfile[$i] & "#" & $g_ahChkDonate[$i])
ElseIf $i > $iCmbTotalAcc Then
GUICtrlSetState($g_ahChkAccount[$i], $GUI_UNCHECKED)
_GUI_Value_STATE("HIDE", $g_ahChkAccount[$i] & "#" & $g_ahCmbProfile[$i] & "#" & $g_ahChkDonate[$i])
EndIf
chkAccount($i)
Next
EndFunc
Func chkSmartSwitch()
If GUICtrlRead($g_hChkSmartSwitch) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkDonateLikeCrazy, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkDonateLikeCrazy, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDonateLikeCrazy, $GUI_DISABLE)
EndIf
EndFunc
Func chkAccount($i)
If GUICtrlRead($g_ahChkAccount[$i]) = $GUI_CHECKED Then
_GUI_Value_STATE("ENABLE", $g_ahCmbProfile[$i] & "#" & $g_ahChkDonate[$i])
SwitchAccountCheckProfileInUse($g_asProfileName[$i])
Else
_GUI_Value_STATE("DISABLE", $g_ahCmbProfile[$i] & "#" & $g_ahChkDonate[$i])
EndIf
EndFunc
Func chkAccountX()
For $i = 0 To UBound($g_ahChkAccount) - 1
If @GUI_CtrlId = $g_ahChkAccount[$i] Then
Return chkAccount($i)
EndIf
Next
EndFunc
Func cmbSwitchAccProfile($i)
Local $sOldProfile = $g_asProfileName[$i]
Local $sNewProfile = GUICtrlRead($g_ahCmbProfile[$i])
SwitchAccountCheckProfileInUse($sNewProfile)
Local $sOthProfile
If $sNewProfile Then
For $j = 0 To UBound($g_ahCmbProfile) - 1
If $j <> $i Then
$sOthProfile = GUICtrlRead($g_ahCmbProfile[$j])
If $sOthProfile = $sNewProfile Then
$g_asProfileName[$j] = $sOldProfile
_GUICtrlComboBox_SetCurSel($g_ahCmbProfile[$j], _GUICtrlComboBox_FindStringExact($g_ahCmbProfile[$j], $sOldProfile))
ExitLoop
EndIf
EndIf
Next
EndIf
$g_asProfileName[$i] = $sNewProfile
EndFunc
Func cmbSwitchAccProfileX()
For $i = 0 To UBound($g_ahCmbProfile) - 1
If @GUI_CtrlId = $g_ahCmbProfile[$i] Then
Return cmbSwitchAccProfile($i)
EndIf
Next
EndFunc
Func chkAccSwitchMode()
If GUICtrlRead($g_hRadSwitchGooglePlay) = $GUI_CHECKED Then
$g_bChkGooglePlay = True
$g_bChkSuperCellID = False
$g_bChkSharedPrefs = False
ElseIf GUICtrlRead($g_hRadSwitchSuperCellID) = $GUI_CHECKED Then
$g_bChkGooglePlay = False
$g_bChkSuperCellID = True
$g_bChkSharedPrefs = False
ElseIf GUICtrlRead($g_hRadSwitchSharedPrefs) = $GUI_CHECKED Then
$g_bChkGooglePlay = False
$g_bChkSuperCellID = False
$g_bChkSharedPrefs = True
Else
$g_bChkGooglePlay = False
$g_bChkSuperCellID = False
$g_bChkSharedPrefs = False
EndIf
EndFunc
Func chkDebugSetLog()
$g_bDebugSetlog =(GUICtrlRead($g_hChkDebugSetlog) = $GUI_CHECKED)
SetDebugLog("DebugSetlog " &($g_bDebugSetlog ? "enabled" : "disabled"))
EndFunc
Func chkDebugAndroid()
$g_bDebugAndroid =(GUICtrlRead($g_hChkDebugAndroid) = $GUI_CHECKED)
SetDebugLog("DebugAndroid " &($g_bDebugAndroid ? "enabled" : "disabled"))
EndFunc
Func chkDebugClick()
$g_bDebugClick =(GUICtrlRead($g_hChkDebugClick) = $GUI_CHECKED)
SetDebugLog("DebugClick " &($g_bDebugClick ? "enabled" : "disabled"))
EndFunc
Func chkDebugFunc()
Local $bDebugFunc =(GUICtrlRead($g_hChkDebugFunc) = $GUI_CHECKED)
$g_bDebugFuncTime = $bDebugFunc
$g_bDebugFuncCall = $bDebugFunc
SetDebugLog("DebugFunc " &($bDebugFunc ? "enabled" : "disabled"))
EndFunc
Func chkDebugDisableZoomout()
$g_bDebugDisableZoomout =(GUICtrlRead($g_hChkDebugDisableZoomout) = $GUI_CHECKED)
SetDebugLog("DebugDisableZoomout " &($g_bDebugDisableZoomout ? "enabled" : "disabled"))
EndFunc
Func chkDebugDisableVillageCentering()
$g_bDebugDisableVillageCentering =(GUICtrlRead($g_hChkDebugDisableVillageCentering) = $GUI_CHECKED)
SetDebugLog("DebugDisableVillageCentering " &($g_bDebugDisableVillageCentering ? "enabled" : "disabled"))
EndFunc
Func chkDebugDeadbaseImage()
$g_bDebugDeadBaseImage =(GUICtrlRead($g_hChkDebugDeadbaseImage) = $GUI_CHECKED)
SetDebugLog("DebugDeadbaseImage " &($g_bDebugDeadBaseImage ? "enabled" : "disabled"))
EndFunc
Func chkDebugOcr()
$g_bDebugOcr =(GUICtrlRead($g_hChkDebugOCR) = $GUI_CHECKED)
SetDebugLog("DebugOcr " &($g_bDebugOcr ? "enabled" : "disabled"))
EndFunc
Func chkDebugImageSave()
$g_bDebugImageSave =(GUICtrlRead($g_hChkDebugImageSave) = $GUI_CHECKED)
SetDebugLog("DebugImageSave " &($g_bDebugImageSave ? "enabled" : "disabled"))
EndFunc
Func chkDebugBuildingPos()
$g_bDebugBuildingPos =(GUICtrlRead($g_hChkdebugBuildingPos) = $GUI_CHECKED)
SetDebugLog("DebugBuildingPos " &($g_bDebugBuildingPos ? "enabled" : "disabled"))
EndFunc
Func chkDebugTrain()
$g_bDebugSetlogTrain =(GUICtrlRead($g_hChkdebugTrain) = $GUI_CHECKED)
SetDebugLog("DebugTrain " &($g_bDebugSetlogTrain ? "enabled" : "disabled"))
EndFunc
Func chkdebugOCRDonate()
$g_bDebugOCRdonate =(GUICtrlRead($g_hChkDebugOCRDonate) = $GUI_CHECKED)
SetDebugLog("DebugOCRDonate " &($g_bDebugOCRdonate ? "enabled" : "disabled"))
EndFunc
Func chkdebugAttackCSV()
$g_bDebugAttackCSV =(GUICtrlRead($g_hChkdebugAttackCSV) = $GUI_CHECKED)
SetDebugLog("DebugAttackCSV " &($g_bDebugAttackCSV ? "enabled" : "disabled"))
EndFunc
Func chkmakeIMGCSV()
$g_bDebugMakeIMGCSV =(GUICtrlRead($g_hChkMakeIMGCSV) = $GUI_CHECKED)
SetDebugLog("MakeIMGCSV " &($g_bDebugMakeIMGCSV ? "enabled" : "disabled"))
EndFunc
Func btnTestTrain()
Local $currentOCR = $g_bDebugOcr
Local $currentRunState = $g_bRunState
$g_bRunState = True
BeginImageTest()
Local $result
SetLog("Testing checkArmyCamp()", $COLOR_INFO)
$result = checkArmyCamp()
If @error Then $result = "Error " & @error & ", " & @extended & ", " &((IsArray($result)) ?(_ArrayToString($result, ",")) :($result))
SetLog("Result checkArmyCamp() = " &((IsArray($result)) ?("Array: " & _ArrayToString($result, ",")) :($result)), $COLOR_INFO)
SetLog("Testing getArmyHeroTime()", $COLOR_INFO)
$result = getArmyHeroTime("all")
If @error Then $result = "Error " & @error & ", " & @extended & ", " &((IsArray($result)) ?(_ArrayToString($result, ",")) :($result))
SetLog("Result getArmyHeroTime() = " &((IsArray($result)) ?("Array: " & _ArrayToString($result, ",")) :($result)), $COLOR_INFO)
$result = ""
SetLog("Testing ArmyHeroStatus()", $COLOR_INFO)
For $i = 0 To 2
$result &= " " & ArmyHeroStatus($i)
Next
If @error Then $result = "Error " & @error & ", " & @extended & ", " &((IsArray($result)) ?(_ArrayToString($result, ",")) :($result))
SetLog("Result ArmyHeroStatus(0, 1, 2) = " &((IsArray($result)) ?("Array: " & _ArrayToString($result, ",")) :($result)), $COLOR_INFO)
SetLog("Testing GetCurCCSpell()", $COLOR_INFO)
$result = GetCurCCSpell(1)
If @error Then $result = "Error " & @error & ", " & @extended & ", " &((IsArray($result)) ?("Array: " & _ArrayToString($result, ",")) :($result))
SetLog("Result GetCurCCSpell(1) = " &((IsArray($result)) ?("Array: " & _ArrayToString($result, ",")) :($result)), $COLOR_INFO)
$result = GetCurCCSpell(2)
If @error Then $result = "Error " & @error & ", " & @extended & ", " &((IsArray($result)) ?("Array: " & _ArrayToString($result, ",")) :($result))
SetLog("Result GetCurCCSpell(2) = " &((IsArray($result)) ?("Array: " & _ArrayToString($result, ",")) :($result)), $COLOR_INFO)
SetLog("Testing Train DONE", $COLOR_INFO)
EndImageTest()
$g_bDebugOcr = $currentOCR
$g_bRunState = $currentRunState
EndFunc
Func btnTestDonateCC()
Local $currentOCR = $g_bDebugOcr
Local $currentRunState = $g_bRunState
Local $currentSetlog = $g_bDebugSetlog
_GUICtrlTab_ClickTab($g_hTabMain, 0)
$g_bDebugOcr = True
$g_bRunState = True
$g_bDebugSetlog = True
ForceCaptureRegion()
DebugImageSave("donateCC_")
SetLog(_PadStringCenter(" Test DonateCC begin (" & $g_sBotVersion & ")", 54, "="), $COLOR_INFO)
$g_iDonationWindowY = 0
Local $aDonWinOffColors[3][3] = [[0xFFFFFF, 0, 1], [0xFFFFFF, 0, 31], [0xABABA8, 0, 32]]
Local $aDonationWindow = _MultiPixelSearch(409, 0, 410, $g_iDEFAULT_HEIGHT, 1, 1, Hex(0xFFFFFF, 6), $aDonWinOffColors, 10)
If IsArray($aDonationWindow) Then
$g_iDonationWindowY = $aDonationWindow[1]
_Sleep(250)
SetLog("$DonationWindowY: " & $g_iDonationWindowY, $COLOR_DEBUG)
Else
SetLog("Could not find the Donate Window :(", $COLOR_ERROR)
Return False
EndIf
SetLog("Detecting Troops...")
DetectSlotTroop($eBowl)
SetLog("Detecting Spells...")
DetectSlotTroop($eSkSpell)
SetLog(_PadStringCenter(" Test DonateCC end ", 54, "="), $COLOR_INFO)
ShellExecute($g_sProfileTempDebugPath & "donateCC_")
$g_bDebugOcr = $currentOCR
$g_bRunState = $currentRunState
$g_bDebugSetlog = $currentSetlog
EndFunc
Func btnTestRequestCC()
Local $currentRunState = $g_bRunState
$g_bRunState = True
$g_bCanRequestCC = True
SetLog(_PadStringCenter(" Test RequestCC begin (" & $g_sBotVersion & ")", 54, "="), $COLOR_INFO)
RequestCC()
SetLog(_PadStringCenter(" Test RequestCC end ", 54, "="), $COLOR_INFO)
$g_bRunState = $currentRunState
EndFunc
Func btnTestSendText()
Local $currentRunState = $g_bRunState
$g_bRunState = True
SetLog(_PadStringCenter(" Test SendText begin (" & $g_sBotVersion & ")", 54, "="), $COLOR_INFO)
Local $s = InputBox("Send characters to Android", "Text to send (please open a input box in Android):", "some text ;-)", "")
SendText($s)
SetLog(_PadStringCenter(" Test SendText end ", 54, "="), $COLOR_INFO)
$g_bRunState = $currentRunState
EndFunc
Func btnTestAttackBar()
BeginImageTest()
Local $currentOCR = $g_bDebugOcr
Local $currentRunState = $g_bRunState
_GUICtrlTab_ClickTab($g_hTabMain, 0)
$g_bDebugOcr = True
$g_bRunState = True
ForceCaptureRegion()
SetLog(_PadStringCenter(" Test Attack Bar begin (" & $g_sBotVersion & ")", 54, "="), $COLOR_INFO)
_CaptureRegion2(0, 571 + $g_iBottomOffsetY, 859, 671 + $g_iBottomOffsetY)
Local $result = DllCallMyBot("searchIdentifyTroop", "ptr", $g_hHBitmap2)
SetLog("DLL Troopsbar list: " & $result[0], $COLOR_DEBUG)
If $g_bForceClanCastleDetection Then $result[0] = FixClanCastle($result[0])
Local $aTroopDataList = StringSplit($result[0], "|")
If $result[0] <> "" Then
For $i = 1 To $aTroopDataList[0]
Local $troopData = StringSplit($aTroopDataList[$i], "#", $STR_NOCOUNT)
If $troopData[0] = 17 Or $troopData[0] = 18 Or $troopData[0] = 19 Or $troopData[0] = 20 Then $troopData[2] = 1
SetLog("position: " & $troopData[1] & " | troop code: " & $troopData[0] & " troop name:" & NameOfTroop($troopData[0]) & " | qty: " & $troopData[2])
Next
EndIf
_CaptureRegion(0, 630, $g_iDEFAULT_WIDTH)
Local $savefolder = $g_sProfileTempDebugPath
$savefolder = $g_sProfileTempDebugPath & "Test_Attack_Bar\"
DirCreate($savefolder)
Local $debugfile
Local $Date = @MDAY & "." & @MON & "." & @YEAR
Local $Time = @HOUR & "." & @MIN & "." & @SEC
$debugfile = "Test_Attack_Bar_" & $g_sBotVersion & "_" & $Date & "_" & $Time & ".png"
_GDIPlus_ImageSaveToFile($g_hBitmap, $savefolder & $debugfile)
EndImageTest()
SetLog(_PadStringCenter(" Test Attack Bar end ", 54, "="), $COLOR_INFO)
ShellExecute($savefolder)
$g_bDebugOcr = $currentOCR
$g_bRunState = $currentRunState
EndFunc
Func btnTestClickDrag()
Local $sUserInputCoor = InputBox("Coordinators", "x1,y1,x2,y2", "650,473,323,473")
Local $asCoor = StringSplit($sUserInputCoor, ",")
If @error Or $asCoor[0] <> 4 Then
SetLog("Please try again with the correct format...", $COLOR_ERROR)
Return
EndIf
SetLog("Testing Click drag functionality...", $COLOR_INFO)
SetLog("Drag from (" & $asCoor[1] & "," & $asCoor[2] & ") to (" & $asCoor[3] & "," & $asCoor[4] & ")", $COLOR_DEBUG)
ClickDrag(Int($asCoor[1]), Int($asCoor[2]), Int($asCoor[3]), Int($asCoor[4]))
SetLog("Sleep 3 seconds...", $COLOR_DEBUG)
_Sleep(3000, True, False)
SetLog("Save the image...", $COLOR_DEBUG)
DebugImageSave("TestClickDrag")
SetLog("Sleep 1 seconds...", $COLOR_DEBUG)
_Sleep(1000, True, False)
SetLog("Drag back", $COLOR_DEBUG)
ClickDrag(Int($asCoor[3]), Int($asCoor[4]), Int($asCoor[1]), Int($asCoor[2]))
EndFunc
Func btnTestImage()
Local $sImageFile = BeginImageTest()
If $sImageFile = False Then $sImageFile = "Live Screenshot"
Local $i
Local $result
Local $currentRunState = $g_bRunState
$g_bRunState = True
For $i = 0 To 0
SetLog("Testing isProblemAffect...", $COLOR_SUCCESS)
$result = isProblemAffect(False)
SetLog("Testing isProblemAffect DONE, $Result=" & $result, $COLOR_SUCCESS)
SetLog("Testing checkObstacles...", $COLOR_SUCCESS)
$result = checkObstacles()
SetLog("Testing checkObstacles DONE, $Result=" & $result, $COLOR_SUCCESS)
SetLog("Testing waitMainScreen...", $COLOR_SUCCESS)
$result = waitMainScreen()
SetLog("Testing waitMainScreen DONE, $Result=" & $result, $COLOR_SUCCESS)
SetLog("Testing waitMainScreenMini...", $COLOR_SUCCESS)
$result = waitMainScreenMini()
SetLog("Testing waitMainScreenMini DONE, $Result=" & $result, $COLOR_SUCCESS)
SetLog("Testing WaitForClouds...", $COLOR_SUCCESS)
SetLog("$aNoCloudsAttack pixel check: " & _CheckPixel($aNoCloudsAttack, $g_bCapturePixel))
SetLog("Testing WaitForClouds DONE", $COLOR_SUCCESS)
Next
SetLog("Testing finished", $COLOR_INFO)
EndImageTest()
$g_bRunState = $currentRunState
EndFunc
Func btnTestVillageSize()
BeginImageTest()
Local $currentRunState = $g_bRunState
$g_bRunState = True
_CaptureRegion()
_CaptureRegion2Sync()
Local $a[2][2] = [["stone", "tree"], ["2stone", "2tree"]]
For $i = 0 To 1
SetLog("Testing GetVillageSize(True, """ & $a[$i][0] & """, """ & $a[$i][1] & """)", $COLOR_INFO)
Local $hTimer = __TimerInit()
Local $village = GetVillageSize(True, $a[$i][0], $a[$i][1])
Local $ms = __TimerDiff($hTimer)
If $village = 0 Then
SetLog("Village not found (" & Round($ms, 0) & " ms.)", $COLOR_WARNING)
Else
SetLog("Village found (" & Round($ms, 0) & " ms.)", $COLOR_WARNING)
SetLog("Village size: " & $village[0])
SetLog("Village zoom level: " & $village[1])
SetLog("Village offset x: " & $village[2])
SetLog("Village offset y: " & $village[3])
SetLog("Village stone " & $village[6] & ": " & $village[4] & ", " & $village[5])
SetLog("Village tree " & $village[9] & ": " & $village[7] & ", " & $village[8])
EndIf
Next
EndImageTest()
$g_bRunState = $currentRunState
EndFunc
Func btnTestDeadBase()
Local $hBMP = 0, $hHBMP = 0
Local $sImageFile = FileOpenDialog("Select CoC screenshot to test, cancel to use live screenshot", $g_sProfileTempPath, "Image (*.png)", $FD_FILEMUSTEXIST, "", $g_hFrmBot)
If @error <> 0 Then
SetLog("Testing image cancelled, taking screenshot from " & $g_sAndroidEmulator, $COLOR_INFO)
_CaptureRegion()
$hHBMP = $g_hHBitmap
TestCapture($hHBMP)
Else
SetLog("Testing image " & $sImageFile, $COLOR_INFO)
$hBMP = _GDIPlus_BitmapCreateFromFile($sImageFile)
$hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap($hBMP)
_GDIPlus_BitmapDispose($hBMP)
TestCapture($hHBMP)
SetLog("Testing image hHBitmap = " & $hHBMP)
EndIf
Local $currentRunState = $g_bRunState
$g_bRunState = True
SearchZoomOut($aCenterEnemyVillageClickDrag, True, "btnTestDeadBase")
ResetTHsearch()
SetLog("Testing FindTownhall()", $COLOR_INFO)
SetLog("FindTownhall() = " & FindTownhall(True), $COLOR_INFO)
SetLog("$g_sImglocRedline = " & $g_sImglocRedline, $COLOR_INFO)
SetLog("Testing checkDeadBase()", $COLOR_INFO)
SetLog("Result checkDeadBase() = " & checkDeadBase(), $COLOR_INFO)
SetLog("Testing checkDeadBase() DONE", $COLOR_INFO)
If $hHBMP <> 0 Then
_WinAPI_DeleteObject($hHBMP)
TestCapture(0)
EndIf
$g_bRunState = $currentRunState
EndFunc
Func btnTestDeadBaseFolder()
Local $directory = FileSelectFolder("Select folder of CoC village screenshot to test for dead base", "", $FSF_NEWDIALOG, @ScriptDir, $g_hFrmBot)
If @error <> 0 Then
SetLog("btnTestDeadBaseFolder cancelled", $COLOR_INFO)
EndIf
Local $oldFill = 'checkDeadBaseSuperNew(False, "' & @ScriptDir & "\imgxml\deadbase\elix\fill\old\" & '")'
Local $newFill = 'checkDeadBaseSuperNew(False, "' & @ScriptDir & "\imgxml\deadbase\elix\fill\new\" & '")'
checkDeadBaseFolder($directory, $oldFill, $newFill)
EndFunc
Func btnTestAttackCSV()
BeginImageTest()
Local $currentRunState = $g_bRunState
Local $currentDebugAttackCSV = $g_bDebugAttackCSV
Local $currentMakeIMGCSV = $g_bDebugMakeIMGCSV
Local $currentiMatchMode = $g_iMatchMode
Local $currentdebugsetlog = $g_bDebugSetlog
Local $currentDebugBuildingPos = $g_bDebugBuildingPos
$g_bRunState = True
$g_bDebugAttackCSV = True
$g_bDebugMakeIMGCSV = True
$g_bDebugSetlog = True
$g_bDebugBuildingPos = True
$g_iMatchMode = $DB
SearchZoomOut($aCenterEnemyVillageClickDrag, True, "btnTestAttackCSV")
ResetTHsearch()
SetLog("Testing FindTownhall()", $COLOR_INFO)
SetLog("FindTownhall() = " & FindTownhall(True), $COLOR_INFO)
SetLog("$g_sImglocRedline = " & $g_sImglocRedline, $COLOR_INFO)
SetLog("Testing PrepareAttack()", $COLOR_INFO)
PrepareAttack($g_iMatchMode)
SetLog("Testing Algorithm_AttackCSV()", $COLOR_INFO)
Algorithm_AttackCSV(True, False)
SetLog("Testing Algorithm_AttackCSV() DONE", $COLOR_INFO)
EndImageTest()
$g_bRunState = $currentRunState
$g_bDebugAttackCSV = $currentDebugAttackCSV
$g_bDebugMakeIMGCSV = $currentMakeIMGCSV
$g_iMatchMode = $currentiMatchMode
$g_bDebugSetlog = $currentdebugsetlog
$g_bDebugBuildingPos = $currentDebugBuildingPos
EndFunc
Func btnTestGetLocationBuilding()
Local $aResult, $iBdlgFindTime, $hTimer
BeginImageTest()
Local $currentRunState = $g_bRunState
Local $currentDebugBuildingPos = $g_bDebugBuildingPos
Local $currentdebugsetlog = $g_bDebugSetlog
$g_bRunState = True
$g_bDebugBuildingPos = True
$g_bDebugSetlog = True
SearchZoomOut($aCenterEnemyVillageClickDrag, True, "btnTestAttackCSV")
ResetTHsearch()
SetLog("Testing FindTownhall()", $COLOR_INFO)
SetLog("FindTownhall() = " & FindTownhall(True), $COLOR_INFO)
_LogObjList($g_oBldgAttackInfo)
SetLog("Testing GetLocationBuilding() with all buildings", $COLOR_INFO)
For $b = $eBldgGoldS To $eBldgAirDefense
If $b = $eBldgDarkS Then ContinueLoop
$aResult = GetLocationBuilding($b, $g_iSearchTH, False)
If $aResult = -1 Then SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$b], $COLOR_ERROR)
Next
_LogObjList($g_oBldgAttackInfo)
btnTestGetLocationBuildingImage()
Local $string, $iFindBldgTotalTestTime
Local $iKeys = $g_oBldgAttackInfo.Keys
For $string In $iKeys
If StringInStr($string, "_FINDTIME", $STR_NOCASESENSEBASIC) > 0 Then $iFindBldgTotalTestTime += $g_oBldgAttackInfo.item($string)
Next
SetLog("GetLocationBuilding() Total Image search time= " & $iFindBldgTotalTestTime, $COLOR_SUCCESS)
$g_oBldgAttackInfo.RemoveAll
SetLog("Testing DONE", $COLOR_INFO)
EndImageTest()
$g_bRunState = $currentRunState
$g_bDebugBuildingPos = $currentDebugBuildingPos
$g_bDebugSetlog = $currentdebugsetlog
EndFunc
Func btnTestGetLocationBuildingImage()
Local $iTimer = __TimerInit()
_CaptureRegion2()
Local $EditedImage = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($EditedImage)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
Local $pixel
Local $hPenWhite = _GDIPlus_PenCreate(0xFFFFFFFF, 2)
Local $hPenMagenta = _GDIPlus_PenCreate(0xFFFF00F6, 2)
Local $hPenRed = _GDIPlus_PenCreate(0xFFFF0000, 2)
Local $hPenNavyBlue = _GDIPlus_PenCreate(0xFF000066, 2)
Local $hPenBlue = _GDIPlus_PenCreate(0xFF0000CC, 2)
Local $hPenSteelBlue = _GDIPlus_PenCreate(0xFF0066CC, 2)
Local $hPenLtBlue = _GDIPlus_PenCreate(0xFF0080FF, 2)
Local $hPenPaleBlue = _GDIPlus_PenCreate(0xFF66B2FF, 2)
Local $hPenCyan = _GDIPlus_PenCreate(0xFF00FFFF, 2)
If $g_oBldgAttackInfo.exists($eBldgGoldS & "_LOCATION") Then
$g_aiCSVGoldStoragePos = $g_oBldgAttackInfo.item($eBldgGoldS & "_LOCATION")
If IsArray($g_aiCSVGoldStoragePos) Then
For $i = 0 To UBound($g_aiCSVGoldStoragePos) - 1
$pixel = $g_aiCSVGoldStoragePos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 15, 20, 20, $hPenMagenta)
Next
EndIf
EndIf
If $g_oBldgAttackInfo.exists($eBldgElixirS & "_LOCATION") Then
$g_aiCSVElixirStoragePos = $g_oBldgAttackInfo.item($eBldgElixirS & "_LOCATION")
If IsArray($g_aiCSVElixirStoragePos) Then
For $i = 0 To UBound($g_aiCSVElixirStoragePos) - 1
$pixel = $g_aiCSVElixirStoragePos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 15, 20, 20, $hPenWhite)
Next
EndIf
EndIf
_GDIPlus_GraphicsDrawRect($hGraphic, $g_iTHx - 5, $g_iTHy - 10, 30, 30, $hPenRed)
If $g_oBldgAttackInfo.exists($eBldgEagle & "_LOCATION") Then
$g_aiCSVEagleArtilleryPos = $g_oBldgAttackInfo.item($eBldgEagle & "_LOCATION")
If IsArray($g_aiCSVEagleArtilleryPos[0]) Then
Local $sPixel = $g_aiCSVEagleArtilleryPos[0]
_GDIPlus_GraphicsDrawRect($hGraphic, $sPixel[0] - 15, $sPixel[1] - 15, 30, 30, $hPenBlue)
EndIf
EndIf
If $g_oBldgAttackInfo.exists($eBldgInferno & "_LOCATION") Then
$g_aiCSVInfernoPos = $g_oBldgAttackInfo.item($eBldgInferno & "_LOCATION")
If IsArray($g_aiCSVInfernoPos) Then
For $i = 0 To UBound($g_aiCSVInfernoPos) - 1
$pixel = $g_aiCSVInfernoPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 10, 20, 20, $hPenNavyBlue)
Next
EndIf
EndIf
If $g_oBldgAttackInfo.exists($eBldgXBow & "_LOCATION") Then
$g_aiCSVXBowPos = $g_oBldgAttackInfo.item($eBldgXBow & "_LOCATION")
If IsArray($g_aiCSVXBowPos) Then
For $i = 0 To UBound($g_aiCSVXBowPos) - 1
$pixel = $g_aiCSVXBowPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 25, 25, 25, $hPenBlue)
Next
EndIf
EndIf
If $g_oBldgAttackInfo.exists($eBldgWizTower & "_LOCATION") Then
$g_aiCSVWizTowerPos = $g_oBldgAttackInfo.item($eBldgWizTower & "_LOCATION")
If IsArray($g_aiCSVWizTowerPos) Then
For $i = 0 To UBound($g_aiCSVWizTowerPos) - 1
$pixel = $g_aiCSVWizTowerPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 5, $pixel[1] - 15, 25, 25, $hPenSteelBlue)
Next
EndIf
EndIf
If $g_oBldgAttackInfo.exists($eBldgMortar & "_LOCATION") Then
$g_aiCSVMortarPos = $g_oBldgAttackInfo.item($eBldgMortar & "_LOCATION")
If IsArray($g_aiCSVMortarPos) Then
For $i = 0 To UBound($g_aiCSVMortarPos) - 1
$pixel = $g_aiCSVMortarPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 15, 25, 25, $hPenLtBlue)
Next
EndIf
EndIf
If $g_oBldgAttackInfo.exists($eBldgAirDefense & "_LOCATION") Then
$g_aiCSVAirDefensePos = $g_oBldgAttackInfo.item($eBldgAirDefense & "_LOCATION")
If IsArray($g_aiCSVAirDefensePos) Then
For $i = 0 To UBound($g_aiCSVAirDefensePos) - 1
$pixel = $g_aiCSVAirDefensePos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 12, $pixel[1] - 10, 25, 25, $hPenPaleBlue)
Next
EndIf
EndIf
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = $g_sProfileTempDebugPath & String("GetLocationBuilding_" & $Date & "_" & $Time) & ".jpg"
_GDIPlus_ImageSaveToFile($EditedImage, $filename)
SetLog("GetLocationBuilding image saved: " & $filename)
_GDIPlus_PenDispose($hPenWhite)
_GDIPlus_PenDispose($hPenMagenta)
_GDIPlus_PenDispose($hPenRed)
_GDIPlus_PenDispose($hPenBlue)
_GDIPlus_PenDispose($hPenNavyBlue)
_GDIPlus_PenDispose($hPenSteelBlue)
_GDIPlus_PenDispose($hPenLtBlue)
_GDIPlus_PenDispose($hPenPaleBlue)
_GDIPlus_PenDispose($hPenCyan)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($EditedImage)
If TestCapture() Then
ShellExecute($filename)
EndIf
SetLog("GetLocationBuilding DEBUG IMAGE Create Required: " & Round((__TimerDiff($iTimer) * 0.001), 1) & "Seconds", $COLOR_DEBUG)
EndFunc
Func btnTestFindButton()
BeginImageTest()
Local $result
Local $sButton = GUICtrlRead($g_hTxtTestFindButton)
SetLog("Testing findButton(""" & $sButton & """)", $COLOR_INFO)
$result = findButton($sButton)
$result =((IsArray($result)) ?(_ArrayToString($result, ",")) :($result))
If @error Then $result = "Error " & @error & ", " & @extended & ", "
SetLog("Result findButton(""" & $sButton & """) = " & $result, $COLOR_INFO)
SetLog("Testing findButton(""" & $sButton & """) DONE", $COLOR_INFO)
EndImageTest()
EndFunc
Func btnTestCleanYard()
Local $currentRunState = $g_bRunState
Local $iCurrFreeBuilderCount = $g_iFreeBuilderCount
$g_iTestFreeBuilderCount = 5
$g_bRunState = True
BeginImageTest()
Local $result
SetLog("Testing CleanYard", $COLOR_INFO)
SearchZoomOut($aCenterEnemyVillageClickDrag, True, "btnTestCleanYard")
$result = CleanYard()
$result =((IsArray($result)) ?(_ArrayToString($result, ",")) :($result))
If @error Then $result = "Error " & @error & ", " & @extended & ", "
SetLog("Result CleanYard", $COLOR_INFO)
SetLog("Testing CheckTombs", $COLOR_INFO)
$result = CheckTombs()
$result =((IsArray($result)) ?(_ArrayToString($result, ",")) :($result))
If @error Then $result = "Error " & @error & ", " & @extended & ", "
SetLog("Result CheckTombs", $COLOR_INFO)
SetLog("Testing CleanYard DONE", $COLOR_INFO)
EndImageTest()
$g_iTestFreeBuilderCount = -1
$g_iFreeBuilderCount = $iCurrFreeBuilderCount
$g_bRunState = $currentRunState
EndFunc
Func BeginImageTest($directory = $g_sProfileTempPath)
Local $hBMP = 0, $hHBMP = 0
Local $sImageFile = FileOpenDialog("Select CoC screenshot to test, cancel to use live screenshot", $directory, "Image (*.png)", $FD_FILEMUSTEXIST, "", $g_hFrmBot)
If @error <> 0 Then
SetLog("Testing image cancelled, taking screenshot from " & $g_sAndroidEmulator, $COLOR_INFO)
_CaptureRegion()
$hHBMP = $g_hHBitmap
TestCapture($hHBMP)
Return False
EndIf
SetLog("Testing image " & $sImageFile, $COLOR_INFO)
$hBMP = _GDIPlus_BitmapCreateFromFile($sImageFile)
$hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap($hBMP)
_GDIPlus_BitmapDispose($hBMP)
TestCapture($hHBMP)
SetLog("Testing image hHBitmap = " & $hHBMP)
Return $sImageFile
EndFunc
Func EndImageTest()
TestCapture(0)
EndFunc
Func FixClanCastle($inputString)
Local $OutputFinal = ""
Local $aTroopDataList = StringSplit($inputString, "|")
Local $counter = 0
If $inputString <> "" Then
For $i = 1 To $aTroopDataList[0]
If $counter > 0 Then $OutputFinal &= "|"
Local $troopData = StringSplit($aTroopDataList[$i], "#", $STR_NOCOUNT)
If $troopData[0] = 17 Or $troopData[0] = 18 Or $troopData[0] = 19 Or $troopData[0] = 20 Then $troopData[2] = 1
If $counter <> Number($troopData[1]) Then
$OutputFinal &= $eCastle & "#" & $counter & "#" & "1" & "|"
$counter = $troopData[1]
SetLog("Clan castle Forced in slot " & $counter, $COLOR_INFO)
EndIf
$counter += 1
$OutputFinal &= $troopData[0] & "#" & $troopData[1] & "#" & $troopData[2]
Next
EndIf
Return $OutputFinal
EndFunc
Func btnTestOcrMemory()
_CaptureRegion2(162, 200, 162 + 120, 200 + 27)
For $i = 1 To 5000
DllCallMyBot("ocr", "ptr", $g_hHBitmap2, "str", "coc-DonTroops", "int", $g_bDebugOcr ? 1 : 0)
Next
EndFunc
Func btnTestWeakBase()
Local $currentRunState = $g_bRunState
$g_bRunState = True
BeginImageTest()
IsWeakBase()
EndImageTest()
$g_bRunState = $currentRunState
EndFunc
Func btnTestClickAway()
ClickP($aAway, 2, 0)
EndFunc
Func btnTestUpgradeWindow()
Local $currentRunState = $g_bRunState
Local $iCurrFreeBuilderCount = $g_iFreeBuilderCount
$g_iTestFreeBuilderCount = 5
$g_bRunState = True
BeginImageTest()
Local $result
SetLog("Testing LocateUpgrade", $COLOR_INFO)
SetLog("Result = " & $result, $COLOR_INFO)
EndImageTest()
$g_iTestFreeBuilderCount = -1
$g_iFreeBuilderCount = $iCurrFreeBuilderCount
$g_bRunState = $currentRunState
EndFunc
Func btnTestSmartWait()
Local $currentRunState = $g_bRunState
Local $bCloseWhileTrainingEnable = $g_bCloseWhileTrainingEnable
$g_bRunState = True
$g_bCloseWhileTrainingEnable = True
SmartWait4Train(20)
$g_bRunState = $currentRunState
$g_bCloseWhileTrainingEnable = $bCloseWhileTrainingEnable
EndFunc
Func btnConsoleWindow()
ConsoleWindow()
EndFunc
Func PopulatePresetComboBox()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sProfilePresetPath & "\*.ini")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbPresetList)
GUICtrlSetData($g_hCmbPresetList, $output)
EndFunc
Func PresetLoadConfigInfo()
Local $inputfilename = $g_sProfilePresetPath & "\" & GUICtrlRead($g_hCmbPresetList) & ".ini"
SetDebugLog("PresetLoadConfigInfo: " & $inputfilename)
Local $message = IniRead($inputfilename, "Preset", "info", "")
If StringInStr($message, "\n") > 0 Then
GUICtrlSetData($g_hTxtPresetMessage, StringReplace($message, "\n", @CRLF))
Else
GUICtrlSetData($g_hTxtPresetMessage, $message)
EndIf
GUICtrlSetState($g_hLblLoadPresetMessage, $GUI_HIDE)
GUICtrlSetState($g_hTxtPresetMessage, $GUI_SHOW)
GUICtrlSetState($g_hBtnGUIPresetLoadConf, $GUI_SHOW)
GUICtrlSetState($g_hBtnGUIPresetDeleteConf, $GUI_SHOW + $GUI_DISABLE)
GUICtrlSetState($g_hChkDeleteConf, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDeleteConf, $GUI_SHOW)
EndFunc
Func PresetLoadConf()
Local $filename = GUICtrlRead($g_hCmbPresetList)
$g_sProfileSecondaryInputFileName = $g_sProfilePresetPath & "\" & $filename & ".ini"
SetDebugLog("PresetLoadConf: " & $g_sProfileSecondaryInputFileName)
SaveConfig()
readConfig()
applyConfig(False)
_GUICtrlTab_ClickTab($g_hTabMain, 0)
SetRedrawBotWindow(True, Default, Default, Default, "PresetLoadConf")
SetLog("Config " & $filename & " LOADED!", $COLOR_SUCCESS)
$g_sProfileSecondaryInputFileName = ""
EndFunc
Func PresetSaveConf()
Local $filename = GUICtrlRead($g_hTxtPresetSaveFilename)
If StringRight($filename, 4) = ".ini" Then
$filename = StringLeft($filename, StringLen($filename) - 4)
GUICtrlSetData($g_hTxtPresetSaveFilename, $filename)
EndIf
If StringRegExp($filename, '\\|/|:|\*|\?|\"|\<|\>|\|') Then GUICtrlSetData($g_hTxtPresetSaveFilename, StringRegExpReplace($filename, '\\|/|:|\*|\?|\"|\<|\>|\|', "_"))
If FileExists($g_sProfilePresetPath & "\" & $filename & ".ini") Then
Local $i = 2
While $i > 0
If FileExists($g_sProfilePresetPath & "\" & $filename & " (" & $i & ").ini") Then
$i += 1
Else
$filename = $filename & " (" & $i & ")"
GUICtrlSetData($g_hTxtPresetSaveFilename, $filename)
$i = 0
EndIf
WEnd
EndIf
Local $msg = StringReplace(GUICtrlRead($g_hTxtSavePresetMessage), @CRLF, "\n")
$g_sProfileSecondaryOutputFileName = $g_sProfilePresetPath & "\" & $filename & ".ini"
SetDebugLog("PresetSaveConf: " & $g_sProfileSecondaryInputFileName)
IniWrite($g_sProfileSecondaryOutputFileName, "preset", "info", $msg)
saveConfig()
readconfig()
applyConfig()
_GUICtrlTab_ClickTab($g_hTabMain, 0)
SetLog("Config " & $filename & " SAVED!", $COLOR_SUCCESS)
$g_sProfileSecondaryOutputFileName = ""
EndFunc
Func PresetDeleteConf()
Local $button = MsgBox($MB_ICONWARNING + $MB_OKCANCEL, GetTranslatedFileIni("MBR Popups", "Func_PresetDeleteConf_Info_01", "Delete Configuration"), GetTranslatedFileIni("MBR Popups", "Func_PresetDeleteConf_Info_02", 'Are you sure you want to delete the configuration ?') & GUICtrlRead($g_hCmbPresetList) & '"?' & @CRLF & "This cannot be undone.")
If $button = $IDOK Then
SetDebugLog("PresetDeleteConf: " & $g_sProfilePresetPath & "\" & GUICtrlRead($g_hCmbPresetList) & ".ini")
FileDelete($g_sProfilePresetPath & "\" & GUICtrlRead($g_hCmbPresetList) & ".ini")
saveconfig()
readconfig()
applyConfig()
EndIf
EndFunc
Func chkCheckDeleteConf()
If GUICtrlRead($g_hChkDeleteConf) = $GUI_CHECKED Then
GUICtrlSetState($g_hBtnGUIPresetDeleteConf, $GUI_ENABLE)
Else
GUICtrlSetState($g_hBtnGUIPresetDeleteConf, $GUI_DISABLE)
EndIf
EndFunc
Func MakeSavePresetMessage()
Local $message = ""
$message &= "NOTES:" & @CRLF & @CRLF
If $g_bDropTrophyEnable Then $message &= "TROPHIES RANGE: " & $g_iDropTrophyMin & " - " & $g_iDropTrophyMax & @CRLF & @CRLF
$message &= "TRAIN ARMY SETTINGS:" & @CRLF
$message &= "- Custom Train Troops:" & @CRLF
For $i = 0 To $eTroopCount - 1
If $g_aiArmyCompTroops[$i] > 0 Then
$message &= "  " & $g_asTroopShortNames[$i] & " " & $g_aiArmyCompTroops[$i] & "x"
If Mod($i + 1, 4) = 0 Then $message &= @CRLF
EndIf
Next
$message &= @CRLF
$message &= "SEARCH SETTINGS:" & @CRLF
For $i = $DB To $TS
If IsSearchModeActive($i, True) Then
Switch $i
Case $DB
$message &= "- DB search: "
Case $LB
$message &= "- AS search: "
Case $TS
$message &= "- TH search: "
EndSwitch
If $g_abSearchSearchesEnable[$i] Then $message &= " " & "s. " & $g_aiSearchSearchesMin[$i] & "-" & $g_aiSearchSearchesMax[$i]
If $g_abSearchTropiesEnable[$i] Then $message &= "  " & "t. " & $g_aiSearchTrophiesMin[$i] & "-" & $g_aiSearchTrophiesMax[$i]
If $g_abSearchCampsEnable[$i] Then $message &= " " & "c. >" & $g_aiSearchCampsPct[$i] & "%"
$message &= @CRLF
Switch $i
Case $DB
$message &= "- DB filter: "
Case $LB
$message &= "- AS filter: "
Case $TS
$message &= "- TH filter: "
EndSwitch
Switch $g_aiFilterMeetGE[$i]
Case 0
$message &= " G >= " & $g_aiFilterMinGold[$i]
$message &= " & "
$message &= " E >= " & $g_aiFilterMinElixir[$i] & "  "
Case 1
$message &= " G >= " & $g_aiFilterMinGold[$i]
$message &= " or "
$message &= " E >= " & $g_aiFilterMinElixir[$i] & "  "
Case 2
$message &= " G+E >= " & $g_aiFilterMinGoldPlusElixir[$i] & "  "
EndSwitch
If $g_abFilterMeetDEEnable[$i] Then $message &= " D >= " & $g_aiFilterMeetDEMin[$i] & "  "
If $g_abFilterMeetTrophyEnable[$i] Then $message &= " TR >= " & $g_aiFilterMeetTrophyMin[$i] & "  "
If $g_abFilterMeetTrophyEnable[$i] Then $message &= " TR <= " & $g_aiFilterMeetTrophyMax[$i] & "  "
If $g_abFilterMeetTH[$i] Then $message &= " TH >= " & $g_aiFilterMeetTHMin[$i] + 6 & "  "
If $g_abFilterMeetTHOutsideEnable[$i] Then $message &= " THO" & "  "
If IsWeakBaseActive($i) Then $message &= " WB" & "  "
If $g_abFilterMeetOneConditionEnable[$i] Then $message &= " MeetOne" & "  "
$message &= @CRLF
EndIf
Next
$message &= @CRLF & "ATTACK SETTINGS:" & @CRLF
For $i = $DB To $TS
If IsSearchModeActive($i, True) Then
Switch $i
Case $DB
$message &= "- DB: "
Case $LB
$message &= "- AS: "
Case $TS
$message &= "- TH: "
EndSwitch
If $i = $DB Or $i = $LB Then
Switch $g_aiAttackAlgorithm[$i]
Case "0"
$message &= "Standard Attack > "
Case "1"
$message &= "Scripted Attack > "
Case "2"
$message &= "Milking Attack   " & @CRLF
EndSwitch
EndIf
If $i = $TS Then $message &= $g_sAtkTSType & @CRLF
If($i = $DB Or $i = $LB) And $g_aiAttackAlgorithm[$i] = 0 Then
Local $tmp = StringSplit("one side|two sides|three sides|four sides|DE side|TH side", "|", 2)
$message &= $tmp[$g_aiAttackStdDropSides[$i]] & @CRLF
EndIf
EndIf
Next
$message &= @CRLF & "END BATTLE SETTINGS:" & @CRLF
For $i = $DB To $TS
If IsSearchModeActive($i, True) Then
Switch $i
Case $DB
$message &= "- DB: "
Case $LB
$message &= "- AS: "
Case $TS
$message &= "- TH: "
EndSwitch
If $g_abStopAtkNoLoot1Enable[$i] Then $message &= "wait " & $g_aiStopAtkNoLoot1Time[$i] & "  "
If $g_abStopAtkNoLoot2Enable[$i] Then $message &= "wait " & $g_aiStopAtkNoLoot2Time[$i] & " ->(" & $g_aiStopAtkNoLoot2MinGold[$i] & "," & $g_aiStopAtkNoLoot2MinElixir[$i] & "," & $g_aiStopAtkNoLoot2MinDark[$i] & ")  "
If $g_abStopAtkNoResources[$i] Then $message &= "nores "
If $g_abStopAtkOneStar[$i] Then $message &= "1star  "
If $g_abStopAtkTwoStars[$i] Then $message &= "2stars  "
EndIf
$message &= @CRLF
Next
GUICtrlSetData($g_hTxtSavePresetMessage, $message)
EndFunc
Func btnStrategyFolder()
ShellExecute("explorer", $g_sProfilePresetPath)
EndFunc
Func cmbProfile()
If LoadProfile() Then
Return True
EndIf
_GUICtrlComboBox_SelectString($g_hCmbProfile, $g_sProfileCurrentName)
Return False
EndFunc
Func LoadProfile($bSaveCurrentProfile = True)
If $bSaveCurrentProfile Then
saveConfig()
EndIf
If setupProfile() Then
readConfig()
applyConfig()
saveConfig()
SetLog("Profile " & $g_sProfileCurrentName & " loaded from " & $g_sProfileConfigPath, $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func btnAddConfirm()
Switch @GUI_CtrlId
Case $g_hBtnAddProfile
GUICtrlSetState($g_hCmbProfile, $GUI_HIDE)
GUICtrlSetState($g_hTxtVillageName, $GUI_SHOW)
GUICtrlSetState($g_hBtnAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnConfirmAddProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnCancelProfileChange, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnPullSharedPrefs, $GUI_HIDE)
GUICtrlSetState($g_hBtnPushSharedPrefs, $GUI_HIDE)
Case $g_hBtnConfirmAddProfile
Local $newProfileName = StringRegExpReplace(GUICtrlRead($g_hTxtVillageName), '[/:*?"<>|]', '_')
If FileExists($g_sProfilePath & "\" & $newProfileName) Then
MsgBox($MB_ICONWARNING, GetTranslatedFileIni("MBR Popups", "Profile_Already_Exists_01", "Profile Already Exists"), GetTranslatedFileIni("MBR Popups", "Profile_Already_Exists_02", "%s already exists.\r\nPlease choose another name for your profile.", $newProfileName))
Return
EndIf
saveConfig()
$g_sProfileCurrentName = $newProfileName
createProfile()
setupProfileComboBox()
selectProfile()
GUICtrlSetState($g_hTxtVillageName, $GUI_HIDE)
GUICtrlSetState($g_hCmbProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnAddProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnCancelProfileChange, $GUI_HIDE)
GUICtrlSetState($g_hBtnConfirmRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnPullSharedPrefs, $GUI_SHOW)
GUICtrlSetState($g_hBtnPushSharedPrefs, $GUI_SHOW)
If GUICtrlGetState($g_hBtnDeleteProfile) <> $GUI_ENABLE Then GUICtrlSetState($g_hBtnDeleteProfile, $GUI_ENABLE)
If GUICtrlGetState($g_hBtnRenameProfile) <> $GUI_ENABLE Then GUICtrlSetState($g_hBtnRenameProfile, $GUI_ENABLE)
Case Else
SetLog("If you are seeing this log message there is something wrong.", $COLOR_ERROR)
EndSwitch
EndFunc
Func btnDeleteCancel()
Switch @GUI_CtrlId
Case $g_hBtnDeleteProfile
Local $msgboxAnswer = MsgBox($MB_ICONWARNING + $MB_OKCANCEL, GetTranslatedFileIni("MBR Popups", "Delete_Profile_01", "Delete Profile"), GetTranslatedFileIni("MBR Popups", "Delete_Profile_02", "Are you sure you really want to delete the profile?\r\nThis action can not be undone."))
If $msgboxAnswer = $IDOK Then
If deleteProfile() Then
GUICtrlSetData($g_hTxtVillageName, GetTranslatedFileIni("MBR Popups", "MyVillage", "MyVillage"))
If _GUICtrlComboBox_GetCount($g_hCmbProfile) > 1 Then
setupProfileComboBox()
selectProfile()
Else
createProfile(True)
EndIf
EndIf
EndIf
Case $g_hBtnCancelProfileChange
GUICtrlSetState($g_hTxtVillageName, $GUI_HIDE)
GUICtrlSetState($g_hCmbProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnAddProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnCancelProfileChange, $GUI_HIDE)
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnPullSharedPrefs, $GUI_SHOW)
GUICtrlSetState($g_hBtnPushSharedPrefs, $GUI_SHOW)
Case Else
SetLog("If you are seeing this log message there is something wrong.", $COLOR_ERROR)
EndSwitch
If GUICtrlRead($g_hCmbProfile) = "<No Profiles>" Then
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_DISABLE)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_DISABLE)
EndIf
EndFunc
Func btnRenameConfirm()
Switch @GUI_CtrlId
Case $g_hBtnRenameProfile
Local $sProfile = GUICtrlRead($g_hCmbProfile)
If aquireProfileMutex($sProfile, False, True) = 0 Then
Return
EndIf
GUICtrlSetData($g_hTxtVillageName, $sProfile)
GUICtrlSetState($g_hCmbProfile, $GUI_HIDE)
GUICtrlSetState($g_hTxtVillageName, $GUI_SHOW)
GUICtrlSetState($g_hBtnAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnConfirmAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnCancelProfileChange, $GUI_SHOW)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnConfirmRenameProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnPullSharedPrefs, $GUI_HIDE)
GUICtrlSetState($g_hBtnPushSharedPrefs, $GUI_HIDE)
Case $g_hBtnConfirmRenameProfile
Local $newProfileName = StringRegExpReplace(GUICtrlRead($g_hTxtVillageName), '[/:*?"<>|]', '_')
If FileExists($g_sProfilePath & "\" & $newProfileName) Then
MsgBox($MB_ICONWARNING, GetTranslatedFileIni("MBR Popups", "Profile_Already_Exists_01", "Profile Already Exists"), $newProfileName & " " & GetTranslatedFileIni("MBR Popups", "Profile_Already_Exists_03", "already exists.") & @CRLF & GetTranslatedFileIni("MBR Popups", "Profile_Already_Exists_04", "Please choose another name for your profile"))
Return
EndIf
$g_sProfileCurrentName = $newProfileName
renameProfile()
setupProfileComboBox()
selectProfile()
GUICtrlSetState($g_hTxtVillageName, $GUI_HIDE)
GUICtrlSetState($g_hCmbProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnAddProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnCancelProfileChange, $GUI_HIDE)
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnPullSharedPrefs, $GUI_SHOW)
GUICtrlSetState($g_hBtnPushSharedPrefs, $GUI_SHOW)
Case Else
SetLog("If you are seeing this log message there is something wrong.", $COLOR_ERROR)
EndSwitch
EndFunc
Func btnPullSharedPrefs()
PullSharedPrefs()
EndFunc
Func btnPushSharedPrefs()
PushSharedPrefs()
EndFunc
Func cmbBotCond()
If _GUICtrlComboBox_GetCurSel($g_hCmbBotCond) = 15 Then
If _GUICtrlComboBox_GetCurSel($g_hCmbHoursStop) = 0 Then _GUICtrlComboBox_SetCurSel($g_hCmbHoursStop, 1)
GUICtrlSetState($g_hCmbHoursStop, $GUI_ENABLE)
Else
_GUICtrlComboBox_SetCurSel($g_hCmbHoursStop, 0)
GUICtrlSetState($g_hCmbHoursStop, $GUI_DISABLE)
EndIf
EndFunc
Func chkBotStop()
If GUICtrlRead($g_hChkBotStop) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbBotCommand, $GUI_ENABLE)
GUICtrlSetState($g_hCmbBotCond, $GUI_ENABLE)
_GUI_Value_STATE("ENABLE", $g_hTxtRestartGold & "#" & $g_hTxtRestartElixir & "#" & $g_hTxtRestartDark)
Else
GUICtrlSetState($g_hCmbBotCommand, $GUI_DISABLE)
GUICtrlSetState($g_hCmbBotCond, $GUI_DISABLE)
_GUI_Value_STATE("DISABLE", $g_hTxtRestartGold & "#" & $g_hTxtRestartElixir & "#" & $g_hTxtRestartDark)
EndIf
EndFunc
Func btnLocateClanCastle()
Local $wasRunState = $g_bRunState
$g_bRunState = True
ZoomOut()
LocateClanCastle()
$g_bRunState = $wasRunState
AndroidShield("btnLocateClanCastle")
EndFunc
Func btnLocateKingAltar()
LocateKingAltar()
EndFunc
Func btnLocateQueenAltar()
LocateQueenAltar()
EndFunc
Func btnLocateWardenAltar()
LocateWardenAltar()
EndFunc
Func btnLocateTownHall()
Local $wasRunState = $g_bRunState
Local $g_iOldTownHallLevel = $g_iTownHallLevel
$g_bRunState = True
ZoomOut()
LocateTownHall()
If Not $g_iOldTownHallLevel = $g_iTownHallLevel Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslatedFileIni("MBR Popups", "Locating_your_TH", "If you locating your TH because you upgraded,") & @CRLF & GetTranslatedFileIni("MBR Popups", "Must_restart_bot", "then you must restart bot!!!") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "OK_to_restart_bot", "Click OK to restart bot,") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Cancel_to_exit", "Or Click Cancel to exit") & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Close_Bot", "Close Bot Please!"), $stext, 120)
If $g_bDebugSetlog Then SetDebugLog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
RestartBot(False, $wasRunState)
EndIf
EndIf
$g_bRunState = $wasRunState
AndroidShield("btnLocateTownHall")
EndFunc
Func btnResetBuilding()
Local $wasRunState = $g_bRunState
$g_bRunState = True
While 1
If _Sleep(500) Then Return
If FileExists($g_sProfileBuildingPath) Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslatedFileIni("MBR Popups", "Delete_and_Reset_Building_info", "Click OK to Delete and Reset all Building info,") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Bot_will_exit", "NOTE =>> Bot will exit and need to be restarted when complete") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Cancel_to_exit", "Or Click Cancel to exit") & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Delete_Building_Info", "Delete Building Infomation ?"), $stext, 120)
If $g_bDebugSetlog Then SetDebugLog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
Local $stext = @CRLF & GetTranslatedFileIni("MBR Popups", "Sure_Delete_Building_Info", "Are you 100% sure you want to delete Building information ?") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Delete_then_restart_bot", "Click OK to Delete and then restart the bot (manually)") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Cancel_to_exit", -1) & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", -1), GetTranslatedFileIni("MBR Popups", "Delete_Building_Info", -1), $stext, 120)
If $g_bDebugSetlog Then SetDebugLog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
Local $Result = FileDelete($g_sProfileBuildingPath)
If $Result = 0 Then
SetLog("Unable to remove building.ini file, please use manual method", $COLOR_ERROR)
Else
BotClose(False)
EndIf
EndIf
EndIf
Else
SetLog("Building.ini file does not exist", $COLOR_INFO)
EndIf
ExitLoop
WEnd
$g_bRunState = $wasRunState
AndroidShield("btnResetBuilding")
EndFunc
Func btnLab()
Local $wasRunState = $g_bRunState
$g_bRunState = True
ZoomOut()
LocateLab()
$g_bRunState = $wasRunState
AndroidShield("btnLab")
EndFunc
Func chkTrophyAtkDead()
If GUICtrlRead($g_hChkTrophyAtkDead) = $GUI_CHECKED Then
$g_bDropTrophyAtkDead = True
GUICtrlSetState($g_hTxtDropTrophyArmyMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblDropTrophyArmyMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblDropTrophyArmyPercent, $GUI_ENABLE)
Else
$g_bDropTrophyAtkDead = False
GUICtrlSetState($g_hTxtDropTrophyArmyMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDropTrophyArmyMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDropTrophyArmyPercent, $GUI_DISABLE)
EndIf
EndFunc
Func chkTrophyRange()
If GUICtrlRead($g_hChkTrophyRange) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtDropTrophy, $GUI_ENABLE)
GUICtrlSetState($g_hTxtMaxTrophy, $GUI_ENABLE)
GUICtrlSetState($g_hChkTrophyHeroes, $GUI_ENABLE)
GUICtrlSetState($g_hChkTrophyAtkDead, $GUI_ENABLE)
chkTrophyAtkDead()
chkTrophyHeroes()
Else
GUICtrlSetState($g_hTxtDropTrophy, $GUI_DISABLE)
GUICtrlSetState($g_hTxtMaxTrophy, $GUI_DISABLE)
GUICtrlSetState($g_hChkTrophyHeroes, $GUI_DISABLE)
GUICtrlSetState($g_hChkTrophyAtkDead, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDropTrophyArmyMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDropTrophyArmyMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDropTrophyArmyPercent, $GUI_DISABLE)
GUICtrlSetState($g_hLblTrophyHeroesPriority, $GUI_DISABLE)
GUICtrlSetState($g_hCmbTrophyHeroesPriority, $GUI_DISABLE)
EndIf
EndFunc
Func TxtDropTrophy()
If Number(GUICtrlRead($g_hTxtDropTrophy)) > Number(GUICtrlRead($g_hTxtMaxTrophy)) Then
GUICtrlSetData($g_hTxtMaxTrophy, GUICtrlRead($g_hTxtDropTrophy))
TxtMaxTrophy()
EndIf
_GUI_Value_STATE("HIDE", $g_aGroupListPicMinTrophy)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[21][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueLegend], $GUI_SHOW)
GUICtrlSetData($g_hLblMinTrophies, "")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[18][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueTitan], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[20][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[19][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[18][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[15][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueChampion], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[17][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[16][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[15][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[12][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueMaster], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[14][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[13][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[12][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[9][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueCrystal], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[11][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[10][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[9][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[6][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueGold], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[8][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[7][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[6][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[3][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueSilver], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[5][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[4][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[3][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[0][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueBronze], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[2][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[1][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[0][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "3")
EndIf
Else
GUICtrlSetState($g_hPicMinTrophies[$eLeagueUnranked], $GUI_SHOW)
GUICtrlSetData($g_hLblMinTrophies, "")
EndIf
EndFunc
Func TxtMaxTrophy()
If Number(GUICtrlRead($g_hTxtDropTrophy)) > Number(GUICtrlRead($g_hTxtMaxTrophy)) Then
GUICtrlSetData($g_hTxtMaxTrophy, GUICtrlRead($g_hTxtDropTrophy))
EndIf
_GUI_Value_STATE("HIDE", $g_aGroupListPicMaxTrophy)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[21][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueLegend], $GUI_SHOW)
GUICtrlSetData($g_hLblMaxTrophies, "")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[18][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueTitan], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[20][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[19][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[18][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[15][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueChampion], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[17][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[16][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[15][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[12][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueMaster], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[14][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[13][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[12][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[9][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueCrystal], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[11][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[10][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[9][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[6][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueGold], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[8][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[7][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[6][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[3][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueSilver], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[5][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[4][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[3][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[0][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueBronze], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[2][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[1][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[0][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "3")
EndIf
Else
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueUnranked], $GUI_SHOW)
GUICtrlSetData($g_hLblMaxTrophies, "")
EndIf
EndFunc
Func chkTrophyHeroes()
If GUICtrlRead($g_hChkTrophyHeroes) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblTrophyHeroesPriority, $GUI_ENABLE)
GUICtrlSetState($g_hCmbTrophyHeroesPriority, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblTrophyHeroesPriority, $GUI_DISABLE)
GUICtrlSetState($g_hCmbTrophyHeroesPriority, $GUI_DISABLE)
EndIf
EndFunc
Func ChkCollect()
If GUICtrlRead($g_hChkCollect) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkTreasuryCollect, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkTreasuryCollect, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTreasuryCollect, $GUI_DISABLE)
EndIf
ChkTreasuryCollect()
EndFunc
Func ChkTreasuryCollect()
If GUICtrlRead($g_hChkTreasuryCollect) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtTreasuryGold, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTreasuryElixir, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTreasuryDark, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtTreasuryGold, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTreasuryElixir, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTreasuryDark, $GUI_DISABLE)
EndIf
EndFunc
Func chkStartClockTowerBoost()
If GUICtrlRead($g_hChkStartClockTowerBoost) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkCTBoostBlderBz, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkCTBoostBlderBz, $GUI_DISABLE)
EndIf
EndFunc
Func chkActivateClangames()
If GUICtrlRead($g_hChkClanGamesEnabled) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkClanGamesOnly, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesAir, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesGround, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesMisc, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesLoot, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesBattle, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesDestruction, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesAirTroop, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesGroundTroop, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesMiscellaneous, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesPurge, $GUI_ENABLE)
If GUICtrlRead($g_hChkClanGamesPurge) = $GUI_CHECKED then GUICtrlSetState($g_hcmbPurgeLimit, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesStopBeforeReachAndPurge, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesDebug, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkClanGamesOnly, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesAir, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesGround, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesMisc, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesLoot, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesBattle, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesDestruction, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesAirTroop, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesGroundTroop, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesMiscellaneous, $GUI_DISABLE)
GUICtrlSetState($g_hcmbPurgeLimit, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesStopBeforeReachAndPurge, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesPurge, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesDebug, $GUI_DISABLE)
EndIf
EndFunc
Func chkPurgeLimits()
If GUICtrlRead($g_hChkClanGamesPurge) = $GUI_CHECKED AND GUICtrlRead($g_hChkClanGamesEnabled) = $GUI_CHECKED Then
GUICtrlSetState($g_hcmbPurgeLimit, $GUI_ENABLE)
Else
GUICtrlSetState($g_hcmbPurgeLimit, $GUI_DISABLE)
EndIf
EndFunc
Func LoadCOCDistributorsComboBox()
Local $sDistributors = $g_sNO_COC
Local $aDistributorsData = GetCOCDistributors()
If @error = 2 Then
$sDistributors = $g_sUNKNOWN_COC
ElseIf IsArray($aDistributorsData) Then
$sDistributors = _ArrayToString($aDistributorsData, "|")
EndIf
GUICtrlSetData($g_hCmbCOCDistributors, "", "")
GUICtrlSetData($g_hCmbCOCDistributors, $sDistributors)
EndFunc
Func SetCurSelCmbCOCDistributors()
Local $sIniDistributor
Local $iIndex
If _GUICtrlComboBox_GetCount($g_hCmbCOCDistributors) = 1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbCOCDistributors, 0)
GUICtrlSetState($g_hCmbCOCDistributors, $GUI_DISABLE)
Else
$sIniDistributor = GetCOCTranslated($g_sAndroidGameDistributor)
$iIndex = _GUICtrlComboBox_FindStringExact($g_hCmbCOCDistributors, $sIniDistributor)
If $iIndex = -1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbCOCDistributors, 0)
Else
_GUICtrlComboBox_SetCurSel($g_hCmbCOCDistributors, $iIndex)
EndIf
GUICtrlSetState($g_hCmbCOCDistributors, $GUI_ENABLE)
EndIf
EndFunc
Func cmbCOCDistributors()
Local $sDistributor
_GUICtrlComboBox_GetLBText($g_hCmbCOCDistributors, _GUICtrlComboBox_GetCurSel($g_hCmbCOCDistributors), $sDistributor)
If $sDistributor = $g_sUserGameDistributor Then
$g_sAndroidGameDistributor = $g_sUserGameDistributor
$g_sAndroidGamePackage = $g_sUserGamePackage
$g_sAndroidGameClass = $g_sUserGameClass
Else
GetCOCUnTranslated($sDistributor)
If Not @error Then
$g_sAndroidGameDistributor = GetCOCUnTranslated($sDistributor)
$g_sAndroidGamePackage = GetCOCPackage($sDistributor)
$g_sAndroidGameClass = GetCOCClass($sDistributor)
EndIf
EndIf
EndFunc
Func DistributorsUpdateGUI()
LoadCOCDistributorsComboBox()
SetCurSelCmbCOCDistributors()
EndFunc
Func AndroidSuspendFlagsToIndex($iFlags)
Local $idx = 0
If BitAND($iFlags, 2) > 0 Then
$idx = 2
ElseIf BitAND($iFlags, 1) > 0 Then
$idx = 1
EndIf
If $idx > 0 And BitAND($iFlags, 4) > 0 Then $idx += 2
Return $idx
EndFunc
Func AndroidSuspendIndexToFlags($idx)
Local $iFlags = 0
Switch $idx
Case 1
$iFlags = 1
Case 2
$iFlags = 2
Case 3
$iFlags = 1 + 4
Case 4
$iFlags = 2 + 4
EndSwitch
Return $iFlags
EndFunc
Func cmbSuspendAndroid()
$g_iAndroidSuspendModeFlags = AndroidSuspendIndexToFlags(_GUICtrlComboBox_GetCurSel($g_hCmbSuspendAndroid))
EndFunc
Func cmbAndroidBackgroundMode()
$g_iAndroidBackgroundMode = _GUICtrlComboBox_GetCurSel($g_hCmbAndroidBackgroundMode)
UpdateAndroidBackgroundMode()
EndFunc
Func BotStart($bAutostartDelay = 0)
FuncEnter(BotStart)
ResumeAndroid()
CleanSecureFiles()
CalCostCamp()
CalCostSpell()
$g_bRunState = True
$g_bTogglePauseAllowed = True
$g_bSkipFirstZoomout = False
$g_bIsSearchLimit = False
$g_bIsClientSyncError = False
EnableControls($g_hFrmBotBottom, False, $g_aFrmBotBottomCtrlState)
$g_bTrainEnabled = True
$g_bDonationEnabled = True
$g_bMeetCondStop = False
$g_bIsClientSyncError = False
$g_bDisableBreakCheck = False
$g_bDisableDropTrophy = False
If Not $g_bSearchMode Then
If $g_hLogFile = 0 Then CreateLogFile()
CreateAttackLogFile()
If $g_iFirstRun = -1 Then $g_iFirstRun = 1
EndIf
SetLogCentered(" BOT LOG ", Default, Default, True)
SaveConfig()
readConfig()
applyConfig(False)
__ObjEventIni()
NotifyGetLastMessageFromTelegram()
$g_iTGLastRemote = $g_sTGLast_UID
If BitAND($g_iAndroidSupportFeature, 1 + 2) = 0 And $g_bChkBackgroundMode = True Then
GUICtrlSetState($g_hChkBackgroundMode, $GUI_UNCHECKED)
UpdateChkBackground()
SetLog("Background Mode not supported for " & $g_sAndroidEmulator & " and has been disabled", $COLOR_ERROR)
EndIf
GUICtrlSetState($g_hBtnStart, $GUI_HIDE)
GUICtrlSetState($g_hBtnStop, $GUI_SHOW)
GUICtrlSetState($g_hBtnPause, $GUI_SHOW)
GUICtrlSetState($g_hBtnResume, $GUI_HIDE)
GUICtrlSetState($g_hBtnSearchMode, $GUI_HIDE)
GUICtrlSetState($g_hChkBackgroundMode, $GUI_DISABLE)
TrayItemSetText($g_hTiStartStop, GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Stop", "Stop bot"))
TrayItemSetState($g_hTiPause, $TRAY_ENABLE)
TrayItemSetText($g_hTiPause, GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Pause", "Pause bot"))
EnableControls($g_hFrmBotBottom, Default, $g_aFrmBotBottomCtrlState)
DisableGuiControls()
SetRedrawBotWindow(True, Default, Default, Default, "BotStart")
If $bAutostartDelay Then
SetLog("Bot Auto Starting in " & Round($bAutostartDelay / 1000, 0) & " seconds", $COLOR_ERROR)
_SleepStatus($bAutostartDelay)
EndIf
LockBotSlot(True)
If $g_bRunState = False Then Return FuncReturn()
Local $Result = False
If WinGetAndroidHandle() = 0 Then
$Result = OpenAndroid(False)
EndIf
SetDebugLog("Android Window Handle: " & WinGetAndroidHandle())
If $g_hAndroidWindow <> 0 Then
If Not $g_bRunState Then Return FuncReturn()
If $g_bAndroidBackgroundLaunched = True Or AndroidControlAvailable() Then
If Not $Result Then
$Result = InitiateLayout()
EndIf
Else
SetLog("Current " & $g_sAndroidEmulator & " Window not supported by MyBot", $COLOR_ERROR)
$Result = RebootAndroid(False)
EndIf
If Not $g_bRunState Then Return FuncReturn()
Local $hWndActive = $g_hAndroidWindow
If $g_bNoFocusTampering = False And $g_bAndroidBackgroundLaunched = False And $g_bAndroidEmbedded = False Then
Local $hTimer = __TimerInit()
$hWndActive = -1
Local $activeHWnD = WinGetHandle("")
While __TimerDiff($hTimer) < 1000 And $hWndActive <> $g_hAndroidWindow And Not _Sleep(100)
$hWndActive = WinActivate($g_hAndroidWindow)
WEnd
WinActivate($activeHWnD)
EndIf
If Not $g_bRunState Then Return FuncReturn()
If $hWndActive = $g_hAndroidWindow And($g_bAndroidBackgroundLaunched = True Or AndroidControlAvailable()) Then
Initiate()
Else
SetLog("Cannot use " & $g_sAndroidEmulator & ", please check log", $COLOR_ERROR)
btnStop()
EndIf
Else
SetLog("Cannot start " & $g_sAndroidEmulator & ", please check log", $COLOR_ERROR)
btnStop()
EndIf
FuncReturn()
EndFunc
Func BotStop()
FuncEnter(BotStop)
LockBotSlot(False)
releaseProfilesMutex()
ResumeAndroid()
$g_bRunState = False
$g_bBotPaused = False
$g_bTogglePauseAllowed = True
EnableControls($g_hFrmBotBottom, False, $g_aFrmBotBottomCtrlState)
EnableGuiControls()
AndroidBotStopEvent()
AndroidAdbTerminateShellInstance()
AndroidShield("btnStop", Default)
EnableControls($g_hFrmBotBottom, Default, $g_aFrmBotBottomCtrlState)
GUICtrlSetState($g_hChkBackgroundMode, $GUI_ENABLE)
GUICtrlSetState($g_hBtnStart, $GUI_SHOW)
GUICtrlSetState($g_hBtnStop, $GUI_HIDE)
GUICtrlSetState($g_hBtnPause, $GUI_HIDE)
GUICtrlSetState($g_hBtnResume, $GUI_HIDE)
If $g_iTownHallLevel > 2 Then GUICtrlSetState($g_hBtnSearchMode, $GUI_ENABLE)
GUICtrlSetState($g_hBtnSearchMode, $GUI_SHOW)
GUICtrlSetState($g_hBtnAttackNowDB, $GUI_HIDE)
GUICtrlSetState($g_hBtnAttackNowLB, $GUI_HIDE)
GUICtrlSetState($g_hBtnAttackNowTS, $GUI_HIDE)
GUICtrlSetState($g_hPicTwoArrowShield, $GUI_SHOW)
GUICtrlSetState($g_hLblVersion, $GUI_SHOW)
TrayItemSetText($g_hTiStartStop, GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Start", "Start bot"))
TrayItemSetState($g_hTiPause, $TRAY_DISABLE)
SetLogCentered(" Bot Stop ", Default, $COLOR_ACTION)
If Not $g_bSearchMode Then
If Not $g_bBotPaused Then $g_iTimePassed += Int(__TimerDiff($g_hTimerSinceStarted))
$g_bRestart = True
If $g_hLogFile <> 0 Then
FileClose($g_hLogFile)
$g_hLogFile = 0
EndIf
If $g_hAttackLogFile <> 0 Then
FileClose($g_hAttackLogFile)
$g_hAttackLogFile = 0
EndIf
Else
$g_bSearchMode = False
EndIf
__ObjEventEnds()
ReduceBotMemory()
FuncReturn()
EndFunc
Func BotSearchMode()
FuncEnter(BotSearchMode)
$g_bSearchMode = True
$g_bRestart = False
$g_bIsClientSyncError = False
If $g_iFirstRun = 1 Then $g_iFirstRun = -1
btnStart()
checkMainScreen(False)
If _Sleep(100) Then Return FuncReturn()
$g_aiCurrentLoot[$eLootTrophy] = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If _Sleep(100) Then Return FuncReturn()
CheckIfArmyIsReady()
ClickP($aAway, 2, 0, "")
If _Sleep(100) Then Return FuncReturn()
If(IsSearchModeActive($DB) And checkCollectors(True, False)) Or IsSearchModeActive($LB) Or IsSearchModeActive($TS) Then
If _Sleep(100) Then Return FuncReturn()
PrepareSearch()
If _Sleep(1000) Then Return FuncReturn()
VillageSearch()
If _Sleep(100) Then Return FuncReturn()
Else
SetLog("Your Army is not prepared, check the Attack/train options")
EndIf
btnStop()
FuncReturn()
EndFunc
Func InitializeMainGUI($bGuiModeUpdate = False)
InitializeControlVariables()
If Not $bGuiModeUpdate Then AtkLogHead()
tabMain()
If FileExists($g_sProfileConfigPath) = 0 And $g_asCmdLine[0] > 0 Then
createProfile()
saveConfig()
setupProfileComboBox()
ElseIf $g_iGuiMode <> 1 Then
setupProfileComboBox()
EndIf
selectProfile()
If FileExists($g_sProfileConfigPath) Or FileExists($g_sProfileBuildingPath) Then
readConfig()
applyConfig()
EndIf
If $g_bDevMode Then
GUICtrlSetState($g_hChkDebugFunc, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugDisableZoomout, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugDisableVillageCentering, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugDeadbaseImage, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugOCR, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugImageSave, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugBuildingPos, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugTrain, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugOCRDonate, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkMakeIMGCSV, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugAttackCSV, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugSmartZap, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hbtnAttNow, $GUI_SHOW + $GUI_ENABLE)
EndIf
GUISetOnEvent($GUI_EVENT_CLOSE, "GUIEvents", $g_hFrmBot)
GUISetOnEvent($GUI_EVENT_MINIMIZE, "GUIEvents", $g_hFrmBot)
GUISetOnEvent($GUI_EVENT_RESTORE, "GUIEvents", $g_hFrmBot)
GUIRegisterMsg($WM_COMMAND, "GUIControl_WM_COMMAND")
GUIRegisterMsg($WM_NOTIFY, "GUIControl_WM_NOTIFY")
For $i = $WM_MOUSEMOVE To $WM_MOUSEWHEEL
GUIRegisterMsg($i, "GUIControl_WM_MOUSE")
Next
GUIRegisterMsg($WM_CLOSE, "GUIControl_WM_CLOSE")
GUIRegisterMsg($WM_NCACTIVATE, "GUIControl_WM_NCACTIVATE")
GUIRegisterMsg($WM_SETFOCUS, "GUIControl_WM_FOCUS")
GUIRegisterMsg($WM_KILLFOCUS, "GUIControl_WM_FOCUS")
GUIRegisterMsg($WM_ACTIVATEAPP, "GUIControl_WM_ACTIVATEAPP")
GUIRegisterMsg($WM_MOVE, "GUIControl_WM_MOVE")
GUIRegisterMsg(_WinAPI_RegisterWindowMessage('SHELLHOOK'), 'GUIControl_WM_SHELLHOOK')
_WinAPI_RegisterShellHookWindow($g_hFrmBot)
$g_hFrmBot_WNDPROC_ptr = DllCallbackGetPtr(DllCallbackRegister("frmBot_WNDPROC", "ptr", "hwnd;uint;long;ptr"))
cmbDBAlgorithm()
cmbABAlgorithm()
SetAccelerators()
EndFunc
Func SetCriticalMessageProcessing($bEnterCritical = Default)
If $bEnterCritical = Default Then Return $g_bCriticalMessageProcessing
Local $wasCritical = $g_bCriticalMessageProcessing
$g_bCriticalMessageProcessing = $bEnterCritical
Return $wasCritical
EndFunc
Func UpdateFrmBotStyle()
If $g_iGuiMode = 0 Then Return False
Local $bChanged = False
Local $ShowMinimize = $g_bAndroidBackgroundLaunched = True Or $g_bAndroidEmbedded = False Or($g_bAndroidEmbedded = True And $g_bChkBackgroundMode = True)
Local $lStyle = $WS_MINIMIZEBOX
Local $lNewStyle =($ShowMinimize ? $lStyle : 0)
Local $lCurStyle = _WinAPI_GetWindowLong($g_hFrmBot, $GWL_STYLE)
If BitAND($lCurStyle, $lStyle) <> $lNewStyle Then
$bChanged = True
If $ShowMinimize Then
$lNewStyle = BitOR($lCurStyle, $lStyle)
SetDebugLog("Show Bot Minimize Button")
Else
$lNewStyle = BitAND($lCurStyle, BitNOT($lStyle))
SetDebugLog("Hide Bot Minimize Button")
EndIf
_WinAPI_SetWindowLong($g_hFrmBot, $GWL_STYLE, $lNewStyle)
EndIf
If CheckBotShrinkExpandButton() Then $bChanged = True
Return $bChanged
EndFunc
Func IsAlwaysEnabledControl($controlID)
Local $bAlwaysEnabled =(($oAlwaysEnabledControls.Item($controlID)) ?(True) :(False))
Return $bAlwaysEnabled
EndFunc
Func SetAccelerators($bDockedUnshieledFocus = False)
If $g_iGuiMode = 0 Then Return
Local $aAccelKeys[2][2] = [["{ESC}", $g_hBtnStop], ["{PAUSE}", $g_hBtnPause]]
Local $aAccelKeys_DockedUnshieldedFocus[3][2] = [["{ESC}", $g_hFrmBotEmbeddedShieldInput], ["{ENTER}", $g_hFrmBotEmbeddedShieldInput], ["{PAUSE}", $g_hBtnPause]]
GUISetAccelerators(0, $g_hFrmBot)
If $bDockedUnshieledFocus = False Then
GUISetAccelerators($aAccelKeys, $g_hFrmBot)
Else
GUISetAccelerators($aAccelKeys_DockedUnshieldedFocus, $g_hFrmBot)
EndIf
EndFunc
Func DisableProcessWindowsGhosting()
DllCall($g_hLibUser32DLL, "none", "DisableProcessWindowsGhosting")
EndFunc
Func GUIControl_WM_SHELLHOOK($hWin, $iMsg, $wParam, $lParam)
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_SHELLHOOK: $hWin=" & $hWin & ", $wParam=" & $wParam & ", $lParam=" & $lParam & ", Active=" & _WinAPI_GetActiveWindow(), Default, True)
If $hWin = $g_hFrmBot And $lParam And BitAND($wParam, $HSHELL_WINDOWACTIVATED) And Not AndroidEmbedded() Then
Select
Case $lParam = $g_hAndroidWindow
BotMinimizeRestore(False, "GUIControl_WM_SHELLHOOK", False, 0, $g_hAndroidWindow)
EndSelect
EndIf
EndFunc
Func GUIControl_WM_ACTIVATEAPP($hWin, $iMsg, $wParam, $lParam)
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_ACTIVATEAPP: $hWin=" & $hWin & ", $wParam=" & $wParam & ", $lParam=" & $lParam & ", Active=" & _WinAPI_GetActiveWindow(), Default, True)
If $wParam Then
If Not $g_bFlushGuiLogActive And Not $g_bIsHidden And Not AndroidEmbedded() And $g_bChkBackgroundMode Then ShowAndroidWindow($g_hFrmBot, False, Default, "GUIControl_WM_ACTIVATEAPP")
Else
If BitAND($g_iBotDesignFlags, 2) And $g_bAndroidEmbedded And Not $g_bBotDockedShrinked Then BotShrinkExpandToggle()
EndIf
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_NCACTIVATE($hWin, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_NCACTIVATE: $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg, 8) & ", $wParam=" & $wParam & ", $lParam=" & $lParam, Default, True)
Local $iActive = BitAND($wParam, 0x0000FFFF)
If $hWin = $g_hFrmBot Then
If $g_bAndroidEmbedded And AndroidShieldActiveDelay() = False Then
If $iActive = 0 Then
AndroidShield("GUIControl_WM_NCACTIVATE not active", Default, False, 0, False, False)
Else
AndroidShield("GUIControl_WM_NCACTIVATE active", Default, False)
EndIf
EndIf
If $iActive = 0 Then
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_NCACTIVATE: Deactivate Bot", Default, True)
_WinAPI_SetFocus(0)
Else
If $g_bHideWhenMinimized = False Then BotRestore("GUIControl_WM_NCACTIVATE")
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_NCACTIVATE: Activate Bot", Default, True)
If BitAND($g_iBotDesignFlags, 2) And $g_bAndroidEmbedded And $g_bBotDockedShrinked Then BotShrinkExpandToggle()
EndIf
If $g_bAndroidEmbedded And $g_iAndroidEmbedMode = 1 And AndroidShieldActiveDelay() = False Then
AndroidEmbedCheck(False, $iActive <> 0, 1)
AndroidShield("GUIControl_WM_NCACTIVATE", Default, False)
EndIf
EndIf
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_FOCUS($hWin, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_FOCUS: $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg, 8) & ", $wParam=" & $wParam & ", $lParam=" & $lParam, Default, True)
Local $iActive = BitAND($wParam, 0x0000FFFF)
Switch $hWin
Case $g_hFrmBot
If $g_bAndroidEmbedded And AndroidShieldActiveDelay() = False Then
AndroidShield("GUIControl_WM_FOCUS", Default, False)
If $g_iAndroidEmbedMode = 1 Then
AndroidEmbedCheck(False, Default, 1)
EndIf
EndIf
EndSwitch
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GetPixelFromWindow($x, $y, $hWin)
Local $hDC = _WinAPI_GetWindowDC($hWin)
Local $Result = DllCall("gdi32.dll", "int", "GetPixel", "int", $hDC, "int", $x, "int", $y)
_WinAPI_ReleaseDC($hWin, $hDC)
If UBound($Result) > 0 Then Return Hex($Result[0], 6)
Return ""
EndFunc
Func GUIControl_WM_MOUSE($hWin, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Local $hWinMouse = $g_hFrmBotEmbeddedMouse
If $g_hFrmBotEmbeddedMouse = 0 Then $hWinMouse =(($g_iAndroidEmbedMode = 0) ? $g_hFrmBotEmbeddedShield : $g_hFrmBot)
If $g_iDebugWindowMessages > 1 Then SetDebugLog("GUIControl_WM_MOUSE: $hWin=" & $hWin & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam & ",$hWinMouse=" & $hWinMouse, Default, True)
CheckBotZOrder()
If $hWin <> $hWinMouse Or $g_bAndroidEmbedded = False Or $g_avAndroidShieldStatus[0] = True Then
If $g_avAndroidShieldStatus[0] = True And $iMsg = $WM_LBUTTONDOWN And $hWin <> $g_hFrmBotButtons Then BotMoveRequest()
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndIf
Switch $iMsg
Case $WM_LBUTTONDOWN, $WM_LBUTTONUP, $WM_RBUTTONDOWN, $WM_RBUTTONUP
Local $hInput = GUICtrlGetHandle($g_hFrmBotEmbeddedShieldInput)
_WinAPI_SetFocus($hInput)
EndSwitch
Local $x = BitAND($lParam, 0xFFFF)
Local $y = BitAND($lParam, 0xFFFF0000) / 0x10000
Switch $iMsg
Case $WM_MOUSEMOVE
If $g_bDebugClick And AndroidShieldHasFocus() Then
Local $c = GetPixelFromWindow($x, $y, $g_hAndroidControl)
_GUICtrlStatusBar_SetText($g_hStatusBar, StringFormat("Mouse %03i,%03i Color %s", $x, $y, $c))
EndIf
Case $WM_LBUTTONDOWN
If $g_bDebugClick And AndroidShieldHasFocus() Then
Local $c = GetPixelFromWindow($x, $y, $g_hAndroidControl)
SetLog(StringFormat("Mouse LBUTTONDOWN %03i,%03i Color %s", $x, $y, $c), $COLOR_DEBUG)
EndIf
Case $WM_LBUTTONUP, $WM_RBUTTONUP
If $g_iDebugWindowMessages Then
SetDebugLog("GUIControl_WM_MOUSE: " &($iMsg = $WM_LBUTTONUP ? "$WM_LBUTTONUP" : "$WM_RBUTTONUP") & " $hWin=" & $hWin & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam & ", X=" & $x & ", Y=" & $y, Default, True)
EndIf
If AndroidShieldHasFocus() = False Then
Local $hInput = GUICtrlGetHandle($g_hFrmBotEmbeddedShieldInput)
_WinAPI_SetFocus($hInput)
AndroidShield("GUIControl_WM_MOUSE", Default, False, 0, True)
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndIf
EndSwitch
If AndroidShieldHasFocus() = False Then
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndIf
Local $hCtrlTarget = $g_aiAndroidEmbeddedCtrlTarget[0]
If $iMsg <> $WM_MOUSEMOVE Or $g_iAndroidEmbedMode <> 0 Then
$lParam = $y * 0x10000 + $x
Local $Result = _WinAPI_PostMessage($hCtrlTarget, $iMsg, $wParam, $lParam)
EndIf
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_AndroidEmbedded($hWin, $iMsg, $wParam, $lParam)
Static $GUIControl_AndroidEmbedded_Call = [0, 0, 0, 0]
If $g_bAndroidEmbedded = False Or $g_avAndroidShieldStatus[0] = True Then
Return $GUI_RUNDEFMSG
EndIf
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Switch $iMsg
Case $WM_KEYDOWN, $WM_KEYUP, $WM_SYSKEYDOWN, $WM_SYSKEYUP, $WM_MOUSEWHEEL
If $iMsg = $WM_KEYUP And $wParam = 27 Then
Local $wasSilentSetLog = $g_bSilentSetLog
$g_bSilentSetLog = True
AndroidBackButton(False)
$g_bSilentSetLog = $wasSilentSetLog
Else
Local $hCtrlTarget = $g_aiAndroidEmbeddedCtrlTarget[0]
If $GUIControl_AndroidEmbedded_Call[0] <> $hCtrlTarget Or $GUIControl_AndroidEmbedded_Call[1] <> $iMsg Or $GUIControl_AndroidEmbedded_Call[2] <> $wParam Or $GUIControl_AndroidEmbedded_Call[3] <> $lParam Then
If $g_bDebugAndroidEmbedded Then SetDebugLog("GUIControl_AndroidEmbedded: FORWARD $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg) & ", $wParam=" & $wParam & ", $lParam=" & $lParam & ", $hCtrlTarget=" & $hCtrlTarget, Default, True)
_WinAPI_PostMessage($hCtrlTarget, $iMsg, $wParam, $lParam)
$GUIControl_AndroidEmbedded_Call[0] = $hCtrlTarget
$GUIControl_AndroidEmbedded_Call[1] = $iMsg
$GUIControl_AndroidEmbedded_Call[2] = $wParam
$GUIControl_AndroidEmbedded_Call[3] = $lParam
EndIf
EndIf
EndSwitch
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_COMMAND($hWind, $iMsg, $wParam, $lParam)
If $g_bGUIControlDisabled = True Then Return $GUI_RUNDEFMSG
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages > 1 Then SetDebugLog("GUIControl_WM_COMMAND: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
Local $nNotifyCode = BitShift($wParam, 16)
Local $nID = BitAND($wParam, 0x0000FFFF)
If $hWind <> $g_hFrmBotEmbeddedShield And $hWind <> $g_hFrmBotEmbeddedGraphics And $hWind <> $g_hFrmBotEmbeddedMouse And $nID <> $g_hFrmBotEmbeddedShieldInput And $hWind <> $g_hFrmBotButtons Then
If AndroidShieldHasFocus() = True Then
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_COMMAND: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
AndroidShield("GUIControl_WM_COMMAND", Default, False, 150, False)
EndIf
EndIf
CheckRedrawBotWindow(Default, Default, "GUIControl_WM_COMMAND")
Switch $nID
Case $g_hDivider
$g_bMoveDivider = True
SetDebugLog("MoveDivider active", Default, True)
Case $g_hLblBotShrink, $g_hLblBotExpand
BotShrinkExpandToggle()
Case $g_hLblBotMinimize
BotMinimizeRequest()
Case $GUI_EVENT_CLOSE, $g_hLblBotClose
BotCloseRequest()
Case $g_hLblBotMiniGUI, $g_hLblBotNormalGUI
BotGuiModeToggleRequest()
Case $g_hLblCreditsBckGrnd
Local $CursorInfo = GUIGetCursorInfo($g_hFrmBot)
If IsArray($CursorInfo) = 1 Then
Switch $CursorInfo[4]
Case $g_hLblMyBotURL, $g_hLblForumURL
OpenURL_Label($CursorInfo[4])
EndSwitch
EndIf
Case $g_hLblMyBotURL, $g_hLblForumURL, $g_hLblUnbreakableLink
OpenURL_Label($nID)
Case $g_hFrmBot_URL_PIC, $g_hFrmBot_URL_PIC2
OpenURL_Label($g_hLblMyBotURL)
Case $g_hLblDonate
ShellExecute("https://mybot.run/forums/index.php?/donate/make-donation/")
Case $g_hBtnStop
btnStop()
Case $g_hBtnPause
btnPause()
Case $g_hBtnResume
btnResume()
Case $g_hBtnHide
btnHide()
Case $btnResetStats
btnResetStats()
Case $g_hBtnAttackNowDB
btnAttackNowDB()
Case $g_hBtnAttackNowLB
btnAttackNowLB()
Case $g_hBtnAttackNowTS
btnAttackNowTS()
Case $g_hBtnNotifyDeleteMessages
If $g_bRunState Then
btnDeletePBMessages()
Else
PushMsg("DeleteAllPBMessages")
EndIf
Case $g_hBtnMakeScreenshot
If $g_bRunState Then
btnMakeScreenshot()
Else
If $g_bScreenshotPNGFormat = False Then
MakeScreenshot($g_sProfileTempPath, "jpg")
Else
MakeScreenshot($g_sProfileTempPath, "png")
EndIf
EndIf
Case $g_hPicTwoArrowShield
btnVillageStat()
Case $g_hPicArrowLeft, $g_hPicArrowRight
btnVillageStat()
Case $g_hChkDebugSetlog
chkDebugSetlog()
Case $g_hChkDebugAndroid
chkDebugAndroid()
Case $g_hChkDebugClick
chkDebugClick()
Case $g_hChkDebugFunc
chkDebugFunc()
Case $g_hChkDebugDisableZoomout
chkDebugDisableZoomout()
Case $g_hChkDebugDisableVillageCentering
chkDebugDisableVillageCentering()
Case $g_hChkDebugDeadbaseImage
chkDebugDeadbaseImage()
Case $g_hChkDebugOCR
chkDebugOcr()
Case $g_hChkDebugImageSave
chkDebugImageSave()
Case $g_hChkdebugBuildingPos
chkDebugBuildingPos()
Case $g_hChkdebugTrain
chkDebugTrain()
Case $g_hChkDebugOCRDonate
chkdebugOCRDonate()
Case $g_hChkdebugAttackCSV
chkdebugAttackCSV()
Case $g_hChkMakeIMGCSV
chkmakeIMGCSV()
Case $g_hBtnTestTrain
btnTestTrain()
Case $g_hBtnTestDonateCC
btnTestDonateCC()
Case $g_hBtnTestRequestCC
btnTestRequestCC()
Case $g_hBtnTestSendText
btnTestSendText()
Case $g_hBtnTestAttackBar
btnTestAttackBar()
Case $g_hBtnTestClickDrag
btnTestClickDrag()
Case $g_hBtnTestImage
btnTestImage()
Case $g_hBtnTestVillageSize
btnTestVillageSize()
Case $g_hBtnTestDeadBase
btnTestDeadBase()
Case $g_hBtnTestDeadBaseFolder
btnTestDeadBaseFolder()
Case $g_hBtnTestTHimgloc
imglocTHSearch()
Case $g_hBtnTestimglocTroopBar
TestImglocTroopBar()
Case $g_hBtnTestAttackCSV
btnTestAttackCSV()
Case $g_hBtnTestBuildingLocation
btnTestGetLocationBuilding()
Case $g_hBtnTestFindButton
btnTestFindButton()
Case $g_hBtnTestCleanYard
btnTestCleanYard()
Case $g_hBtnTestOcrMemory
btnTestOcrMemory()
Case $g_hBtnTestConfigSave
saveConfig()
Case $g_hBtnTestConfigRead
readConfig()
Case $g_hBtnTestConfigApply
applyConfig()
Case $g_hBtnTestWeakBase
btnTestWeakBase()
Case $g_hBtnTestClickAway
btnTestClickAway()
Case $g_hBtnTestAutoUpgrade
AutoUpgrade(True)
Case $g_hBtnTestUpgradeWindow
btnTestUpgradeWindow()
Case $g_hBtnTestSmartWait
btnTestSmartWait()
Case $g_hBtnConsoleWindow
btnConsoleWindow()
EndSwitch
If $lParam = $g_hCmbGUILanguage Then
If $nNotifyCode = $CBN_SELCHANGE Then cmbLanguage()
EndIf
$g_bTogglePauseAllowed = $wasAllowed
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_MOVE($hWind, $iMsg, $wParam, $lParam)
If $g_bBotShrinkExpandToggleRequested Then Return $GUI_RUNDEFMSG
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_MOVE: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
If $hWind = $g_hFrmBot Then
If $g_bUpdatingWhenMinimized And BotWindowCheck() = False And _WinAPI_IsIconic($g_hFrmBot) Then
BotMinimize("GUIControl_WM_MOVE")
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndIf
Local $g_iFrmBotPos = WinGetPos($g_hFrmBot)
If $g_bAndroidEmbedded = False Then
$g_iFrmBotPosX =($g_iFrmBotPos[0] > -30000 ? $g_iFrmBotPos[0] : $g_iFrmBotPosX)
$g_iFrmBotPosY =($g_iFrmBotPos[1] > -30000 ? $g_iFrmBotPos[1] : $g_iFrmBotPosY)
Else
$g_iFrmBotDockedPosX =($g_iFrmBotPos[0] > -30000 ? $g_iFrmBotPos[0] : $g_iFrmBotDockedPosX)
$g_iFrmBotDockedPosY =($g_iFrmBotPos[1] > -30000 ? $g_iFrmBotPos[1] : $g_iFrmBotDockedPosY)
EndIf
If $g_bAndroidEmbedded And AndroidEmbedArrangeActive() = False Then
CheckBotShrinkExpandButton()
Local $iAction = AndroidEmbedCheck(True)
If $iAction > 0 Then
AndroidEmbedCheck(False, Default, $iAction)
EndIf
If $g_iDebugWindowMessages Then
Local $a = $g_iFrmBotPos
SetDebugLog("Bot Position: " & $a[0] & "," & $a[1] & " " & $a[2] & "x" & $a[3])
$a = WinGetPos($g_hAndroidWindow)
SetDebugLog("Android Position: " & $a[0] & "," & $a[1] & " " & $a[2] & "x" & $a[3])
If $g_hFrmBotEmbeddedMouse <> 0 Then
$a = WinGetPos($g_hFrmBotEmbeddedMouse)
SetDebugLog("Mouse Window Position: " & $a[0] & "," & $a[1] & " " & $a[2] & "x" & $a[3])
EndIf
EndIf
EndIf
EndIf
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_SYSCOMMAND($hWind, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_SYSCOMMAND: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
If $hWind = $g_hFrmBot Then
Switch $wParam
Case $SC_MINIMIZE
BotMinimize("GUIControl_WM_SYSCOMMAND")
Case $SC_RESTORE
BotRestore("GUIControl_WM_SYSCOMMAND")
Case $SC_CLOSE
BotCloseRequest()
EndSwitch
EndIf
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_NOTIFY($hWind, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages > 1 Then SetDebugLog("GUIControl_WM_NOTIFY: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
Local $nNotifyCode = BitShift($wParam, 16)
Local $nID = BitAND($wParam, 0x0000FFFF)
Local $bCheckEmbeddedShield = True
Switch $nID
Case $g_hTabMain
tabMain()
Case $g_hGUI_VILLAGE_TAB
tabVillage()
Case $g_hGUI_DONATE_TAB
tabDONATE()
Case $g_hGUI_ATTACK_TAB
tabAttack()
Case $g_hGUI_SEARCH_TAB
tabSEARCH()
Case $g_hGUI_DEADBASE_TAB
tabDeadbase()
Case $g_hGUI_ACTIVEBASE_TAB
tabActivebase()
Case $g_hGUI_THSNIPE_TAB
tabTHSnipe()
Case $g_hGUI_BOT_TAB
tabBot()
Case Else
$bCheckEmbeddedShield = False
EndSwitch
If $bCheckEmbeddedShield Then
If $hWind <> $g_hFrmBotEmbeddedShield And $hWind <> $g_hFrmBotEmbeddedGraphics And $hWind <> $g_hFrmBotEmbeddedMouse Then
If AndroidShieldHasFocus() = True Then
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_NOTIFY: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
AndroidShield("GUIControl_WM_NOTIFY", Default, False, 150, False)
EndIf
EndIf
EndIf
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_CLOSE($hWind, $iMsg, $wParam, $lParam)
If $g_iDebugWindowMessages > 0 Then SetDebugLog("GUIControl_WM_CLOSE: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
If $hWind = $g_hFrmBot Then
BotCloseRequest()
EndIf
EndFunc
Func GUIEvents()
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Local $GUI_CtrlId = @GUI_CtrlId
If $g_bFrmBotMinimized And $GUI_CtrlId = $GUI_EVENT_MINIMIZE Then
If $g_iDebugWindowMessages Then SetDebugLog("$GUI_EVENT_MINIMIZE changed to $GUI_EVENT_RESTORE", Default, True)
$GUI_CtrlId = $GUI_EVENT_RESTORE
EndIf
Switch $GUI_CtrlId
Case $GUI_EVENT_CLOSE
If $g_iDebugWindowMessages Then SetDebugLog("$GUI_EVENT_CLOSE", Default, True)
BotCloseRequest()
Case $GUI_EVENT_MINIMIZE
If $g_iDebugWindowMessages Then SetDebugLog("$GUI_EVENT_MINIMIZE", Default, True)
BotMinimize("GUIEvents")
Case $GUI_EVENT_RESTORE
If $g_iDebugWindowMessages Then SetDebugLog("$GUI_EVENT_RESTORE", Default, True)
BotRestore("GUIEvents")
Case Else
If $g_iDebugWindowMessages Then SetDebugLog("$GUI_EVENT: " & @GUI_CtrlId, Default, True)
EndSwitch
$g_bTogglePauseAllowed = $wasAllowed
EndFunc
Func OpenURL_Label($LabelCtrlID)
Local $url = GUICtrlRead($LabelCtrlID)
If StringInStr($url, "http") <> 1 Then
$url = _GUIToolTip_GetText($g_hToolTip, 0, GUICtrlGetHandle($LabelCtrlID))
EndIf
If StringInStr($url, "http") = 1 Then
SetDebugLog("Open URL: " & $url)
ShellExecute($url)
Else
SetDebugLog("Cannot open URL for Control ID " & $LabelCtrlID, $COLOR_ERROR)
EndIf
EndFunc
Func BotMinimizeRequest()
BotMinimize("MinimizeButton", False, 500)
EndFunc
Func BotToFront($hHWndAfter = $HWND_TOPMOST)
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $hHWndAfter, 0, False)
If $hHWndAfter = $HWND_TOPMOST Or $hHWndAfter = $HWND_TOP Then WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
EndFunc
Func CheckBotZOrder($bCheckOnly = False, $bForceZOrder = False)
If $g_iAndroidEmbedMode = 1 And $g_bBotDockedShrinked Then
Local $hWinBehindButtons =($g_hFrmBotEmbeddedGraphics ? $g_hFrmBotEmbeddedGraphics :($g_hFrmBotEmbeddedShield ? $g_hFrmBotEmbeddedShield : $g_hFrmBot))
Local $bCheck = $hWinBehindButtons And($bForceZOrder Or _WinAPI_GetWindow($g_hFrmBotLogoUrlSmall, $GW_HWNDNEXT) <> $g_hFrmBotButtons Or _WinAPI_GetWindow($g_hFrmBotButtons, $GW_HWNDNEXT) <> $hWinBehindButtons)
If $bCheckOnly Then Return $bCheck
If $bCheck Then
SetDebugLog("CheckBotZOrder: Ajust windows Z Order for custom window")
If $bForceZOrder Then
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $HWND_TOPMOST, 0, False)
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
If $g_hFrmBotEmbeddedShield Then WinMove2($g_hFrmBotEmbeddedShield, "", -1, -1, -1, -1, $g_hFrmBot, 0, False)
EndIf
WinMove2($g_hFrmBotLogoUrlSmall, "", -1, -1, -1, -1, $g_hFrmBot, 0, False)
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $g_hFrmBotLogoUrlSmall, 0, False)
WinMove2($g_hFrmBotButtons, "", -1, -1, -1, -1, $g_hFrmBotLogoUrlSmall, 0, False)
If $hWinBehindButtons <> $g_hFrmBot Then WinMove2($hWinBehindButtons, "", -1, -1, -1, -1, $g_hFrmBotButtons, 0, False)
If $g_hFrmBotEmbeddedShield And $g_hFrmBotEmbeddedShield <> $hWinBehindButtons Then WinMove2($g_hFrmBotEmbeddedShield, "", -1, -1, -1, -1, $hWinBehindButtons, 0, False)
EndIf
Return $bCheck
EndIf
If($g_iAndroidEmbedMode = 1 And $g_bCustomTitleBarActive = False) Or $g_avAndroidShieldStatus[4] Then
Local $hTopWin =($g_hFrmBotEmbeddedGraphics ? $g_hFrmBotEmbeddedGraphics :($g_hFrmBotEmbeddedShield ? $g_hFrmBotEmbeddedShield : 0))
Local $bCheck = $hTopWin And($bForceZOrder Or _WinAPI_GetWindow($hTopWin, $GW_HWNDNEXT) <> $g_hFrmBot)
If $bCheckOnly Then Return $bCheck
If $bCheck Then
SetDebugLog("CheckBotZOrder: Ajust windows Z Order for standard window")
If $bForceZOrder Then
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $HWND_TOPMOST, 0, False)
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
WinMove2($g_hFrmBotEmbeddedShield, "", -1, -1, -1, -1, $g_hFrmBot, 0, False)
EndIf
WinMove2($hTopWin, "", -1, -1, -1, -1, $g_hFrmBot, 0, False)
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $hTopWin, 0, False)
If $g_hFrmBotEmbeddedShield And $g_hFrmBotEmbeddedShield <> $hTopWin Then WinMove2($g_hFrmBotEmbeddedShield, "", -1, -1, -1, -1, $hTopWin, 0, False)
EndIf
Return $bCheck
EndIf
Return False
EndFunc
Func CheckBotShrinkExpandButton($bCheckOnlyParent = False)
If $g_hFrmBotButtons = 0 Then Return False
Local $bInconsistent = False
If $g_bAndroidEmbedded = False And $g_bBotDockedShrinked Then
SetDebugLog("Bot Buttons inconsistent state", $COLOR_ERROR)
$bInconsistent = True
$bCheckOnlyParent = False
$g_bBotDockedShrinked = False
EndIf
Local $bChanged = False
Local $aBtnSize = $_GUI_MAIN_BUTTON_SIZE
Local $aPos = ControlGetPos($g_hFrmBot, "", $g_hFrmBotButtons)
Local $bDetached = False
Local $bBottonsHidden = False
If UBound($aPos) > 3 Then
Local $x = $_GUI_MAIN_WIDTH - $aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT
Local $y = 0
Local $iStyle = _WinAPI_GetWindowLong($g_hFrmBotButtons, $GWL_STYLE)
If $g_bAndroidEmbedded = True Then
Local $a = $g_aiAndroidEmbeddedCtrlTarget[6]
Local $iAndroidWidth = $a[2]
$x = $iAndroidWidth + 2 +(($g_bBotDockedShrinked) ?(-$aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT) :($_GUI_MAIN_WIDTH - $aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT))
If $g_iAndroidEmbedMode = 1 Then
If $g_bBotDockedShrinked Then
$bDetached = True
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $x)
DllStructSetData($tPoint, "Y", $y)
_WinAPI_ClientToScreen($g_hFrmBot, $tPoint)
Local $abs_x = DllStructGetData($tPoint, "X")
Local $abs_y = DllStructGetData($tPoint, "Y")
$x = $abs_x
$y = $abs_y
If BitAND($iStyle, $WS_POPUP) <> $WS_POPUP Then
SetDebugLog("Detach Bot Buttons")
$bBottonsHidden = True
GUISetState(@SW_HIDE, $g_hFrmBotButtons)
_WinAPI_SetWindowLong($g_hFrmBotButtons, $GWL_EXSTYLE, BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE))
_WinAPI_SetWindowLong($g_hFrmBotButtons, $GWL_STYLE, BitOR(BitAND($iStyle, BitNOT($WS_CHILD)), $WS_POPUP))
_WinAPI_SetWindowLong($g_hFrmBotButtons, $GWL_HWNDPARENT, 0)
WinMove2($g_hFrmBotButtons, "", $x, $y, -1, -1, $HWND_TOPMOST, 0, False)
WinMove2($g_hFrmBotButtons, "", $x, $y, -1, -1, $HWND_NOTOPMOST, 0, False)
$aPos[0] = $x
$aPos[1] = $y
_WinAPI_SetWindowLong($g_hFrmBotLogoUrlSmall, $GWL_EXSTYLE, BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE))
_WinAPI_SetWindowLong($g_hFrmBotLogoUrlSmall, $GWL_STYLE, BitOR(BitAND($iStyle, BitNOT($WS_CHILD)), $WS_POPUP))
_WinAPI_SetWindowLong($g_hFrmBotLogoUrlSmall, $GWL_HWNDPARENT, 0)
WinMove2($g_hFrmBotLogoUrlSmall, "", $x - 290, $y, -1, -1, $HWND_TOPMOST, 0, False)
WinMove2($g_hFrmBotLogoUrlSmall, "", $x - 290, $y, -1, -1, $HWND_NOTOPMOST, 0, False)
If $bCheckOnlyParent Then Return True
EndIf
If $bCheckOnlyParent Then Return False
$aPos = WinGetPos($g_hFrmBotButtons)
$bChanged = True
EndIf
EndIf
EndIf
If(Not $g_bAndroidEmbedded Or Not $g_bBotDockedShrinked) And BitAND($iStyle, $WS_POPUP) = $WS_POPUP Then
SetDebugLog("Integrate Bot Buttons")
$bBottonsHidden = True
If Not $bInconsistent Then GUISetState(@SW_HIDE, $g_hFrmBotButtons)
_WinAPI_SetParent($g_hFrmBotButtons, $g_hFrmBot)
_WinAPI_SetWindowLong($g_hFrmBotButtons, $GWL_HWNDPARENT, $g_hFrmBot)
_WinAPI_SetWindowLong($g_hFrmBotButtons, $GWL_EXSTYLE, BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE,($g_bAndroidShieldPreWin8 ? 0 : $WS_EX_LAYERED)))
_WinAPI_SetWindowLong($g_hFrmBotButtons, $GWL_STYLE, BitOR(BitAND($iStyle, BitNOT($WS_POPUP)), $WS_CHILD))
If $bInconsistent Then
_WinAPI_SetParent($g_hFrmBotButtons, $g_hFrmBot)
EndIf
_WinAPI_SetParent($g_hFrmBotLogoUrlSmall, $g_hFrmBot)
_WinAPI_SetWindowLong($g_hFrmBotLogoUrlSmall, $GWL_HWNDPARENT, $g_hFrmBot)
_WinAPI_SetWindowLong($g_hFrmBotLogoUrlSmall, $GWL_EXSTYLE, BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE,($g_bAndroidShieldPreWin8 ? 0 : $WS_EX_LAYERED)))
_WinAPI_SetWindowLong($g_hFrmBotLogoUrlSmall, $GWL_STYLE, BitOR(BitAND($iStyle, BitNOT($WS_POPUP)), $WS_CHILD))
If $bInconsistent Then
_WinAPI_SetParent($g_hFrmBotLogoUrlSmall, $g_hFrmBot)
EndIf
If $bCheckOnlyParent Then Return True
$aPos = ControlGetPos($g_hFrmBot, "", $g_hFrmBotButtons)
$bChanged = True
EndIf
If $bCheckOnlyParent Then Return False
If $x <> $aPos[0] Or $y <> $aPos[1] Or $bInconsistent Then
SetDebugLog("Move Bot Buttons: " & $x & ", " & $y)
If $bDetached Then
WinMove2($g_hFrmBotButtons, "", $x, $y, -1, -1, $HWND_TOPMOST, 0, False)
WinMove2($g_hFrmBotButtons, "", $x, $y, -1, -1, $HWND_NOTOPMOST, 0, False)
WinMove2($g_hFrmBotLogoUrlSmall, "", $x - 290, $y, -1, -1, $HWND_TOPMOST, 0, False)
WinMove2($g_hFrmBotLogoUrlSmall, "", $x - 290, $y, -1, -1, $HWND_NOTOPMOST, 0, False)
Else
WinMove2($g_hFrmBotButtons, "", $x, $y, -1, -1, 0, 0, False)
WinMove2($g_hFrmBotLogoUrlSmall, "", $x - 290, $y, -1, -1, 0, 0, False)
WinMove2($g_hFrmBotLogoUrlSmall, "", $x - 290, $y, -1, -1, 0, 0, False)
EndIf
$bChanged = True
EndIf
EndIf
If $bBottonsHidden = True Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotButtons)
If $g_bBotDockedShrinked Then GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotLogoUrlSmall)
EndIf
If $bInconsistent Then
GUICtrlSetState($g_hLblBotShrink,(($g_bBotDockedShrinked) ?($GUI_HIDE) :($GUI_SHOW)))
GUICtrlSetState($g_hLblBotExpand,(($g_bBotDockedShrinked) ?($GUI_SHOW) :($GUI_HIDE)))
WinSetTrans($g_hFrmBotButtons, "",(($g_bBotDockedShrinked) ?(210) :(254)))
EndIf
Return $bChanged
EndFunc
Func BotShrinkExpandToggle()
$g_bBotShrinkExpandToggleRequested = True
EndFunc
Func BotShrinkExpandToggleExecute()
If $g_hFrmBotButtons = 0 Then Return False
If $g_iBotAction = $eBotClose Then Return False
If $g_bAndroidEmbedded = False Then
SetDebugLog("BotShrinkExpandToggle: Android not docked")
$g_bBotShrinkExpandToggleRequested = False
Return False
EndIf
Local $aPos = WinGetPos($g_hFrmBot)
If UBound($aPos) < 4 Then
SetDebugLog("BotShrinkExpandToggle: Bot Window not accessible")
$g_bBotShrinkExpandToggleRequested = False
Return False
EndIf
Local $aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
$aPos[2] =(($g_bBotDockedShrinked) ?($aPosCtl[2] + 2) :($g_aFrmBotPosInit[2] + $aPosCtl[2] + 2))
$aPos[3] = $g_aFrmBotPosInit[3] + $g_iFrmBotAddH + $g_aFrmBotPosInit[7]
Local $bAndroidShieldEnabled = $g_bAndroidShieldEnabled
$g_bAndroidShieldEnabled = False
$g_bBotDockedShrinked = Not $g_bBotDockedShrinked
If Not $g_bBotDockedShrinked Then GUISetState(@SW_HIDE, $g_hFrmBotLogoUrlSmall)
Local $aBtnSize = $_GUI_MAIN_BUTTON_SIZE
Local $a = $g_aiAndroidEmbeddedCtrlTarget[6]
Local $iAndroidWidth = $a[2]
If Not $g_bBotDockedShrinked And CheckBotShrinkExpandButton(True) Then
Local $bStillShrinked = True
WinMove2($g_hFrmBotButtons, "", $iAndroidWidth + 2 +(($bStillShrinked) ?(-$aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT) :($_GUI_MAIN_WIDTH - $aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT)), 0, -1, -1, 0, 0, False)
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotButtons)
EndIf
Local $iMode =(($g_bBotDockedShrinked) ?(1) :(-1))
Local $aPosBtn = ControlGetPos($g_hFrmBot, "", $g_hFrmBotButtons)
Local $bAnimate = $bAndroidShieldEnabled And Not $g_bAndroidShieldPreWin8 And $g_bChkBackgroundMode
GUISetState(@SW_HIDE, $g_hFrmBotEx)
GUISetState(@SW_HIDE, $g_hFrmBotBottom)
Local $iSteps = 10
Local $fStep = $_GUI_MAIN_WIDTH / $iSteps
Local $bGetAnimationSpeed = True
Local $iAnimationDelay = 0
If $bAnimate Then
For $i = 1 To $iSteps
Local $iWidth = Round($aPos[2] - $i * $fStep * $iMode, 0)
Local $iChange = $iWidth - $aPos[2]
If $bGetAnimationSpeed Then Local $hTimer = __TimerInit()
WinMove2($g_hFrmBot, "", -1, -1, $iWidth, $aPos[3], 0, 0, False)
WinMove2($g_hFrmBotButtons, "", $iAndroidWidth + 2 - $aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT + $iChange +(($g_bBotDockedShrinked) ?($_GUI_MAIN_WIDTH) :(0)), $aPosBtn[1], -1, -1, 0, 0, False)
If $bGetAnimationSpeed Then
$iAnimationDelay = 100 / $iSteps - __TimerDiff($hTimer)
EndIf
If $iAnimationDelay > 0 Then _SleepMilli($iAnimationDelay)
Next
EndIf
GUICtrlSetState($g_hLblBotShrink,(($g_bBotDockedShrinked) ?($GUI_HIDE) :($GUI_SHOW)))
GUICtrlSetState($g_hLblBotExpand,(($g_bBotDockedShrinked) ?($GUI_SHOW) :($GUI_HIDE)))
WinSetTrans($g_hFrmBotButtons, "",(($g_bBotDockedShrinked) ?(210) :(254)))
WinMove2($g_hFrmBot, "", -1, -1, $aPos[2] - $_GUI_MAIN_WIDTH * $iMode, $aPos[3], 0, 0, False)
WinMove2($g_hFrmBotButtons, "", $iAndroidWidth + 2 +(($g_bBotDockedShrinked) ?(-$aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT) :($_GUI_MAIN_WIDTH - $aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT)), $aPosBtn[1], -1, -1, 0, 0, False)
If $g_bBotDockedShrinked Then
WinMove2($g_hFrmBotLogoUrlSmall, "", $iAndroidWidth + 2 +(($g_bBotDockedShrinked) ?(-$aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT) :($_GUI_MAIN_WIDTH - $aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT)) - 290, $aPosBtn[1], -1, -1, 0, 0, False)
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotLogoUrlSmall)
EndIf
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotEx)
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotBottom)
If $g_bBotDockedShrinked Then CheckBotShrinkExpandButton()
SetDebugLog("BotShrinkExpandToggle: Bot " &(($g_bBotDockedShrinked) ?("collapsed") :("expanded")))
$g_bAndroidShieldEnabled = $bAndroidShieldEnabled
$g_bBotShrinkExpandToggleRequested = False
Return True
EndFunc
Func BotGuiModeToggleRequest()
If Not $g_bRunState And Not IsConfigActive() And Not DllCallMyBotIsActive() Then
BotGuiModeToggle()
Return False
EndIf
$g_bBotGuiModeToggleRequested = True
Return True
EndFunc
Func BotGuiModeToggle()
Static $bIsActive = False
If $g_iBotAction = $eBotClose Or $g_iGuiMode = 0 Or $bIsActive Or IsConfigActive() Or DllCallMyBotIsActive() Then Return False
$bIsActive = True
$g_bBotGuiModeToggleRequested = False
If $g_bAndroidEmbedded Then AndroidEmbed(False)
Local $_GUI_MAIN_WIDTH_OLD = $_GUI_MAIN_WIDTH
Local $_GUI_MAIN_HEIGHT_OLD = $_GUI_MAIN_HEIGHT
Switch $g_iGuiMode
Case 1
SetLog("Switch to Mini GUI Mode")
applyConfig(False, "Save")
saveConfig()
$g_iGuiMode = 2
SetRedrawBotWindow(False, Default, Default, Default, "BotGuiModeToggle")
$_GUI_MAIN_WIDTH = $_MINIGUI_MAIN_WIDTH
$_GUI_MAIN_HEIGHT = $_MINIGUI_MAIN_HEIGHT
_WinAPI_SetParent($g_hTxtLog, $g_hFrmBotEx)
_WinAPI_SetParent($g_hTxtAtkLog, $g_hFrmBotEx)
_WinAPI_SetWindowLong($g_hTxtLog, $GWL_HWNDPARENT, $g_hFrmBotEx)
_WinAPI_SetWindowLong($g_hTxtAtkLog, $GWL_HWNDPARENT, $g_hFrmBotEx)
WinSetState($g_hTxtLog, "", @SW_MINIMIZE)
WinSetState($g_hTxtAtkLog, "", @SW_MINIMIZE)
GUICtrlDelete($g_hTabMain)
GUICtrlDelete($g_hTabLog)
GUICtrlDelete($g_hTabVillage)
GUICtrlDelete($g_hTabAttack)
GUICtrlDelete($g_hTabBot)
GUICtrlDelete($g_hTabAbout)
GUICtrlDelete($g_hGUI_VILLAGE_TAB)
GUICtrlDelete($g_hGUI_MISC_TAB)
GUICtrlDelete($g_hGUI_DONATE_TAB)
GUICtrlDelete($g_hGUI_UPGRADE_TAB)
GUICtrlDelete($g_hGUI_NOTIFY_TAB)
GUICtrlDelete($g_hGUI_ATTACK_TAB)
GUICtrlDelete($g_hGUI_TRAINARMY_TAB)
GUICtrlDelete($g_hGUI_SEARCH_TAB)
GUICtrlDelete($g_hGUI_DEADBASE_TAB)
GUICtrlDelete($g_hGUI_ACTIVEBASE_TAB)
GUICtrlDelete($g_hGUI_THSNIPE_TAB)
GUICtrlDelete($g_hGUI_ATTACKOPTION_TAB)
GUICtrlDelete($g_hGUI_STRATEGIES_TAB)
GUICtrlDelete($g_hGUI_BOT_TAB)
GUICtrlDelete($g_hGUI_LOG_SA)
GUICtrlDelete($g_hGUI_STATS_TAB)
For $i = $g_hFirstControlToHide To $g_hLastControlToHide
GUICtrlDelete($i)
Next
$g_hFirstControlToHide = 0
$g_hLastControlToHide = 0
For $hGUI In $g_oGuiNotInMini
SetDebugLog("GUIDelete: " & $hGUI)
GUIDelete($hGUI)
Next
$g_oGuiNotInMini.RemoveAll
$oAlwaysEnabledControls.RemoveAll
__GDIPlus_Shutdown()
__GDIPlus_Startup()
Case 2
SetLog("Switch to Normal GUI Mode")
$g_iGuiMode = 1
$_GUI_MAIN_WIDTH = $_NORMALGUI_MAIN_WIDTH
$_GUI_MAIN_HEIGHT = $_NORMALGUI_MAIN_HEIGHT
CreateSplashScreen(6)
CreateMainGUIControls(True)
tabBot()
tabDONATE()
tabSEARCH()
tabAttack()
tabVillage()
InitializeMainGUI(True)
UpdateStats(True)
UpdateMultiStats()
DistributorsUpdateGUI()
DestroySplashScreen()
applyConfig(False)
If Not $g_bGuiControlsEnabled Then DisableGuiControls()
SetRedrawBotWindow(False, Default, Default, Default, "BotGuiModeToggle")
_GUICtrlRichEdit_SetSel($g_hTxtLog, 0, 0)
_GUICtrlRichEdit_SetSel($g_hTxtLog, -1, -1)
_GUICtrlRichEdit_SetSel($g_hTxtAtkLog, 0, 0)
_GUICtrlRichEdit_SetSel($g_hTxtAtkLog, -1, -1)
GUICtrlSetState($g_hTabMain, $GUI_FOCUS)
EndSwitch
WinMove2($g_hFrmBotBottom, "", 0, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP, -1, -1, 0, 0, False)
Local $xComp = $g_aFrmBotPosInit[2] - $_GUI_MAIN_WIDTH_OLD
Local $yComp = $g_aFrmBotPosInit[3] + $g_aFrmBotPosInit[7] - $_GUI_MAIN_HEIGHT_OLD
WinMove2($g_hFrmBotEx, "", -1, -1, $_GUI_MAIN_WIDTH, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP, 0, 0, False)
WinMove2($g_hFrmBot, "", -1, -1, $_GUI_MAIN_WIDTH + $xComp, $_GUI_MAIN_HEIGHT + $yComp, 0, 0, False)
GUICtrlSetState($g_hLblBotNormalGUI,(($g_iGuiMode = 1) ?($GUI_HIDE) :($GUI_SHOW)))
GUICtrlSetState($g_hLblBotMiniGUI,(($g_iGuiMode = 2) ?($GUI_HIDE) :($GUI_SHOW)))
updateBtnEmbed()
SetRedrawBotWindow(True, Default, Default, Default, "BotGuiModeToggle")
ShowMainGUI()
$bIsActive = False
Return True
EndFunc
Func BotMoveRequest()
$g_bBotMoveRequested = True
EndFunc
Func CheckBotRequests()
CheckBotZOrder()
If $g_bBotMoveRequested = True Then
$g_bBotMoveRequested = False
_WinAPI_PostMessage($g_hFrmBot, $WM_SYSCOMMAND, 0xF012, 0)
Else
If $g_bBotShrinkExpandToggleRequested Then BotShrinkExpandToggleExecute()
If $g_bBotGuiModeToggleRequested Then BotGuiModeToggle()
EndIf
EndFunc
Func BotCloseRequest()
If $g_iBotAction = $eBotClose Then
BotClose()
Else
SetLog("Closing " & $g_sBotTitle & ", please wait ...")
EndIf
$g_bRunState = False
$g_bBotPaused = False
$g_iBotAction = $eBotClose
EndFunc
Func BotCloseRequestProcessed()
Return False
EndFunc
Func BotClose($SaveConfig = Default, $bExit = True)
If $SaveConfig = Default Then $SaveConfig = IsBotLaunched()
$g_bRunState = False
$g_bBotPaused = False
ResumeAndroid()
SetLog("Closing " & $g_sBotTitle & " now ...")
LockBotSlot(False)
If $SaveConfig = True Then
setupProfile()
SaveConfig()
EndIf
$g_bChkBackgroundMode = True
AndroidEmbed(False)
AndroidShieldDestroy()
If $g_bAndroidCloseWithBot And $g_hAndroidWindow Then
$g_bRunState = True
CloseAndroid("BotClose")
$g_bRunState = False
Else
AndroidBotStopEvent()
AndroidToFront(Default, "BotClose")
AndroidAdbTerminateShellInstance()
EndIf
If $g_hMutex_BotTitle <> 0 Then ReleaseMutex($g_hMutex_BotTitle)
ReleaseProfilesMutex(True)
If $g_hMutex_MyBot <> 0 Then ReleaseMutex($g_hMutex_MyBot)
__GDIPlus_Shutdown()
_Crypt_Shutdown()
_GUICtrlRichEdit_Destroy($g_hTxtLog)
_GUICtrlRichEdit_Destroy($g_hTxtAtkLog)
_WinAPI_DeregisterShellHookWindow($g_hFrmBot)
If $g_hAndroidWindow <> 0 Then ControlFocus($g_hAndroidWindow, "", $g_hAndroidWindow)
GUIDelete($g_hFrmBot)
$g_aiAndroidAdbScreencapBuffer = 0
$g_hStruct_SleepMicro = 0
UnregisterManagedMyBotHost()
If $bExit = True Then Exit
EndFunc
Func BotMinimizeRestore($bMinimize, $sCaller, $iForceUpdatingWhenMinimized = False, $iStayMinimizedMillis = 0, $hHWndAfter = $HWND_TOP)
Static $siStayMinimizedMillis = 0
Static $shStayMinimizedTimer = 0
If $bMinimize Then
If $iStayMinimizedMillis > 0 Then
$siStayMinimizedMillis = $iStayMinimizedMillis
$shStayMinimizedTimer = __TimerInit()
EndIf
If $g_bAndroidEmbedded = True And $g_bChkBackgroundMode = False Then
Return False
EndIf
SetDebugLog("Minimize bot window, caller: " & $sCaller, Default, True)
$g_bFrmBotMinimized = True
If $g_bUpdatingWhenMinimized Or $iForceUpdatingWhenMinimized = True Then
If $g_bHideWhenMinimized Then
WinMove2($g_hFrmBot, "", -32000, -32000, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_SetWindowLong($g_hFrmBot, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($g_hFrmBot, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW))
EndIf
If _WinAPI_IsIconic($g_hFrmBot) Then WinSetState($g_hFrmBot, "", @SW_RESTORE)
If _WinAPI_IsIconic($g_hAndroidWindow) Then WinSetState($g_hAndroidWindow, "", @SW_RESTORE)
WinMove2($g_hFrmBot, "", -32000, -32000, -1, -1, 0, BitOR($SWP_SHOWWINDOW, $SWP_NOACTIVATE), False)
Else
If $g_bHideWhenMinimized Then
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_SetWindowLong($g_hFrmBot, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($g_hFrmBot, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW))
EndIf
WinSetState($g_hFrmBot, "", @SW_MINIMIZE)
EndIf
If $g_bChkBackgroundMode And Not $g_bIsHidden Then HideAndroidWindow(True, False, Default, "BotMinimizeRestore")
Return True
EndIf
If $siStayMinimizedMillis > 0 And __TimerDiff($shStayMinimizedTimer) < $siStayMinimizedMillis Then
SetDebugLog("Prevent Bot Window Restore")
Return False
Else
$siStayMinimizedMillis = 0
$shStayMinimizedTimer = 0
EndIf
$g_bFrmBotMinimized = False
Local $botPosX =($g_bAndroidEmbedded = False ? $g_iFrmBotPosX : $g_iFrmBotDockedPosX)
Local $botPosY =($g_bAndroidEmbedded = False ? $g_iFrmBotPosY : $g_iFrmBotDockedPosY)
Local $aPos = [$botPosX, $botPosY]
SetDebugLog("Restore bot window to " & $botPosX & ", " & $botPosY & ", caller: " & $sCaller, Default, True)
Local $iExStyle = _WinAPI_GetWindowLong($g_hFrmBot, $GWL_EXSTYLE)
If BitAND($iExStyle, $WS_EX_TOOLWINDOW) Then
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_SetWindowLong($g_hFrmBot, $GWL_EXSTYLE, BitAND($iExStyle, BitNOT($WS_EX_TOOLWINDOW)))
EndIf
If _WinAPI_IsIconic($g_hFrmBot) Then WinSetState($g_hFrmBot, "", @SW_RESTORE)
If $g_bAndroidAdbScreencap = False And $g_bRunState = True And $g_bBotPaused = False And _WinAPI_IsIconic($g_hAndroidWindow) Then WinSetState($g_hAndroidWindow, "", @SW_RESTORE)
WinMove2($g_hFrmBot, "", $botPosX, $botPosY, -1, -1, $hHWndAfter, BitOR($SWP_SHOWWINDOW, $SWP_NOACTIVATE))
If _CheckWindowVisibility($g_hFrmBot, $aPos) Then
SetDebugLog("Bot Window '" & $g_sAndroidTitle & "' not visible, moving to position: " & $aPos[0] & ", " & $aPos[1])
WinMove2($g_hFrmBot, "", $aPos[0], $aPos[1])
EndIf
WinSetTrans($g_hFrmBot, "", 255)
BotToFront($hHWndAfter)
If $g_bChkBackgroundMode And Not $g_bIsHidden And $hHWndAfter <> $g_hAndroidWindow Then HideAndroidWindow(False, False, Default, "BotMinimizeRestore", $g_hFrmBot)
Return True
EndFunc
Func BotMinimize($sCaller, $iForceUpdatingWhenMinimized = False, $iStayMinimizedMillis = 0)
Return BotMinimizeRestore(True, $sCaller, $iForceUpdatingWhenMinimized, $iStayMinimizedMillis)
EndFunc
Func BotRestore($sCaller)
Return BotMinimizeRestore(False, $sCaller)
EndFunc
Func BotWindowCheck()
If $g_bFrmBotMinimized Then
Local $aPos = WinGetPos($g_hFrmBot)
If IsArray($aPos) And $aPos[0] > -30000 Or $aPos[0] > -30000 Then
BotMinimize("BotWindowCheck")
Return True
EndIf
EndIf
Return False
EndFunc
Func tiStartStop()
If $g_bRunState Then
btnStop()
Else
btnStart()
EndIf
EndFunc
Func tiShow()
BotRestore("tiShow")
EndFunc
Func tiHide()
$g_bHideWhenMinimized = Not $g_bHideWhenMinimized
TrayItemSetState($g_hTiHide,($g_bHideWhenMinimized ? $TRAY_CHECKED : $TRAY_UNCHECKED))
GUICtrlSetState($g_hChkHideWhenMinimized,($g_bHideWhenMinimized ? $GUI_CHECKED : $GUI_UNCHECKED))
If $g_bFrmBotMinimized = True Then
If $g_bHideWhenMinimized = False Then
BotRestore("tiHide")
Else
BotMinimize("tiHide")
EndIf
EndIf
EndFunc
Func tiAbout()
Local $sMsg = "Clash of Clans Bot" & @CRLF & @CRLF & "Version: " & $g_sBotVersion & @CRLF & "Released under the GNU GPLv3 license." & @CRLF & "Visit www.MyBot.run"
MsgBox(64 + $MB_APPLMODAL + $MB_TOPMOST, $g_sBotTitle, $sMsg, 0, $g_hFrmBot)
EndFunc
Func tiDonate()
ShellExecute("https://mybot.run/forums/index.php?/donate/make-donation/")
EndFunc
Func tiExit()
BotCloseRequest()
EndFunc
Func SetRedrawBotWindow($bEnableRedraw, $bCheckRedrawBotWindow = Default, $bForceRedraw = Default, $RedrawControlIDs = Default, $sSource = "")
If $g_iRedrawBotWindowMode = 0 Then Return False
If $g_iRedrawBotWindowMode = 1 Then $RedrawControlIDs = Default
If $bCheckRedrawBotWindow = Default Then $bCheckRedrawBotWindow = True
If $bForceRedraw = Default Then $bForceRedraw = False
Local $bWasRedraw = $g_bRedrawBotWindow[0]
If $g_bRedrawBotWindow[0] = $bEnableRedraw Then
Return $bWasRedraw
EndIf
_SendMessage($g_hFrmBotEx, $WM_SETREDRAW, $bEnableRedraw, 0)
$g_bRedrawBotWindow[0] = $bEnableRedraw
If $bEnableRedraw Then
If $bCheckRedrawBotWindow Then
CheckRedrawBotWindow($bForceRedraw, $RedrawControlIDs, $sSource)
EndIf
Else
SetDebugLog("Disable MyBot Window Redraw" &(($sSource <> "") ?(": " & $sSource) :("")))
$g_bRedrawBotWindow[1] = True
EndIf
Return $bWasRedraw
EndFunc
Func SetRedrawBotWindowControls($bEnableRedraw, $RedrawControlIDs, $sSource = "")
Return SetRedrawBotWindow($bEnableRedraw, True, False, $RedrawControlIDs, $sSource)
EndFunc
Func CheckRedrawBotWindow($bForceRedraw = Default, $RedrawControlIDs = Default, $sSource = "")
If $g_iRedrawBotWindowMode = 0 Then Return False
If $bForceRedraw = Default Then $bForceRedraw = False
If $g_iRedrawBotWindowMode = 1 Then $RedrawControlIDs = Default
If Not $g_bRedrawBotWindow[0] Then Return False
If $g_bRedrawBotWindow[1] Or $bForceRedraw Then
$g_bRedrawBotWindow[1] = False
$g_bRedrawBotWindow[2] = False
If $RedrawControlIDs = Default Then
SetDebugLog("Redraw MyBot Window" &($bForceRedraw ? " (forced)" : "") &(($sSource <> "") ?(": " & $sSource) :("")))
_WinAPI_RedrawWindow($g_hFrmBotEx, 0, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN, $RDW_ERASE))
Else
If IsArray($RedrawControlIDs) Then
SetDebugLog("Redraw MyBot ControlIds" &($bForceRedraw ? " (forced)" : "") & ": " & _ArrayToString($RedrawControlIDs, ", "))
Local $c
For $c In $RedrawControlIDs
If ControlRedraw($g_hFrmBot, $c) = 0 Then
_WinAPI_RedrawWindow($g_hFrmBotEx, 0, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN, $RDW_ERASE))
ExitLoop
EndIf
Next
Else
SetDebugLog("Redraw MyBot ControlId" &($bForceRedraw ? " (forced)" : "") & ": " & $RedrawControlIDs)
If ControlRedraw($g_hFrmBot, $RedrawControlIDs) = 0 Then
_WinAPI_RedrawWindow($g_hFrmBotEx, 0, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN, $RDW_ERASE))
EndIf
EndIf
EndIf
_WinAPI_UpdateWindow($g_hFrmBotEx)
Return True
Else
Return CheckRedrawControls(Default, $sSource)
EndIf
Return False
EndFunc
Func CheckRedrawControls($ForceCheck = Default, $sSource = "")
If $g_iRedrawBotWindowMode = 0 Then Return False
If $ForceCheck = Default Then $ForceCheck = False
If Not $g_bRedrawBotWindow[2] And Not $ForceCheck Then Return False
If GUICtrlRead($g_hTabMain, 1) = $g_hTabLog Then
Local $a = [$g_hTxtLog, $g_hTxtAtkLog]
Return CheckRedrawBotWindow(True, $a, $sSource)
EndIf
$g_bRedrawBotWindow[2] = False
Return False
EndFunc
Func RedrawBotWindowNow()
SetDebugLog("Redraw MyBot Window Now")
_WinAPI_RedrawWindow($g_hFrmBot, 0, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN, $RDW_ERASE))
_WinAPI_UpdateWindow($g_hFrmBot)
EndFunc
Func ControlRedraw($hWin, $ConrolId)
Local $a = ControlGetPos($hWin, "", $ConrolId)
If IsArray($a) = 0 Then
SetDebugLog("ControlRedraw: Invalid ControlId: " & $ConrolId)
Return 0
EndIf
Local $hCtrl =(IsHWnd($ConrolId) ? $ConrolId : GUICtrlGetHandle($ConrolId))
Local $hWinParent = _WinAPI_GetParent($hCtrl)
SetDebugLog("Control ID " & $ConrolId & " handle: " & $hCtrl & " parent: " & $hWinParent & " $g_hFrmBot: " & $g_hFrmBot & " $g_hFrmBotEx: " & $g_hFrmBotEx & " Pos: " & $a[0] & ", " & $a[1] & ", " & $a[2] & ", " & $a[3], Default, True)
Local $left = $a[0]
Local $top = $a[1]
Local $width = $a[2]
Local $height = $a[3]
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $left)
DllStructSetData($tRECT, "Top", $top)
DllStructSetData($tRECT, "Right", $left + $width)
DllStructSetData($tRECT, "Bottom", $top + $height)
SetDebugLog("Control ID " & $ConrolId & " RedrawWindow Pos: " & $left & ", " & $top & ", " & $left + $width & ", " & $top + $height, Default, True)
_WinAPI_RedrawWindow($hWin, $tRECT, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN))
$tRECT = 0
Return 1
EndFunc
Func SetTime($bForceUpdate = False)
If $g_hTimerSinceStarted = 0 Then Return
Local $day = 0, $hour = 0, $min = 0, $sec = 0
If GUICtrlRead($g_hGUI_STATS_TAB, 1) = $g_hGUI_STATS_TAB_ITEM2 Or $bForceUpdate = True Then
_TicksToDay(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed), $day, $hour, $min, $sec)
GUICtrlSetData($g_hLblResultRuntime, $day > 0 ? StringFormat("%2u Day(s) %02i:%02i:%02i", $day, $hour, $min, $sec) : StringFormat("%02i:%02i:%02i", $hour, $min, $sec))
EndIf
If GUICtrlGetState($g_hLblResultGoldNow) <> $GUI_ENABLE + $GUI_SHOW Or $bForceUpdate = True Then
_TicksToTime(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed), $hour, $min, $sec)
GUICtrlSetData($g_hLblResultRuntimeNow, StringFormat("%02i:%02i:%02i", $hour, $min, $sec))
EndIf
Local Static $DisplayLoop = 0
If $DisplayLoop >= 3 Then
$DisplayLoop = 0
If ProfileSwitchAccountEnabled() Then
If GUICtrlRead($g_hGUI_STATS_TAB, 1) = $g_hGUI_STATS_TAB_ITEM5 Then
Local $abAccountNo = AccountNoActive()
For $i = 0 To $g_iTotalAcc
If $abAccountNo[$i] And Not $g_abDonateOnly[$i] And $g_aiTimerStart[$i] <> 0 Then
Local $UpdateTrainTime = $g_aiRemainTrainTime[$i] - TimerDiff($g_aiTimerStart[$i]) / 60 / 1000
Local $sReadyTime = ""
If Abs($UpdateTrainTime) >= 60 Then
$sReadyTime &= Int($UpdateTrainTime / 60) & "h " & Abs(Round(Mod($UpdateTrainTime, 60), 0)) & "m"
Else
$sReadyTime &= Int($UpdateTrainTime) & "m " & Abs(Round(Mod($UpdateTrainTime, 1) * 60, 0)) & "s"
EndIf
If $i = $g_iCurAccount Then
GUICtrlSetBkColor($g_ahLblTroopsTime[$i], $COLOR_GREEN)
GUICtrlSetColor($g_ahLblTroopsTime[$i], $COLOR_WHITE)
ElseIf $UpdateTrainTime < 0 Then
GUICtrlSetBkColor($g_ahLblTroopsTime[$i], $COLOR_RED)
GUICtrlSetColor($g_ahLblTroopsTime[$i], $COLOR_WHITE)
Else
GUICtrlSetBkColor($g_ahLblTroopsTime[$i], $COLOR_YELLOW)
GUICtrlSetColor($g_ahLblTroopsTime[$i], $COLOR_BLACK)
EndIf
GUICtrlSetData($g_ahLblTroopsTime[$i], $sReadyTime)
EndIf
Next
EndIf
EndIf
EndIf
$DisplayLoop += 1
EndFunc
Func tabMain()
If $g_iGuiMode = 0 Then Return
Local $tabidx = GUICtrlRead($g_hTabMain)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
GUISetState(@SW_HIDE, $g_hGUI_ABOUT)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_LOG)
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
GUISetState(@SW_HIDE, $g_hGUI_ABOUT)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_VILLAGE)
tabVillage()
Case $tabidx = 2
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
GUISetState(@SW_HIDE, $g_hGUI_ABOUT)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ATTACK)
tabAttack()
Case $tabidx = 3
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_ABOUT)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_BOT)
tabBot()
Case $tabidx = 4
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ABOUT)
Case Else
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
EndSelect
EndFunc
Func tabVillage()
Local $tabidx = GUICtrlRead($g_hGUI_VILLAGE_TAB)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $g_hGUI_UPGRADE)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_MISC)
GUISetState(@SW_HIDE, $g_hGUI_DONATE)
GUISetState(@SW_HIDE, $g_hGUI_NOTIFY)
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_UPGRADE)
GUISetState(@SW_HIDE, $g_hGUI_MISC)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DONATE)
GUISetState(@SW_HIDE, $g_hGUI_NOTIFY)
Case $tabidx = 2
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_UPGRADE)
GUISetState(@SW_HIDE, $g_hGUI_MISC)
GUISetState(@SW_HIDE, $g_hGUI_DONATE)
GUISetState(@SW_HIDE, $g_hGUI_NOTIFY)
Case $tabidx = 4
GUISetState(@SW_HIDE, $g_hGUI_UPGRADE)
GUISetState(@SW_HIDE, $g_hGUI_MISC)
GUISetState(@SW_HIDE, $g_hGUI_DONATE)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_NOTIFY)
Case Else
GUISetState(@SW_HIDE, $g_hGUI_UPGRADE)
GUISetState(@SW_HIDE, $g_hGUI_MISC)
GUISetState(@SW_HIDE, $g_hGUI_DONATE)
GUISetState(@SW_HIDE, $g_hGUI_NOTIFY)
EndSelect
EndFunc
Func tabAttack()
Local $tabidx = GUICtrlRead($g_hGUI_ATTACK_TAB)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $g_hGUI_STRATEGIES)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_TRAINARMY)
GUISetState(@SW_HIDE, $g_hGUI_SEARCH)
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_STRATEGIES)
GUISetState(@SW_HIDE, $g_hGUI_TRAINARMY)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_SEARCH)
tabSEARCH()
Case $tabidx = 2
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_STRATEGIES)
GUISetState(@SW_HIDE, $g_hGUI_TRAINARMY)
GUISetState(@SW_HIDE, $g_hGUI_SEARCH)
EndSelect
EndFunc
Func tabSEARCH()
Local $tabidx = GUICtrlRead($g_hGUI_SEARCH_TAB)
Local $tabdbx = _GUICtrlTab_GetItemRect($g_hGUI_SEARCH_TAB, 0)
Local $tababx = _GUICtrlTab_GetItemRect($g_hGUI_SEARCH_TAB, 1)
Local $tabtsx = _GUICtrlTab_GetItemRect($g_hGUI_SEARCH_TAB, 2)
Local $tabblx = _GUICtrlTab_GetItemRect($g_hGUI_SEARCH_TAB, 3)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $g_hGUI_THSNIPE)
GUISetState(@SW_HIDE, $g_hGUI_BULLY)
GUISetState(@SW_HIDE, $g_hGUI_ATTACKOPTION)
If GUICtrlRead($g_hChkDeadbase) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DEADBASE)
GUICtrlSetState($g_hLblDeadbaseDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE)
GUICtrlSetState($g_hLblDeadbaseDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkActivebase, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($g_hChkTHSnipe, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($g_hChkBully, $tabblx[2] - 15, $tabblx[3] - 15)
GUICtrlSetPos($g_hChkDeadbase, $tabdbx[2] - 15, $tabdbx[3] - 17)
tabDeadbase()
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE)
GUISetState(@SW_HIDE, $g_hGUI_THSNIPE)
GUISetState(@SW_HIDE, $g_hGUI_BULLY)
GUISetState(@SW_HIDE, $g_hGUI_ATTACKOPTION)
If GUICtrlRead($g_hChkActivebase) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ACTIVEBASE)
GUICtrlSetState($g_hLblActivebaseDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE)
GUICtrlSetState($g_hLblActivebaseDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkDeadbase, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($g_hChkTHSnipe, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($g_hChkBully, $tabblx[2] - 15, $tabblx[3] - 15)
GUICtrlSetPos($g_hChkActivebase, $tababx[2] - 15, $tababx[3] - 17)
tabActivebase()
Case $tabidx = 2
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $g_hGUI_BULLY)
GUISetState(@SW_HIDE, $g_hGUI_ATTACKOPTION)
If GUICtrlRead($g_hChkTHSnipe) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_THSNIPE)
GUICtrlSetState($g_hLblTHSnipeDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_THSNIPE)
GUICtrlSetState($g_hLblTHSnipeDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkDeadbase, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($g_hChkActivebase, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($g_hChkBully, $tabblx[2] - 15, $tabblx[3] - 15)
GUICtrlSetPos($g_hChkTHSnipe, $tabtsx[2] - 15, $tabtsx[3] - 17)
tabTHSnipe()
Case $tabidx = 3
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $g_hGUI_THSNIPE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACKOPTION)
If GUICtrlRead($g_hChkBully) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_BULLY)
GUICtrlSetState($g_hLblBullyDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_BULLY)
GUICtrlSetState($g_hLblBullyDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkDeadbase, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($g_hChkActivebase, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($g_hChkTHSnipe, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($g_hChkBully, $tabblx[2] - 15, $tabblx[3] - 17)
Case $tabidx = 4
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $g_hGUI_THSNIPE)
GUISetState(@SW_HIDE, $g_hGUI_BULLY)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ATTACKOPTION)
GUICtrlSetPos($g_hChkDeadbase, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($g_hChkActivebase, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($g_hChkTHSnipe, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($g_hChkBully, $tabblx[2] - 15, $tabblx[3] - 15)
EndSelect
EndFunc
Func tabDONATE()
Local $tabidx = GUICtrlRead($g_hGUI_DONATE_TAB)
Local $tabdonx = _GUICtrlTab_GetItemRect($g_hGUI_DONATE_TAB, 1)
Select
Case $tabidx = 0
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_RequestCC)
GUISetState(@SW_HIDE, $g_hGUI_DONATECC)
GUISetState(@SW_HIDE, $g_hGUI_ScheduleCC)
GUICtrlSetPos($g_hChkDonate, $tabdonx[2] - 15, $tabdonx[3] - 15)
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_RequestCC)
GUISetState(@SW_HIDE, $g_hGUI_ScheduleCC)
If GUICtrlRead($g_hChkDonate) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DONATECC)
GUICtrlSetState($g_hLblDonateDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_DONATECC)
GUICtrlSetState($g_hLblDonateDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkDonate, $tabdonx[2] - 15, $tabdonx[3] - 15)
Case $tabidx = 2
GUISetState(@SW_HIDE, $g_hGUI_RequestCC)
GUISetState(@SW_HIDE, $g_hGUI_DONATECC)
If GUICtrlRead($g_hChkDonate) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ScheduleCC)
GUICtrlSetState($g_hLblScheduleDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_ScheduleCC)
GUICtrlSetState($g_hLblScheduleDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkDonate, $tabdonx[2] - 15, $tabdonx[3] - 15)
EndSelect
EndFunc
Func tabBot()
Local $tabidx = GUICtrlRead($g_hGUI_BOT_TAB)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $g_hGUI_STATS)
GUISetState(@SW_HIDE, $g_hGUI_LOG_SA)
ControlShow("", "", $g_hCmbGUILanguage)
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_STATS)
GUISetState(@SW_HIDE, $g_hGUI_LOG_SA)
ControlHide("", "", $g_hCmbGUILanguage)
Case $tabidx = 2
GUISetState(@SW_HIDE, $g_hGUI_STATS)
GUISetState(@SW_HIDE, $g_hGUI_LOG_SA)
ControlHide("", "", $g_hCmbGUILanguage)
Case $tabidx = 3
GUISetState(@SW_HIDE, $g_hGUI_STATS)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_LOG_SA)
ControlHide("", "", $g_hCmbGUILanguage)
Case $tabidx = 4
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_STATS)
GUISetState(@SW_HIDE, $g_hGUI_LOG_SA)
If Not $g_bRunState Then UpdateMultiStats()
ControlHide("", "", $g_hCmbGUILanguage)
EndSelect
EndFunc
Func tabDeadbase()
Local $tabidx = GUICtrlRead($g_hGUI_DEADBASE_TAB)
Select
Case $tabidx = 1
cmbDBAlgorithm()
Case Else
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_MILKING)
EndSelect
EndFunc
Func tabActivebase()
Local $tabidx = GUICtrlRead($g_hGUI_ACTIVEBASE_TAB)
Select
Case $tabidx = 1
cmbABAlgorithm()
Case Else
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
EndSelect
EndFunc
Func tabTHSnipe()
Local $tabidx = GUICtrlRead($g_hGUI_THSNIPE_TAB)
Select
Case $tabidx = 1
Case Else
EndSelect
EndFunc
Func Bind_ImageList($nCtrl, ByRef $hImageList)
Local $aIconIndex = 0
If $hImageList = 0 Then
$hImageList = _GUIImageList_Create(16, 16, 5, 1)
EndIf
GUICtrlSendMsg($nCtrl, $TCM_SETIMAGELIST, 0, $hImageList)
Local $tTcItem = DllStructCreate("uint;dword;dword;ptr;int;int;int")
DllStructSetData($tTcItem, 1, 0x0002)
Switch $nCtrl
Case $g_hTabMain
Local $aIconIndex = [$eIcnHourGlass, $eIcnTH12, $eIcnAttack, $eIcnGUI, $eIcnInfo]
Case $g_hGUI_VILLAGE_TAB
Local $aIconIndex = [$eIcnTH1, $eIcnCC, $eIcnLaboratory, $eIcnAchievements, $eIcnPBNotify]
Case $g_hGUI_TRAINARMY_TAB
Local $aIconIndex = [$eIcnTrain, $eIcnGem, $eIcnReOrder, $eIcnOptions]
Case $g_hGUI_MISC_TAB
Local $aIconIndex = [$eIcnTH1, $eIcnBuilderHall]
Case $g_hGUI_DONATE_TAB
Local $aIconIndex = [$eIcnCCRequest, $eIcnCCDonate, $eIcnHourGlass]
Case $g_hGUI_UPGRADE_TAB
Local $aIconIndex = [$eIcnLaboratory, $eIcnHeroes, $eIcnMortar, $eIcnBuilder, $eIcnWall]
Case $g_hGUI_NOTIFY_TAB
Local $aIconIndex = [$eIcnPBNotify, $eIcnHourGlass]
Case $g_hGUI_ATTACK_TAB
Local $aIconIndex = [$eIcnTrain, $eIcnMagnifier, $eIcnStrategies]
Case $g_hGUI_SEARCH_TAB
Local $aIconIndex = [$eIcnCollector, $eIcnCC, $eIcnTH10, $eIcnTH1, $eIcnOptions]
Case $g_hGUI_DEADBASE_TAB
Local $aIconIndex = [$eIcnMagnifier, $eIcnCamp, $eIcnSilverStar, $eIcnCollector]
Case $g_hGUI_ACTIVEBASE_TAB
Local $aIconIndex = [$eIcnMagnifier, $eIcnCamp, $eIcnSilverStar]
Case $g_hGUI_THSNIPE_TAB
Local $aIconIndex = [$eIcnMagnifier, $eIcnCamp, $eIcnSilverStar]
Case $g_hGUI_ATTACKOPTION_TAB
Local $aIconIndex = [$eIcnMagnifier, $eIcnCamp, $eIcnLightSpell, $eIcnSilverStar, $eIcnTrophy]
Case $g_hGUI_BOT_TAB
Local $aIconIndex = [$eIcnOptions, $eIcnAndroid, $eIcnProfile, $eIcnProfile, $eIcnGold]
Case $g_hGUI_STRATEGIES_TAB
Local $aIconIndex = [$eIcnReload, $eIcnCopy]
Case $g_hGUI_STATS_TAB
Local $aIconIndex = [$eIcnGoldElixir, $eIcnOptions, $eIcnCamp, $eIcnCCRequest, $eIcnGoldElixir]
Case Else
EndSwitch
If IsArray($aIconIndex) Then
For $i = 0 To UBound($aIconIndex) - 1
DllStructSetData($tTcItem, 6, $i)
AddImageToTab($nCtrl, $hImageList, $i, $tTcItem, $g_sLibIconPath, $aIconIndex[$i] - 1)
Next
$aIconIndex = 0
EndIf
EndFunc
Func AddImageToTab($nCtrl, ByRef $hImageList, $nTabIndex, $nItem, $g_sLibIconPath, $nIconID)
Local $hIcon = DllStructCreate("int")
Local $Result = DllCall("shell32.dll", "int", "ExtractIconEx", "str", $g_sLibIconPath, "int", $nIconID, "hwnd", 0, "ptr", DllStructGetPtr($hIcon), "int", 1)
If UBound($Result) > 0 Then
$Result = $Result[0]
If $Result > 0 Then
DllCall("comctl32.dll", "int", "ImageList_AddIcon", "hwnd", $hImageList, "hwnd", DllStructGetData($hIcon, 1))
DllCall("user32.dll", "int", "SendMessage", "hwnd", ControlGetHandle($g_hFrmBot, "", $nCtrl), "int", $TCM_SETITEM, "int", $nTabIndex, "ptr", DllStructGetPtr($nItem))
DllCall("user32.dll", "int", "DestroyIcon", "hwnd", DllStructGetData($hIcon, 1))
EndIf
EndIf
EndFunc
Func _GUICtrlListView_SetItemHeightByFont($hListView, $iHeight)
Local $hDC = _WinAPI_GetDC($hListView), $hFont = _SendMessage($hListView, $WM_GETFONT)
Local $hObject = _WinAPI_SelectObject($hDC, $hFont), $lvLOGFONT = DllStructCreate($tagLOGFONT)
_WinAPI_GetObject($hFont, DllStructGetSize($lvLOGFONT), DllStructGetPtr($lvLOGFONT))
Local $hLVfont = _WinAPI_CreateFontIndirect($lvLOGFONT)
_WinAPI_SelectObject($hDC, $hObject)
_WinAPI_ReleaseDC($hListView, $hDC)
_WinAPI_DeleteObject($hFont)
$hFont = _WinAPI_CreateFont($iHeight, 0)
_WinAPI_SetFont($hListView, $hFont)
_WinAPI_DeleteObject($hFont)
Local $hHeader = _GUICtrlListView_GetHeader($hListView)
If $hHeader Then _WinAPI_SetFont($hHeader, $hLVfont)
$lvLOGFONT = 0
Return $hLVfont
EndFunc
Func _GUICtrlListView_GetHeightToFitRows($hListView, $iRows)
Local $tRECT = _WinAPI_GetClientRect($hListView)
Local $hHeader = _GUICtrlListView_GetHeader($hListView)
Local $tWindowPos = _GUICtrlHeader_Layout($hHeader, $tRECT)
Local $iHdrHeight = DllStructGetData($tWindowPos, "CY")
Local $aItemRect = _GUICtrlListView_GetItemRect($hListView, 0, 0)
Return($aItemRect[3] - $aItemRect[1]) * $iRows + $iHdrHeight + 8
EndFunc
Func EnableControls($hWin, $Enable, ByRef $avArr, $bGUIControl_Disabled = True, $i = 0)
If $hWin = 0 Or $hWin = -1 Then Return 0
Local $initalCall = $i = 0
If UBound($avArr, 0) <> 2 Then
Local $avTmp[1][2] = [[0]]
$avArr = $avTmp
EndIf
If $initalCall And $bGUIControl_Disabled Then
_SendMessage($hWin, $WM_SETREDRAW, False, 0)
Local $g_bGUIControlDisabled_ = $g_bGUIControlDisabled
$g_bGUIControlDisabled = True
EndIf
Local $hChild = _WinAPI_GetWindow($hWin, $GW_CHILD)
While $hChild
$i += 1
If $avArr[0][0] + 1 > UBound($avArr, 1) - 1 Then
ReDim $avArr[$avArr[0][0] + 2][2]
$avArr[$avArr[0][0] + 1][0] = $hChild
$avArr[$avArr[0][0] + 1][1] = BitAND(WinGetState($hChild), 4) > 0
EndIf
If $Enable = Default Then
WinSetState($hChild, "",($avArr[$i][1] = True ? @SW_ENABLE : @SW_DISABLE))
Else
WinSetState($hChild, "",($Enable ? @SW_ENABLE : @SW_DISABLE))
EndIf
$avArr[0][0] += 1
$i = EnableControls($hChild, $Enable, $avArr, $bGUIControl_Disabled, $i)
$hChild = _WinAPI_GetWindow($hChild, $GW_HWNDNEXT)
WEnd
If $initalCall And $Enable = Default Then $avArr = 0
If $initalCall And $bGUIControl_Disabled Then
_SendMessage($hWin, $WM_SETREDRAW, True, 0)
_WinAPI_RedrawWindow($hWin, 0, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN))
$g_bGUIControlDisabled = $g_bGUIControlDisabled_
EndIf
Return $i
EndFunc
Func frmBot_WNDPROC($hWin, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
If $g_iDebugWindowMessages > 0 Then SetDebugLog("frmBot_WNDPROC: FORWARD $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg) & ", $wParam=" & Hex($wParam) & ", $lParam=" & $lParam, Default, True)
Switch $iMsg
Case $WM_KEYDOWN, $WM_KEYUP, $WM_SYSKEYDOWN, $WM_SYSKEYUP, $WM_MOUSEHWHEEL
GUIControl_AndroidEmbedded($hWin, $iMsg, $wParam, $lParam)
EndSwitch
Local $wndproc = $g_hFrmBot_WNDPROC
Local $Return = 1
If $wndproc <> 0 Then
_WinAPI_CallWindowProc($wndproc, $hWin, $iMsg, $wParam, $lParam)
$Return = 0
EndIf
SetCriticalMessageProcessing($wasCritical)
Return $Return
EndFunc
Func HandleWndProc($Enable = True)
If $g_hFrmBot_WNDPROC = 0 And $Enable = True Then
$g_hFrmBot_WNDPROC = _WinAPI_SetWindowLong(ControlGetHandle($g_hFrmBot, "", $g_hFrmBotEmbeddedShieldInput), $GWL_WNDPROC, $g_hFrmBot_WNDPROC_ptr)
ElseIf $g_hFrmBot_WNDPROC <> 0 And $Enable = False Then
_WinAPI_SetWindowLong(ControlGetHandle($g_hFrmBot, "", $g_hFrmBotEmbeddedShieldInput), $GWL_WNDPROC, $g_hFrmBot_WNDPROC)
$g_hFrmBot_WNDPROC = 0
EndIf
EndFunc
Func IsGUICtrlHidden($hGUICtrl)
If BitAND(WinGetState(GUICtrlGetHandle($hGUICtrl), ""), 2) = 0 Then Return True
Return False
EndFunc
Func IsConfigActive()
Return $g_bReadConfigIsActive Or $g_bSaveConfigIsActive Or $g_bApplyConfigIsActive
EndFunc
Func IsBotLaunched()
Return $g_iBotLaunchTime > 0
EndFunc
Func ConsoleWindow($bShow = Default)
Static $bConsoleAllocated = False
If $bShow = Default Then $bShow = Not $bConsoleAllocated
If $bShow Then
_WinAPI_AllocConsole()
_WinAPI_SetConsoleIcon($g_sLibIconPath, $eIcnGUI)
$bConsoleAllocated = True
SetDebugLog("Allocate Console Window")
Else
SetDebugLog("Free Console Window")
_WinAPI_FreeConsole()
$bConsoleAllocated = False
EndIf
EndFunc
Global $_B64E_CodeBuffer, $_B64E_CodeBufferMemory, $_B64E_Init, $_B64E_EncodeData, $_B64E_EncodeEnd
Func _B64E_Exit()
$_B64E_CodeBuffer = 0
_MemVirtualFree($_B64E_CodeBufferMemory, 0, $MEM_RELEASE)
EndFunc
Func _Base64EncodeInit($LineBreak = 76)
If Not IsDllStruct($_B64E_CodeBuffer) Then
If @AutoItX64 Then
Local $Opcode = '0x89C08D42034883EC0885D2C70100000000C64104000F49C2C7410800000000C1F80283E20389410C740683C00189410C4883C408C389C94883EC3848895C242848897424304889CB8B0A83F901742083F9024889D87444C6000A4883C001488B74243029D8488B5C24284883C438C30FB67204E803020000BA3D0000004080FE3F7F08480FBEF60FB614308813C643013D488D4303C643023DEBBC0FB67204E8D7010000BA3D0000004080FE3F7F08480FBEF60FB614308813C643013D488D4302EB9489DB4883EC68418B014863D248895C242848897424304C89C348897C24384C896424484C89CE83F80148896C24404C896C24504C897424584C897C24604C8D2411410FB6790474434D89C64989CD0F82F700000083F8024C89C5747B31C0488B5C2428488B742430488B7C2438488B6C24404C8B6424484C8B6C24504C8B7424584C8B7C24604883C468C34C89C54989CF4D39E70F840B010000450FBE374D8D6F014489F025F0000000C1F80409C7E8040100004080FF3FBA3D0000007F08480FBEFF0FB614384489F78855004883C50183E70FC1E7024D39E50F84B2000000450FB675004983C5014489F025C0000000C1F80609C7E8BD0000004080FF3FBA3D0000007F08480FBEFF0FB61438BF3F0000008855004421F74C8D7502E896000000480FBED70FB604108845018B460883C0013B460C89460875104C8D7503C645020AC7460800000000904D39E5742E410FBE7D004D8D7D01498D6E01E8560000004889FA83E70348C1EA02C1E70483E23F0FB60410418806E913FFFFFF4489F040887E04C7060000000029D8E9CCFEFFFF89E840887E04C7060200000029D8E9B9FEFFFF89E840887E04C7060100000029D8E9A6FEFFFFE8400000004142434445464748494A4B4C4D4E4F505152535455565758595A6162636465666768696A6B6C6D6E6F707172737475767778797A303132333435363738392B2F58C3'
Else
Local $Opcode = '0x89C08B4C24088B44240489CAC1FA1FC1EA1E01CAC1FA0283E103C70000000000C6400400C740080000000089500C740683C20189500CC2100089C983EC0C8B4C2414895C24048B5C2410897424088B1183FA01741D83FA0289D87443C6000A83C0018B74240829D88B5C240483C40CC210000FB67104E80C020000BA3D00000089F180F93F7F0989F20FBEF20FB6143088138D4303C643013DC643023DEBBD0FB67104E8DF010000BA3D00000089F180F93F7F0989F20FBEF20FB6143088138D4302C643013DEB9489DB83EC3C895C242C8B5C244C896C24388B542440897424308B6C2444897C24348B030FB6730401D583F801742D8B4C24488954241C0F820101000083F80289CF747D31C08B5C242C8B7424308B7C24348B6C243883C43CC210008B4C244889D739EF0F84400100008D57010FBE3F89542418894C241489F825F0000000C1F80409C6897C241CE8330100008B542418C644240C3D8B4C241489C789F03C3F7F0B0FBEF00FB604378844240C0FB644240C8D790188018B74241C83E60FC1E60239EA0F84CB0000000FB60A83C2018954241C89C825C0000000C1F80609C6884C2414E8D8000000BA3D0000000FB64C24148944240C89F03C3F7F0B0FBEF08B44240C0FB6143083E13F881789CEE8AD00000089F10FBED18D4F020FB604108847018B430883C0013B430C894308750EC647020A8D4F03C7430800000000396C241C743A8B44241C8B7C241C0FBE30894C241483C701E8650000008B4C241489F283E60381E2FC000000C1EA02C1E6040FB60410880183C101E9E4FEFFFF89F088430489C8C703000000002B442448E9B2FEFFFF89F189F8884B04C703020000002B442448E99CFEFFFF89F088430489C8C703010000002B442448E986FEFFFFE8400000004142434445464748494A4B4C4D4E4F505152535455565758595A6162636465666768696A6B6C6D6E6F707172737475767778797A303132333435363738392B2F58C3'
EndIf
$_B64E_Init =(StringInStr($Opcode, "89C0") - 3) / 2
$_B64E_EncodeData =(StringInStr($Opcode, "89DB") - 3) / 2
$_B64E_EncodeEnd =(StringInStr($Opcode, "89C9") - 3) / 2
$Opcode = Binary($Opcode)
$_B64E_CodeBufferMemory = _MemVirtualAlloc(0, BinaryLen($Opcode), $MEM_COMMIT, $PAGE_EXECUTE_READWRITE)
$_B64E_CodeBuffer = DllStructCreate("byte[" & BinaryLen($Opcode) & "]", $_B64E_CodeBufferMemory)
DllStructSetData($_B64E_CodeBuffer, 1, $Opcode)
OnAutoItExitRegister("_B64E_Exit")
EndIf
Local $State = DllStructCreate("byte[16]")
DllCall("user32.dll", "none", "CallWindowProc", "ptr", DllStructGetPtr($_B64E_CodeBuffer) + $_B64E_Init, "ptr", DllStructGetPtr($State), "uint", $LineBreak, "int", 0, "int", 0)
Return $State
EndFunc
Func _Base64EncodeData(ByRef $State, $Data)
If Not IsDllStruct($_B64E_CodeBuffer) Or Not IsDllStruct($State) Then Return SetError(1, 0, "")
$Data = Binary($Data)
Local $InputLen = BinaryLen($Data)
Local $Input = DllStructCreate("byte[" & $InputLen & "]")
DllStructSetData($Input, 1, $Data)
Local $OputputLen = Ceiling(BinaryLen($Data) * 1.4) + 3
Local $Output = DllStructCreate("char[" & $OputputLen & "]")
DllCall("user32.dll", "int", "CallWindowProc", "ptr", DllStructGetPtr($_B64E_CodeBuffer) + $_B64E_EncodeData, "ptr", DllStructGetPtr($Input), "uint", $InputLen, "ptr", DllStructGetPtr($Output), "ptr", DllStructGetPtr($State))
Return DllStructGetData($Output, 1)
EndFunc
Func _Base64EncodeEnd(ByRef $State)
If Not IsDllStruct($_B64E_CodeBuffer) Or Not IsDllStruct($State) Then Return SetError(1, 0, "")
Local $Output = DllStructCreate("char[5]")
DllCall("user32.dll", "int", "CallWindowProc", "ptr", DllStructGetPtr($_B64E_CodeBuffer) + $_B64E_EncodeEnd, "ptr", DllStructGetPtr($Output), "ptr", DllStructGetPtr($State), "int", 0, "int", 0)
Return DllStructGetData($Output, 1)
EndFunc
Func _Base64Encode($Data, $LineBreak = 76)
Local $State = _Base64EncodeInit($LineBreak)
Return _Base64EncodeData($State, $Data) & _Base64EncodeEnd($State)
EndFunc
Global $g_oTxtLogInitText = ObjCreate("Scripting.Dictionary")
Global $g_oTxtAtkLogInitText = ObjCreate("Scripting.Dictionary")
Global $g_oTxtSALogInitText = ObjCreate("Scripting.Dictionary")
Global $g_bSilentSetDebugLog = False
Global $g_aLastStatusBar
Func SetLog($sLogMessage, $iColor = Default, $sFont = Default, $iFontSize = Default, $iStatusbar = Default, $bConsoleWrite = Default)
If $sLogMessage <> "" Then Return _SetLog($sLogMessage, $iColor, $sFont, $iFontSize, $iStatusbar, $bConsoleWrite)
EndFunc
Func _SetLog($sLogMessage, $Color = Default, $Font = Default, $FontSize = Default, $statusbar = Default, $time = Default, $bConsoleWrite = Default, $LogPrefix = Default, $bPostponed = Default, $bSilentSetLog = Default, $bWriteToLogFile = Default)
Local Static $bActive = False
Local Static $hLogCheckFreeSpaceTimer = 0
If $Color = Default Then $Color = $COLOR_BLACK
If $Font = Default Then $Font = "Verdana"
If $FontSize = Default Then $FontSize = 7.5
If $statusbar = Default Then $statusbar = 1
If $time = Default Then $time = Time()
Local $debugTime = TimeDebug()
If $bConsoleWrite = Default Then $bConsoleWrite = True
If $LogPrefix = Default Then $LogPrefix = "L "
If $bPostponed = Default Then $bPostponed = $g_bCriticalMessageProcessing
If $bSilentSetLog = Default Then $bSilentSetLog = $g_bSilentSetLog
If $bWriteToLogFile = Default Then $bWriteToLogFile = True
Local $log = $LogPrefix & $debugTime & $sLogMessage
If $bConsoleWrite = True And $sLogMessage <> "" Then
Local $sLevel = GetLogLevel($Color)
_ConsoleWrite($sLevel & $log & @CRLF)
EndIf
If $g_hLogFile = 0 And $g_sProfileLogsPath Then
CreateLogFile()
EndIf
If $bWriteToLogFile Then __FileWriteLog($g_hLogFile, $log)
If $bSilentSetLog = True And($bWriteToLogFile = False Or $g_hLogFile) Then
Return
EndIf
Local $a[6]
$a[0] = $sLogMessage
$a[1] = $Color
$a[2] = $Font
$a[3] = $FontSize
$a[4] = $statusbar
$a[5] = $time
If $statusbar Then $g_aLastStatusBar = $a
If $g_hLogFile = 0 Then
ReDim $a[8]
$a[6] =(($bSilentSetLog) ?(1) :(2))
$a[7] = $LogPrefix & $debugTime
EndIf
$g_oTxtLogInitText($g_oTxtLogInitText.Count + 1) = $a
If $bActive Then Return
$bActive = True
If(($g_hTxtLog <> 0 Or $g_iGuiMode <> 1) And $g_bRunState = False) Or($bPostponed = False And __TimerDiff($g_hTxtLogTimer) >= $g_iTxtLogTimerTimeout) Then
CheckPostponedLog()
If $g_iLogCheckFreeSpaceMB And $g_bRunState Then
If $hLogCheckFreeSpaceTimer = 0 Or __TimerDiff($hLogCheckFreeSpaceTimer) > 600000 Then
Local $fFree = DriveSpaceFree($g_sProfilePath & "\" & $g_sProfileCurrentName)
If $hLogCheckFreeSpaceTimer = 0 Then SetDebugLog("Free disk space is " & $fFree & " MB")
$hLogCheckFreeSpaceTimer = __TimerInit()
If @error = 0 And $fFree < $g_iLogCheckFreeSpaceMB Then
$hLogCheckFreeSpaceTimer = 0
SetLog("Less than " & $g_iLogCheckFreeSpaceMB & " MB free disk space, bot is stopping!", $COLOR_ERROR)
If $g_bRunState Then btnStop()
EndIf
EndIf
EndIf
EndIf
$bActive = False
EndFunc
Func GetLogLevel($Color)
Local $sLevel = ""
Switch $Color
Case $COLOR_ERROR
$sLevel = "ERROR    "
Case $COLOR_WARNING
$sLevel = "WARN     "
Case $COLOR_SUCCESS
$sLevel = "SUCCESS  "
Case $COLOR_SUCCESS1
$sLevel = "SUCCESS1 "
Case $COLOR_INFO
$sLevel = "INFO     "
Case $COLOR_DEBUG
$sLevel = "DEBUG    "
Case $COLOR_DEBUG1
$sLevel = "DEBUG1   "
Case $COLOR_DEBUG2
$sLevel = "DEBUG2   "
Case $COLOR_DEBUGS
$sLevel = "DEBUGS   "
Case $COLOR_ACTION
$sLevel = "ACTION   "
Case $COLOR_ACTION1
$sLevel = "ACTION1  "
Case $COLOR_ORANGE
$sLevel = "ORANGE   "
Case $COLOR_BLACK
$sLevel = "NORMAL   "
Case Else
$sLevel = Hex($Color, 6) & "   "
EndSwitch
Return $sLevel
EndFunc
Func SetLogText(ByRef $hTxtLog, ByRef $sLogMessage, ByRef $Color, ByRef $Font, ByRef $FontSize, ByRef $time)
If $time Then
_GUICtrlRichEdit_SetFont($hTxtLog, 6, "Lucida Console")
_GUICtrlRichEdit_AppendTextColor($hTxtLog, $time, 0x000000, False)
EndIf
_GUICtrlRichEdit_SetFont($hTxtLog, $FontSize, $Font)
_GUICtrlRichEdit_AppendTextColor($hTxtLog, $sLogMessage & @CRLF, _ColorConvert($Color), False)
EndFunc
Func SetDebugLog($sLogMessage, $sColor = $COLOR_DEBUG, $bSilentSetLog = Default, $Font = Default, $FontSize = Default, $statusbar = 0)
Local $sLogPrefix = "D "
Local $sLog = $sLogPrefix & TimeDebug() & $sLogMessage
If $bSilentSetLog = Default Then $bSilentSetLog = $g_bSilentSetDebugLog
If $g_bDebugSetlog And $bSilentSetLog = False Then
_SetLog($sLogMessage, $sColor, $Font, $FontSize, $statusbar, Default, True, $sLogPrefix)
Else
If $sLogMessage <> "" Then _ConsoleWrite(GetLogLevel($sColor) & $sLog & @CRLF)
If $g_hLogFile = 0 And $g_sProfileLogsPath Then CreateLogFile()
If $g_hLogFile Then
__FileWriteLog($g_hLogFile, $sLog)
Else
_SetLog($sLogMessage, $sColor, $Font, $FontSize, $statusbar, Default, False, $sLogPrefix, Default, True)
EndIf
EndIf
EndFunc
Func SetGuiLog($sLogMessage, $Color = Default, $bGuiLog = Default)
If $bGuiLog = Default Then $bGuiLog = True
If $bGuiLog = True Then
Return _SetLog($sLogMessage, $Color)
EndIf
Return SetDebugLog($sLogMessage, $Color)
EndFunc
Func FlushGuiLog(ByRef $hTxtLog, ByRef $oTxtLog, $bUpdateStatus = False, $sLogMutexName = "txtLog")
$g_bFlushGuiLogActive = True
Local $wasLock = AndroidShieldLock(True)
If $hTxtLog Then
Local $activeBot = _WinAPI_GetForegroundWindow() = $g_hFrmBot
Local $hCtrl = _WinAPI_GetFocus()
_SendMessage($hTxtLog, $WM_SETREDRAW, False, 0)
_WinAPI_EnableWindow($hTxtLog, False)
_GUICtrlRichEdit_SetSel($hTxtLog, -1, -1)
EndIf
Local $sLastStatus = ""
For $i = 1 To $oTxtLog.Count
Local $a = $oTxtLog($i)
Local $iSize = UBound($a)
If $hTxtLog Then
If $iSize = 0 And $a = 0 Then
_GUICtrlEdit_SetText($hTxtLog, "")
ContinueLoop
EndIf
If $iSize = 6 Or($iSize > 6 And $a[6] = 2) Then
SetLogText($hTxtLog, $a[0], $a[1], $a[2], $a[3], $a[5])
EndIf
EndIf
If $iSize > 7 And $a[6] > 0 Then
__FileWriteLog($g_hLogFile, $a[7] & $a[0])
If $a[6] = 1 Then
ContinueLoop
EndIf
EndIf
If $bUpdateStatus = True And($g_hStatusBar Or $g_iGuiMode <> 1) And $iSize > 4 And $a[4] = 1 Then
$sLastStatus = $a[0]
EndIf
Next
If $sLastStatus Then
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, "Status : " & $sLastStatus)
EndIf
Local $iLogs = $oTxtLog.Count
$oTxtLog.RemoveAll
If $hTxtLog Then
_WinAPI_EnableWindow($hTxtLog, True)
_GUICtrlRichEdit_SetSel($hTxtLog, -1, -1)
_SendMessage($hTxtLog, $WM_SETREDRAW, True, 0)
_WinAPI_RedrawWindow($hTxtLog, 0, 0, $RDW_INVALIDATE)
If $activeBot And $hCtrl <> $hTxtLog Then _WinAPI_SetFocus($hCtrl)
EndIf
AndroidShieldLock($wasLock)
$g_bFlushGuiLogActive = False
Return $iLogs
EndFunc
Func UpdateStatusBar($sText)
Local $iPosCr = StringInStr($sText, Chr(13))
Local $iPosLf = StringInStr($sText, Chr(10))
Local $iPos = $iPosCr
If $iPosLf > 0 And $iPosLf < $iPosCr Then $iPos = $iPosLf
If $iPos > 0 Then $sText = StringLeft($sText, $iPos - 1)
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, "Status : " & $sText)
EndFunc
Func CheckPostponedLog($bNow = False)
Local $iLogs = 0
If $g_bCriticalMessageProcessing Or($bNow = False And __TimerDiff($g_hTxtLogTimer) < $g_iTxtLogTimerTimeout) Then Return 0
If $g_oTxtLogInitText.Count > 0 And($g_iGuiMode <> 1 Or $g_hTxtLog) Then
If $g_hTxtLog And UBound($g_aLastStatusBar) > 0 And BitAND(WinGetState($g_hGUI_LOG), 2) = 0 Then
UpdateStatusBar($g_aLastStatusBar[0])
$g_aLastStatusBar = 0
Else
$iLogs += FlushGuiLog($g_hTxtLog, $g_oTxtLogInitText, True, "txtLog")
EndIf
EndIf
If $g_oTxtAtkLogInitText.Count > 0 And($g_iGuiMode <> 1 Or($g_hTxtAtkLog And BitAND(WinGetState($g_hGUI_LOG), 2))) Then
$iLogs += FlushGuiLog($g_hTxtAtkLog, $g_oTxtAtkLogInitText, False, "txtAtkLog")
EndIf
If $g_oTxtSALogInitText.Count > 0 And($g_iGuiMode <> 1 Or($g_hTxtSALog And BitAND(WinGetState($g_hGUI_LOG_SA), 2))) Then
$iLogs += FlushGuiLog($g_hTxtSALog, $g_oTxtSALogInitText, False, "txtSALog")
EndIf
$g_hTxtLogTimer = __TimerInit()
Return $iLogs
EndFunc
Func _GUICtrlRichEdit_AppendTextColor($hWnd, $sText, $iColor, $bGotoEnd = True)
If $bGotoEnd Then _GUICtrlRichEdit_SetSel($hWnd, -1, -1)
_GUICtrlRichEdit_SetCharColor($hWnd, $iColor)
_GUICtrlRichEdit_AppendText($hWnd, $sText)
EndFunc
Func _ColorConvert($nColor)
Return BitOR(BitShift(BitAND($nColor, 0x000000FF), -16), BitAND($nColor, 0x0000FF00), BitShift(BitAND($nColor, 0x00FF0000), 16))
EndFunc
Func SetAtkLog($String1, $String2 = "", $Color = $COLOR_BLACK, $Font = "Lucida Console", $FontSize = 7.5)
If $g_hAttackLogFile = 0 Then CreateAttackLogFile()
_FileWriteLog($g_hAttackLogFile, $String1 & $String2)
Dim $a[6]
$a[0] = $String1
$a[1] = $Color
$a[2] = $Font
$a[3] = $FontSize
$a[4] = 0
$a[5] = 0
$g_oTxtAtkLogInitText($g_oTxtAtkLogInitText.Count + 1) = $a
EndFunc
Func SetSwitchAccLog($String, $Color = $COLOR_BLACK, $Font = "Verdana", $FontSize = 7.5, $time = True)
If $time = True Then
$time = Time()
Else
$time = 0
EndIf
If $g_hSwitchLogFile = 0 Then CreateSwitchLogFile()
_FileWriteLog($g_hSwitchLogFile, $String)
Dim $a[6]
$a[0] = $String
$a[1] = $Color
$a[2] = $Font
$a[3] = $FontSize
$a[4] = 0
$a[5] = $time
$g_oTxtSALogInitText($g_oTxtSALogInitText.Count + 1) = $a
EndFunc
Func AtkLogHead()
SetAtkLog(_PadStringCenter(" " & GetTranslatedFileIni("MBR Func_AtkLogHead", "AtkLogHead_Text_01", "ATTACK LOG") & " ", 71, "="), "", $COLOR_BLACK, "MS Shell Dlg", 8.5)
SetAtkLog(GetTranslatedFileIni("MBR Func_AtkLogHead", "AtkLogHead_Text_02", '|                      --------  LOOT --------       ----- BONUS ------'), "")
SetAtkLog(GetTranslatedFileIni("MBR Func_AtkLogHead", "AtkLogHead_Text_03", '|AC|TIME.|TROP.|SEARCH|   GOLD| ELIXIR|DARK EL|TR.|S|  GOLD|ELIXIR|  DE|L.'), "")
EndFunc
Func __FileWriteLog($handle, $text)
Return FileWriteLine($handle, BitAND(WinGetState($g_hFrmBot), 2) & ": " & $text)
EndFunc
Func ClearLog($hRichEditCtrl = $g_hTxtLog)
Switch $hRichEditCtrl
Case $g_hTxtLog
$g_oTxtLogInitText($g_oTxtLogInitText.Count + 1) = 0
Case $g_hTxtAtkLog
$g_oTxtAtkLogInitText($g_oTxtAtkLogInitText.Count + 1) = 0
EndSwitch
EndFunc
Func SetLogCentered($String, $sPad = Default, $Color = Default, $bClearLog = False)
If $sPad = Default Then $sPad = "="
If $bClearLog = True Then ClearLog($g_hTxtLog)
_SetLog(_PadStringCenter($String, 53, $sPad), $Color, "Lucida Console", 8)
EndFunc
Func SetDebugLogSilent($bSilent = Default)
If $bSilent = Default Then $bSilent = True
Local $bWasSilent = $g_bSilentSetDebugLog
$g_bSilentSetDebugLog = $bSilent
Return $bWasSilent
EndFunc
Global $g_oStopWatches = ObjCreate("Scripting.Dictionary")
Global $g_oFuncCall = ObjCreate("Scripting.Dictionary")
If Not IsDeclared("g_bDebugFuncTime") Then Global $g_bDebugFuncTime = False
If Not IsDeclared("g_bDebugFuncCall") Then Global $g_bDebugFuncCall = False
Func FuncEnter($fFunc, $bLog = $g_bDebugFuncCall)
Local $sFunc = FuncName($fFunc)
Local $iLevel = FuncCallLevel()
$g_oFuncCall("__CURRENT_FUNC__" & $iLevel) = $sFunc
$g_oFuncCall("__CURRENT_FUNC_LEVEL__") = $iLevel + 1
If $bLog Then
SetDebugLog(">>> Enter Func: " & $sFunc & ", call-hierarchy: " & FuncCallHierarchy(False), $COLOR_WARNING)
EndIf
Return $iLevel
EndFunc
Func FuncCallHierarchy($bIncludeCurrent = True)
Local $iLevel = FuncCallLevel() - 1
If Not $bIncludeCurrent Then $iLevel -= 1
Local $sHierarchy = ""
For $i = 0 To $iLevel
If $sHierarchy = "" Then
$sHierarchy = $g_oFuncCall("__CURRENT_FUNC__" & $i)
Else
$sHierarchy &= " -> " & $g_oFuncCall("__CURRENT_FUNC__" & $i)
EndIf
Next
Return $sHierarchy
EndFunc
Func FuncCallLevel()
Local $iLevel = $g_oFuncCall("__CURRENT_FUNC_LEVEL__")
If IsNumber($iLevel) = 0 Then $iLevel = 0
Return $iLevel
EndFunc
Func FuncReturn($Result = "__No_Result", $bLog = $g_bDebugFuncCall)
Local $bNoResult =(IsString($Result) And $Result = "__No_Result")
Local $iLevel = FuncCallLevel() - 1
If $iLevel < 0 Then
SetDebugLog("FuncReturn improper use", $COLOR_ERROR)
Else
$g_oFuncCall("__CURRENT_FUNC_LEVEL__") = $iLevel
Local $sTag = "__CURRENT_FUNC__" & $iLevel
Local $sFunc = $g_oFuncCall($sTag)
$g_oFuncCall.remove($sTag)
If $bLog Then
SetDebugLog("<<< Return Func: " & $sFunc &(($bNoResult) ?(", no result") :(", Result: " & $Result)) & ", call-hierarchy: " & FuncCallHierarchy(True), $COLOR_WARNING)
EndIf
EndIf
If $bNoResult Then Return
Return $Result
EndFunc
Func StopWatchStart($sTag)
StopWatchStopPushTag($sTag)
$g_oStopWatches($sTag) = __TimerInit()
EndFunc
Func StopWatchLevel()
Local $iLevel = $g_oStopWatches("__CURRENT_TAG_LEVEL__")
If IsNumber($iLevel) = 0 Then $iLevel = 0
Return $iLevel
EndFunc
Func StopWatchStopPushTag($sTag)
Local $iLevel = StopWatchLevel()
$g_oStopWatches("__CURRENT_TAG__" & $iLevel) = $sTag
$g_oStopWatches("__CURRENT_TAG_LEVEL__") = $iLevel + 1
Return $iLevel
EndFunc
Func StopWatchStopPopTag($iNewLevel = Default)
Local $iLevel = StopWatchLevel() - 1
$g_oStopWatches("__CURRENT_TAG_LEVEL__") = $iLevel
Return $g_oStopWatches("__CURRENT_TAG__" & $iLevel)
EndFunc
Func StopWatchStopLog($sTag = Default, $iNewLevel = Default, $bLog = True)
Local $sTagLevel = StopWatchStopPopTag()
If $sTag = Default Then
$sTag = $sTagLevel
ElseIf $sTag <> $sTagLevel Then
SetLog("StopWatch Level mismatch: " & $sTag & " <> " & $sTagLevel, $COLOR_ERROR)
EndIf
Local $hTimer = $g_oStopWatches($sTag)
$g_oStopWatches.Remove($sTag)
SetLog($sTag & " Execution-time: " & __TimerDiff($hTimer))
If $iNewLevel <> Default Then
While StopWatchLevel() > $iNewLevel
StopWatchStopLog(Default, Default, $bLog)
WEnd
EndIf
EndFunc
Func StopWatchReturn($iNewLevel, $bLog = $g_bDebugFuncTime)
Local $iCurLevel = StopWatchLevel()
If $iNewLevel <> $iCurLevel Then StopWatchStopLog(Default, $iNewLevel, $bLog)
EndFunc
Global Enum $iOAER_bSet_ErrLine, $iOAER_bIn_Proc, $iOAER_bUse_StdOut, $iOAER_iPID, $iOAER_hErr_Callback, $iOAER_hErr_WinHook, $iOAER_sUserFunc, $iOAER_vUserParams, $iOAER_iCOMErrorNumber, $iOAER_sCOMErrorDesc, $iOAER_Total
Global $aOAER_DATA[$iOAER_Total]
Func _OnAutoItErrorRegister()
If $aOAER_DATA[$iOAER_hErr_WinHook] Then
Return
EndIf
$aOAER_DATA[$iOAER_hErr_CallBack] = DllCallbackRegister('__OAER_OnErrorCallback', 'int', 'int;int;int')
$aOAER_DATA[$iOAER_hErr_WinHook] = _WinAPI_SetWindowsHookEx($WH_CBT, DllCallbackGetPtr($aOAER_DATA[$iOAER_hErr_CallBack]), 0, _WinAPI_GetCurrentThreadId())
If Not $aOAER_DATA[$iOAER_hErr_WinHook] Then
DllCallbackFree($aOAER_DATA[$iOAER_hErr_CallBack])
Return 0
Else
Return 1
EndIf
EndFunc
Func _OnAutoItErrorUnRegister()
__OAER_OnExit()
EndFunc
Func __OAER_OnExit()
If $aOAER_DATA[$iOAER_hErr_WinHook] Then
_WinAPI_UnhookWindowsHookEx($aOAER_DATA[$iOAER_hErr_WinHook])
$aOAER_DATA[$iOAER_hErr_WinHook] = 0
EndIf
If $aOAER_DATA[$iOAER_hErr_CallBack] Then
DllCallbackFree($aOAER_DATA[$iOAER_hErr_CallBack])
$aOAER_DATA[$iOAER_hErr_CallBack] = 0
EndIf
EndFunc
Func __OAER_OnErrorCallback($nCode, $wParam, $lParam)
If $nCode < 0 Then
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndIf
Switch $nCode
Case 5
If Not _WinAPI_FindWindow('#32770', 'AutoIt Error') Then
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndIf
Local $hError_Wnd = HWnd($wParam)
Local $sError_Msg = StringRegExpReplace(ControlGetText($hError_Wnd, '', 'Static2'), '(?<!\r)\n', @CRLF)
If(_WinAPI_GetClassName($hError_Wnd) <> '#32770' And WinGetTitle($hError_Wnd) <> 'AutoIt Error') Or Not StringRegExp($sError_Msg, '(?is)^.*Line \d+\s+\(File "(.*?)"\):\s+.*Error: .*') Then
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndIf
SetDebugLog($g_sBotTitle & " AutoIt Error: " & $sError_Msg, Default, True)
BotClose(Default, False)
_WinAPI_FatalAppExit($sError_Msg)
EndSwitch
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndFunc
Func AttackReport()
Static $iBonusLast = 0
Local $g_asLeagueDetailsShort = ""
Local $iCount
$iCount = 0
While _CheckPixel($aEndFightSceneAvl, True) = False
$iCount += 1
If _Sleep($DELAYATTACKREPORT1) Then Return
If $g_bDebugSetlog Then SetDebugLog("Waiting Attack Report Ready, " &($iCount / 2) & " Seconds.", $COLOR_DEBUG)
If $iCount > 30 Then ExitLoop
WEnd
If $iCount > 30 Then SetLog("End of Attack scene slow to appear, attack values my not be correct", $COLOR_INFO)
$iCount = 0
While getResourcesLoot(290, 289 + $g_iMidOffsetY) = ""
$iCount += 1
If _Sleep($DELAYATTACKREPORT1) Then Return
If $g_bDebugSetlog Then SetDebugLog("Waiting Attack Report Ready, " &($iCount / 2) & " Seconds.", $COLOR_DEBUG)
If $iCount > 20 Then ExitLoop
WEnd
If $iCount > 20 Then SetLog("End of Attack scene read gold error, attack values my not be correct", $COLOR_INFO)
If _ColorCheck(_GetPixelColor($aAtkRprtDECheck[0], $aAtkRprtDECheck[1], True), Hex($aAtkRprtDECheck[2], 6), $aAtkRprtDECheck[3]) Then
$g_iStatsLastAttack[$eLootGold] = getResourcesLoot(290, 289 + $g_iMidOffsetY)
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsLastAttack[$eLootElixir] = getResourcesLoot(290, 328 + $g_iMidOffsetY)
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsLastAttack[$eLootDarkElixir] = getResourcesLootDE(365, 365 + $g_iMidOffsetY)
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsLastAttack[$eLootTrophy] = getResourcesLootT(403, 402 + $g_iMidOffsetY)
If _ColorCheck(_GetPixelColor($aAtkRprtTrophyCheck[0], $aAtkRprtTrophyCheck[1], True), Hex($aAtkRprtTrophyCheck[2], 6), $aAtkRprtTrophyCheck[3]) Then
$g_iStatsLastAttack[$eLootTrophy] = -$g_iStatsLastAttack[$eLootTrophy]
EndIf
SetLog("Loot: [G]: " & _NumberFormat($g_iStatsLastAttack[$eLootGold]) & " [E]: " & _NumberFormat($g_iStatsLastAttack[$eLootElixir]) & " [DE]: " & _NumberFormat($g_iStatsLastAttack[$eLootDarkElixir]) & " [T]: " & $g_iStatsLastAttack[$eLootTrophy], $COLOR_SUCCESS)
Else
$g_iStatsLastAttack[$eLootGold] = getResourcesLoot(290, 289 + $g_iMidOffsetY)
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsLastAttack[$eLootElixir] = getResourcesLoot(290, 328 + $g_iMidOffsetY)
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsLastAttack[$eLootTrophy] = getResourcesLootT(403, 365 + $g_iMidOffsetY)
If _ColorCheck(_GetPixelColor($aAtkRprtTrophyCheck[0], $aAtkRprtTrophyCheck[1], True), Hex($aAtkRprtTrophyCheck[2], 6), $aAtkRprtTrophyCheck[3]) Then
$g_iStatsLastAttack[$eLootTrophy] = -$g_iStatsLastAttack[$eLootTrophy]
EndIf
$g_iStatsLastAttack[$eLootDarkElixir] = ""
SetLog("Loot: [G]: " & _NumberFormat($g_iStatsLastAttack[$eLootGold]) & " [E]: " & _NumberFormat($g_iStatsLastAttack[$eLootElixir]) & " [T]: " & $g_iStatsLastAttack[$eLootTrophy], $COLOR_SUCCESS)
EndIf
If $g_iStatsLastAttack[$eLootTrophy] >= 0 Then
$iBonusLast = Number(getResourcesBonusPerc(570, 309 + $g_iMidOffsetY))
If $iBonusLast > 0 Then
SetLog("Bonus Percentage: " & $iBonusLast & "%")
Local $iCalcMaxBonus = 0, $iCalcMaxBonusDark = 0
If _ColorCheck(_GetPixelColor($aAtkRprtDECheck2[0], $aAtkRprtDECheck2[1], True), Hex($aAtkRprtDECheck2[2], 6), $aAtkRprtDECheck2[3]) Then
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsBonusLast[$eLootGold] = getResourcesBonus(590, 340 + $g_iMidOffsetY)
$g_iStatsBonusLast[$eLootGold] = StringReplace($g_iStatsBonusLast[$eLootGold], "+", "")
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsBonusLast[$eLootElixir] = getResourcesBonus(590, 371 + $g_iMidOffsetY)
$g_iStatsBonusLast[$eLootElixir] = StringReplace($g_iStatsBonusLast[$eLootElixir], "+", "")
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsBonusLast[$eLootDarkElixir] = getResourcesBonus(621, 402 + $g_iMidOffsetY)
$g_iStatsBonusLast[$eLootDarkElixir] = StringReplace($g_iStatsBonusLast[$eLootDarkElixir], "+", "")
If $iBonusLast = 100 Then
$iCalcMaxBonus = $g_iStatsBonusLast[$eLootGold]
SetLog("Bonus [G]: " & _NumberFormat($g_iStatsBonusLast[$eLootGold]) & " [E]: " & _NumberFormat($g_iStatsBonusLast[$eLootElixir]) & " [DE]: " & _NumberFormat($g_iStatsBonusLast[$eLootDarkElixir]), $COLOR_SUCCESS)
Else
$iCalcMaxBonus = Ceiling($g_iStatsBonusLast[$eLootGold] /($iBonusLast / 100))
$iCalcMaxBonusDark = Ceiling($g_iStatsBonusLast[$eLootDarkElixir] /($iBonusLast / 100))
SetLog("Bonus [G]: " & _NumberFormat($g_iStatsBonusLast[$eLootGold]) & " out of " & _NumberFormat($iCalcMaxBonus) & " [E]: " & _NumberFormat($g_iStatsBonusLast[$eLootElixir]) & " out of " & _NumberFormat($iCalcMaxBonus) & " [DE]: " & _NumberFormat($g_iStatsBonusLast[$eLootDarkElixir]) & " out of " & _NumberFormat($iCalcMaxBonusDark), $COLOR_SUCCESS)
EndIf
Else
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsBonusLast[$eLootGold] = getResourcesBonus(590, 340 + $g_iMidOffsetY)
$g_iStatsBonusLast[$eLootGold] = StringReplace($g_iStatsBonusLast[$eLootGold], "+", "")
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsBonusLast[$eLootElixir] = getResourcesBonus(590, 371 + $g_iMidOffsetY)
$g_iStatsBonusLast[$eLootElixir] = StringReplace($g_iStatsBonusLast[$eLootElixir], "+", "")
$g_iStatsBonusLast[$eLootDarkElixir] = 0
If $iBonusLast = 100 Then
$iCalcMaxBonus = $g_iStatsBonusLast[$eLootGold]
SetLog("Bonus [G]: " & _NumberFormat($g_iStatsBonusLast[$eLootGold]) & " [E]: " & _NumberFormat($g_iStatsBonusLast[$eLootElixir]), $COLOR_SUCCESS)
Else
$iCalcMaxBonus = Number($g_iStatsBonusLast[$eLootGold] /($iBonusLast / 100))
SetLog("Bonus [G]: " & _NumberFormat($g_iStatsBonusLast[$eLootGold]) & " out of " & _NumberFormat($iCalcMaxBonus) & " [E]: " & _NumberFormat($g_iStatsBonusLast[$eLootElixir]) & " out of " & _NumberFormat($iCalcMaxBonus), $COLOR_SUCCESS)
EndIf
EndIf
$g_asLeagueDetailsShort = "--"
For $i = 1 To 21
If _Sleep($DELAYATTACKREPORT2) Then Return
If $g_asLeagueDetails[$i][0] = $iCalcMaxBonus Then
SetLog("Your league level is: " & $g_asLeagueDetails[$i][1])
$g_asLeagueDetailsShort = $g_asLeagueDetails[$i][3]
ExitLoop
EndIf
Next
Else
SetLog("No Bonus")
$g_asLeagueDetailsShort = "--"
If $g_aiCurrentLoot[$eLootTrophy] + $g_iStatsLastAttack[$eLootTrophy] >= 400 And $g_aiCurrentLoot[$eLootTrophy] + $g_iStatsLastAttack[$eLootTrophy] < 500 Then
SetLog("Your league level is: " & $g_asLeagueDetails[0][1])
$g_asLeagueDetailsShort = $g_asLeagueDetails[0][3]
EndIf
EndIf
GUICtrlSetData($g_hLblLeague, "")
If StringInStr($g_asLeagueDetailsShort, "1") > 1 Then
GUICtrlSetData($g_hLblLeague, "1")
ElseIf StringInStr($g_asLeagueDetailsShort, "2") > 1 Then
GUICtrlSetData($g_hLblLeague, "2")
ElseIf StringInStr($g_asLeagueDetailsShort, "3") > 1 Then
GUICtrlSetData($g_hLblLeague, "3")
EndIf
_GUI_Value_STATE("HIDE", $g_aGroupLeague)
If StringInStr($g_asLeagueDetailsShort, "B") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueBronze], $GUI_SHOW)
ElseIf StringInStr($g_asLeagueDetailsShort, "S") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueSilver], $GUI_SHOW)
ElseIf StringInStr($g_asLeagueDetailsShort, "G") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueGold], $GUI_SHOW)
ElseIf StringInStr($g_asLeagueDetailsShort, "c", $STR_CASESENSE) > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueCrystal], $GUI_SHOW)
ElseIf StringInStr($g_asLeagueDetailsShort, "M") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueMaster], $GUI_SHOW)
ElseIf StringInStr($g_asLeagueDetailsShort, "C", $STR_CASESENSE) > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueChampion], $GUI_SHOW)
ElseIf StringInStr($g_asLeagueDetailsShort, "T") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueTitan], $GUI_SHOW)
ElseIf StringInStr($g_asLeagueDetailsShort, "LE") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueLegend], $GUI_SHOW)
Else
GUICtrlSetState($g_ahPicLeague[$eLeagueUnranked], $GUI_SHOW)
EndIf
Else
$g_iStatsBonusLast[$eLootGold] = 0
$g_iStatsBonusLast[$eLootElixir] = 0
$g_iStatsBonusLast[$eLootDarkElixir] = 0
$g_asLeagueDetailsShort = "--"
EndIf
Local $starsearned = 0
If _ColorCheck(_GetPixelColor($aWonOneStarAtkRprt[0], $aWonOneStarAtkRprt[1], True), Hex($aWonOneStarAtkRprt[2], 6), $aWonOneStarAtkRprt[3]) Then $starsearned += 1
If _ColorCheck(_GetPixelColor($aWonTwoStarAtkRprt[0], $aWonTwoStarAtkRprt[1], True), Hex($aWonTwoStarAtkRprt[2], 6), $aWonTwoStarAtkRprt[3]) Then $starsearned += 1
If _ColorCheck(_GetPixelColor($aWonThreeStarAtkRprt[0], $aWonThreeStarAtkRprt[1], True), Hex($aWonThreeStarAtkRprt[2], 6), $aWonThreeStarAtkRprt[3]) Then $starsearned += 1
SetLog("Stars earned: " & $starsearned)
Local $AtkLogTxt
$AtkLogTxt = "  " & String($g_iCurAccount + 1) & "|" & _NowTime(4) & "|"
$AtkLogTxt &= StringFormat("%5d", $g_aiCurrentLoot[$eLootTrophy]) & "|"
$AtkLogTxt &= StringFormat("%6d", $g_iSearchCount) & "|"
$AtkLogTxt &= StringFormat("%7d", $g_iStatsLastAttack[$eLootGold]) & "|"
$AtkLogTxt &= StringFormat("%7d", $g_iStatsLastAttack[$eLootElixir]) & "|"
$AtkLogTxt &= StringFormat("%7d", $g_iStatsLastAttack[$eLootDarkElixir]) & "|"
$AtkLogTxt &= StringFormat("%3d", $g_iStatsLastAttack[$eLootTrophy]) & "|"
$AtkLogTxt &= StringFormat("%1d", $starsearned) & "|"
$AtkLogTxt &= StringFormat("%6d", $g_iStatsBonusLast[$eLootGold]) & "|"
$AtkLogTxt &= StringFormat("%6d", $g_iStatsBonusLast[$eLootElixir]) & "|"
$AtkLogTxt &= StringFormat("%4d", $g_iStatsBonusLast[$eLootDarkElixir]) & "|"
$AtkLogTxt &= $g_asLeagueDetailsShort & "|"
Local $AtkLogTxtExtend
$AtkLogTxtExtend = "|"
$AtkLogTxtExtend &= $g_CurrentCampUtilization & "/" & $g_iTotalCampSpace & "|"
If Int($g_iStatsLastAttack[$eLootTrophy]) >= 0 Then
SetAtkLog($AtkLogTxt, $AtkLogTxtExtend, $COLOR_BLACK)
Else
SetAtkLog($AtkLogTxt, $AtkLogTxtExtend, $COLOR_ERROR)
EndIf
If $g_bDebugDeadBaseImage Then
setZombie($g_iStatsLastAttack[$eLootElixir])
EndIf
If $g_bShareAttackEnable Then
If(Number($g_iStatsLastAttack[$eLootGold]) >= Number($g_iShareMinGold)) And(Number($g_iStatsLastAttack[$eLootElixir]) >= Number($g_iShareMinElixir)) And(Number($g_iStatsLastAttack[$eLootDarkElixir]) >= Number($g_iShareMinDark)) Then
SetLog("Reached miminum Loot values... Share Replay")
$g_bShareAttackEnableNow = True
Else
SetLog("Below miminum Loot values... No Share Replay")
$g_bShareAttackEnableNow = False
EndIf
EndIf
If $g_iFirstAttack = 0 Then $g_iFirstAttack = 1
$g_iStatsTotalGain[$eLootGold] += $g_iStatsLastAttack[$eLootGold] + $g_iStatsBonusLast[$eLootGold]
$g_aiTotalGoldGain[$g_iMatchMode] += $g_iStatsLastAttack[$eLootGold] + $g_iStatsBonusLast[$eLootGold]
$g_iStatsTotalGain[$eLootElixir] += $g_iStatsLastAttack[$eLootElixir] + $g_iStatsBonusLast[$eLootElixir]
$g_aiTotalElixirGain[$g_iMatchMode] += $g_iStatsLastAttack[$eLootElixir] + $g_iStatsBonusLast[$eLootElixir]
If $g_iStatsStartedWith[$eLootDarkElixir] <> "" Then
$g_iStatsTotalGain[$eLootDarkElixir] += $g_iStatsLastAttack[$eLootDarkElixir] + $g_iStatsBonusLast[$eLootDarkElixir]
$g_aiTotalDarkGain[$g_iMatchMode] += $g_iStatsLastAttack[$eLootDarkElixir] + $g_iStatsBonusLast[$eLootDarkElixir]
EndIf
$g_iStatsTotalGain[$eLootTrophy] += $g_iStatsLastAttack[$eLootTrophy]
$g_aiTotalTrophyGain[$g_iMatchMode] += $g_iStatsLastAttack[$eLootTrophy]
If $g_iMatchMode = $TS Then
If $starsearned > 0 Then
$g_iNbrOfTHSnipeSuccess += 1
Else
$g_iNbrOfTHSnipeFails += 1
EndIf
EndIf
$g_aiAttackedVillageCount[$g_iMatchMode] += 1
If ProfileSwitchAccountEnabled() Then
$g_aiGoldTotalAcc[$g_iCurAccount] += $g_iStatsLastAttack[$eLootGold] + $g_iStatsBonusLast[$eLootGold]
$g_aiElixirTotalAcc[$g_iCurAccount] += $g_iStatsLastAttack[$eLootElixir] + $g_iStatsBonusLast[$eLootElixir]
If $g_iStatsStartedWith[$eLootDarkElixir] <> "" Then
$g_aiDarkTotalAcc[$g_iCurAccount] += $g_iStatsLastAttack[$eLootDarkElixir] + $g_iStatsBonusLast[$eLootDarkElixir]
EndIf
$g_aiTrophyLootAcc[$g_iCurAccount] += $g_iStatsLastAttack[$eLootTrophy]
$g_aiAttackedCountAcc[$g_iCurAccount] += 1
SetSwitchAccLog(" - Acc. " & $g_iCurAccount + 1 & ", Attack: " & $g_aiAttackedCountAcc[$g_iCurAccount])
EndIf
UpdateStats()
$g_iActualTrainSkip = 0
EndFunc
Global $g_abSaveiChkTimeStopAtk[$g_iModeCount], $g_abSaveiChkTimeStopAtk2[$g_iModeCount], $g_abSaveichkEndOneStar[$g_iModeCount], $g_abSaveichkEndTwoStars[$g_iModeCount]
Global $g_iBuildingLoc = 0, $g_iBuildingLocX = 0, $g_iBuildingLocY = 0
Func GetBuildingEdge($TypeBuilding = $eSideBuildingDES)
Local $TypeBuildingName
BuildingXY($TypeBuilding)
Switch $TypeBuilding
Case $eSideBuildingDES
$TypeBuildingName = "DE Storage"
Case $eSideBuildingTH
$TypeBuildingName = "TownHall"
EndSwitch
If $g_iBuildingLoc = 1 Then
If($g_iBuildingLocX = 430) And($g_iBuildingLocY = 313) Then
SetLog($TypeBuildingName & " Located in Middle... Attacking Random Side", $COLOR_INFO)
$g_iBuildingEdge =(Random(Round(0, 3)))
ElseIf($g_iBuildingLocX >= 430) And($g_iBuildingLocY >= 313) Then
SetLog($TypeBuildingName & " Located Bottom Right... Attacking Bottom Right", $COLOR_INFO)
$g_iBuildingEdge = 0
ElseIf($g_iBuildingLocX > 430) And($g_iBuildingLocY < 313) Then
SetLog($TypeBuildingName & " Located Top Right... Attacking Top Right", $COLOR_INFO)
$g_iBuildingEdge = 3
ElseIf($g_iBuildingLocX <= 430) And($g_iBuildingLocY <= 313) Then
SetLog($TypeBuildingName & " Located Top Left... Attacking Top Left", $COLOR_INFO)
$g_iBuildingEdge = 1
ElseIf($g_iBuildingLocX < 430) And($g_iBuildingLocY > 313) Then
SetLog($TypeBuildingName & " Located Bottom Left... Attacking Bottom Left", $COLOR_INFO)
$g_iBuildingEdge = 2
EndIf
ElseIf $g_iBuildingLoc = 0 Then
SetLog($TypeBuildingName & " Not Located... Attacking Random Side", $COLOR_INFO)
$g_iBuildingEdge =(Random(Round(0, 3)))
EndIf
EndFunc
Func BuildingXY($TypeBuilding = $eSideBuildingDES)
Local $TypeBuildingName
_CaptureRegion2(230, 170, 630, 440)
Switch $TypeBuilding
Case $eSideBuildingDES
$TypeBuildingName = "DE Storage"
$g_iBuildingToLoc = GetLocationDarkElixirStorage()
Case $eSideBuildingTH
$TypeBuildingName = "TownHall"
$g_iBuildingToLoc = GetLocationTownHall()
EndSwitch
Local $pixel
If(UBound($g_iBuildingToLoc) > 1) Then
Local $centerPixel[2] = [430, 313]
Local $arrPixelCloser = _FindPixelCloser($g_iBuildingToLoc, $centerPixel, 1)
$pixel = $arrPixelCloser[0]
ElseIf(UBound($g_iBuildingToLoc) > 0) Then
$pixel = $g_iBuildingToLoc[0]
Else
$pixel = -1
EndIf
If $pixel = -1 Then
$g_iBuildingLoc = 0
SetLog(" == " & $TypeBuildingName & " Not Found ==")
Else
$pixel[0] += 230
$pixel[1] += 170
SetLog("== " & $TypeBuildingName & " : [" & $pixel[0] & "," & $pixel[1] & "] ==", $COLOR_INFO)
If _Sleep(1000) Then Return False
$g_iBuildingLocX = $pixel[0]
$g_iBuildingLocY = $pixel[1]
$g_iBuildingLoc = 1
EndIf
EndFunc
Func DELow()
Local $DarkE = ""
Local $Dchk = 0
While $DarkE = ""
$DarkE = getDarkElixirVillageSearch(48, 126)
$Dchk += 1
If _Sleep(50) Then Return
If $Dchk >= 10 Then
SetLog("Can't find De", $COLOR_ERROR)
Return False
EndIf
WEnd
If Number($DarkE) <(Number($g_iSearchDark) *(Number($g_iDESideEndMin) / 100)) Then
If _Sleep(50) Then Return
$DarkE = getDarkElixirVillageSearch(48, 126)
If _Sleep(50) Then Return
If Number($DarkE) <(Number($g_iSearchDark) *(Number($g_iDESideEndMin) / 100)) Then
If $g_bDESideEndAQWeak And $g_bDropQueen And Not $g_bCheckQueenPower Then
If $g_iActivateQueen = 0 Then
$g_iDarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and AQ health Low. Return to protect Heroes.  Returning immediately", $COLOR_SUCCESS)
Return False
ElseIf Not _ColorCheck(_GetPixelColor(68 +(72 * $g_iQueenSlot), 572, True), Hex(0x72F50B, 6), 120, "Heroes") Then
$g_iDarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and AQ health Low. Return to protect Heroes.  Returning immediately", $COLOR_SUCCESS)
Return False
EndIf
EndIf
If $g_bDESideEndBKWeak And $g_bDropKing And Not $g_bCheckKingPower Then
If $g_iActivateKing = 0 Then
$g_iDarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and BK health Low. Return to protect Heroes.  Returning immediately", $COLOR_SUCCESS)
Return False
ElseIf Not _ColorCheck(_GetPixelColor(68 +(72 * $g_iKingSlot), 572, True), Hex(0x4FD404, 6), 120, "Heroes") Then
$g_iDarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and BK health Low. Return to protect Heroes.  Returning immediately", $COLOR_SUCCESS)
Return False
EndIf
EndIf
If $g_bDESideEndOneStar Then
If _ColorCheck(_GetPixelColor($aWonOneStar[0], $aWonOneStar[1], True), Hex($aWonOneStar[2], 6), $aWonOneStar[3]) Then
SetLog("Low De. De = ( " & $DarkE & " ) and 1 star achieved. Return to protect Heroes.  Returning immediately", $COLOR_SUCCESS)
$g_iDarkLow = 1
Return False
Else
SetLog("Low De. ( " & $DarkE & " ) Waiting for 1 star", $COLOR_SUCCESS)
$g_iDarkLow = 2
Return False
EndIf
EndIf
If Not $g_bDESideEndAQWeak And Not $g_bDESideEndBKWeak And Not $g_bDESideEndOneStar Then
SetLog("Low De. De = ( " & $DarkE & " ). Return to protect Heroes.  Returning immediately", $COLOR_SUCCESS)
Return False
EndIf
EndIf
Else
$g_iDarkLow = 0
EndIf
EndFunc
Func SaveandDisableEBO()
$g_abSaveichkEndOneStar[$g_iMatchMode] = $g_abStopAtkOneStar[$g_iMatchMode]
$g_abSaveichkEndTwoStars[$g_iMatchMode] = $g_abStopAtkTwoStars[$g_iMatchMode]
$g_abSaveiChkTimeStopAtk[$g_iMatchMode] = $g_abStopAtkNoLoot1Enable[$g_iMatchMode]
$g_abSaveiChkTimeStopAtk2[$g_iMatchMode] = $g_abStopAtkNoLoot2Enable[$g_iMatchMode]
$g_abStopAtkOneStar[$g_iMatchMode] = 0
$g_abStopAtkTwoStars[$g_iMatchMode] = 0
$g_abStopAtkNoLoot1Enable[$g_iMatchMode] = 0
$g_abStopAtkNoLoot2Enable[$g_iMatchMode] = 0
EndFunc
Func RevertEBO()
$g_abStopAtkOneStar[$g_iMatchMode] = $g_abSaveichkEndOneStar
$g_abStopAtkTwoStars[$g_iMatchMode] = $g_abSaveichkEndTwoStars
$g_abStopAtkNoLoot1Enable[$g_iMatchMode] = $g_abSaveiChkTimeStopAtk
$g_abStopAtkNoLoot2Enable[$g_iMatchMode] = $g_abSaveiChkTimeStopAtk2
EndFunc
Func GoldElixirChangeThSnipes($x)
Local $Gold1, $Gold2
Local $GoldChange, $ElixirChange
Local $Elixir1, $Elixir2
SetLog("Checking if the Gold6Elixir are changing...", $COLOR_INFO)
For $y = 0 To $x
$Gold1 = getGoldVillageSearch(48, 69)
$Elixir1 = getElixirVillageSearch(48, 69 + 29)
Local $iBegin = __TimerInit()
While __TimerDiff($iBegin) < 2000
CheckHeroesHealth()
If $g_bCheckKingPower Or $g_bCheckQueenPower Then
If _Sleep($DELAYGOLDELIXIRCHANGE1) Then Return
Else
If _Sleep($DELAYGOLDELIXIRCHANGE2) Then Return
EndIf
$Gold2 = getGoldVillageSearch(48, 69)
If $Gold2 = "" Then
If _Sleep($DELAYGOLDELIXIRCHANGE1) Then Return
$Gold2 = getGoldVillageSearch(48, 69)
EndIf
$Elixir2 = getElixirVillageSearch(48, 69 + 29)
If $Gold2 <> "" Or $Elixir2 <> "" Then
$GoldChange = $Gold2
$ElixirChange = $Elixir2
EndIf
If($Gold2 = "" And $Elixir2 = "") Then
If _Sleep($DELAYGOLDELIXIRCHANGE1) Then Return
If getGoldVillageSearch(48, 69) = "" And getElixirVillageSearch(48, 69 + 29) = "" Then
SetLog("Battle has finished", $COLOR_SUCCESS)
Return True
ExitLoop
EndIf
EndIf
WEnd
If($Gold1 = $Gold2 And $Elixir1 = $Elixir2) Or($Gold2 = "" And $Elixir2 = "") Then
ExitLoop
Else
SetLog("Gold & Elixir change detected, waiting...", $COLOR_SUCCESS)
ContinueLoop
EndIf
$x += 1
If Sleep(1000) Then Return
Return False
Next
EndFunc
Func GoldElixirChangeEBO()
Local $Gold1, $Gold2
Local $GoldChange, $ElixirChange
Local $Elixir1, $Elixir2
Local $DarkElixir1, $DarkElixir2
Local $DarkElixirChange
Local $Trophies
Local $txtDiff
Local $exitOneStar = 0, $exitTwoStars = 0
Local $Damage, $CurDamage
$g_iDarkLow = 0
$Gold1 = getGoldVillageSearch(48, 69)
$Elixir1 = getElixirVillageSearch(48, 69 + 29)
$Trophies = getTrophyVillageSearch(48, 69 + 99)
$Damage = getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)
If $Trophies <> "" Then
If _Sleep($DELAYGOLDELIXIRCHANGEEBO1) Then Return
$DarkElixir1 = getDarkElixirVillageSearch(48, 69 + 57)
Else
$DarkElixir1 = ""
$Trophies = getTrophyVillageSearch(48, 69 + 69)
EndIf
Local $x = $g_aiStopAtkNoLoot1Time[$g_iMatchMode] * 1000, $y = $g_aiStopAtkNoLoot2Time[$g_iMatchMode] * 1000, $z, $w = $g_aiStopAtkPctNoChangeTime[$g_iMatchMode] * 1000
If Number($Gold1) < $g_aiStopAtkNoLoot2MinGold[$g_iMatchMode] And Number($Elixir1) < $g_aiStopAtkNoLoot2MinElixir[$g_iMatchMode] And Number($DarkElixir1) < $g_aiStopAtkNoLoot2MinDark[$g_iMatchMode] And $g_abStopAtkNoLoot2Enable[$g_iMatchMode] Then
$z = $y
ElseIf $Damage <> "" And $g_abStopAtkPctNoChangeEnable[$g_iMatchMode] Then
$z = $w
Else
If $g_abStopAtkNoLoot1Enable[$g_iMatchMode] Then
$z = $x
Else
$z = AttackRemainingTime()
EndIf
EndIf
If $g_abStopAtkTwoStars[$g_iMatchMode] And _CheckPixel($aWonTwoStar, True) Then
SetLog("Two Star Reach, exit", $COLOR_SUCCESS)
$exitTwoStars = 1
$z = 0
EndIf
If $g_abStopAtkOneStar[$g_iMatchMode] And _CheckPixel($aWonOneStar, True) Then
SetLog("One Star Reach, exit", $COLOR_SUCCESS)
$exitOneStar = 1
$z = 0
EndIf
If $g_abStopAtkPctHigherEnable[$g_iMatchMode] And Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)) > Number($g_aiStopAtkPctHigherAmt[$g_iMatchMode]) Then
SetLog("Overall Damage above " & Number($g_aiStopAtkPctHigherAmt[$g_iMatchMode]), $COLOR_SUCCESS)
$z = 0
EndIf
Local $NoResourceOCR = False
Local $iBegin = __TimerInit()
Local $iSuspendAndroidTimeOffset = SuspendAndroidTime()
SetDebugLog("GoldElixirChangeEBO: Start waiting for battle end, Wait: " & $z & ", Offset: " & $iSuspendAndroidTimeOffset)
Local $iTime = 0
Local $bOneLoop = True
While $bOneLoop Or($iTime < $z And $z > 0 And $iTime >= 0)
$bOneLoop = False
CheckHeroesHealth()
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 4 And $g_bDESideEndEnable Then
If $g_bDropQueen Or $g_bDropKing Then DELow()
If $g_iDarkLow = 1 Then ExitLoop
EndIf
If $g_bCheckKingPower Or $g_bCheckQueenPower Or $g_iDarkLow = 2 Then
If _Sleep($DELAYGOLDELIXIRCHANGEEBO1) Then Return
Else
If _Sleep($DELAYGOLDELIXIRCHANGEEBO2) Then Return
EndIf
$Gold2 = getGoldVillageSearch(48, 69)
If $Gold2 = "" Then
If _Sleep($DELAYGOLDELIXIRCHANGEEBO1) Then Return
$Gold2 = getGoldVillageSearch(48, 69)
EndIf
$Elixir2 = getElixirVillageSearch(48, 69 + 29)
$Trophies = getTrophyVillageSearch(48, 69 + 99)
CheckHeroesHealth()
If $Trophies <> "" Then
If _Sleep($DELAYGOLDELIXIRCHANGEEBO1) Then Return
$DarkElixir2 = getDarkElixirVillageSearch(48, 69 + 57)
Else
$DarkElixir2 = ""
$Trophies = getTrophyVillageSearch(48, 69 + 69)
EndIf
$CurDamage = getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)
CheckHeroesHealth()
$txtDiff = Round(($z -(__TimerDiff($iBegin) - SuspendAndroidTime() + $iSuspendAndroidTimeOffset)) / 1000, 0)
If Number($txtDiff) < 0 Then
$txtDiff = "0s"
Else
Local $m = Int($txtDiff / 60)
Local $s = $txtDiff - $m * 60
$txtDiff = ""
If $m > 0 Then $txtDiff = $m & "m "
$txtDiff &= $s & "s"
EndIf
$NoResourceOCR = StringLen($Gold2) = 0 And StringLen($Elixir2) = 0 And StringLen($DarkElixir2) = 0
If $NoResourceOCR Then
SetLog("Exit now, [G]: " & $Gold2 & " [E]: " & $Elixir2 & " [DE]: " & $DarkElixir2 & " [%]: " & $CurDamage, $COLOR_INFO)
Else
If $g_bDebugSetlog Then
SetDebugLog("Exit in " & $txtDiff & ", [G]: " & $Gold2 & " [E]: " & $Elixir2 & " [DE]: " & $DarkElixir2 & " [%]: " & $CurDamage & ", Suspend-Time: " & $g_iSuspendAndroidTime & ", Suspend-Count: " & $g_iSuspendAndroidTimeCount & ", Offset: " & $iSuspendAndroidTimeOffset, $COLOR_INFO)
Else
SetLog("Exit in " & $txtDiff & ", [G]: " & $Gold2 & " [E]: " & $Elixir2 & " [DE]: " & $DarkElixir2 & " [%]: " & $CurDamage, $COLOR_INFO)
EndIf
EndIf
If Number($CurDamage) >= 92 Then
If($g_bCheckKingPower Or $g_bCheckQueenPower Or $g_bCheckWardenPower) Then
If $g_bCheckKingPower And $g_iActivateKing = 0 Then
SetLog("Activating King's ability to restore some health before leaving with a 3 Star", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($g_iKingSlot)
$g_bCheckKingPower = False
EndIf
If $g_bCheckQueenPower And $g_iActivateQueen = 0 Then
SetLog("Activating Queen's ability to restore some health before leaving with a 3 Star", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($g_iQueenSlot)
$g_bCheckQueenPower = False
EndIf
If $g_bCheckWardenPower And $g_iActivateWarden = 0 Then
SetLog("Activating Warden's ability to restore some health before leaving with a 3 Star", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($g_iWardenSlot)
$g_bCheckWardenPower = False
EndIf
EndIf
EndIf
If $Gold2 <> "" Or $Elixir2 <> "" Or $DarkElixir2 <> "" Then
$GoldChange = $Gold2
$ElixirChange = $Elixir2
$DarkElixirChange = $DarkElixir2
EndIf
If $g_abStopAtkNoResources[$g_iMatchMode] And Number($Gold2) = 0 And Number($Elixir2) = 0 And Number($DarkElixir2) = 0 Then
SetLog("Gold & Elixir & DE = 0, end battle ", $COLOR_SUCCESS)
If _Sleep($DELAYGOLDELIXIRCHANGEEBO2) Then Return
ExitLoop
EndIf
If $g_abStopAtkTwoStars[$g_iMatchMode] And _CheckPixel($aWonTwoStar, True) Then
SetLog("Two Star Reach, exit", $COLOR_SUCCESS)
$exitTwoStars = 1
ExitLoop
EndIf
If $g_abStopAtkOneStar[$g_iMatchMode] And _CheckPixel($aWonOneStar, True) Then
SetLog("One Star Reach, exit", $COLOR_SUCCESS)
$exitOneStar = 1
ExitLoop
EndIf
If getGoldVillageSearch(48, 69) = "" And getElixirVillageSearch(48, 69 + 29) = "" And $DarkElixir2 = "" Then
ExitLoop
EndIf
If $g_abStopAtkPctHigherEnable[$g_iMatchMode] And Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)) > Number($g_aiStopAtkPctHigherAmt[$g_iMatchMode]) Then
SetLog("Overall Damage above " & Number($g_aiStopAtkPctHigherAmt[$g_iMatchMode]) & ", exit", $COLOR_SUCCESS)
ExitLoop
EndIf
If($g_abStopAtkNoLoot1Enable[$g_iMatchMode] Or $g_abStopAtkNoLoot2Enable[$g_iMatchMode]) And($Gold1 <> $Gold2 Or $Elixir1 <> $Elixir2 Or $DarkElixir1 <> $DarkElixir2) Then
SetLog("Gold & Elixir & DE change detected, waiting...", $COLOR_SUCCESS)
Return True
EndIf
If $g_abStopAtkPctNoChangeEnable[$g_iMatchMode] And(Number($Damage) <> Number($CurDamage)) Then
SetLog("Overall Damage Percentage change detected, waiting...", $COLOR_SUCCESS)
Return True
EndIf
$iTime = __TimerDiff($iBegin) - SuspendAndroidTime() + $iSuspendAndroidTimeOffset
WEnd
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 4 And $g_bDESideEndEnable And $g_iDarkLow = 1 Then
SetLog("Returning Now -DE-", $COLOR_SUCCESS)
Return False
EndIf
If $g_abStopAtkOneStar[$g_iMatchMode] And $exitOneStar = 1 Then
If _Sleep($DELAYGOLDELIXIRCHANGEEBO2) Then Return
Return False
EndIf
If $g_abStopAtkTwoStars[$g_iMatchMode] And $exitTwoStars = 1 Then
If _Sleep($DELAYGOLDELIXIRCHANGEEBO2) Then Return
Return False
EndIf
If($NoResourceOCR = True) Then
SetLog("Battle has finished", $COLOR_SUCCESS)
Return False
EndIf
If $g_abStopAtkPctHigherEnable[$g_iMatchMode] And Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)) > Number($g_aiStopAtkPctHigherAmt[$g_iMatchMode]) Then
Return False
EndIf
If $g_abStopAtkNoResources[$g_iMatchMode] And $NoResourceOCR = False And Number($Gold2) = 0 And Number($Elixir2) = 0 And Number($DarkElixir2) = 0 Then
SetLog("Gold & Elixir & DE = 0, end battle ", $COLOR_SUCCESS)
If _Sleep($DELAYGOLDELIXIRCHANGEEBO2) Then Return
Return False
EndIf
If $g_abStopAtkPctNoChangeEnable[$g_iMatchMode] And Number($Damage) = Number($CurDamage) Then
SetLog("No Overall Damage Percentage change detected, exit", $COLOR_SUCCESS)
Return False
EndIf
If(Number($Gold1) = Number($Gold2) And Number($Elixir1) = Number($Elixir2) And Number($DarkElixir1) = Number($DarkElixir2)) Then
If $g_abStopAtkNoLoot1Enable[$g_iMatchMode] Or $g_abStopAtkNoLoot2Enable[$g_iMatchMode] Then
SetLog("Gold & Elixir & DE no change detected, exit", $COLOR_SUCCESS)
Return False
Else
SetLog("Gold & Elixir & DE no change detected, waiting...", $COLOR_SUCCESS)
EndIf
Else
If $g_bDebugSetlog Then
SetDebugLog("Gold1: " & Number($Gold1) & "  Gold2: " & Number($Gold2), $COLOR_DEBUG)
SetDebugLog("Elixir1: " & Number($Elixir1) & "  Elixir2: " & Number($Elixir2), $COLOR_DEBUG)
SetDebugLog("Dark Elixir1: " & Number($DarkElixir1) & "  Dark Elixir2: " & Number($DarkElixir2), $COLOR_DEBUG)
EndIf
EndIf
Return True
EndFunc
Func PrepareAttack($pMatchMode, $Remaining = False)
If($pMatchMode = $DB And $g_aiAttackAlgorithm[$DB] = 1) Or($pMatchMode = $LB And $g_aiAttackAlgorithm[$LB] = 1) Then
If $g_bDebugMakeIMGCSV And $Remaining = False And TestCapture() = 0 Then
If $g_iSearchTH = "-" Then
imglocTHSearch(True, False, False)
EndIf
DebugImageSave("clean", False, Default, Default, "TH" & $g_iSearchTH & "-")
EndIf
EndIf
If $Remaining = False Then
$g_bDropKing = False
$g_bDropQueen = False
$g_bDropWarden = False
If $g_iActivateKing = 1 Or $g_iActivateKing = 2 Then $g_aHeroesTimerActivation[$eHeroBarbarianKing] = 0
If $g_iActivateQueen = 1 Or $g_iActivateQueen = 2 Then $g_aHeroesTimerActivation[$eHeroArcherQueen] = 0
If $g_iActivateWarden = 1 Or $g_iActivateWarden = 2 Then $g_aHeroesTimerActivation[$eHeroGrandWarden] = 0
EndIf
Local $troopsnumber = 0
If $g_bDebugSetlog Then SetDebugLog("PrepareAttack for " & $pMatchMode & " " & $g_asModeText[$pMatchMode], $COLOR_DEBUG)
If $Remaining Then
SetLog("Checking remaining unused troops for: " & $g_asModeText[$pMatchMode], $COLOR_INFO)
Else
SetLog("Initiating attack for: " & $g_asModeText[$pMatchMode], $COLOR_ERROR)
EndIf
If Not $Remaining And IsTroopToBeUsed($pMatchMode, $eCastle) Then
If QuickMIS("BC1", $g_sImgSwitchSiegeMacines, 28, 698, 820, 726, True, False) Then
Setlog("Switching button in a Siege Machine detected.")
Click($g_iQuickMISX + 28, $g_iQuickMISY + 698, 1)
Local $lastX = $g_iQuickMISX , $LastX1 = $g_iQuickMISX + 165 , $lastY = $g_iQuickMISY
If _Sleep(1500) then return
If QuickMIS("BC1", $g_sImgSwitchSiegeCastle, $lastX, 535, $LastX1, 560, True, False) Then
Click($g_iQuickMISX + $lastX, $g_iQuickMISY + 535, 1)
Setlog("Clan Castle troops selected!", $COLOR_SUCCESS)
Else
Click($lastX + 28, $lastY + 698, 1)
EndIf
If _Sleep(1500) then return
EndIf
EndIf
_CaptureRegion2(0, 571 + $g_iBottomOffsetY, 859, 671 + $g_iBottomOffsetY)
If _Sleep($DELAYPREPAREATTACK1) Then Return
For $i = 0 To UBound($g_avAttackTroops) - 1
$g_avAttackTroops[$i][0] = -1
$g_avAttackTroops[$i][1] = 0
Next
Local $Plural = 0
Local $result = AttackBarCheck($Remaining)
If $g_bDebugSetlog Then SetDebugLog("DLL Troopsbar list: " & $result, $COLOR_DEBUG)
Local $aTroopDataList = StringSplit($result, "|")
Local $aTemp[12][3]
If $result <> "" Then
For $i = 1 To $aTroopDataList[0]
Local $troopData = StringSplit($aTroopDataList[$i], "#", $STR_NOCOUNT)
$aTemp[Number($troopData[1])][0] = $troopData[0]
$aTemp[Number($troopData[1])][1] = Number($troopData[2])
$aTemp[Number($troopData[1])][2] = Number($troopData[1])
Next
EndIf
For $i = 0 To UBound($aTemp) - 1
If $aTemp[$i][0] = "" And $aTemp[$i][1] = "" Then
$g_avAttackTroops[$i][0] = -1
$g_avAttackTroops[$i][1] = 0
Else
Local $troopKind = $aTemp[$i][0]
If $troopKind < $eKing Then
If Not IsTroopToBeUsed($pMatchMode, $troopKind) Then
If $g_bDebugSetlog Then SetDebugLog("Discard use of troop " & $troopKind & " " & NameOfTroop($troopKind), $COLOR_ERROR)
$g_avAttackTroops[$i][0] = -1
$g_avAttackTroops[$i][1] = 0
$troopKind = -1
Else
$g_avAttackTroops[$i][0] = $aTemp[$i][0]
$g_avAttackTroops[$i][1] = $aTemp[$i][1]
$troopsnumber += $aTemp[$i][1]
EndIf
Else
$g_avAttackTroops[$i][0] = $troopKind
If IsSpecialTroopToBeUsed($pMatchMode, $troopKind) Then
$troopsnumber += 1
$g_avAttackTroops[$i][0] = $aTemp[$i][0]
$g_avAttackTroops[$i][1] = $aTemp[$i][1]
If $g_avAttackTroops[$i][0] = $eKing Or $g_avAttackTroops[$i][0] = $eQueen Or $g_avAttackTroops[$i][0] = $eWarden Then $g_avAttackTroops[$i][1] = 1
$troopKind = $g_avAttackTroops[$i][1]
$troopsnumber += 1
Else
If $g_bDebugSetlog Then SetDebugLog($aTemp[$i][2] & " » Discard use hero/poison " & $troopKind & " " & NameOfTroop($troopKind), $COLOR_ERROR)
$troopKind = -1
EndIf
EndIf
$Plural = 0
If $aTemp[$i][1] > 1 Then $Plural = 1
If $troopKind <> -1 Then SetLog($aTemp[$i][2] & " » " & $g_avAttackTroops[$i][1] & " " & NameOfTroop($g_avAttackTroops[$i][0], $Plural), $COLOR_SUCCESS)
EndIf
Next
If $g_bDebugSetlog Then SetDebugLog("troopsnumber  = " & $troopsnumber)
Return $troopsnumber
EndFunc
Func IsTroopToBeUsed($pMatchMode, $pTroopType)
If $pMatchMode = $DT Or $pMatchMode = $TB Then Return True
If $pMatchMode = $MA Then
Local $tempArr = $g_aaiTroopsToBeUsed[$g_aiAttackTroopSelection[$DB]]
Else
Local $tempArr = $g_aaiTroopsToBeUsed[$g_aiAttackTroopSelection[$pMatchMode]]
EndIf
For $x = 0 To UBound($tempArr) - 1
If $tempArr[$x] = $pTroopType Then
If $pMatchMode = $MA And $pTroopType = $eGobl Then
Return False
Else
Return True
EndIf
EndIf
Next
Return False
EndFunc
Func IsSpecialTroopToBeUsed($pMatchMode, $pTroopType)
Local $iTempMode =($pMatchMode = $MA ? $DB : $pMatchMode)
If $pMatchMode <> $DB And $pMatchMode <> $LB And $pMatchMode <> $TS And $pMatchMode <> $MA Then
Return True
Else
Switch $pTroopType
Case $eKing
If(BitAND($g_aiAttackUseHeroes[$iTempMode], $eHeroKing) = $eHeroKing) Then Return True
Case $eQueen
If(BitAND($g_aiAttackUseHeroes[$iTempMode], $eHeroQueen) = $eHeroQueen) Then Return True
Case $eWarden
If(BitAND($g_aiAttackUseHeroes[$iTempMode], $eHeroWarden) = $eHeroWarden) Then Return True
Case $eCastle
If $g_abAttackDropCC[$iTempMode] Then Return True
Case $eLSpell
If $g_abAttackUseLightSpell[$iTempMode] Or $g_bSmartZapEnable = True Then Return True
Case $eHSpell
If $g_abAttackUseHealSpell[$iTempMode] Then Return True
Case $eRSpell
If $g_abAttackUseRageSpell[$iTempMode] Then Return True
Case $eJSpell
If $g_abAttackUseJumpSpell[$iTempMode] Then Return True
Case $eFSpell
If $g_abAttackUseFreezeSpell[$iTempMode] Then Return True
Case $ePSpell
If $g_abAttackUsePoisonSpell[$iTempMode] Then Return True
Case $eESpell
If $g_abAttackUseEarthquakeSpell[$iTempMode] = 1 Or $g_bSmartZapEnable = True Then Return True
Case $eHaSpell
If $g_abAttackUseHasteSpell[$iTempMode] Then Return True
Case $eCSpell
If $g_abAttackUseCloneSpell[$iTempMode] Then Return True
Case $eSkSpell
If $g_abAttackUseSkeletonSpell[$iTempMode] Then Return True
Case Else
Return False
EndSwitch
Return False
EndIf
EndFunc
Func AttackRemainingTime($bInitialze = Default)
If $bInitialze = True Then
$g_hAttackTimer = __TimerInit()
$g_iAttackTimerOffset = Default
SuspendAndroidTime(True)
Return
EndIf
Local $iPrepareTime = 29 * 1000
If $g_iAttackTimerOffset = Default Then
$g_iAttackTimerOffset = __TimerDiff($g_hAttackTimer) - SuspendAndroidTime()
If $g_iAttackTimerOffset > $iPrepareTime Then
$g_iAttackTimerOffset = $iPrepareTime - $g_iAttackTimerOffset
EndIf
EndIf
If $bInitialze = False Then Return
Local $iAttackTime = 3 * 60 * 1000
Local $iRemaining = $iAttackTime -(__TimerDiff($g_hAttackTimer) - SuspendAndroidTime() - $g_iAttackTimerOffset)
If $iRemaining < 0 Then Return 0
Return $iRemaining
EndFunc
Func ReturnHome($TakeSS = 1, $GoldChangeCheck = True)
If $g_bDebugSetlog Then SetDebugLog("ReturnHome function... (from matchmode=" & $g_iMatchMode & " - " & $g_asModeText[$g_iMatchMode] & ")", $COLOR_DEBUG)
Local $counter = 0
Local $hBitmap_Scaled
Local $i, $j
If $g_bDESideDisableOther And $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 4 And $g_bDESideEndEnable And($g_bDropQueen Or $g_bDropKing) Then
SaveandDisableEBO()
SetLog("Disabling Normal End Battle Options", $COLOR_SUCCESS)
EndIf
If $GoldChangeCheck Then
If Not(IsReturnHomeBattlePage(True, False)) Then
SetLog("Checking if the battle has finished", $COLOR_INFO)
While GoldElixirChangeEBO()
If _Sleep($DELAYRETURNHOME1) Then Return
WEnd
If IsAttackPage() Then smartZap()
If($g_bCheckKingPower Or $g_bCheckQueenPower Or $g_bCheckWardenPower) Then
If _ColorCheck(_GetPixelColor($aRtnHomeCheck1[0], $aRtnHomeCheck1[1], True), Hex($aRtnHomeCheck1[2], 6), $aRtnHomeCheck1[3]) = False And _ColorCheck(_GetPixelColor($aRtnHomeCheck2[0], $aRtnHomeCheck2[1], True), Hex($aRtnHomeCheck2[2], 6), $aRtnHomeCheck2[3]) = False Then
If $g_bCheckKingPower Then
SetLog("Activating King's power to restore some health before EndBattle", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($g_iKingSlot)
EndIf
If $g_bCheckQueenPower Then
SetLog("Activating Queen's power to restore some health before EndBattle", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($g_iQueenSlot)
EndIf
If $g_bCheckWardenPower Then
SetLog("Activating Warden's power to restore some health before EndBattle", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($g_iWardenSlot)
EndIf
EndIf
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("Battle already over", $COLOR_DEBUG)
EndIf
EndIf
If $g_bDESideDisableOther And $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 4 And $g_bDESideEndEnable And($g_bDropQueen Or $g_bDropKing) Then
RevertEBO()
EndIf
$g_bCheckKingPower = False
$g_bCheckQueenPower = False
$g_bCheckWardenPower = False
$g_bDropKing = False
$g_bDropQueen = False
$g_bDropWarden = False
$g_aHeroesTimerActivation[$eHeroBarbarianKing] = 0
$g_aHeroesTimerActivation[$eHeroArcherQueen] = 0
$g_aHeroesTimerActivation[$eHeroGrandWarden] = 0
_ObjDeleteKey($g_oBldgAttackInfo, "")
If $g_abAttackTypeEnable[$TS] = 1 And $g_iMatchMode = $TS Then $g_bFirstStart = True
SetLog("Returning Home", $COLOR_INFO)
If $g_bRunState = False Then Return
If Not(IsReturnHomeBattlePage(True, False)) Then
For $i = 0 To 5
If $g_bDebugSetlog Then SetDebugLog("Wait for surrender button to appear #" & $i)
If _CheckPixel($aSurrenderButton, $g_bCapturePixel) Then
If IsAttackPage() Then
ClickP($aSurrenderButton, 1, 0, "#0099")
$j = 0
While 1
If $g_bDebugSetlog Then SetDebugLog("Wait for OK button to appear #" & $j)
If IsEndBattlePage(False) Then
ClickOkay("SurrenderOkay")
ExitLoop 2
Else
$j += 1
EndIf
If ReturnHomeMainPage() Then Return
If $j > 10 Then ExitLoop
If _Sleep($DELAYRETURNHOME5) Then Return
WEnd
EndIf
EndIf
If ReturnHomeMainPage() Then Return
If _Sleep($DELAYRETURNHOME5) Then Return
Next
Else
If $g_bDebugSetlog Then SetDebugLog("Battle already over.", $COLOR_DEBUG)
EndIf
If _Sleep($DELAYRETURNHOME2) Then Return
TrayTip($g_sBotTitle, "", BitOR($TIP_ICONASTERISK, $TIP_NOSOUND))
CheckAndroidReboot(False)
If $GoldChangeCheck Then
If IsAttackPage() Then
$counter = 0
While _ColorCheck(_GetPixelColor($aRtnHomeCheck1[0], $aRtnHomeCheck1[1], True), Hex($aRtnHomeCheck1[2], 6), $aRtnHomeCheck1[3]) = False And _ColorCheck(_GetPixelColor($aRtnHomeCheck2[0], $aRtnHomeCheck2[1], True), Hex($aRtnHomeCheck2[2], 6), $aRtnHomeCheck2[3]) = False
If $g_bDebugSetlog Then SetDebugLog("Wait for Return Home Button to appear #" & $counter)
If _Sleep($DELAYRETURNHOME2) Then ExitLoop
$counter += 1
If $counter > 40 Then ExitLoop
WEnd
EndIf
If _Sleep($DELAYRETURNHOME3) Then Return
_CaptureRegion()
AttackReport()
EndIf
If $TakeSS = 1 And $GoldChangeCheck Then
SetLog("Taking snapshot of your loot", $COLOR_SUCCESS)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion()
$hBitmap_Scaled = _GDIPlus_ImageResize($g_hBitmap, _GDIPlus_ImageGetWidth($g_hBitmap) / 2, _GDIPlus_ImageGetHeight($g_hBitmap) / 2)
If $g_bScreenshotLootInfo Then
$g_sLootFileName = $Date & "_" & $Time & " G" & $g_iStatsLastAttack[$eLootGold] & " E" & $g_iStatsLastAttack[$eLootElixir] & " DE" & $g_iStatsLastAttack[$eLootDarkElixir] & " T" & $g_iStatsLastAttack[$eLootTrophy] & " S" & StringFormat("%3s", $g_iSearchCount) & ".jpg"
Else
$g_sLootFileName = $Date & "_" & $Time & ".jpg"
EndIf
_GDIPlus_ImageSaveToFile($hBitmap_Scaled, $g_sProfileLootsPath & $g_sLootFileName)
_GDIPlus_ImageDispose($hBitmap_Scaled)
EndIf
If $GoldChangeCheck Then PushMsg("LastRaid")
$i = 0
While 1
If $g_bDebugSetlog Then SetDebugLog("Wait for End Fight Scene to appear #" & $i)
If _CheckPixel($aEndFightSceneAvl, $g_bCapturePixel) Then
If IsReturnHomeBattlePage() Then ClickP($aReturnHomeButton, 1, 0, "#0101")
ExitLoop
Else
$i += 1
EndIf
If $i > 10 Then ExitLoop
If _Sleep($DELAYRETURNHOME5) Then Return
WEnd
If _Sleep($DELAYRETURNHOME2) Then Return
$counter = 0
While 1
If $g_bDebugSetlog Then SetDebugLog("Wait for Star Bonus window to appear #" & $counter)
If _Sleep($DELAYRETURNHOME4) Then Return
If StarBonus() Then SetLog("Star Bonus window closed chief!", $COLOR_INFO)
If ReturnHomeMainPage() Then Return
$counter += 1
If $counter >= 50 Or isProblemAffect(True) Then
SetLog("Cannot return home.", $COLOR_ERROR)
checkMainScreen()
Return
EndIf
WEnd
EndFunc
Func ReturnHomeMainPage()
If IsMainPage(1) Then
SetLogCentered(" BOT LOG ", Default, Default, True)
Return True
EndIf
Return False
EndFunc
Func Unbreakable()
Local $x, $y, $i, $iTime, $iCount
Switch $g_iUnbrkMode
Case 2
If(Number($g_aiCurrentLoot[$eLootGold]) > Number($g_iUnbrkMaxGold)) And(Number($g_aiCurrentLoot[$eLootElixir]) > Number($g_iUnbrkMaxElixir)) And(Number($g_aiCurrentLoot[$eLootDarkElixir]) > Number($g_iUnbrkMaxDark)) Then
SetLog(" ====== Unbreakable Mode restarted! ====== ", $COLOR_SUCCESS)
$g_iUnbrkMode = 1
Else
SetLog(" = Unbreakable Mode Paused, Farming to Refill Storages =", $COLOR_INFO)
Return False
EndIf
Case 1
SetLog(" ====== Unbreakable Mode enabled! ====== ", $COLOR_SUCCESS)
Case Else
SetLog(">>> Programmer Humor, You shouldn't ever see this message, RUN! <<<", $COLOR_DEBUG)
EndSwitch
If $g_bDropTrophyAtkDead Then
If($g_CurrentCampUtilization <=($g_iTotalCampSpace * 70 / 100)) Then
SetLog("Oops, wait for 70% troops due attack dead base checked", $COLOR_ERROR)
Return True
EndIf
Else
If($g_CurrentCampUtilization <=($g_iTotalCampSpace * 20 / 100)) Then
SetLog("Oops, wait for 20% troops for use in trophy drop", $COLOR_ERROR)
Return True
EndIf
EndIf
Local $sMissingLoot = ""
If((Number($g_aiCurrentLoot[$eLootGold]) - Number($g_iUnbrkMinGold)) < 0) Then
$sMissingLoot &= "Gold, "
EndIf
If((Number($g_aiCurrentLoot[$eLootElixir]) - Number($g_iUnbrkMinElixir)) < 0) Then
$sMissingLoot &= "Elixir, "
EndIf
If((Number($g_aiCurrentLoot[$eLootDarkElixir]) - Number($g_iUnbrkMinDark)) < 0) Then
$sMissingLoot &= "Dark Elixir"
EndIf
If $sMissingLoot <> "" Then
SetLog("Oops, Out of " & $sMissingLoot & " - back to farming", $COLOR_ERROR)
$g_iUnbrkMode = 2
Return False
EndIf
DropTrophy()
If _Sleep($DELAYUNBREAKABLE2) Then Return True
ClickP($aAway, 1, $DELAYUNBREAKABLE7, "#0112")
If _Sleep($DELAYUNBREAKABLE1) Then Return True
If $g_bRestart = True Then Return True
$iCount = 0
Local $iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If $g_bDebugSetlog Then SetDebugLog("Trophy Count Read = " & $iTrophyCurrent, $COLOR_DEBUG)
While Number($iTrophyCurrent) > Number($g_iDropTrophyMax)
If $g_bDebugSetlog Then SetDebugLog("Drop Trophy Loop #" & $iCount + 1, $COLOR_DEBUG)
DropTrophy()
If _Sleep($DELAYUNBREAKABLE2) Then Return
ClickP($aAway, 1, 0, "#0395")
If _Sleep($DELAYUNBREAKABLE1) Then Return
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If($iCount > 2) And(Number($iTrophyCurrent) > Number($g_iDropTrophyMax)) Then
SetLog("Unable to drop trophy, trying again", $COLOR_ERROR)
If _Sleep(500) Then Return
Return True
EndIf
$iCount += 1
WEnd
If $g_bRestart = True Then Return True
BreakPersonalShield()
If @error Then
If @extended <> "" Then SetLog("PersonalShield button problem: " & @extended, $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0395")
Return True
EndIf
ClickP($aAway, 2, $DELAYUNBREAKABLE8, "#0115")
If _Sleep($DELAYUNBREAKABLE1) Then Return True
If CheckObstacles() = True Then SetLog("Window clean required, but no problem for MyBot!", $COLOR_INFO)
SetLog("Closing Clash Of Clans", $COLOR_INFO)
$i = 0
While 1
AndroidBackButton()
If _Sleep($DELAYUNBREAKABLE1) Then Return True
Local $offColors[3][3] = [[0x000000, 144, 0], [0xFFFFFF, 54, 17], [0xCBE870, 54, 10]]
Local $ButtonPixel = _MultiPixelSearch(438, 372 + $g_iMidOffsetY, 590, 404 + $g_iMidOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $g_bDebugSetlog Then SetDebugLog("Exit btn chk-#1: " & _GetPixelColor(441, 374, True) & ", #2: " & _GetPixelColor(441 + 144, 374, True) & ", #3: " & _GetPixelColor(441 + 54, 374 + 17, True) & ", #4: " & _GetPixelColor(441 + 54, 374 + 10, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Then
SetDebugLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetDebugLog("Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 144, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 17, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 27, True), $COLOR_DEBUG)
EndIf
PureClick($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 2, 50, "#0117")
ExitLoop
EndIf
If $i > 15 Then ExitLoop
$i += 1
WEnd
$iTime = Number($g_iUnbrkWait)
If $iTime < 1 Then $iTime = 1
Local Const $iGracePeriodTime = 5
$iTime =($iTime + $iGracePeriodTime) * 60 * 1000
WaitnOpenCoC($iTime, False)
$iCount = 0
While 1
If $g_bDebugSetlog Then SetDebugLog("Under Attack Pixels = " & _GetPixelColor(841, 342 + $g_iMidOffsetY, True) & "/" & _GetPixelColor(842, 348 + $g_iMidOffsetY, True), $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor(841, 342 + $g_iMidOffsetY, True), Hex(0x711C0A, 6), 20) And _ColorCheck(_GetPixelColor(842, 348 + $g_iMidOffsetY, True), Hex(0x721C0E, 6), 20) Then
SetLog("Base is under attack, waiting 30 seocnds for end", $COLOR_INFO)
Else
ExitLoop
EndIf
If _SleepStatus($DELAYUNBREAKABLE6) Then Return True
If $iCount > 7 Then ExitLoop
$iCount += 1
WEnd
If _Sleep($DELAYUNBREAKABLE4) Then Return True
Local $Message = _PixelSearch(20, 624, 105, 627, Hex(0xE1E3CB, 6), 15)
If IsArray($Message) Then
If $g_bDebugSetlog Then SetDebugLog("Return Home Pixel = " & _GetPixelColor($Message[0], $Message[1], True) & ", Pos: " & $Message[0] & "/" & $Message[1], $COLOR_DEBUG)
PureClick(67, 602 + $g_iBottomOffsetY, 1, 0, "#0138")
If _Sleep($DELAYUNBREAKABLE3) Then Return True
EndIf
If _ColorCheck(_GetPixelColor(235, 209 + $g_iMidOffsetY, True), Hex(0x9E3826, 6), 20) And _ColorCheck(_GetPixelColor(242, 140 + $g_iMidOffsetY, True), Hex(0xFFFFFF, 6), 20) Then
If $g_bDebugSetlog Then SetDebugLog("Village Attacked Pixels = " & _GetPixelColor(235, 209 + $g_iMidOffsetY, True) & "/" & _GetPixelColor(242, 140 + $g_iMidOffsetY, True), $COLOR_DEBUG)
PureClick(429, 493 + $g_iMidOffsetY, 1, 0, "#0132")
If _Sleep($DELAYUNBREAKABLE3) Then Return True
EndIf
If CheckObstacles() = True Then
If _Sleep($DELAYUNBREAKABLE3) Then Return
If CheckObstacles() = True Then CheckMainScreen(False)
Return
EndIf
ZoomOut()
If _Sleep($DELAYUNBREAKABLE1) Then Return True
Return True
EndFunc
Func algorithm_AllTroops()
If $g_bDebugSetlog Then SetDebugLog("algorithm_AllTroops()", $COLOR_DEBUG)
SetSlotSpecialTroops()
If _Sleep($DELAYALGORITHM_ALLTROOPS1) Then Return
SmartAttackStrategy($g_iMatchMode)
If($g_iSearchTH = "-" And($g_iMatchMode = $DB And $g_bTHSnipeBeforeEnable[$DB])) Or($g_iSearchTH = "-" And($g_iMatchMode = $LB And $g_bTHSnipeBeforeEnable[$LB])) Then
FindTownHall(True)
EndIf
Local $bTHSearchTemp = SearchTownHallLoc()
If $g_iMatchMode = $TS Or($g_iMatchMode = $DB And $g_bTHSnipeBeforeEnable[$DB] And $bTHSearchTemp = True) Or($g_iMatchMode = $LB And $g_bTHSnipeBeforeEnable[$LB] And $bTHSearchTemp = True) Then
SwitchAttackTHType()
EndIf
If $g_iMatchMode = $TS Then
If($g_bTHSnipeUsedKing = True Or $g_bTHSnipeUsedQueen = True) And($g_bSmartZapEnable = True And $g_bSmartZapSaveHeroes = True) Then
SetLog("King and/or Queen dropped, close attack")
If $g_bSmartZapEnable = True Then SetLog("Skipping SmartZap to protect your royals!", $COLOR_FUCHSIA)
ElseIf IsAttackPage() And Not SmartZap() And $g_bTHSnipeUsedKing = False And $g_bTHSnipeUsedQueen = False Then
SetLog("Wait few sec before close attack")
If _Sleep(Random(0, 2, 1) * 1000) Then Return
EndIf
If CompareResources($DB) And $g_aiAttackAlgorithm[$DB] = 0 And $g_bEndTSCampsEnable And Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100) >= Int($g_iEndTSCampsPct) Then
$g_iMatchMode = $DB
Else
CloseBattle()
Return
EndIf
EndIf
Local $nbSides = 0
Switch $g_aiAttackStdDropSides[$g_iMatchMode]
Case 0
SetLog("Attacking on a single side", $COLOR_INFO)
$nbSides = 1
Case 1
SetLog("Attacking on two sides", $COLOR_INFO)
$nbSides = 2
Case 2
SetLog("Attacking on three sides", $COLOR_INFO)
$nbSides = 3
Case 3
SetLog("Attacking on all sides", $COLOR_INFO)
$nbSides = 4
Case 4
SetLog("Attacking on Dark Elixir Side.", $COLOR_INFO)
$nbSides = 1
If Not($g_abAttackStdSmartAttack[$g_iMatchMode]) Then GetBuildingEdge($eSideBuildingDES)
Case 5
SetLog("Attacking on Town Hall Side.", $COLOR_INFO)
$nbSides = 1
If Not($g_abAttackStdSmartAttack[$g_iMatchMode]) Then GetBuildingEdge($eSideBuildingTH)
EndSwitch
If($nbSides = 0) Then Return
If _Sleep($DELAYALGORITHM_ALLTROOPS2) Then Return
Local $GiantComp = $g_ahTxtTrainArmyTroopCount[$eTroopGiant]
If Number($GiantComp) > 16 Or(Number($GiantComp) >= 8 And $nbSides = 4) Then $g_iSlotsGiants = 2
If Number($GiantComp) > 20 Or(Number($GiantComp) >= 12 And $nbSides = 4) Then $g_iSlotsGiants = 0
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 4 Then
Switch $g_aiAttackStdDropOrder[$g_iMatchMode]
Case 0
If $g_bCustomDropOrderEnable Then
Local $listInfoDeploy[22][5] = [[MatchTroopDropName(0), MatchSidesDrop(0), MatchTroopWaveNb(0), 1, MatchSlotsPerEdge(0)], [MatchTroopDropName(1), MatchSidesDrop(1), MatchTroopWaveNb(1), 1, MatchSlotsPerEdge(1)], [MatchTroopDropName(2), MatchSidesDrop(2), MatchTroopWaveNb(2), 1, MatchSlotsPerEdge(2)], [MatchTroopDropName(3), MatchSidesDrop(3), MatchTroopWaveNb(3), 1, MatchSlotsPerEdge(3)], [MatchTroopDropName(4), MatchSidesDrop(4), MatchTroopWaveNb(4), 1, MatchSlotsPerEdge(4)], [MatchTroopDropName(5), MatchSidesDrop(5), MatchTroopWaveNb(5), 1, MatchSlotsPerEdge(5)], [MatchTroopDropName(6), MatchSidesDrop(6), MatchTroopWaveNb(6), 1, MatchSlotsPerEdge(6)], [MatchTroopDropName(7), MatchSidesDrop(7), MatchTroopWaveNb(7), 1, MatchSlotsPerEdge(7)], [MatchTroopDropName(8), MatchSidesDrop(8), MatchTroopWaveNb(8), 1, MatchSlotsPerEdge(8)], [MatchTroopDropName(9), MatchSidesDrop(9), MatchTroopWaveNb(9), 1, MatchSlotsPerEdge(9)], [MatchTroopDropName(10), MatchSidesDrop(10), MatchTroopWaveNb(10), 1, MatchSlotsPerEdge(10)], [MatchTroopDropName(11), MatchSidesDrop(11), MatchTroopWaveNb(11), 1, MatchSlotsPerEdge(11)], [MatchTroopDropName(12), MatchSidesDrop(12), MatchTroopWaveNb(12), 1, MatchSlotsPerEdge(12)], [MatchTroopDropName(13), MatchSidesDrop(13), MatchTroopWaveNb(13), 1, MatchSlotsPerEdge(13)], [MatchTroopDropName(14), MatchSidesDrop(14), MatchTroopWaveNb(14), 1, MatchSlotsPerEdge(14)], [MatchTroopDropName(15), MatchSidesDrop(15), MatchTroopWaveNb(15), 1, MatchSlotsPerEdge(15)], [MatchTroopDropName(16), MatchSidesDrop(16), MatchTroopWaveNb(16), 1, MatchSlotsPerEdge(16)], [MatchTroopDropName(17), MatchSidesDrop(17), MatchTroopWaveNb(17), 1, MatchSlotsPerEdge(17)], [MatchTroopDropName(18), MatchSidesDrop(18), MatchTroopWaveNb(18), 1, MatchSlotsPerEdge(18)], [MatchTroopDropName(19), MatchSidesDrop(19), MatchTroopWaveNb(19), 1, MatchSlotsPerEdge(19)], [MatchTroopDropName(20), MatchSidesDrop(20), MatchTroopWaveNb(20), 1, MatchSlotsPerEdge(20)], [MatchTroopDropName(21), MatchSidesDrop(21), MatchTroopWaveNb(21), 1, MatchSlotsPerEdge(21)]]
Else
Local $listInfoDeploy[22][5] = [[$eGole, $nbSides, 1, 1, 2] , [$eLava, $nbSides, 1, 1, 2] , [$eGiant, $nbSides, 1, 1, $g_iSlotsGiants] , [$eDrag, $nbSides, 1, 1, 0] , ["CC", 1, 1, 1, 1] , [$eBall, $nbSides, 1, 1, 0] , [$eBabyD, $nbSides, 1, 1, 1] , [$eHogs, $nbSides, 1, 1, 1] , [$eValk, $nbSides, 1, 1, 0] , [$eBowl, $nbSides, 1, 1, 0] , [$eMine, $nbSides, 1, 1, 0] , [$eEDrag, $nbSides, 1, 1, 0] , [$eBarb, $nbSides, 1, 1, 0] , [$eWall, $nbSides, 1, 1, 1] , [$eArch, $nbSides, 1, 1, 0] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eWitc, $nbSides, 1, 1, 1] , [$eGobl, $nbSides, 1, 1, 0] , [$eHeal, $nbSides, 1, 1, 1] , [$ePekk, $nbSides, 1, 1, 1] , ["HEROES", 1, 2, 1, 1] ]
EndIf
Case 1
Local $listInfoDeploy[6][5] = [[$eBarb, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 1, 1, 0] , [$eGobl, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , ["CC", 1, 1, 1, 1] , ["HEROES", 1, 2, 1, 1] ]
Case 2
Local $listInfoDeploy[13][5] = [[$eGiant, $nbSides, 1, 1, $g_iSlotsGiants] , ["CC", 1, 1, 1, 1] , [$eWall, $nbSides, 1, 1, 2] , [$eBarb, $nbSides, 1, 2, 2] , [$eArch, $nbSides, 1, 3, 3] , [$eBarb, $nbSides, 2, 2, 2] , [$eArch, $nbSides, 2, 3, 3] , ["HEROES", 1, 2, 1, 0] , [$eHogs, $nbSides, 1, 1, 1] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 3, 3, 2] , [$eGobl, $nbSides, 1, 1, 1] ]
EndSwitch
Else
If $g_bDebugSetlog Then SetDebugLog("listdeploy standard for attack", $COLOR_DEBUG)
Switch $g_aiAttackStdDropOrder[$g_iMatchMode]
Case 0
If $g_bCustomDropOrderEnable Then
Local $listInfoDeploy[22][5] = [[MatchTroopDropName(0), MatchSidesDrop(0), MatchTroopWaveNb(0), 1, MatchSlotsPerEdge(0)], [MatchTroopDropName(1), MatchSidesDrop(1), MatchTroopWaveNb(1), 1, MatchSlotsPerEdge(1)], [MatchTroopDropName(2), MatchSidesDrop(2), MatchTroopWaveNb(2), 1, MatchSlotsPerEdge(2)], [MatchTroopDropName(3), MatchSidesDrop(3), MatchTroopWaveNb(3), 1, MatchSlotsPerEdge(3)], [MatchTroopDropName(4), MatchSidesDrop(4), MatchTroopWaveNb(4), 1, MatchSlotsPerEdge(4)], [MatchTroopDropName(5), MatchSidesDrop(5), MatchTroopWaveNb(5), 1, MatchSlotsPerEdge(5)], [MatchTroopDropName(6), MatchSidesDrop(6), MatchTroopWaveNb(6), 1, MatchSlotsPerEdge(6)], [MatchTroopDropName(7), MatchSidesDrop(7), MatchTroopWaveNb(7), 1, MatchSlotsPerEdge(7)], [MatchTroopDropName(8), MatchSidesDrop(8), MatchTroopWaveNb(8), 1, MatchSlotsPerEdge(8)], [MatchTroopDropName(9), MatchSidesDrop(9), MatchTroopWaveNb(9), 1, MatchSlotsPerEdge(9)], [MatchTroopDropName(10), MatchSidesDrop(10), MatchTroopWaveNb(10), 1, MatchSlotsPerEdge(10)], [MatchTroopDropName(11), MatchSidesDrop(11), MatchTroopWaveNb(11), 1, MatchSlotsPerEdge(11)], [MatchTroopDropName(12), MatchSidesDrop(12), MatchTroopWaveNb(12), 1, MatchSlotsPerEdge(12)], [MatchTroopDropName(13), MatchSidesDrop(13), MatchTroopWaveNb(13), 1, MatchSlotsPerEdge(13)], [MatchTroopDropName(14), MatchSidesDrop(14), MatchTroopWaveNb(14), 1, MatchSlotsPerEdge(14)], [MatchTroopDropName(15), MatchSidesDrop(15), MatchTroopWaveNb(15), 1, MatchSlotsPerEdge(15)], [MatchTroopDropName(16), MatchSidesDrop(16), MatchTroopWaveNb(16), 1, MatchSlotsPerEdge(16)], [MatchTroopDropName(17), MatchSidesDrop(17), MatchTroopWaveNb(17), 1, MatchSlotsPerEdge(17)], [MatchTroopDropName(18), MatchSidesDrop(18), MatchTroopWaveNb(18), 1, MatchSlotsPerEdge(18)], [MatchTroopDropName(19), MatchSidesDrop(19), MatchTroopWaveNb(19), 1, MatchSlotsPerEdge(19)], [MatchTroopDropName(20), MatchSidesDrop(20), MatchTroopWaveNb(20), 1, MatchSlotsPerEdge(20)], [MatchTroopDropName(21), MatchSidesDrop(21), MatchTroopWaveNb(21), 1, MatchSlotsPerEdge(21)]]
Else
Local $listInfoDeploy[22][5] = [[$eGole, $nbSides, 1, 1, 2] , [$eLava, $nbSides, 1, 1, 2] , [$eGiant, $nbSides, 1, 1, $g_iSlotsGiants] , [$eDrag, $nbSides, 1, 1, 0] , ["CC", 1, 1, 1, 1] , [$eBall, $nbSides, 1, 1, 0] , [$eBabyD, $nbSides, 1, 1, 0] , [$eHogs, $nbSides, 1, 1, 1] , [$eValk, $nbSides, 1, 1, 0] , [$eBowl, $nbSides, 1, 1, 0] , [$eMine, $nbSides, 1, 1, 0] , [$eEDrag, $nbSides, 1, 1, 0] , [$eBarb, $nbSides, 1, 1, 0] , [$eWall, $nbSides, 1, 1, 1] , [$eArch, $nbSides, 1, 1, 0] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eWitc, $nbSides, 1, 1, 1] , [$eGobl, $nbSides, 1, 1, 0] , [$eHeal, $nbSides, 1, 1, 1] , [$ePekk, $nbSides, 1, 1, 1] , ["HEROES", 1, 2, 1, 1] ]
EndIf
Case 1
Local $listInfoDeploy[6][5] = [[$eBarb, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 1, 1, 0] , [$eGobl, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , ["CC", 1, 1, 1, 1] , ["HEROES", 1, 2, 1, 1] ]
Case 2
Local $listInfoDeploy[13][5] = [[$eGiant, $nbSides, 1, 1, $g_iSlotsGiants] , ["CC", 1, 1, 1, 1] , [$eBarb, $nbSides, 1, 2, 0] , [$eWall, $nbSides, 1, 1, 1] , [$eArch, $nbSides, 1, 2, 0] , [$eBarb, $nbSides, 2, 2, 0] , [$eGobl, $nbSides, 1, 2, 0] , [$eHogs, $nbSides, 1, 1, 1] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 2, 2, 0] , [$eGobl, $nbSides, 2, 2, 0] , ["HEROES", 1, 2, 1, 1] ]
Case Else
SetLog("Algorithm type unavailable, defaulting to regular", $COLOR_ERROR)
Local $listInfoDeploy[13][5] = [[$eGiant, $nbSides, 1, 1, $g_iSlotsGiants] , ["CC", 1, 1, 1, 1] , [$eBarb, $nbSides, 1, 2, 0] , [$eWall, $nbSides, 1, 1, 1] , [$eArch, $nbSides, 1, 2, 0] , [$eBarb, $nbSides, 2, 2, 0] , [$eGobl, $nbSides, 1, 2, 0] , [$eHogs, $nbSides, 1, 1, 1] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 2, 2, 0] , [$eGobl, $nbSides, 2, 2, 0] , ["HEROES", 1, 2, 1, 1] ]
EndSwitch
EndIf
$g_bIsCCDropped = False
$g_aiDeployCCPosition[0] = -1
$g_aiDeployCCPosition[1] = -1
$g_bIsHeroesDropped = False
$g_aiDeployHeroesPosition[0] = -1
$g_aiDeployHeroesPosition[1] = -1
LaunchTroop2($listInfoDeploy, $g_iClanCastleSlot, $g_iKingSlot, $g_iQueenSlot, $g_iWardenSlot)
CheckHeroesHealth()
If _Sleep($DELAYALGORITHM_ALLTROOPS4) Then Return
SetLog("Dropping left over troops", $COLOR_INFO)
For $x = 0 To 1
If PrepareAttack($g_iMatchMode, True) = 0 Then
If $g_bDebugSetlog Then SetDebugLog("No Wast time... exit, no troops usable left", $COLOR_DEBUG)
ExitLoop
EndIf
For $i = $eBarb To $eBowl
LaunchTroop($i, $nbSides, 0, 1)
If $g_iActivateQueen = 0 Or $g_iActivateKing = 0 Or $g_iActivateWarden = 0 Then CheckHeroesHealth()
If _Sleep($DELAYALGORITHM_ALLTROOPS5) Then Return
Next
Next
CheckHeroesHealth()
SetLog("Finished Attacking, waiting for the battle to end")
EndFunc
Func SetSlotSpecialTroops()
$g_iKingSlot = -1
$g_iQueenSlot = -1
$g_iClanCastleSlot = -1
$g_iWardenSlot = -1
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $eCastle Then
$g_iClanCastleSlot = $i
ElseIf $g_avAttackTroops[$i][0] = $eKing Then
$g_iKingSlot = $i
ElseIf $g_avAttackTroops[$i][0] = $eQueen Then
$g_iQueenSlot = $i
ElseIf $g_avAttackTroops[$i][0] = $eWarden Then
$g_iWardenSlot = $i
EndIf
Next
If $g_bDebugSetlog Then
SetDebugLog("SetSlotSpecialTroops() King Slot: " & $g_iKingSlot, $COLOR_DEBUG)
SetDebugLog("SetSlotSpecialTroops() Queen Slot: " & $g_iQueenSlot, $COLOR_DEBUG)
SetDebugLog("SetSlotSpecialTroops() Warden Slot: " & $g_iWardenSlot, $COLOR_DEBUG)
SetDebugLog("SetSlotSpecialTroops() Clan Castle Slot: " & $g_iClanCastleSlot, $COLOR_DEBUG)
EndIf
EndFunc
Func CloseBattle()
If IsAttackPage() Then
For $i = 1 To 30
If _ColorCheck(_GetPixelColor($aWonOneStar[0], $aWonOneStar[1], True), Hex($aWonOneStar[2], 6), $aWonOneStar[3]) = True Then ExitLoop
If _Sleep($DELAYALGORITHM_ALLTROOPS2) Then Return
Next
EndIf
If IsAttackPage() Then ClickP($aSurrenderButton, 1, 0, "#0030")
If _Sleep($DELAYALGORITHM_ALLTROOPS3) Then Return
If IsEndBattlePage() Then
ClickP($aConfirmSurrender, 1, 0, "#0031")
If _Sleep($DELAYALGORITHM_ALLTROOPS1) Then Return
EndIf
EndFunc
Func SmartAttackStrategy($imode)
If $g_iMatchMode <> $MA Then
If($g_abAttackStdSmartAttack[$imode]) Then
SetLog("Calculating Smart Attack Strategy", $COLOR_INFO)
Local $hTimer = __TimerInit()
_CaptureRegion2()
_GetRedArea()
SetLog("Calculated  (in " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds) :")
If($g_abAttackStdSmartNearCollectors[$imode][0] Or $g_abAttackStdSmartNearCollectors[$imode][1] Or $g_abAttackStdSmartNearCollectors[$imode][2]) Then
SetLog("Locating Mines, Collectors & Drills", $COLOR_INFO)
$hTimer = __TimerInit()
Global $g_aiPixelMine[0]
Global $g_aiPixelElixir[0]
Global $g_aiPixelDarkElixir[0]
Global $g_aiPixelNearCollector[0]
If $g_abAttackStdSmartNearCollectors[$imode][0] Then
$g_aiPixelMine = GetLocationMine()
If(IsArray($g_aiPixelMine)) Then
_ArrayAdd($g_aiPixelNearCollector, $g_aiPixelMine, 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
EndIf
EndIf
If $g_abAttackStdSmartNearCollectors[$imode][1] Then
$g_aiPixelElixir = GetLocationElixir()
If(IsArray($g_aiPixelElixir)) Then
_ArrayAdd($g_aiPixelNearCollector, $g_aiPixelElixir, 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
EndIf
EndIf
If $g_abAttackStdSmartNearCollectors[$imode][2] Then
$g_aiPixelDarkElixir = GetLocationDarkElixir()
If(IsArray($g_aiPixelDarkElixir)) Then
_ArrayAdd($g_aiPixelNearCollector, $g_aiPixelDarkElixir, 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
EndIf
EndIf
SetLog("Located  (in " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds) :")
SetLog("[" & UBound($g_aiPixelMine) & "] Gold Mines")
SetLog("[" & UBound($g_aiPixelElixir) & "] Elixir Collectors")
SetLog("[" & UBound($g_aiPixelDarkElixir) & "] Dark Elixir Drill/s")
$g_aiNbrOfDetectedMines[$imode] += UBound($g_aiPixelMine)
$g_aiNbrOfDetectedCollectors[$imode] += UBound($g_aiPixelElixir)
$g_aiNbrOfDetectedDrills[$imode] += UBound($g_aiPixelDarkElixir)
UpdateStats()
EndIf
EndIf
EndIf
EndFunc
Func Barch()
While 1
Local $iBarb = -1, $iArch = -1, $iCC = -1
Local $iKing = -1, $iQueen = -1, $iWarden = -1
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = "Barbarian" Then
$iBarb = $i
ElseIf $g_avAttackTroops[$i][0] = "Archer" Then
$iArch = $i
ElseIf $g_avAttackTroops[$i][0] = "Clan Castle" Then
$iCC = $i
ElseIf $g_avAttackTroops[$i][0] = "King" Then
$iKing = $i
ElseIf $g_avAttackTroops[$i][0] = "Queen" Then
$iQueen = $i
ElseIf $g_avAttackTroops[$i][0] = "Warden" Then
$iWarden = $i
EndIf
Next
If _Sleep($DELAYBARCH2) Then ExitLoop
Switch $g_aiAttackStdDropSides[$g_iMatchMode]
Case 0
SetLog("~Attacking from two sides...")
If _Sleep($DELAYBARCH3) Then ExitLoop
Local $numBarbPerSpot = Ceiling((($g_avAttackTroops[$iBarb][1] / 2) / 5) / 2)
Local $numArchPerSpot = Ceiling((($g_avAttackTroops[$iArch][1] / 2) / 5) / 2)
SetLog("Dropping first wave of Barbarians", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($iBarb, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0032")
If _Sleep($DELAYBARCH1) Then ExitLoop(2)
Click($g_aaiTopLeftDropPoints[$i][0], $g_aaiTopLeftDropPoints[$i][1], $numBarbPerSpot, 1, "#0033")
Click($g_aaiBottomRightDropPoints[$i][0], $g_aaiBottomRightDropPoints[$i][1], $numBarbPerSpot, 1, "#0034")
Next
If _Sleep($DELAYBARCH3) Then ExitLoop
SetLog("Dropping first wave of Archers", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($iArch, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0035")
If _Sleep($DELAYBARCH1) Then ExitLoop(2)
Click($g_aaiTopLeftDropPoints[$i][0], $g_aaiTopLeftDropPoints[$i][1], $numArchPerSpot, 1, "#0036")
Click($g_aaiBottomRightDropPoints[$i][0], $g_aaiBottomRightDropPoints[$i][1], $numArchPerSpot, 1, "#0037")
Next
If _Sleep(2000) Then ExitLoop
SetLog("Dropping second wave of Barbarians", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($iBarb, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0038")
If _Sleep($DELAYBARCH1) Then ExitLoop(2)
Click($g_aaiTopLeftDropPoints[$i][0], $g_aaiTopLeftDropPoints[$i][1], $numBarbPerSpot, 1, "#0039")
Click($g_aaiBottomRightDropPoints[$i][0], $g_aaiBottomRightDropPoints[$i][1], $numBarbPerSpot, 1, "#0040")
Next
If _Sleep($DELAYBARCH3) Then ExitLoop
SetLog("Dropping second wave of Archers", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($iArch, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0041")
If _Sleep($DELAYBARCH1) Then ExitLoop(2)
Click($g_aaiTopLeftDropPoints[$i][0], $g_aaiTopLeftDropPoints[$i][1], $numArchPerSpot, 1, "#0042")
Click($g_aaiBottomRightDropPoints[$i][0], $g_aaiBottomRightDropPoints[$i][1], $numArchPerSpot, 1, "#0043")
Next
dropHeroes($g_aaiTopLeftDropPoints[3][0], $g_aaiTopLeftDropPoints[3][1], $iKing, $iQueen, $iWarden)
If _Sleep($DELAYBARCH3) Then ExitLoop
dropCC($g_aaiTopLeftDropPoints[3][0], $g_aaiTopLeftDropPoints[3][1], $iCC)
Case 1
SetLog("~Attacking from three sides...")
If _Sleep($DELAYBARCH3) Then ExitLoop
Local $numBarbPerSpot = Ceiling((($g_avAttackTroops[$iBarb][1] / 3) / 5) / 2)
Local $numArchPerSpot = Ceiling((($g_avAttackTroops[$iArch][1] / 3) / 5) / 2)
SetLog("Dropping first wave of Barbarians", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($iBarb, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0044")
If _Sleep($DELAYBARCH1) Then ExitLoop(2)
Click($g_aaiTopLeftDropPoints[$i][0], $g_aaiTopLeftDropPoints[$i][1], $numBarbPerSpot, 1, "#0045")
Click($g_aaiTopRightDropPoints[$i][0], $g_aaiTopRightDropPoints[$i][1], $numBarbPerSpot, 1, "#0046")
Click($g_aaiBottomRightDropPoints[$i][0], $g_aaiBottomRightDropPoints[$i][1], $numBarbPerSpot, 1, "#0047")
Next
If _Sleep($DELAYBARCH3) Then ExitLoop
SetLog("Dropping first wave of Archers", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($iArch, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0048")
If _Sleep($DELAYBARCH1) Then ExitLoop(2)
Click($g_aaiTopLeftDropPoints[$i][0], $g_aaiTopLeftDropPoints[$i][1], $numArchPerSpot, 1, "#0049")
Click($g_aaiTopRightDropPoints[$i][0], $g_aaiTopRightDropPoints[$i][1], $numArchPerSpot, 1, "#0050")
Click($g_aaiBottomRightDropPoints[$i][0], $g_aaiBottomRightDropPoints[$i][1], $numArchPerSpot, 1, "#0051")
Next
If _Sleep(2000) Then ExitLoop
SetLog("Dropping second wave of Barbarians", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($iBarb, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0052")
If _Sleep($DELAYBARCH1) Then ExitLoop(2)
Click($g_aaiTopLeftDropPoints[$i][0], $g_aaiTopLeftDropPoints[$i][1], $numBarbPerSpot, 1, "#0053")
Click($g_aaiTopRightDropPoints[$i][0], $g_aaiTopRightDropPoints[$i][1], $numBarbPerSpot, 1, "#0054")
Click($g_aaiBottomRightDropPoints[$i][0], $g_aaiBottomRightDropPoints[$i][1], $numBarbPerSpot, 1, "#0055")
Next
If _Sleep($DELAYBARCH3) Then ExitLoop
SetLog("Dropping second wave of Archers", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($iArch, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0085")
If _Sleep($DELAYBARCH1) Then ExitLoop(2)
Click($g_aaiTopLeftDropPoints[$i][0], $g_aaiTopLeftDropPoints[$i][1], $numArchPerSpot, 1, "#0056")
Click($g_aaiTopRightDropPoints[$i][0], $g_aaiTopRightDropPoints[$i][1], $numArchPerSpot, 1, "#0057")
Click($g_aaiBottomRightDropPoints[$i][0], $g_aaiBottomRightDropPoints[$i][1], $numArchPerSpot, 1, "#0058")
Next
dropHeroes($g_aaiTopRightDropPoints[3][0], $g_aaiTopRightDropPoints[3][1], $iKing, $iQueen, $iWarden)
If _Sleep($DELAYBARCH3) Then ExitLoop
dropCC($g_aaiTopRightDropPoints[3][0], $g_aaiTopRightDropPoints[3][1], $iCC)
Case 2
SetLog("~Attacking from all sides...")
If _Sleep($DELAYBARCH3) Then ExitLoop
Local $numBarbPerSpot = Ceiling((($g_avAttackTroops[$iBarb][1] / 4) / 5) / 2)
Local $numArchPerSpot = Ceiling((($g_avAttackTroops[$iArch][1] / 4) / 5) / 2)
SetLog("Dropping first wave of Barbarians", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($iBarb, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0059")
If _Sleep($DELAYBARCH1) Then ExitLoop(2)
Click($g_aaiTopLeftDropPoints[$i][0], $g_aaiTopLeftDropPoints[$i][1], $numBarbPerSpot, 1, "#0060")
Click($g_aaiTopRightDropPoints[$i][0], $g_aaiTopRightDropPoints[$i][1], $numBarbPerSpot, 1, "#0061")
Click($g_aaiBottomLeftDropPoints[$i][0], $g_aaiBottomLeftDropPoints[$i][1], $numBarbPerSpot, 1, "#0062")
Click($g_aaiBottomRightDropPoints[$i][0], $g_aaiBottomRightDropPoints[$i][1], $numBarbPerSpot, 1, "#0063")
Next
If _Sleep($DELAYBARCH3) Then ExitLoop
SetLog("Dropping first wave of Archers", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($iArch, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0064")
If _Sleep($DELAYBARCH1) Then ExitLoop(2)
Click($g_aaiTopLeftDropPoints[$i][0], $g_aaiTopLeftDropPoints[$i][1], $numArchPerSpot, 1, "#0065")
Click($g_aaiTopRightDropPoints[$i][0], $g_aaiTopRightDropPoints[$i][1], $numArchPerSpot, 1, "#0066")
Click($g_aaiBottomLeftDropPoints[$i][0], $g_aaiBottomLeftDropPoints[$i][1], $numArchPerSpot, 1, "#0067")
Click($g_aaiBottomRightDropPoints[$i][0], $g_aaiBottomRightDropPoints[$i][1], $numArchPerSpot, 1, "#0068")
Next
If _Sleep(2000) Then ExitLoop
SetLog("Dropping second wave of Barbarians", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($iBarb, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0069")
If _Sleep($DELAYBARCH1) Then ExitLoop(2)
Click($g_aaiTopLeftDropPoints[$i][0], $g_aaiTopLeftDropPoints[$i][1], $numBarbPerSpot, 1, "#0070")
Click($g_aaiTopRightDropPoints[$i][0], $g_aaiTopRightDropPoints[$i][1], $numBarbPerSpot, 1, "#0071")
Click($g_aaiBottomLeftDropPoints[$i][0], $g_aaiBottomLeftDropPoints[$i][1], $numBarbPerSpot, 1, "#0072")
Click($g_aaiBottomRightDropPoints[$i][0], $g_aaiBottomRightDropPoints[$i][1], $numBarbPerSpot, 1, "#0073")
Next
If _Sleep($DELAYBARCH3) Then ExitLoop
SetLog("Dropping second wave of Archers", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($iArch, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0074")
If _Sleep($DELAYBARCH1) Then ExitLoop(2)
Click($g_aaiTopLeftDropPoints[$i][0], $g_aaiTopLeftDropPoints[$i][1], $numArchPerSpot, 1, "#0075")
Click($g_aaiTopRightDropPoints[$i][0], $g_aaiTopRightDropPoints[$i][1], $numArchPerSpot, 1, "#0076")
Click($g_aaiBottomLeftDropPoints[$i][0], $g_aaiBottomLeftDropPoints[$i][1], $numArchPerSpot, 1, "#0077")
Click($g_aaiBottomRightDropPoints[$i][0], $g_aaiBottomRightDropPoints[$i][1], $numArchPerSpot, 1, "#0078")
Next
dropHeroes($g_aaiBottomLeftDropPoints[3][0], $g_aaiBottomLeftDropPoints[3][1], $iKing, $iQueen, $iWarden)
If _Sleep($DELAYBARCH3) Then ExitLoop
dropCC($g_aaiBottomLeftDropPoints[3][0], $g_aaiBottomLeftDropPoints[3][1], $iCC)
EndSwitch
If _Sleep($DELAYBARCH1) Then ExitLoop
SetLog("Dropping left over troops", $COLOR_INFO)
$g_avAttackTroops[$iBarb][1] = Number(ReadTroopQuantity($iBarb))
$g_avAttackTroops[$iArch][1] = Number(ReadTroopQuantity($iArch))
While $g_avAttackTroops[$iBarb][1] <> 0
Click(GetXPosOfArmySlot($iBarb, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0079")
Click($g_aaiTopLeftDropPoints[3][0], $g_aaiTopLeftDropPoints[3][1], $g_avAttackTroops[$iBarb][1], 1, "#0080")
$g_avAttackTroops[$iBarb][1] = Number(ReadTroopQuantity($iBarb))
WEnd
If _Sleep($DELAYBARCH3) Then ExitLoop
While $g_avAttackTroops[$iArch][1] <> 0
Click(GetXPosOfArmySlot($iArch, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0081")
Click($g_aaiTopLeftDropPoints[3][0], $g_aaiTopLeftDropPoints[3][1], $g_avAttackTroops[$iArch][1], 1, "#0082")
$g_avAttackTroops[$iArch][1] = Number(ReadTroopQuantity($iArch))
WEnd
If _Sleep($DELAYBARCH1) Then ExitLoop
If $g_bCheckKingPower Or $g_bCheckQueenPower Then
Local $iWaitTime = 0
If Int($g_iDelayActivateKing) > Int($g_iDelayActivateQueen) Then
$iWaitTime = Int($g_iDelayActivateKing)
ElseIf Int($g_iDelayActivateQueen) > Int($g_iDelayActivateKing) Then
$iWaitTime = Int($g_iDelayActivateQueen)
EndIf
SetLog("Waiting " & $iWaitTime / 1000 & " seconds before activating Hero abilities", $COLOR_SUCCESS)
If _Sleep($iWaitTime) Then Return
If $g_bCheckKingPower Then
SetLog("Activate King's power", $COLOR_INFO)
Click(GetXPosOfArmySlot($iKing, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0083")
EndIf
If $g_bCheckQueenPower Then
SetLog("Activate Queen's power", $COLOR_INFO)
Click(GetXPosOfArmySlot($iQueen, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0084")
EndIf
EndIf
SetLog("~Finished Attacking, waiting to finish")
ExitLoop
WEnd
EndFunc
Func AttackTHGrid($troopKind, $iNbOfSpots = 1, $iAtEachSpot = 1, $Sleep = Random(800, 900, 1), $waveNb = 0)
Local $TroopCountBeg
Local $THtroop = -1
Local $troopNb = 0
Local $name = ""
Local $plural = 0
Local $waveName = "first"
Local $NumTroopDeployed = 0
If _Sleep(5) Then Return
If $g_bRestart = True Then Return
If CheckOneStar(0, False, True) Then Return
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $troopKind Then
$THtroop = $i
EndIf
Next
If($THtroop = -1) And $g_bDebugSetlog Then SetLog("No " & $name & " Found!!!")
If($THtroop = -1) Then Return False
If $troopKind >= $eKing And $troopKind <= $eCastle Then
$iNbOfSpots = 1
$iAtEachSpot = 1
$troopNb = 1
If $troopKind = $eKing Then
If $g_bDuringMilkingAttack = False And BitAND($g_aiAttackUseHeroes[$TS], $eHeroKing) <> $eHeroKing Then Return
If $g_bDuringMilkingAttack = True And BitAND($g_aiAttackUseHeroes[$DB], $eHeroKing) <> $eHeroKing Then Return
$g_bCheckKingPower = True
SetLog("Dropping King", $COLOR_SUCCESS)
$g_bTHSnipeUsedKing = True
EndIf
If $troopKind = $eQueen Then
If $g_bDuringMilkingAttack = False And BitAND($g_aiAttackUseHeroes[$TS], $eHeroQueen) <> $eHeroQueen Then Return
If $g_bDuringMilkingAttack = True And BitAND($g_aiAttackUseHeroes[$DB], $eHeroQueen) <> $eHeroQueen Then Return
$g_bCheckQueenPower = True
SetLog("Dropping Queen", $COLOR_SUCCESS)
$g_bTHSnipeUsedQueen = True
EndIf
If $troopKind = $eWarden Then
If $g_bDuringMilkingAttack = False And BitAND($g_aiAttackUseHeroes[$TS], $eHeroWarden) <> $eHeroWarden Then Return
If $g_bDuringMilkingAttack = True And BitAND($g_aiAttackUseHeroes[$DB], $eHeroWarden) <> $eHeroWarden Then Return
$g_bCheckWardenPower = True
SetLog("Dropping Grand Warden", $COLOR_SUCCESS)
$g_bTHSnipeUsedWarden = True
EndIf
If $troopKind = $eCastle Then
If $g_bDuringMilkingAttack = False And $g_abAttackDropCC[$TS] Then Return
If $g_bDuringMilkingAttack = True And $g_abAttackDropCC[$DB] Then Return
If $g_bPlannedDropCCHoursEnable = True Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abPlannedDropCCHours[$hour[0]] = False Then
SetLog("Drop Clan Castle not Planned, Skipped..", $COLOR_SUCCESS)
Return
EndIf
EndIf
If $g_bUseCCBalanced = True Then
If Number($g_iTroopsReceived) <> 0 Then
If Number(Number($g_iTroopsDonated) / Number($g_iTroopsReceived)) >=(Number($g_iCCDonated) / Number($g_iCCReceived)) Then
SetLog("Dropping Clan Castle, donated (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") >= " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
Else
SetLog("Not Dropping Clan Castle, donated  (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") < " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
Return
EndIf
Else
If Number(Number($g_iTroopsDonated) / 1) >=(Number($g_iCCDonated) / Number($g_iCCReceived)) Then
SetLog("Dropping Clan Castle, donated (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") >= " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
Else
SetLog("Not Dropping Clan Castle, donated  (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") < " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
Return
EndIf
EndIf
EndIf
EndIf
EndIf
If $troopKind >= $eBarb And $troopKind <= $eBowl Then
$troopNb = $iNbOfSpots * $iAtEachSpot
If $troopNb > 1 Then $plural = 1
$name = NameOfTroop($troopKind, $plural)
$TroopCountBeg = Number(ReadTroopQuantity($THtroop))
If($TroopCountBeg = 0) And $g_bDebugSetlog Then SetLog("No " & $name & " Remaining!!!")
If($TroopCountBeg = 0) Then Return False
If $waveNb = 0 Then $waveName = "Only"
If $waveNb = 1 Then $waveName = "First"
If $waveNb = 2 Then $waveName = "Second"
If $waveNb = 3 Then $waveName = "Third"
If $waveNb = 4 Then $waveName = "Last"
SetLog("Dropping " & $waveName & " wave of " & $troopNb & " " & $name, $COLOR_SUCCESS)
EndIf
SelectDropTroop($THtroop)
If _Sleep($DELAYCASTSPELL1) Then Return
DeployTHNormal($iAtEachSpot, $iNbOfSpots)
If $troopKind >= $eBarb And $troopKind <= $eBowl Then
If $TroopCountBeg <> Number(ReadTroopQuantity($THtroop)) Then
$NumTroopDeployed = $TroopCountBeg - Number(ReadTroopQuantity($THtroop))
SetLog("Deployment of " & $NumTroopDeployed & " " & $name & " was Successful!")
If _Sleep($Sleep) Then Return
Else
SetLog("Deployment of " & $name & " wasn't Successful!")
EndIf
EndIf
If $troopKind >= $eKing And $troopKind <= $eCastle Then
SelectDropTroop(0)
If _Sleep($Sleep) Then Return
EndIf
EndFunc
Func DeployTHNormal($iAtEachSpot, $iNbOfSpots)
Local $aThx = 0, $aThy = 0
Switch $g_iTHside
Case 0
For $num = 0 To $iAtEachSpot - 1
For $i = $g_iTHi - 1 To $g_iTHi - 1 + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 25 - $i * 16
$aThy = 314 + $i * 12
Next
For $ii = $g_iTHi - 1 To $g_iTHi - 1 +($iNbOfSpots - 1)
$aThx = 25 + $ii * 16
$aThy = 314 - $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0019")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
Case 1
For $num = 0 To $iAtEachSpot - 1
For $i = $g_iTHi To $g_iTHi + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 25 - $i * 16
$aThy = 314 - $i * 12
Next
For $ii = $g_iTHi To $g_iTHi +($iNbOfSpots - 1)
$aThx = 25 + $ii * 16
$aThy = 314 + $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0020")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
Case 2
For $num = 0 To $iAtEachSpot - 1
For $i = $g_iTHi To $g_iTHi + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 830 + $i * 16
$aThy = 314 + $i * 12
Next
For $ii = $g_iTHi To $g_iTHi +($iNbOfSpots - 1)
$aThx = 830 - $ii * 16
$aThy = 314 - $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0021")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
Case 3
For $num = 0 To $iAtEachSpot - 1
For $i = $g_iTHi + 1 To $g_iTHi + 1 + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 830 + $i * 16
$aThy = 314 - $i * 12
Next
For $ii = $g_iTHi + 1 To $g_iTHi + 1 +($iNbOfSpots - 1)
$aThx = 830 - $ii * 16
$aThy = 314 + $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0022")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
EndSwitch
EndFunc
Func SpellTHGrid($S)
If $g_bDuringMilkingAttack = False And(($S = $eHSpell And $g_abAttackUseHealSpell[$TS]) Or($S = $eLSpell And $g_abAttackUseLightSpell[$TS]) Or($S = $eRSpell And $g_abAttackUseRageSpell[$TS]) Or($S = $eJSpell And $g_abAttackUseJumpSpell[$TS]) Or($S = $eFSpell And $g_abAttackUseFreezeSpell[$TS]) Or($S = $ePSpell And $g_abAttackUsePoisonSpell[$TS]) Or($S = $eHaSpell And $g_abAttackUseHasteSpell[$TS]) Or($S = $eESpell And $g_abAttackUseEarthquakeSpell[$TS])) Or $g_bDuringMilkingAttack = True And(($S = $eHSpell And $g_abAttackUseHealSpell[$DB]) Or($S = $eLSpell And $g_abAttackUseLightSpell[$DB]) Or($S = $eRSpell And $g_abAttackUseRageSpell[$DB]) Or($S = $eJSpell And $g_abAttackUseJumpSpell[$DB]) Or($S = $eFSpell And $g_abAttackUseFreezeSpell[$DB]) Or($S = $ePSpell And $g_abAttackUsePoisonSpell[$DB]) Or($S = $eHaSpell And $g_abAttackUseHasteSpell[$DB]) Or($S = $eESpell And $g_abAttackUseEarthquakeSpell[$DB])) Then
If _Sleep(10) Then Return
If $g_bRestart = True Then Return
If CheckOneStar(0, False, True) Then Return
If $g_iTHi <= 15 Or $g_iTHside = 0 Or $g_iTHside = 2 Then
Switch $g_iTHside
Case 0
CastSpell($S, 114 + $g_iTHi * 16 + Ceiling(-2 * 16), 359 - $g_iTHi * 12 + Ceiling(-2 * 12))
Case 1
CastSpell($S, 117 + $g_iTHi * 16 + Ceiling(-2 * 16), 268 + $g_iTHi * 12 - Floor(-2 * 12))
Case 2
CastSpell($S, 743 - $g_iTHi * 16 - Floor(-2 * 16), 358 - $g_iTHi * 12 + Ceiling(-2 * 12))
Case 3
CastSpell($S, 742 - $g_iTHi * 16 - Floor(-2 * 16), 268 + $g_iTHi * 12 - Floor(-2 * 12))
EndSwitch
EndIf
If $g_iTHi > 15 And($g_iTHside = 1 Or $g_iTHside = 3) Then
CastSpell($S, $g_iTHx, $g_iTHy)
EndIf
EndIf
EndFunc
Func CastSpell($THSpell, $x, $y)
Local $Spell = -1
Local $name = ""
If _Sleep(10) Then Return
If $g_bRestart = True Then Return
If CheckOneStar(0, False, True) Then Return
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $THSpell Then
$Spell = $i
$name = NameOfTroop($THSpell, 0)
EndIf
Next
If $Spell > -1 Then
SetLog("Dropping " & $name)
SelectDropTroop($Spell)
If _Sleep($DELAYATTCKTHGRID1) Then Return
If IsAttackPage() Then Click($x, $y, 1, 0, "#0029")
Else
If $g_bDebugSetlog Then SetDebugLog("No " & $name & " Found")
EndIf
EndFunc
Func CheckOneStar($DelayInSec = 0, $Log = True, $CheckHeroes = True)
For $i = 0 To $DelayInSec
If _Sleep(5) Then Return True
If $g_bRestart = True Then Return True
If $CheckHeroes = True And($g_bCheckQueenPower = True Or $g_bCheckKingPower = True) Then CheckHeroesHealth()
If _ColorCheck(_GetPixelColor($aWonOneStar[0], $aWonOneStar[1], True), Hex($aWonOneStar[2], 6), $aWonOneStar[3]) Then
If $Log = True Then SetLog("Townhall has been destroyed!", $COLOR_ACTION)
If $g_bRestart = True Then Return True
If $g_bCheckQueenPower = True Then
SetLog("Activating Queen's power to restore some health before EndBattle", $COLOR_INFO)
SelectDropTroop($g_iQueenSlot)
$g_bCheckQueenPower = False
EndIf
If _Sleep(500) Then Return True
If $g_bRestart = True Then Return True
If $g_bCheckKingPower = True Then
SetLog("Activating King's power to restore some health before EndBattle", $COLOR_INFO)
SelectDropTroop($g_iKingSlot)
$g_bCheckKingPower = False
EndIf
If $Log = True Then
If _Sleep(1000) Then Return
EndIf
Return True
Else
If $i <> 0 Then
If _Sleep(1000) Then Return True
If $g_bRestart = True Then Return True
EndIf
EndIf
Next
Return False
EndFunc
Func SwitchAttackTHType()
$g_bTHSnipeUsedKing = False
$g_bTHSnipeUsedQueen = False
AttackTHParseCSV()
EndFunc
Func AttackTHParseCSV($test = False)
If $g_bDebugSetlog Then SetDebugLog("AttackTHParseCSV start", $COLOR_DEBUG)
Local $f, $line, $acommand, $command
Local $attackCSVtoUse = ""
Switch $g_iMatchMode
Case $TS
$attackCSVtoUse = $g_sAtkTSType
Case $LB
$attackCSVtoUse = $g_iTHSnipeBeforeScript[$LB]
Case $DB
If $g_bDuringMilkingAttack = True Then
$attackCSVtoUse = $g_sMilkFarmAlgorithmTh
Else
$attackCSVtoUse = $g_iTHSnipeBeforeScript[$DB]
EndIf
EndSwitch
If FileExists($g_sTHSnipeAttacksPath & "\" & $attackCSVtoUse & ".csv") Then
$f = FileOpen($g_sTHSnipeAttacksPath & "\" & $attackCSVtoUse & ".csv", 0)
If $g_bDebugSetlog Then SetDebugLog("Use algorithm " & $attackCSVtoUse & ".csv", $COLOR_DEBUG)
While 1
$line = FileReadLine($f)
If @error = -1 Then ExitLoop
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), 2)
Select
Case $command = "TROOP" Or $command = ""
Case $command = "TEXT"
If $g_bDebugSetlog Then SetDebugLog(">> SETLOG(""" & $acommand[8] & """)")
SetLog($acommand[8], $COLOR_INFO)
Case StringInStr(StringUpper("-Barb-Arch-Giant-Gobl-Wall-Ball-Wiza-Heal-Drag-Pekk-BabyD-Mine-EDrag-Mini-Hogs-Valk-Gole-Witc-Lava-Bowl"), "-" & $command & "-") > 0
If $g_bDebugSetlog Then SetDebugLog(">> AttackTHGrid($e" & $command & ", Random (" & Int($acommand[2]) & "," & Int($acommand[3]) & ",1), Random(" & Int($acommand[4]) & "," & Int($acommand[5]) & ",1), Random(" & Int($acommand[6]) & "," & Int($acommand[7]) & ",1) )")
Local $iNbOfSpots
If Int($acommand[2]) = Int($acommand[3]) Then
$iNbOfSpots = Int($acommand[2])
Else
$iNbOfSpots = Random(Int($acommand[2]), Int($acommand[3]), 1)
EndIf
Local $iAtEachSpot
If Int($acommand[4]) = Int($acommand[5]) Then
$iAtEachSpot = Int($acommand[4])
Else
$iAtEachSpot = Random(Int($acommand[4]), Int($acommand[5]), 1)
EndIf
Local $Sleep
If Int($acommand[6]) = Int($acommand[7]) Then
$Sleep = Int($acommand[6])
Else
$Sleep = Random(Int($acommand[6]), Int($acommand[7]), 1)
EndIf
AttackTHGrid(Eval("e" & $command), $iNbOfSpots, $iAtEachSpot, $Sleep, 0)
Case $command = "WAIT"
If $g_bDebugSetlog Then SetDebugLog(">> GoldElixirChangeThSnipes(" & Int($acommand[7]) & ") ")
If CheckOneStar(Int($acommand[7]) / 2000) Then ExitLoop
If GoldElixirChangeThSnipes(Int($acommand[7]) / 2000) Then ExitLoop
Case StringInStr(StringUpper("-King-Queen-Castle-"), "-" & $command & "-") > 0
If $g_bDebugSetlog Then SetDebugLog(">> AttackTHGrid($e" & $command & ")")
AttackTHGrid(Eval("e" & $command))
Case StringInStr(StringUpper("-HSpell-RSpell-LSpell-JSpell-FSpell-PSpell-ESpell-HaSpell"), "-" & $command & "-") > 0
If $g_bDebugSetlog Then SetDebugLog(">> SpellTHGrid($e" & $command & ")")
SpellTHGrid(Eval("e" & $command))
Case StringInStr(StringUpper("-LSpell-"), "-" & $command & "-") > 0
If $g_bDebugSetlog Then SetDebugLog(">> CastSpell($e" & $command & ",$g_iTHx, $g_iTHy)")
CastSpell(Eval("e" & $command), $g_iTHx, $g_iTHy)
Case Else
SetLog("attack row bad, discard: " & $line, $COLOR_ERROR)
EndSelect
If $acommand[8] <> "" And $command <> "TEXT" And $command <> "TROOP" Then
If $g_bDebugSetlog Then SetDebugLog(">> SETLOG(""" & $acommand[8] & """)")
SETLOG($acommand[8], $COLOR_INFO)
EndIf
Else
If StringStripWS($acommand[1], 2) <> "" Then SetLog("attack row error, discard: " & $line, $COLOR_ERROR)
EndIf
If $g_bDebugSetlog Then SetDebugLog(">> CheckOneStar()")
If CheckOneStar() Then ExitLoop
WEnd
FileClose($f)
Else
SetLog("Cannot found THSnipe attack file " & $g_sTHSnipeAttacksPath & "\" & $attackCSVtoUse & ".csv", $COLOR_ERROR)
EndIf
EndFunc
Global $MAINSIDE = "BOTTOM-RIGHT"
Global $FRONT_LEFT = "BOTTOM-RIGHT-DOWN"
Global $FRONT_RIGHT = "BOTTOM-RIGHT-UP"
Global $RIGHT_FRONT = "TOP-RIGHT-DOWN"
Global $RIGHT_BACK = "TOP-RIGHT-UP"
Global $LEFT_FRONT = "BOTTOM-LEFT-DOWN"
Global $LEFT_BACK = "BOTTOM-LEFT-UP"
Global $BACK_LEFT = "TOP-LEFT-DOWN"
Global $BACK_RIGHT = "TOP-LEFT-UP"
Global $g_aiPixelTopLeftDropLine
Global $g_aiPixelTopRightDropLine
Global $g_aiPixelBottomLeftDropLine
Global $g_aiPixelBottomRightDropLine
Global $g_aiPixelTopLeftUPDropLine
Global $g_aiPixelTopLeftDOWNDropLine
Global $g_aiPixelTopRightUPDropLine
Global $g_aiPixelTopRightDOWNDropLine
Global $g_aiPixelBottomLeftUPDropLine
Global $g_aiPixelBottomLeftDOWNDropLine
Global $g_aiPixelBottomRightUPDropLine
Global $g_aiPixelBottomRightDOWNDropLine
Local $DeployableLRTB = [0, $g_iGAME_WIDTH - 1, 0, 626]
Local $DiamandAdjX = -28
Local $DiamandAdjY = -24
Local $OuterDiamondLeft = -18 - $DiamandAdjX, $OuterDiamondRight = 857 + $DiamandAdjX, $OuterDiamondTop = 20 - $DiamandAdjY, $OuterDiamondBottom = 679 + $DiamandAdjY
Local $DiamondMiddleX =($OuterDiamondLeft + $OuterDiamondRight) / 2
Local $DiamondMiddleY =($OuterDiamondTop + $OuterDiamondBottom) / 2
Local $InnerDiamandDiffX = 55 + $DiamandAdjX
Local $InnerDiamandDiffY = 47 + $DiamandAdjY
Local $InnerDiamondLeft = $OuterDiamondLeft + $InnerDiamandDiffX, $InnerDiamondRight = $OuterDiamondRight - $InnerDiamandDiffX, $InnerDiamondTop = $OuterDiamondTop + $InnerDiamandDiffY, $InnerDiamondBottom = $OuterDiamondBottom - $InnerDiamandDiffY
Global $CocDiamondECD = "ECD"
Global $ExternalArea[8][3]
Global $ExternalAreaRef[8][3] = [ [$OuterDiamondLeft, $DiamondMiddleY, "LEFT"], [$OuterDiamondRight, $DiamondMiddleY, "RIGHT"], [$DiamondMiddleX, $OuterDiamondTop, "TOP"], [$DiamondMiddleX, $OuterDiamondBottom, "BOTTOM"], [$OuterDiamondLeft +($DiamondMiddleX - $OuterDiamondLeft) / 2, $OuterDiamondTop +($DiamondMiddleY - $OuterDiamondTop) / 2, "TOP-LEFT"], [$DiamondMiddleX +($OuterDiamondRight - $DiamondMiddleX) / 2, $OuterDiamondTop +($DiamondMiddleY - $OuterDiamondTop) / 2, "TOP-RIGHT"], [$OuterDiamondLeft +($DiamondMiddleX - $OuterDiamondLeft) / 2, $DiamondMiddleY +($OuterDiamondBottom - $DiamondMiddleY) / 2, "BOTTOM-LEFT"], [$DiamondMiddleX +($OuterDiamondRight - $DiamondMiddleX) / 2, $DiamondMiddleY +($OuterDiamondBottom - $DiamondMiddleY) / 2, "BOTTOM-RIGHT"] ]
Global $CocDiamondDCD = "DCD"
Global $InternalArea[8][3]
Global $InternalAreaRef[8][3] = [ [$InnerDiamondLeft, $DiamondMiddleY, "LEFT"], [$InnerDiamondRight, $DiamondMiddleY, "RIGHT"], [$DiamondMiddleX, $InnerDiamondTop, "TOP"], [$DiamondMiddleX, $InnerDiamondBottom, "BOTTOM"], [$InnerDiamondLeft +($DiamondMiddleX - $InnerDiamondLeft) / 2, $InnerDiamondTop +($DiamondMiddleY - $InnerDiamondTop) / 2, "TOP-LEFT"], [$DiamondMiddleX +($InnerDiamondRight - $DiamondMiddleX) / 2, $InnerDiamondTop +($DiamondMiddleY - $InnerDiamondTop) / 2, "TOP-RIGHT"], [$InnerDiamondLeft +($DiamondMiddleX - $InnerDiamondLeft) / 2, $DiamondMiddleY +($InnerDiamondBottom - $DiamondMiddleY) / 2, "BOTTOM-LEFT"], [$DiamondMiddleX +($InnerDiamondRight - $DiamondMiddleX) / 2, $DiamondMiddleY +($InnerDiamondBottom - $DiamondMiddleY) / 2, "BOTTOM-RIGHT"] ]
ConvertInternalExternArea()
Func ConvertInternalExternArea()
Local $x, $y
For $i = 0 To 7
$x = $ExternalAreaRef[$i][0]
$y = $ExternalAreaRef[$i][1]
ConvertToVillagePos($x, $y)
$ExternalArea[$i][0] = $x
$ExternalArea[$i][1] = $y
$ExternalArea[$i][2] = $ExternalAreaRef[$i][2]
Next
$x = $ExternalAreaRef[2][0]
$y = $ExternalAreaRef[2][1] + $DiamandAdjY
ConvertToVillagePos($x, $y)
$CocDiamondECD = $x & "," & $y
$x = $ExternalAreaRef[1][0] - $DiamandAdjX
$y = $ExternalAreaRef[1][1]
ConvertToVillagePos($x, $y)
$CocDiamondECD &= "|" & $x & "," & $y
$x = $ExternalAreaRef[3][0]
$y = $ExternalAreaRef[3][1] - $DiamandAdjY
ConvertToVillagePos($x, $y)
$CocDiamondECD &= "|" & $x & "," & $y
$x = $ExternalAreaRef[0][0] + $DiamandAdjX
$y = $ExternalAreaRef[0][1]
ConvertToVillagePos($x, $y)
$CocDiamondECD &= "|" & $x & "," & $y
For $i = 0 To 7
$x = $InternalAreaRef[$i][0]
$y = $InternalAreaRef[$i][1]
ConvertToVillagePos($x, $y)
$InternalArea[$i][0] = $x
$InternalArea[$i][1] = $y
$InternalArea[$i][2] = $InternalAreaRef[$i][2]
Next
$CocDiamondDCD = $InternalArea[2][0] & "," & $InternalArea[2][1] & "|" & $InternalArea[1][0] & "," & $InternalArea[1][1] & "|" & $InternalArea[3][0] & "," & $InternalArea[3][1] & "|" & $InternalArea[0][0] & "," & $InternalArea[0][1]
EndFunc
Func CheckAttackLocation(ByRef $x, ByRef $y)
If $y > $DeployableLRTB[3] Then
$y = $DeployableLRTB[3]
Return False
EndIf
Return True
EndFunc
Func GetMinPoint($PointList, $Dim)
Local $Result = [9999, 9999]
For $i = 0 To UBound($PointList) - 1
Local $Point = $PointList[$i]
If $Point[$Dim] < $Result[$Dim] Then $Result = $Point
Next
Return $Result
EndFunc
Func GetMaxPoint($PointList, $Dim)
Local $Result = [-9999, -9999]
For $i = 0 To UBound($PointList) - 1
Local $Point = $PointList[$i]
If $Point[$Dim] > $Result[$Dim] Then $Result = $Point
Next
Return $Result
EndFunc
Func Algorithm_AttackCSV($testattack = False, $captureredarea = True)
Local $g_aiPixelNearCollectorTopLeft[0]
Local $g_aiPixelNearCollectorBottomLeft[0]
Local $g_aiPixelNearCollectorTopRight[0]
Local $g_aiPixelNearCollectorBottomRight[0]
Local $aResult
ParseAttackCSV_Read_SIDE_variables()
$g_iCSVLastTroopPositionDropTroopFromINI = -1
If _Sleep($DELAYRESPOND) Then Return
debugAttackCSV("Troops to be used (purged from troops) ")
For $i = 0 To UBound($g_avAttackTroops) - 1
debugAttackCSV("SLOT n.: " & $i & " - Troop: " & NameOfTroop($g_avAttackTroops[$i][0]) & " (" & $g_avAttackTroops[$i][0] & ") - Quantity: " & $g_avAttackTroops[$i][1])
Next
Local $hTimerTOTAL = __timerinit()
Local $hTimer = __timerinit()
SetDebugLog("Redline mode: " & $g_aiAttackScrRedlineRoutine[$g_iMatchMode])
SetDebugLog("Dropline mode: " & $g_aiAttackScrDroplineEdge[$g_iMatchMode])
_CaptureRegion2()
If $captureredarea Then _GetRedArea($g_aiAttackScrRedlineRoutine[$g_iMatchMode])
If _Sleep($DELAYRESPOND) Then Return
Local $htimerREDAREA = Round(__timerdiff($hTimer) / 1000, 2)
debugAttackCSV("Calculated  (in " & $htimerREDAREA & " seconds) :")
debugAttackCSV("	[" & UBound($g_aiPixelTopLeft) & "] pixels TopLeft")
debugAttackCSV("	[" & UBound($g_aiPixelTopRight) & "] pixels TopRight")
debugAttackCSV("	[" & UBound($g_aiPixelBottomLeft) & "] pixels BottomLeft")
debugAttackCSV("	[" & UBound($g_aiPixelBottomRight) & "] pixels BottomRight")
If $g_aiAttackScrDroplineEdge[$g_iMatchMode] = $DROPLINE_DROPPOINTS_ONLY Then
$g_aiPixelTopLeftDropLine = $g_aiPixelTopLeft
$g_aiPixelTopRightDropLine = $g_aiPixelTopRight
$g_aiPixelBottomLeftDropLine = $g_aiPixelBottomLeft
$g_aiPixelBottomRightDropLine = $g_aiPixelBottomRight
Else
Local $coordLeft = [$ExternalArea[0][0], $ExternalArea[0][1]]
Local $coordTop = [$ExternalArea[2][0], $ExternalArea[2][1]]
Local $coordRight = [$ExternalArea[1][0], $ExternalArea[1][1]]
Local $coordBottom = [$ExternalArea[3][0], $ExternalArea[3][1]]
Local $StartEndTopLeft = [$coordLeft, $coordTop]
If UBound($g_aiPixelTopLeft) > 2 Then Local $StartEndTopLeft = [$g_aiPixelTopLeft[0], $g_aiPixelTopLeft[UBound($g_aiPixelTopLeft) - 1]]
Local $StartEndTopRight = [$coordTop, $coordRight]
If UBound($g_aiPixelTopRight) > 2 Then Local $StartEndTopRight = [$g_aiPixelTopRight[0], $g_aiPixelTopRight[UBound($g_aiPixelTopRight) - 1]]
Local $StartEndBottomLeft = [$coordLeft, $coordBottom]
If UBound($g_aiPixelBottomLeft) > 2 Then Local $StartEndBottomLeft = [$g_aiPixelBottomLeft[0], $g_aiPixelBottomLeft[UBound($g_aiPixelBottomLeft) - 1]]
Local $StartEndBottomRight = [$coordBottom, $coordRight]
If UBound($g_aiPixelBottomRight) > 2 Then Local $StartEndBottomRight = [$g_aiPixelBottomRight[0], $g_aiPixelBottomRight[UBound($g_aiPixelBottomRight) - 1]]
Switch $g_aiAttackScrDroplineEdge[$g_iMatchMode]
Case $DROPLINE_EDGE_FIXED, $DROPLINE_FULL_EDGE_FIXED
Local $StartEndTopLeft = [$coordLeft, $coordTop]
Local $StartEndTopRight = [$coordTop, $coordRight]
Local $StartEndBottomLeft = [$coordLeft, $coordBottom]
Local $StartEndBottomRight = [$coordBottom, $coordRight]
EndSwitch
SetDebugLog("MakeDropLines, StartEndTopLeft     = " & PixelArrayToString($StartEndTopLeft, ","))
SetDebugLog("MakeDropLines, StartEndTopRight    = " & PixelArrayToString($StartEndTopRight, ","))
SetDebugLog("MakeDropLines, StartEndBottomLeft  = " & PixelArrayToString($StartEndBottomLeft, ","))
SetDebugLog("MakeDropLines, StartEndBottomRight = " & PixelArrayToString($StartEndBottomRight, ","))
Switch $g_aiAttackScrDroplineEdge[$g_iMatchMode]
Case $DROPLINE_EDGE_FIXED, $DROPLINE_EDGE_FIRST
$g_aiPixelTopLeftDropLine = MakeDropLineOriginal($g_aiPixelTopLeft, $StartEndTopLeft[0], $StartEndTopLeft[1])
$g_aiPixelTopRightDropLine = MakeDropLineOriginal($g_aiPixelTopRight, $StartEndTopRight[0], $StartEndTopRight[1])
$g_aiPixelBottomLeftDropLine = MakeDropLineOriginal($g_aiPixelBottomLeft, $StartEndBottomLeft[0], $StartEndBottomLeft[1])
$g_aiPixelBottomRightDropLine = MakeDropLineOriginal($g_aiPixelBottomRight, $StartEndBottomRight[0], $StartEndBottomRight[1])
Case $DROPLINE_FULL_EDGE_FIXED, $DROPLINE_FULL_EDGE_FIRST
Local $iLineDistanceThreshold = 75
If $g_aiAttackScrRedlineRoutine[$g_iMatchMode] = $REDLINE_IMGLOC Then $iLineDistanceThreshold = 25
$g_aiPixelTopLeftDropLine = MakeDropLine($g_aiPixelTopLeft, $StartEndTopLeft[0], $StartEndTopLeft[1], $iLineDistanceThreshold, $g_aiAttackScrDroplineEdge[$g_iMatchMode] = $DROPLINE_FULL_EDGE_FIXED)
$g_aiPixelTopRightDropLine = MakeDropLine($g_aiPixelTopRight, $StartEndTopRight[0], $StartEndTopRight[1], $iLineDistanceThreshold, $g_aiAttackScrDroplineEdge[$g_iMatchMode] = $DROPLINE_FULL_EDGE_FIXED)
$g_aiPixelBottomLeftDropLine = MakeDropLine($g_aiPixelBottomLeft, $StartEndBottomLeft[0], $StartEndBottomLeft[1], $iLineDistanceThreshold, $g_aiAttackScrDroplineEdge[$g_iMatchMode] = $DROPLINE_FULL_EDGE_FIXED)
$g_aiPixelBottomRightDropLine = MakeDropLine($g_aiPixelBottomRight, $StartEndBottomRight[0], $StartEndBottomRight[1], $iLineDistanceThreshold, $g_aiAttackScrDroplineEdge[$g_iMatchMode] = $DROPLINE_FULL_EDGE_FIXED)
EndSwitch
EndIf
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($g_aiPixelTopLeftDropLine) - 1
Local $pixel = $g_aiPixelTopLeftDropLine[$i]
Local $slice = Slice8($pixel)
Switch StringLeft($slice, 1)
Case "6"
$tempvectstr1 &= $pixel[0] & "," & $pixel[1] & "|"
Case "5"
$tempvectstr2 &= $pixel[0] & "," & $pixel[1] & "|"
Case Else
SetDebugLog("TOP LEFT: Skip slice " & $slice & " at " & $pixel[0] & ", " & $pixel[1])
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$g_aiPixelTopLeftDOWNDropLine = GetListPixel($tempvectstr1, ",", "TL-DOWN")
$g_aiPixelTopLeftUPDropLine = GetListPixel($tempvectstr2, ",", "TL-UP")
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($g_aiPixelTopRightDropLine) - 1
Local $pixel = $g_aiPixelTopRightDropLine[$i]
Local $slice = Slice8($pixel)
Switch StringLeft($slice, 1)
Case "3"
$tempvectstr1 &= $pixel[0] & "," & $pixel[1] & "|"
Case "4"
$tempvectstr2 &= $pixel[0] & "," & $pixel[1] & "|"
Case Else
SetDebugLog("TOP RIGHT: Skip slice " & $slice & " at " & $pixel[0] & ", " & $pixel[1])
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$g_aiPixelTopRightDOWNDropLine = GetListPixel($tempvectstr1, ",", "TR-DOWN")
$g_aiPixelTopRightUPDropLine = GetListPixel($tempvectstr2, ",", "TR-UP")
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($g_aiPixelBottomLeftDropLine) - 1
Local $pixel = $g_aiPixelBottomLeftDropLine[$i]
Local $slice = Slice8($pixel)
Switch StringLeft($slice, 1)
Case "8"
$tempvectstr1 &= $pixel[0] & "," & $pixel[1] & "|"
Case "7"
$tempvectstr2 &= $pixel[0] & "," & $pixel[1] & "|"
Case Else
SetDebugLog("BOTTOM LEFT: Skip slice " & $slice & " at " & $pixel[0] & ", " & $pixel[1])
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$g_aiPixelBottomLeftDOWNDropLine = GetListPixel($tempvectstr1, ",", "BL-DOWN")
$g_aiPixelBottomLeftUPDropLine = GetListPixel($tempvectstr2, ",", "BL-UP")
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($g_aiPixelBottomRightDropLine) - 1
Local $pixel = $g_aiPixelBottomRightDropLine[$i]
Local $slice = Slice8($pixel)
Switch StringLeft($slice, 1)
Case "1"
$tempvectstr1 &= $pixel[0] & "," & $pixel[1] & "|"
Case "2"
$tempvectstr2 &= $pixel[0] & "," & $pixel[1] & "|"
Case Else
SetDebugLog("BOTTOM RIGHT: Skip slice " & $slice & " at " & $pixel[0] & ", " & $pixel[1])
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$g_aiPixelBottomRightDOWNDropLine = GetListPixel($tempvectstr1, ",", "BR-DOWN")
$g_aiPixelBottomRightUPDropLine = GetListPixel($tempvectstr2, ",", "BR-UP")
SetLog("> Drop Lines located in  " & Round(__timerdiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
If _Sleep($DELAYRESPOND) Then Return
If $g_bCSVLocateStorageTownHall = True Then
If $g_iSearchTH = "-" Or $g_oBldgAttackInfo.Exists($eBldgTownHall & "_LOCATION") = False Then
imglocTHSearch(True, False, False)
Else
SetLog("> Townhall has already been located in while searching for an image", $COLOR_INFO)
EndIf
Else
SetLog("> Townhall search not needed, skip")
EndIf
If _Sleep($DELAYRESPOND) Then Return
Global $g_aiPixelMine[0]
Global $g_aiPixelElixir[0]
Global $g_aiPixelDarkElixir[0]
Local $g_aiPixelNearCollectorTopLeftSTR = ""
Local $g_aiPixelNearCollectorBottomLeftSTR = ""
Local $g_aiPixelNearCollectorTopRightSTR = ""
Local $g_aiPixelNearCollectorBottomRightSTR = ""
If $g_bCSVLocateMine = True Then
$hTimer = __timerinit()
SuspendAndroid()
$g_aiPixelMine = GetLocationMine()
ResumeAndroid()
If _Sleep($DELAYRESPOND) Then Return
CleanRedArea($g_aiPixelMine)
Local $htimerMine = Round(__timerdiff($hTimer) / 1000, 2)
If(IsArray($g_aiPixelMine)) Then
For $i = 0 To UBound($g_aiPixelMine) - 1
Local $pixel = $g_aiPixelMine[$i]
Local $str = $pixel[0] & "-" & $pixel[1] & "-" & "MINE"
If isInsideDiamond($pixel) Then
If $pixel[0] <= $InternalArea[2][0] Then
If $pixel[1] <= $InternalArea[0][1] Then
$g_aiPixelNearCollectorTopLeftSTR &= $str & "|"
Else
$g_aiPixelNearCollectorBottomLeftSTR &= $str & "|"
EndIf
Else
If $pixel[1] <= $InternalArea[0][1] Then
$g_aiPixelNearCollectorTopRightSTR &= $str & "|"
Else
$g_aiPixelNearCollectorBottomRightSTR &= $str & "|"
EndIf
EndIf
EndIf
Next
EndIf
SetLog("> Mines located in " & Round(__timerdiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
SetLog("> Mines detection not needed, skip", $COLOR_INFO)
EndIf
If _Sleep($DELAYRESPOND) Then Return
If $g_bCSVLocateElixir = True Then
$hTimer = __timerinit()
SuspendAndroid()
$g_aiPixelElixir = GetLocationElixir()
ResumeAndroid()
If _Sleep($DELAYRESPOND) Then Return
CleanRedArea($g_aiPixelElixir)
Local $htimerMine = Round(__timerdiff($hTimer) / 1000, 2)
If(IsArray($g_aiPixelElixir)) Then
For $i = 0 To UBound($g_aiPixelElixir) - 1
Local $pixel = $g_aiPixelElixir[$i]
Local $str = $pixel[0] & "-" & $pixel[1] & "-" & "ELIXIR"
If isInsideDiamond($pixel) Then
If $pixel[0] <= $InternalArea[2][0] Then
If $pixel[1] <= $InternalArea[0][1] Then
$g_aiPixelNearCollectorTopLeftSTR &= $str & "|"
Else
$g_aiPixelNearCollectorBottomLeftSTR &= $str & "|"
EndIf
Else
If $pixel[1] <= $InternalArea[0][1] Then
$g_aiPixelNearCollectorTopRightSTR &= $str & "|"
Else
$g_aiPixelNearCollectorBottomRightSTR &= $str & "|"
EndIf
EndIf
EndIf
Next
EndIf
SetLog("> Elixir collectors located in " & Round(__timerdiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
SetLog("> Elixir collectors detection not needed, skip", $COLOR_INFO)
EndIf
If _Sleep($DELAYRESPOND) Then Return
If $g_bCSVLocateDrill = True Then
$hTimer = __timerinit()
SuspendAndroid()
$g_aiPixelDarkElixir = GetLocationDarkElixir()
ResumeAndroid()
If _Sleep($DELAYRESPOND) Then Return
CleanRedArea($g_aiPixelDarkElixir)
Local $htimerMine = Round(__timerdiff($hTimer) / 1000, 2)
If(IsArray($g_aiPixelDarkElixir)) Then
For $i = 0 To UBound($g_aiPixelDarkElixir) - 1
Local $pixel = $g_aiPixelDarkElixir[$i]
Local $str = $pixel[0] & "-" & $pixel[1] & "-" & "DRILL"
If isInsideDiamond($pixel) Then
If $pixel[0] <= $InternalArea[2][0] Then
If $pixel[1] <= $InternalArea[0][1] Then
$g_aiPixelNearCollectorTopLeftSTR &= $str & "|"
Else
$g_aiPixelNearCollectorBottomLeftSTR &= $str & "|"
EndIf
Else
If $pixel[1] <= $InternalArea[0][1] Then
$g_aiPixelNearCollectorTopRightSTR &= $str & "|"
Else
$g_aiPixelNearCollectorBottomRightSTR &= $str & "|"
EndIf
EndIf
EndIf
Next
EndIf
SetLog("> Drills located in " & Round(__timerdiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
SetLog("> Drills detection not needed, skip", $COLOR_INFO)
EndIf
If _Sleep($DELAYRESPOND) Then Return
If StringLen($g_aiPixelNearCollectorTopLeftSTR) > 0 Then $g_aiPixelNearCollectorTopLeftSTR = StringLeft($g_aiPixelNearCollectorTopLeftSTR, StringLen($g_aiPixelNearCollectorTopLeftSTR) - 1)
If StringLen($g_aiPixelNearCollectorTopRightSTR) > 0 Then $g_aiPixelNearCollectorTopRightSTR = StringLeft($g_aiPixelNearCollectorTopRightSTR, StringLen($g_aiPixelNearCollectorTopRightSTR) - 1)
If StringLen($g_aiPixelNearCollectorBottomLeftSTR) > 0 Then $g_aiPixelNearCollectorBottomLeftSTR = StringLeft($g_aiPixelNearCollectorBottomLeftSTR, StringLen($g_aiPixelNearCollectorBottomLeftSTR) - 1)
If StringLen($g_aiPixelNearCollectorBottomRightSTR) > 0 Then $g_aiPixelNearCollectorBottomRightSTR = StringLeft($g_aiPixelNearCollectorBottomRightSTR, StringLen($g_aiPixelNearCollectorBottomRightSTR) - 1)
$g_aiPixelNearCollectorTopLeft = GetListPixel3($g_aiPixelNearCollectorTopLeftSTR)
$g_aiPixelNearCollectorTopRight = GetListPixel3($g_aiPixelNearCollectorTopRightSTR)
$g_aiPixelNearCollectorBottomLeft = GetListPixel3($g_aiPixelNearCollectorBottomLeftSTR)
$g_aiPixelNearCollectorBottomRight = GetListPixel3($g_aiPixelNearCollectorBottomRightSTR)
If $g_bCSVLocateStorageGold = True Then
$aResult = GetLocationBuilding($eBldgGoldS, $g_iSearchTH, False)
If $aResult <> -1 Then
If $aResult = 1 Then
SetLog("> " & $g_sBldgNames[$eBldgGoldS] & " Not found", $COLOR_WARNING)
Else
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgGoldS & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgGoldS] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgGoldS] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult) Then $g_aiCSVGoldStoragePos = $aResult
EndIf
EndIf
Else
SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgGoldS], $COLOR_ERROR)
EndIf
EndIf
If $g_bCSVLocateStorageElixir = True Then
$aResult = GetLocationBuilding($eBldgElixirS, $g_iSearchTH, False)
If @error And $g_bDebugSetlog Then _logErrorGetBuilding(@error)
If $aResult <> -1 Then
If $aResult = 1 Then
SetLog("> " & $g_sBldgNames[$eBldgElixirS] & " Not found", $COLOR_WARNING)
Else
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgElixirS & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgElixirS] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgElixirS] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult) Then $g_aiCSVElixirStoragePos = $aResult
EndIf
EndIf
Else
SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgElixirS], $COLOR_ERROR)
EndIf
EndIf
If $g_bCSVLocateStorageDarkElixir = True Then
$hTimer = __timerinit()
SuspendAndroid()
Local $g_aiPixelDarkElixirStorage = GetLocationDarkElixirStorageWithLevel()
ResumeAndroid()
If _Sleep($DELAYRESPOND) Then Return
CleanRedArea($g_aiPixelDarkElixirStorage)
Local $pixel = StringSplit($g_aiPixelDarkElixirStorage, "#", 2)
If UBound($pixel) >= 2 Then
Local $pixelpos = StringSplit($pixel[1], "-", 2)
If UBound($pixelpos) >= 2 Then
Local $temp = [Int($pixelpos[0]), Int($pixelpos[1])]
$g_aiCSVDarkElixirStoragePos = $temp
EndIf
EndIf
SetLog("> Dark Elixir Storage located in " & Round(__timerdiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
SetLog("> Dark Elixir Storage detection not need, skip", $COLOR_INFO)
EndIf
$g_aiCSVEagleArtilleryPos = ""
If $g_bCSVLocateEagle = True Then
If $g_iSearchTH = "-" Or $g_iSearchTH > 10 Then
If _ObjSearch($g_oBldgAttackInfo, $eBldgEagle & "_LOCATION") = False Then
$aResult = GetLocationBuilding($eBldgEagle, $g_iSearchTH, False)
If $aResult = -1 Then SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgEagle], $COLOR_ERROR)
EndIf
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgEagle & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgEagle] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgEagle] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult[0]) Then $g_aiCSVEagleArtilleryPos = $aResult[0]
EndIf
Else
SetLog("> TH Level to low for Eagle, skip detection", $COLOR_INFO)
EndIf
Else
SetDebugLog("> Eagle Artillery detection not need, skipping", $COLOR_DEBUG)
EndIf
$g_aiCSVInfernoPos = ""
If $g_bCSVLocateInferno = True Then
If $g_iSearchTH = "-" Or $g_iSearchTH > 9 Then
If _ObjSearch($g_oBldgAttackInfo, $eBldgInferno & "_LOCATION") = False Then
$aResult = GetLocationBuilding($eBldgInferno, $g_iSearchTH, False)
If $aResult = -1 Then SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgInferno], $COLOR_ERROR)
EndIf
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgInferno & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgInferno] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgInferno] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult) Then $g_aiCSVInfernoPos = $aResult
EndIf
Else
SetLog("> TH Level to low for Inferno, ignore location", $COLOR_INFO)
EndIf
Else
SetDebugLog("> Inferno detection not need, skipping", $COLOR_DEBUG)
EndIf
$g_aiCSVXBowPos = ""
If $g_bCSVLocateXBow = True Then
If $g_iSearchTH = "-" Or $g_iSearchTH > 8 Then
If _ObjSearch($g_oBldgAttackInfo, $eBldgXBow & "_LOCATION") = False Then
$aResult = GetLocationBuilding($eBldgXBow, $g_iSearchTH, False)
If $aResult = -1 Then SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgXBow], $COLOR_ERROR)
EndIf
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgXBow & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgXBow] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgXBow] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult) Then $g_aiCSVXBowPos = $aResult
EndIf
Else
SetLog("> TH Level to low for " & $g_sBldgNames[$eBldgXBow] & " , ignore location", $COLOR_INFO)
EndIf
Else
SetDebugLog("> " & $g_sBldgNames[$eBldgXBow] & " detection not need, skipping", $COLOR_DEBUG)
EndIf
$g_aiCSVWizTowerPos = ""
If $g_bCSVLocateWizTower = True Then
If _ObjSearch($g_oBldgAttackInfo, $eBldgWizTower & "_LOCATION") = False Then
$aResult = GetLocationBuilding($eBldgWizTower, $g_iSearchTH, False)
If $aResult = -1 Then SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgWizTower], $COLOR_ERROR)
EndIf
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgWizTower & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgWizTower] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgWizTower] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult) Then $g_aiCSVWizTowerPos = $aResult
EndIf
Else
SetDebugLog("> " & $g_sBldgNames[$eBldgWizTower] & " detection not need, skipping", $COLOR_DEBUG)
EndIf
$g_aiCSVMortarPos = ""
If $g_bCSVLocateMortar = True Then
If _ObjSearch($g_oBldgAttackInfo, $eBldgMortar & "_LOCATION") = False Then
$aResult = GetLocationBuilding($eBldgMortar, $g_iSearchTH, False)
If $aResult = -1 Then SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgMortar], $COLOR_ERROR)
EndIf
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgMortar & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgMortar] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgMortar] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult) Then $g_aiCSVMortarPos = $aResult
EndIf
Else
SetDebugLog("> " & $g_sBldgNames[$eBldgMortar] & " detection not need, skipping", $COLOR_DEBUG)
EndIf
$g_aiCSVAirDefensePos = ""
If $g_bCSVLocateAirDefense = True Then
If _ObjSearch($g_oBldgAttackInfo, $eBldgAirDefense & "_LOCATION") = False Then
$aResult = GetLocationBuilding($eBldgAirDefense, $g_iSearchTH, False)
If $aResult = -1 Then SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgAirDefense], $COLOR_ERROR)
EndIf
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgAirDefense & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgAirDefense] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgAirDefense] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult) Then $g_aiCSVAirDefensePos = $aResult
EndIf
Else
SetDebugLog("> " & $g_sBldgNames[$eBldgAirDefense] & " detection not need, skipping", $COLOR_DEBUG)
EndIf
SetLog(">> Total time: " & Round(__timerdiff($hTimerTOTAL) / 1000, 2) & " seconds", $COLOR_INFO)
If $g_bDebugMakeIMGCSV Then AttackCSVDEBUGIMAGE()
If $g_bDebugAttackCSV Then _LogObjList($g_oBldgAttackInfo)
If $g_bTHSnipeBeforeEnable[$DB] And $g_iSearchTH = "-" Then FindTownHall(True)
If $g_bTHSnipeBeforeEnable[$DB] Then
If $g_iSearchTH <> "-" Then
If SearchTownHallLoc() Then
SetLogCentered(" TH snipe Before Scripted Attack ", Default, $COLOR_INFO)
$g_bTHSnipeUsedKing = False
$g_bTHSnipeUsedQueen = False
AttackTHParseCSV()
Else
If $g_bDebugSetlog Then SetDebugLog("TH snipe before scripted attack skip, th internal village", $COLOR_DEBUG)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("TH snipe before scripted attack skip, no th found", $COLOR_DEBUG)
EndIf
EndIf
SetSlotSpecialTroops()
If _Sleep($DELAYRESPOND) Then Return
ParseAttackCSV($testattack)
CheckHeroesHealth()
EndFunc
Func AttackCSVDEBUGIMAGE()
Local $iTimer = __TimerInit()
_CaptureRegion2()
Local $EditedImage = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
Local $testx
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($EditedImage)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
Local $pixel
Local $hPenLtGreen = _GDIPlus_PenCreate(0xFF00DC00, 2)
Local $hPenDkGreen = _GDIPlus_PenCreate(0xFF006E00, 2)
Local $hPenMdGreen = _GDIPlus_PenCreate(0xFF4CFF00, 2)
Local $hPenRed = _GDIPlus_PenCreate(0xFFFF0000, 2)
Local $hPenDkRed = _GDIPlus_PenCreate(0xFF6A0000, 2)
Local $hPenNavyBlue = _GDIPlus_PenCreate(0xFF000066, 2)
Local $hPenBlue = _GDIPlus_PenCreate(0xFF0000CC, 2)
Local $hPenSteelBlue = _GDIPlus_PenCreate(0xFF0066CC, 2)
Local $hPenLtBlue = _GDIPlus_PenCreate(0xFF0080FF, 2)
Local $hPenPaleBlue = _GDIPlus_PenCreate(0xFF66B2FF, 2)
Local $hPenCyan = _GDIPlus_PenCreate(0xFF00FFFF, 2)
Local $hPenYellow = _GDIPlus_PenCreate(0xFFFFD800, 2)
Local $hPenLtGrey = _GDIPlus_PenCreate(0xFFCCCCCC, 2)
Local $hPenWhite = _GDIPlus_PenCreate(0xFFFFFFFF, 2)
Local $hPenMagenta = _GDIPlus_PenCreate(0xFFFF00F6, 2)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[0][0], $ExternalArea[0][1], $ExternalArea[2][0], $ExternalArea[2][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[0][0], $ExternalArea[0][1], $ExternalArea[3][0], $ExternalArea[3][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[1][0], $ExternalArea[1][1], $ExternalArea[2][0], $ExternalArea[2][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[1][0], $ExternalArea[1][1], $ExternalArea[3][0], $ExternalArea[3][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[0][0], $InternalArea[0][1], $InternalArea[2][0], $InternalArea[2][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[0][0], $InternalArea[0][1], $InternalArea[3][0], $InternalArea[3][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[1][0], $InternalArea[1][1], $InternalArea[2][0], $InternalArea[2][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[1][0], $InternalArea[1][1], $InternalArea[3][0], $InternalArea[3][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[2][0], 0, $InternalArea[2][0], $g_iDEFAULT_HEIGHT, $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, 0, $InternalArea[0][1], $g_iDEFAULT_WIDTH, $InternalArea[0][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[4][0], $ExternalArea[4][1], $ExternalArea[7][0], $ExternalArea[7][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[5][0], $ExternalArea[5][1], $ExternalArea[6][0], $ExternalArea[6][1], $hPenLtGreen)
For $i = 0 To UBound($g_aiPixelTopLeft) - 1
$pixel = $g_aiPixelTopLeft[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($g_aiPixelTopRight) - 1
$pixel = $g_aiPixelTopRight[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($g_aiPixelBottomLeft) - 1
$pixel = $g_aiPixelBottomLeft[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($g_aiPixelBottomRight) - 1
$pixel = $g_aiPixelBottomRight[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($g_aiPixelTopLeftDropLine) - 1
$pixel = $g_aiPixelTopLeftDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenBlue)
Next
For $i = 0 To UBound($g_aiPixelTopRightDropLine) - 1
$pixel = $g_aiPixelTopRightDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenCyan)
Next
For $i = 0 To UBound($g_aiPixelBottomLeftDropLine) - 1
$pixel = $g_aiPixelBottomLeftDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenYellow)
Next
For $i = 0 To UBound($g_aiPixelBottomRightDropLine) - 1
$pixel = $g_aiPixelBottomRightDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenLtGrey)
Next
For $i = 0 To UBound($g_aiPixelTopLeftDOWNDropLine) - 1
$pixel = $g_aiPixelTopLeftDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenBlue)
Next
For $i = 0 To UBound($g_aiPixelTopLeftUPDropLine) - 1
$pixel = $g_aiPixelTopLeftUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenCyan)
Next
For $i = 0 To UBound($g_aiPixelBottomLeftDOWNDropLine) - 1
$pixel = $g_aiPixelBottomLeftDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenYellow)
Next
For $i = 0 To UBound($g_aiPixelBottomLeftUPDropLine) - 1
$pixel = $g_aiPixelBottomLeftUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenLtGrey)
Next
For $i = 0 To UBound($g_aiPixelTopRightDOWNDropLine) - 1
$pixel = $g_aiPixelTopRightDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenBlue)
Next
For $i = 0 To UBound($g_aiPixelTopRightUPDropLine) - 1
$pixel = $g_aiPixelTopRightUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenCyan)
Next
For $i = 0 To UBound($g_aiPixelBottomRightDOWNDropLine) - 1
$pixel = $g_aiPixelBottomRightDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenYellow)
Next
For $i = 0 To UBound($g_aiPixelBottomRightUPDropLine) - 1
$pixel = $g_aiPixelBottomRightUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenLtGrey)
Next
$testx = MakeDropPoints("TOP-LEFT-DOWN", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-LEFT-DOWN", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-UP", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-UP", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("TOP-RIGHT-DOWN", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-RIGHT-DOWN", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-UP", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-UP", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("TOP-LEFT-UP", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-LEFT-UP", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-DOWN", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-DOWN", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("TOP-RIGHT-UP", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-RIGHT-UP", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-DOWN", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-DOWN", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
For $i = 0 To UBound($g_aiPixelMine) - 1
$pixel = $g_aiPixelMine[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 10, 20, 20, $hPenLtGreen)
Next
For $i = 0 To UBound($g_aiPixelElixir) - 1
$pixel = $g_aiPixelElixir[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 5, 20, 20, $hPenDkGreen)
Next
For $i = 0 To UBound($g_aiPixelDarkElixir) - 1
$pixel = $g_aiPixelDarkElixir[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 5, 20, 20, $hPenDkRed)
Next
If $g_bCSVLocateStorageGold = True And IsArray($g_aiCSVGoldStoragePos) Then
For $i = 0 To UBound($g_aiCSVGoldStoragePos) - 1
$pixel = $g_aiCSVGoldStoragePos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 15, 20, 20, $hPenWhite)
Next
EndIf
If $g_bCSVLocateStorageElixir = True And IsArray($g_aiCSVElixirStoragePos) Then
For $i = 0 To UBound($g_aiCSVElixirStoragePos) - 1
$pixel = $g_aiCSVElixirStoragePos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 15, 20, 20, $hPenMagenta)
Next
EndIf
_GDIPlus_GraphicsDrawRect($hGraphic, $g_iTHx - 5, $g_iTHy - 10, 30, 30, $hPenRed)
If $g_bCSVLocateEagle = True And IsArray($g_aiCSVEagleArtilleryPos) Then
_GDIPlus_GraphicsDrawRect($hGraphic, $g_aiCSVEagleArtilleryPos[0] - 15, $g_aiCSVEagleArtilleryPos[1] - 15, 30, 30, $hPenBlue)
EndIf
If $g_bCSVLocateInferno = True And IsArray($g_aiCSVInfernoPos) Then
For $i = 0 To UBound($g_aiCSVInfernoPos) - 1
$pixel = $g_aiCSVInfernoPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 10, 20, 20, $hPenNavyBlue)
Next
EndIf
If $g_bCSVLocateXBow = True And IsArray($g_aiCSVXBowPos) Then
For $i = 0 To UBound($g_aiCSVXBowPos) - 1
$pixel = $g_aiCSVXBowPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 25, 25, 25, $hPenBlue)
Next
EndIf
If $g_bCSVLocateWizTower = True And IsArray($g_aiCSVWizTowerPos) Then
For $i = 0 To UBound($g_aiCSVWizTowerPos) - 1
$pixel = $g_aiCSVWizTowerPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 5, $pixel[1] - 15, 25, 25, $hPenSteelBlue)
Next
EndIf
If $g_bCSVLocateMortar = True And IsArray($g_aiCSVMortarPos) Then
For $i = 0 To UBound($g_aiCSVMortarPos) - 1
$pixel = $g_aiCSVMortarPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 15, 25, 25, $hPenLtBlue)
Next
EndIf
If $g_bCSVLocateAirDefense = True And IsArray($g_aiCSVAirDefensePos) Then
For $i = 0 To UBound($g_aiCSVAirDefensePos) - 1
$pixel = $g_aiCSVAirDefensePos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 12, $pixel[1] - 10, 25, 25, $hPenPaleBlue)
Next
EndIf
_GDIPlus_GraphicsDrawString($hGraphic, "1", 580, 580, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "2", 750, 450, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "3", 750, 200, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "4", 580, 110, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "5", 260, 110, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "6", 110, 200, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "7", 110, 450, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "8", 310, 580, "Arial", 20)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = $g_sProfileTempDebugPath & String("AttackDebug_" & $Date & "_" & $Time) & ".jpg"
_GDIPlus_ImageSaveToFile($EditedImage, $filename)
If @error Then SetLog("Debug Image save error: " & @extended, $COLOR_ERROR)
SetDebugLog("Attack CSV image saved: " & $filename)
_GDIPlus_PenDispose($hPenLtGreen)
_GDIPlus_PenDispose($hPenDkGreen)
_GDIPlus_PenDispose($hPenMdGreen)
_GDIPlus_PenDispose($hPenRed)
_GDIPlus_PenDispose($hPenDkRed)
_GDIPlus_PenDispose($hPenBlue)
_GDIPlus_PenDispose($hPenNavyBlue)
_GDIPlus_PenDispose($hPenSteelBlue)
_GDIPlus_PenDispose($hPenLtBlue)
_GDIPlus_PenDispose($hPenPaleBlue)
_GDIPlus_PenDispose($hPenCyan)
_GDIPlus_PenDispose($hPenYellow)
_GDIPlus_PenDispose($hPenLtGrey)
_GDIPlus_PenDispose($hPenWhite)
_GDIPlus_PenDispose($hPenMagenta)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($EditedImage)
If TestCapture() = True Then
ShellExecute($filename)
EndIf
SetDebugLog("AttackCSV DEBUG IMAGE Create Required: " & Round((__TimerDiff($iTimer) * 0.001), 1) & "Seconds", $COLOR_DEBUG)
EndFunc
Func CheckCsvValues($instruction, $variablenumber, $variable)
Switch $instruction
Case "MAKE"
Switch $variablenumber
Case 1
If $variable = "RANDOM" Then
Return True
Else
Local $vect1 = StringSplit($variable, "-", 2)
If UBound($vect1) = 0 Then
If StringLen($vect1) = 1 Then
If(Asc($vect1[$i]) >= 65 And Asc($vect1[$i]) <= 90) Then
Return True
Else
Return False
EndIf
Else
Return False
EndIf
Else
For $i = 0 To UBound($vect1) - 1
Local $tempstr = $vect1[$i]
If StringLen($tempstr) <> 1 Then
Return False
Else
If Not(Asc($vect1[$i]) >= 65 And Asc($vect1[$i]) <= 90) Then Return False
EndIf
Next
Return True
EndIf
EndIf
Case 2
Switch $variable
Case "FRONT-LEFT"
Return True
Case "FRONT-RIGHT"
Return True
Case "RIGHT-FRONT"
Return True
Case "RIGHT-BACK"
Return True
Case "LEFT-FRONT"
Return True
Case "LEFT-BACK"
Return True
Case "BACK-LEFT"
Return True
Case "BACK-RIGHT"
Return True
Case "RANDOM"
Return True
EndSwitch
Case 5
Switch $variable
Case "EXT-INT"
Return True
Case "INT-EXT"
Return True
Case "IGNORE"
Return True
Case Else
Return False
EndSwitch
Case 8
Switch $variable
Case "TOWNHALL"
Return True
Case "EAGLE"
Return True
Case "INFERNO"
Return True
Case "XBOW"
Return True
Case "WIZTOWER"
Return True
Case "MORTAR"
Return True
Case "AIRDEFENSE"
Return True
Case Else
Return False
EndSwitch
EndSwitch
EndSwitch
Return False
EndFunc
Func debugAttackCSV($string)
If $g_bDebugAttackCSV Then
_ConsoleWrite("A " & TimeDebug() & $string & @CRLF)
Local $hfile = FileOpen($g_sProfileLogsPath & "debugAttackCSV.log", $FO_APPEND)
_FileWriteLog($hfile, $string)
FileClose($hfile)
EndIf
EndFunc
Func DropTroopFromINI($vectors, $indexStart, $indexEnd, $indexArray, $qtaMin, $qtaMax, $troopName, $delayPointmin, $delayPointmax, $delayDropMin, $delayDropMax, $sleepafterMin, $sleepAfterMax, $debug = False)
If IsArray($indexArray) = 0 Then
debugAttackCSV("drop using vectors " & $vectors & " index " & $indexStart & "-" & $indexEnd & " and using " & $qtaMin & "-" & $qtaMax & " of " & $troopName)
Else
debugAttackCSV("drop using vectors " & $vectors & " index " & _ArrayToString($indexArray, ",") & " and using " & $qtaMin & "-" & $qtaMax & " of " & $troopName)
EndIf
debugAttackCSV(" - delay for multiple troops in same point: " & $delayPointmin & "-" & $delayPointmax)
debugAttackCSV(" - delay when  change deploy point : " & $delayDropMin & "-" & $delayDropMax)
debugAttackCSV(" - delay after drop all troops : " & $sleepafterMin & "-" & $sleepAfterMax)
Local $temp = StringSplit($vectors, "-")
Local $numbersOfVectors
If UBound($temp) > 0 Then
$numbersOfVectors = $temp[0]
Else
$numbersOfVectors = 0
EndIf
Local $vector1, $vector2, $vector3, $vector4
If UBound($temp) > 0 Then
If $temp[0] >= 1 Then $vector1 = "ATTACKVECTOR_" & $temp[1]
If $temp[0] >= 2 Then $vector2 = "ATTACKVECTOR_" & $temp[2]
If $temp[0] >= 3 Then $vector3 = "ATTACKVECTOR_" & $temp[3]
If $temp[0] >= 4 Then $vector4 = "ATTACKVECTOR_" & $temp[4]
Else
$vector1 = $vectors
EndIf
If $qtaMin <> $qtaMax Then
Local $qty = Random($qtaMin, $qtaMax, 1)
Else
Local $qty = $qtaMin
EndIf
debugAttackCSV(">> qty to deploy: " & $qty)
Local $qtyxpoint = Int($qty /($indexEnd - $indexStart + 1))
Local $extraunit = Mod($qty,($indexEnd - $indexStart + 1))
debugAttackCSV(">> qty x point: " & $qtyxpoint)
debugAttackCSV(">> qty extra: " & $extraunit)
Local $iTroopIndex = TroopIndexLookup($troopName, "DropTroopFromINI")
If $iTroopIndex = -1 Then
SetLog("CSV troop name '" & $troopName & "' is unrecognized.")
Return
EndIf
Local $bHeroDrop =($iTroopIndex = $eWarden ? True : False)
Local $troopPosition = -1
Local $troopCount = -1
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $iTroopIndex And $g_avAttackTroops[$i][1] >= $troopCount Then
$troopPosition = $i
$troopCount = $g_avAttackTroops[$i][1]
EndIf
Next
Local $usespell = True
Switch $iTroopIndex
Case $eLSpell
If $g_abAttackUseLightSpell[$g_iMatchMode] = False Then $usespell = False
Case $eHSpell
If $g_abAttackUseHealSpell[$g_iMatchMode] = False Then $usespell = False
Case $eRSpell
If $g_abAttackUseRageSpell[$g_iMatchMode] = False Then $usespell = False
Case $eJSpell
If $g_abAttackUseJumpSpell[$g_iMatchMode] = False Then $usespell = False
Case $eFSpell
If $g_abAttackUseFreezeSpell[$g_iMatchMode] = False Then $usespell = False
Case $eCSpell
If $g_abAttackUseCloneSpell[$g_iMatchMode] = False Then $usespell = False
Case $ePSpell
If $g_abAttackUsePoisonSpell[$g_iMatchMode] = False Then $usespell = False
Case $eESpell
If $g_abAttackUseEarthquakeSpell[$g_iMatchMode] = False Then $usespell = False
Case $eHaSpell
If $g_abAttackUseHasteSpell[$g_iMatchMode] = False Then $usespell = False
Case $eSkSpell
If $g_abAttackUseSkeletonSpell[$g_iMatchMode] = False Then $usespell = False
EndSwitch
If $troopPosition = -1 Or $usespell = False Then
If $usespell = True Then
SetLog("No troop found in your attack troops list")
debugAttackCSV("No troop found in your attack troops list")
Else
If $g_bDebugSetlog Then SetDebugLog("discard use spell", $COLOR_DEBUG)
EndIf
Else
If $g_iCSVLastTroopPositionDropTroopFromINI <> $troopPosition Then
ReleaseClicks()
SelectDropTroop($troopPosition)
$g_iCSVLastTroopPositionDropTroopFromINI = $troopPosition
ReleaseClicks()
EndIf
For $i = $indexStart To $indexEnd
Local $delayDrop = 0
Local $index = $i
Local $indexMax = $indexEnd
If IsArray($indexArray) = 1 Then
$index = $indexArray[$i]
$indexMax = $indexArray[$indexEnd]
EndIf
If $index <> $indexMax Then
If $delayDropMin <> $delayDropMax Then
$delayDrop = Random($delayDropMin, $delayDropMax, 1)
Else
$delayDrop = $delayDropMin
EndIf
debugAttackCSV(">> delay change drop point: " & $delayDrop)
EndIf
For $j = 1 To $numbersOfVectors
Local $delayDropLast = 0
If $j = $numbersOfVectors Then $delayDropLast = $delayDrop
If $index <= UBound(Execute("$" & Eval("vector" & $j))) Then
Local $pixel = Execute("$" & Eval("vector" & $j) & "[" & $index - 1 & "]")
Local $qty2 = $qtyxpoint
If $index < $indexStart + $extraunit Then $qty2 += 1
If $delayPointmin <> $delayPointmax Then
Local $delayPoint = Random($delayPointmin, $delayPointmax, 1)
Else
Local $delayPoint = $delayPointmin
EndIf
Switch $iTroopIndex
Case $eBarb To $eBowl
If $debug = True Then
SetLog("AttackClick( " & $pixel[0] & ", " & $pixel[1] & " , " & $qty2 & ", " & $delayPoint & ",#0666)")
Else
AttackClick($pixel[0], $pixel[1], $qty2, $delayPoint, $delayDropLast, "#0666")
EndIf
Case $eKing
If $debug = True Then
SetLog("dropHeroes(" & $pixel[0] & ", " & $pixel[1] & ", " & $g_iKingSlot & ", -1, -1) ")
Else
dropHeroes($pixel[0], $pixel[1], $g_iKingSlot, -1, -1)
EndIf
Case $eQueen
If $debug = True Then
SetLog("dropHeroes(" & $pixel[0] & ", " & $pixel[1] & ",-1," & $g_iQueenSlot & ", -1) ")
Else
dropHeroes($pixel[0], $pixel[1], -1, $g_iQueenSlot, -1)
EndIf
Case $eWarden
If $debug = True Then
SetLog("dropHeroes(" & $pixel[0] & ", " & $pixel[1] & ", -1, -1," & $g_iWardenSlot & ") ")
Else
dropHeroes($pixel[0], $pixel[1], -1, -1, $g_iWardenSlot)
EndIf
Case $eCastle
If $debug = True Then
SetLog("dropCC(" & $pixel[0] & ", " & $pixel[1] & ", " & $g_iClanCastleSlot & ")")
Else
dropCC($pixel[0], $pixel[1], $g_iClanCastleSlot)
EndIf
Case $eLSpell To $eSkSpell
If $debug = True Then
SetLog("Drop Spell AttackClick( " & $pixel[0] & ", " & $pixel[1] & " , " & $qty2 & ", " & $delayPoint & ",#0666)")
Else
AttackClick($pixel[0], $pixel[1], $qty2, $delayPoint, $delayDropLast, "#0667")
EndIf
If UBound($g_avAttackTroops) > $troopPosition And $g_avAttackTroops[$troopPosition][1] > 0 Then $g_avAttackTroops[$troopPosition][1] -= 1
Case Else
SetLog("Error parsing line")
EndSwitch
debugAttackCSV($troopName & " qty " & $qty2 & " in (" & $pixel[0] & "," & $pixel[1] & ") delay " & $delayPoint)
EndIf
Next
Next
ReleaseClicks()
Local $sleepafter = 0
If $sleepafterMin <> $sleepAfterMax Then
$sleepafter = Random($sleepafterMin, $sleepAfterMax, 1)
Else
$sleepafter = Int($sleepafterMin)
EndIf
If $sleepafter > 0 And IsKeepClicksActive() = False Then
debugAttackCSV(">> delay after drop all troops: " & $sleepafter)
If $sleepafter <= 1000 Then
If _Sleep($sleepafter) Then Return
If $bHeroDrop = True Then
Local $bHold = $g_bCheckWardenPower
$g_bCheckWardenPower = False
CheckHeroesHealth()
$g_bCheckWardenPower = $bHold
Else
CheckHeroesHealth()
EndIf
Else
For $z = 1 To Int($sleepafter / 1000)
If _Sleep(980) Then Return
CheckHeroesHealth()
Next
If _Sleep(Mod($sleepafter, 1000)) Then Return
CheckHeroesHealth()
EndIf
EndIf
EndIf
EndFunc
Func GetListPixel3($listPixel)
Local $listPixelSideStr = StringSplit($listPixel, "|")
If($listPixelSideStr[0] > 1) Then
Local $listPixelSide[UBound($listPixelSideStr) - 1]
For $i = 0 To UBound($listPixelSide) - 1
Local $pixelStr = StringSplit($listPixelSideStr[$i + 1], "-")
If($pixelStr[0] > 2) Then
Local $pixel = [Int($pixelStr[1]), Int($pixelStr[2]), Int($pixelStr[3])]
$listPixelSide[$i] = $pixel
EndIf
Next
Return $listPixelSide
Else
If StringInStr($listPixel, "-") > 0 Then
Local $pixelStrHere = StringSplit($listPixel, "-")
Local $pixelHere = [Int($pixelStrHere[1]), Int($pixelStrHere[2]), Int($pixelStrHere[3])]
Local $listPixelHere = [$pixelHere]
Return $listPixelHere
EndIf
Return -1
EndIf
EndFunc
Func isInsideDiamondRedArea($aCoords)
Local $Left = $ExternalArea[0][0], $Right = $ExternalArea[1][0], $Top = $ExternalArea[2][1], $Bottom = $ExternalArea[3][1]
Local $aDiamond[2][2] = [[$Left, $Top], [$Right, $Bottom]]
Local $aMiddle = [($aDiamond[0][0] + $aDiamond[1][0]) / 2,($aDiamond[0][1] + $aDiamond[1][1]) / 2]
Local $aSize = [$aMiddle[0] - $aDiamond[0][0], $aMiddle[1] - $aDiamond[0][1]]
Local $DX = Abs($aCoords[0] - $aMiddle[0])
Local $DY = Abs($aCoords[1] - $aMiddle[1])
If $DX >= 5 Then $DX -= 5
If $DY >= 5 Then $DY -= 5
If($DX / $aSize[0] + $DY / $aSize[1] <= 1) And $aCoords[0] > $DeployableLRTB[0] And $aCoords[0] <= $DeployableLRTB[1] And $aCoords[1] >= $DeployableLRTB[2] And $aCoords[1] <= $DeployableLRTB[3] Then
Return True
Else
Return False
EndIf
EndFunc
Func Line2Points($pixel0, $pixel1, $iXY, $iDim0 = 0)
Local $iDim1 = 1 - $iDim0
Return Round(($iXY - $pixel0[$iDim0]) /($pixel1[$iDim0] - $pixel0[$iDim0]) *($pixel1[$iDim1] - $pixel0[$iDim1]) + $pixel0[$iDim1])
EndFunc
Func MakeDropLine($searchvect, $startpoint, $endpoint, $iLineDistanceThreshold = 75, $bLineToCorner = False)
SetDebugLog("MakeDropLine for " & UBound($searchvect) & " points")
If $bLineToCorner = False And UBound($searchvect) > 0 Then $startpoint = $searchvect[0]
If $bLineToCorner = False And UBound($searchvect) > 0 Then $endpoint = $searchvect[UBound($searchvect) - 1]
SetDebugLog("MakeDropLine: Start = " & PixelToString($startpoint) & ", End = " & PixelToString($endpoint) & ": " & PixelArrayToString($searchvect, ","))
Local $startX = $startpoint[0]
Local $startY = $startpoint[1]
Local $size = UBound($searchvect)
ReDim $searchvect[$size + 1]
$searchvect[$size] = $endpoint
Local $Pixel0 = [$startX, $startY]
Local $ReturnVect = $startX & "," & $startY
For $idx = 0 To $size
Local $Pixel1 = $searchvect[$idx]
If $Pixel1[0] < 0 Then ContinueLoop
Local $aLen = [$Pixel1[0] - $Pixel0[0], $Pixel1[1] - $Pixel0[1]]
Local $iStart
Local $iEnd
Local $iStep
Local $iLoopAxis =((Abs($aLen[0]) >= Abs($aLen[1])) ?(0) :(1))
Local $iOtherAxis = 1 - $iLoopAxis
Local $iDistance
$iStep =(($aLen[$iLoopAxis] > 0) ?(1) :(-1))
$iStart = $Pixel0[$iLoopAxis]
$iEnd = $Pixel1[$iLoopAxis]
$iDistance = GetPixelDistance($Pixel0, $Pixel1)
If $iLineDistanceThreshold = -1 Or $iDistance <= $iLineDistanceThreshold Or($bLineToCorner = True And($idx = 0 Or $idx = $size)) Then
For $i = $iStart + $iStep To $iEnd Step $iStep
Local $j = Line2Points($Pixel0, $Pixel1, $i, $iLoopAxis)
Local $p[2]
$p[$iLoopAxis] = $i
$p[$iOtherAxis] = $j
$ReturnVect &= "|" & $p[0] & "," & $p[1]
Next
Else
$ReturnVect &= "|" & $Pixel1[0] & "," & $Pixel1[1]
EndIf
$Pixel0 = $Pixel1
Next
SetDebugLog("MakeDropLine: Done: " & $ReturnVect)
Return GetListPixel($ReturnVect, ",")
EndFunc
Func MakeDropLineOriginal($searchvect, $startpoint, $endpoint)
SetDebugLog("MakeDropLine for " & UBound($searchvect) & " points")
Local $startX = $startpoint[0]
Local $startY = $startpoint[1]
Local $endX = $endpoint[0]
Local $endY = $endpoint[1]
CheckAttackLocation($startX, $startY)
CheckAttackLocation($endX, $endY)
Local $point1 = [$startX, $startY]
Local $t, $f
$t = 0
$f = 0
Local $ReturnVect = $startX & "," & $startY
For $i = $startX + 1 To $endX
For $j = $t To UBound($searchvect) - 1
Local $pixel = $searchvect[$j]
If $i < $pixel[0] Then
Local $h = Line2Points($point1, $pixel, $i)
CheckAttackLocation($i, $h)
$ReturnVect &= "|" & $i & "," & $h
$f = $i
ExitLoop
Else
If $i = $pixel[0] Then
Local $x = $pixel[0]
Local $h = $pixel[1]
CheckAttackLocation($x, $h)
$ReturnVect &= "|" & $x & "," & $h
$point1 = $pixel
$t = $j + 1
$f = $i
ExitLoop
EndIf
EndIf
Next
Next
For $i = $f + 1 To $endX
Local $h = Line2Points($point1, $endpoint, $i)
CheckAttackLocation($i, $h)
$ReturnVect &= "|" & $i & "," & $h
Next
Return GetListPixel($ReturnVect, ",")
EndFunc
Func MakeDropPoints($side, $pointsQty, $addtiles, $versus, $randomx = 2, $randomy = 2)
debugAttackCSV("make for side " & $side)
Local $Vector, $Output = ""
Local $rndx = Random(0, Abs(Int($randomx)), 1)
Local $rndy = Random(0, Abs(Int($randomy)), 1)
If $side = "RANDOM" Then
EndIf
Switch $side
Case "TOP-LEFT-DOWN"
Local $Vector = $g_aiPixelTopLeftDOWNDropLine
Case "TOP-LEFT-UP"
Local $Vector = $g_aiPixelTopLeftUPDropLine
Case "TOP-RIGHT-DOWN"
Local $Vector = $g_aiPixelTopRightDOWNDropLine
Case "TOP-RIGHT-UP"
Local $Vector = $g_aiPixelTopRightUPDropLine
Case "BOTTOM-LEFT-UP"
Local $Vector = $g_aiPixelBottomLeftUPDropLine
Case "BOTTOM-LEFT-DOWN"
Local $Vector = $g_aiPixelBottomLeftDOWNDropLine
Case "BOTTOM-RIGHT-UP"
Local $Vector = $g_aiPixelBottomRightUPDropLine
Case "BOTTOM-RIGHT-DOWN"
Local $Vector = $g_aiPixelBottomRightDOWNDropLine
Case Else
EndSwitch
If $versus = "IGNORE" Then $versus = "EXT-INT"
If Int($pointsQty) > 0 Then
Local $pointsQtyCleaned = Abs(Int($pointsQty))
Else
Local $pointsQtyCleaned = 1
EndIf
Local $p = Int(UBound($Vector) / $pointsQtyCleaned)
If $p = 0 Then $p = 1
Local $x = 0
Local $y = 0
Local $str = ""
For $i = 0 To UBound($Vector) - 1
Local $pixel = $Vector[$i]
$str &= $pixel[0] & "-" & $pixel[1] & "|"
Next
Switch $side & "|" & $versus
Case "TOP-LEFT-DOWN|INT-EXT", "TOP-LEFT-UP|EXT-INT", "TOP-RIGHT-DOWN|EXT-INT", "TOP-RIGHT-UP|INT-EXT", "BOTTOM-LEFT-DOWN|EXT-INT", "BOTTOM-LEFT-UP|INT-EXT", "BOTTOM-RIGHT-DOWN|INT-EXT", "BOTTOM-RIGHT-UP|EXT-INT"
For $i = UBound($Vector) To 1 Step -1
$pixel = $Vector[$i - 1]
$x += $pixel[0]
$y += $pixel[1]
If Mod(UBound($Vector) - $i + 1, $p) = 0 Then
For $u = 8 * Abs(Int($addtiles)) To 0 Step -1
If Int($addtiles) > 0 Then
Local $l = $u
Else
Local $l = -$u
EndIf
Switch $side
Case "TOP-LEFT-UP", "TOP-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "TOP-RIGHT-UP", "TOP-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "BOTTOM-LEFT-UP", "BOTTOM-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case "BOTTOM-RIGHT-UP", "BOTTOM-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case Else
EndSwitch
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
If isInsideDiamondRedArea($pixel) Then ExitLoop
Next
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
$Output &= $pixel[0] & "-" & $pixel[1] & "|"
$x = 0
$y = 0
EndIf
Next
Case "TOP-LEFT-DOWN|EXT-INT", "TOP-LEFT-UP|INT-EXT", "TOP-RIGHT-DOWN|INT-EXT", "TOP-RIGHT-UP|EXT-INT", "BOTTOM-LEFT-DOWN|INT-EXT", "BOTTOM-LEFT-UP|EXT-INT", "BOTTOM-RIGHT-DOWN|EXT-INT", "BOTTOM-RIGHT-UP|INT-EXT"
For $i = 1 To UBound($Vector)
$pixel = $Vector[$i - 1]
$x += $pixel[0]
$y += $pixel[1]
If Mod($i, $p) = 0 Then
For $u = 8 * Abs(Int($addtiles)) To 0 Step -1
If Int($addtiles) > 0 Then
Local $l = $u
Else
Local $l = -$u
EndIf
Switch $side
Case "TOP-LEFT-UP", "TOP-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "TOP-RIGHT-UP", "TOP-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "BOTTOM-LEFT-UP", "BOTTOM-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case "BOTTOM-RIGHT-UP", "BOTTOM-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case Else
EndSwitch
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
If isInsideDiamondRedArea($pixel) Then ExitLoop
Next
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
$Output &= $pixel[0] & "-" & $pixel[1] & "|"
$x = 0
$y = 0
EndIf
Next
Case Else
EndSwitch
If StringLen($Output) > 0 Then $Output = StringLeft($Output, StringLen($Output) - 1)
Return GetListPixel($Output)
EndFunc
Func MakeTargetDropPoints($side, $pointsQty, $addtiles, $building)
debugAttackCSV("make for side " & $side & ", target: " & $building)
Local $Vector, $Output = ""
Local $x, $y
Local $sLoc, $aLocation, $pixel[2], $BuildingEnum, $result, $array
Switch $building
Case "TOWNHALL"
$BuildingEnum = $eBldgTownHall
Case "EAGLE"
$BuildingEnum = $eBldgEagle
Case "INFERNO"
$BuildingEnum = $eBldgInferno
Case "XBOW"
$BuildingEnum = $eBldgXBow
Case "WIZTOWER"
$BuildingEnum = $eBldgWizTower
Case "MORTAR"
$BuildingEnum = $eBldgMortar
Case "AIRDEFENSE"
$BuildingEnum = $eBldgAirDefense
Case Else
SetLog("Defense name not understood", $COLOR_ERROR)
SetError(1, 0, "")
Return
EndSwitch
Local $aBuildingLoc = _ObjGetValue($g_oBldgAttackInfo, $BuildingEnum & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$BuildingEnum] & " _LOCATION", @error)
SetError(2, 0, "")
Return
EndIf
If IsArray($aBuildingLoc) Then
If UBound($aBuildingLoc, 1) > 1 And IsArray($aBuildingLoc[1]) Then
For $p = 0 To UBound($aBuildingLoc) - 1
$array = $aBuildingLoc[$p]
$result = IsPointOnSide($array, $side)
If @error Then
Return SetError(4, 0, "")
EndIf
If $result = True Then
$aLocation = $aBuildingLoc[$p]
ExitLoop
EndIf
Next
If $aLocation = "" Then
SetLog("Building location not found on side, random pick", $COLOR_ERROR)
If IsArray($aBuildingLoc[0]) Then $aLocation = $aBuildingLoc[0]
EndIf
Else
$aLocation = $aBuildingLoc[0]
EndIf
Else
SetLog($g_sBldgNames[$BuildingEnum] & " _LOCATION not an array", $COLOR_ERROR)
Return SetError(3, 0, "")
EndIf
Switch Int($pointsQty)
Case 1
$x += $aLocation[0]
$y += $aLocation[1]
For $u = 8 * Abs(Int($addtiles)) To 0 Step -1
If Int($addtiles) > 0 Then
Local $l = $u
Else
Local $l = -$u
EndIf
Switch $side
Case "TOP-LEFT-UP", "TOP-LEFT-DOWN"
$pixel[0] = $x - $l
$pixel[1] = $y - $l
Case "TOP-RIGHT-UP", "TOP-RIGHT-DOWN"
$pixel[0] = $x + $l
$pixel[1] = $y - $l
Case "BOTTOM-LEFT-UP", "BOTTOM-LEFT-DOWN"
$pixel[0] = $x - $l
$pixel[1] = $y + $l
Case "BOTTOM-RIGHT-UP", "BOTTOM-RIGHT-DOWN"
$pixel[0] = $x + $l
$pixel[1] = $y + $l
Case Else
SetLog("Silly code monkey 'MAKE' TargetDropPoints mistake", $COLOR_ERROR)
SetError(5, 0, "")
Return
EndSwitch
If isInsideDiamondRedArea($pixel) Then ExitLoop
Next
If isInsideDiamondRedArea($pixel) = False Then SetDebugLog("MakeTargetDropPoints() ADDTILES error!")
$sLoc = $pixel[0] & "-" & $pixel[1]
Return GetListPixel($sLoc, "-", "MakeTargetDropPoints TARGET")
Case 5
$sLoc = $aLocation[0] & "|" & $aLocation[1]
$Output = GetDeployableNextTo($sLoc, 10, $g_oBldgAttackInfo.item($eBldgRedLine & "_OBJECTPOINTS"))
Return GetListPixel($Output, ",", "MakeTargetDropPoints NEARPOINTS")
Case Else
SetLog("Strange MakeTargetDropPoint Error", $COLOR_ERROR)
Return SetError(6, 0, "")
EndSwitch
EndFunc
Func ParseAttackCSV($debug = False)
Local $bForceSideExist = False
Local $sErrorText, $sTargetVectors = ""
Local $iTroopIndex, $bWardenDrop = False
For $v = 0 To 25
Assign("ATTACKVECTOR_" & Chr(65+$v), "", $ASSIGN_EXISTFAIL)
If @error Then SetLog("Failed to erase old vector: " & Chr(65+$v) & ", ask code monkey to fix!", $COLOR_ERROR)
Next
If $g_iMatchMode = $DB Then
Local $filename = $g_sAttackScrScriptName[$DB]
Else
Local $filename = $g_sAttackScrScriptName[$LB]
EndIf
SetLog("execute " & $filename)
Local $f, $line, $acommand, $command
Local $value1 = "", $value2 = "", $value3 = "", $value4 = "", $value5 = "", $value6 = "", $value7 = "", $value8 = "", $value9 = ""
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
Local $aLines = FileReadToArray($g_sCSVAttacksPath & "\" & $filename & ".csv")
For $iLine = 0 To UBound($aLines) - 1
$line = $aLines[$iLine]
$sErrorText = ""
debugAttackCSV("line: " & $iLine + 1)
If @error = -1 Then ExitLoop
If $debug = True Then SetLog("parse line:<<" & $line & ">>")
debugAttackCSV("line content: " & $line)
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), $STR_STRIPTRAILING)
If $command = "TRAIN" Or $command = "REDLN" Or $command = "DRPLN" Or $command = "CCREQ" Then ContinueLoop
For $i = 2 To(UBound($acommand) - 1)
Assign("value" & Number($i - 1), StringStripWS(StringUpper($acommand[$i]), $STR_STRIPTRAILING))
Next
Switch $command
Case ""
debugAttackCSV("comment line")
Case "MAKE"
ReleaseClicks()
If CheckCsvValues("MAKE", 2, $value2) Then
Local $sidex = StringReplace($value2, "-", "_")
If $sidex = "RANDOM" Then
Switch Random(1, 4, 1)
Case 1
$sidex = "FRONT_"
If Random(0, 1, 1) = 0 Then
$sidex &= "LEFT"
Else
$sidex &= "RIGHT"
EndIf
Case 2
$sidex = "BACK_"
If Random(0, 1, 1) = 0 Then
$sidex &= "LEFT"
Else
$sidex &= "RIGHT"
EndIf
Case 3
$sidex = "LEFT_"
If Random(0, 1, 1) = 0 Then
$sidex &= "FRONT"
Else
$sidex &= "BACK"
EndIf
Case 4
$sidex = "RIGHT_"
If Random(0, 1, 1) = 0 Then
$sidex &= "FRONT"
Else
$sidex &= "BACK"
EndIf
EndSwitch
EndIf
If CheckCsvValues("MAKE", 1, $value1) And CheckCsvValues("MAKE", 5, $value5) Then
$sTargetVectors = StringReplace($sTargetVectors, $value3, "", Default, $STR_NOCASESENSEBASIC)
If CheckCsvValues("MAKE", 8, $value8) Then
If $value3 = 1 Or $value3 = 5 Then
Local $tmpArray = MakeTargetDropPoints(Eval($sidex), $value3, $value4, $value8)
If @error Then
$sErrorText = "MakeTargetDropPoints: " & @error
Else
Assign("ATTACKVECTOR_" & $value1, $tmpArray)
$sTargetVectors &= $value1
EndIf
Else
$sErrorText = "value 3"
EndIf
Else
Assign("ATTACKVECTOR_" & $value1, MakeDropPoints(Eval($sidex), $value3, $value4, $value5, $value6, $value7))
EndIf
Else
$sErrorText = "value1 or value 5"
EndIf
Else
$sErrorText = "value2"
EndIf
If $sErrorText <> "" Then
SetLog("Discard row, bad " & $sErrorText & " parameter: row " & $iLine + 1)
debugAttackCSV("Discard row, bad " & $sErrorText & " parameter: row " & $iLine + 1)
Else
For $i = 0 To UBound(Execute("$ATTACKVECTOR_" & $value1)) - 1
Local $pixel = Execute("$ATTACKVECTOR_" & $value1 & "[" & $i & "]")
debugAttackCSV($i & " - " & $pixel[0] & "," & $pixel[1])
Next
EndIf
Case "DROP"
KeepClicks()
Local $index1, $index2, $indexArray, $indexvect
$indexvect = StringSplit($value2, "-", 2)
If UBound($indexvect) > 1 Then
$indexArray = 0
If Int($indexvect[0]) > 0 And Int($indexvect[1]) > 0 Then
$index1 = Int($indexvect[0])
$index2 = Int($indexvect[1])
Else
$index1 = 1
$index2 = 1
EndIf
Else
$indexArray = StringSplit($value2, ",", 2)
If UBound($indexArray) > 1 Then
$index1 = 0
$index2 = UBound($indexArray) - 1
Else
$indexArray = 0
If Int($value2) > 0 Then
$index1 = Int($value2)
$index2 = Int($value2)
Else
$index1 = 1
$index2 = 1
EndIf
EndIf
EndIf
Local $qty1, $qty2, $qtyvect
$qtyvect = StringSplit($value3, "-", 2)
If UBound($qtyvect) > 1 Then
If Int($qtyvect[0]) > 0 And Int($qtyvect[1]) > 0 Then
$qty1 = Int($qtyvect[0])
$qty2 = Int($qtyvect[1])
Else
$index1 = 1
$qty2 = 1
EndIf
Else
If Int($value3) > 0 Then
$qty1 = Int($value3)
$qty2 = Int($value3)
Else
$qty1 = 1
$qty2 = 1
EndIf
EndIf
Local $delaypoints1, $delaypoints2, $delaypointsvect
$delaypointsvect = StringSplit($value5, "-", 2)
If UBound($delaypointsvect) > 1 Then
If Int($delaypointsvect[0]) >= 0 And Int($delaypointsvect[1]) >= 0 Then
$delaypoints1 = Int($delaypointsvect[0])
$delaypoints2 = Int($delaypointsvect[1])
Else
$delaypoints1 = 1
$delaypoints2 = 1
EndIf
Else
If Int($value5) >= 0 Then
$delaypoints1 = Int($value5)
$delaypoints2 = Int($value5)
Else
$delaypoints1 = 1
$delaypoints2 = 1
EndIf
EndIf
Local $delaydrop1, $delaydrop2, $delaydropvect
$delaydropvect = StringSplit($value6, "-", 2)
If UBound($delaydropvect) > 1 Then
If Int($delaydropvect[0]) >= 0 And Int($delaydropvect[1]) >= 0 Then
$delaydrop1 = Int($delaydropvect[0])
$delaydrop2 = Int($delaydropvect[1])
Else
$delaydrop1 = 1
$delaydrop2 = 1
EndIf
Else
If Int($value6) >= 0 Then
$delaydrop1 = Int($value6)
$delaydrop2 = Int($value6)
Else
$delaydrop1 = 1
$delaydrop2 = 1
EndIf
EndIf
Local $sleepdrop1, $sleepdrop2, $sleepdroppvect
$sleepdroppvect = StringSplit($value7, "-", 2)
If UBound($sleepdroppvect) > 1 Then
If Int($sleepdroppvect[0]) >= 0 And Int($sleepdroppvect[1]) >= 0 Then
$sleepdrop1 = Int($sleepdroppvect[0])
$sleepdrop2 = Int($sleepdroppvect[1])
Else
$index1 = 1
$sleepdrop2 = 1
EndIf
Else
If Int($value7) >= 0 Then
$sleepdrop1 = Int($value7)
$sleepdrop2 = Int($value7)
Else
$sleepdrop1 = 1
$sleepdrop2 = 1
EndIf
EndIf
Local $tmpVectorList = StringSplit($value1, "-", $STR_NOCOUNT)
For $v = 0 To UBound($tmpVectorList) - 1
If StringInStr($sTargetVectors, $tmpVectorList[$v], $STR_NOCASESENSEBASIC) = True Then
If IsArray($indexArray) Then
For $i = $index1 To $index2
If $indexArray[$i] < 1 Or $indexArray[$i] > 5 Then
$sErrorText &= "Invalid INDEX for near building DROP"
SetDebugLog("$index1: " & $index1 & ", $index2: " & $index2 & ", $indexArray[" & $i & "]: " & $indexArray[$i], $COLOR_ERROR)
ExitLoop
EndIf
Next
ElseIf $indexArray = 0 Then
Select
Case $index1 = 1 And $index1 = $index2
Case $index1 >= 1 And $index1 <= 5 And $index2 > 1 And $index2 <= 5
Case Else
$sErrorText &= "Invalid INDEX for building target"
SetDebugLog("$index1: " & $index1 & ", $index2: " & $index2, $COLOR_ERROR)
EndSelect
Else
SetDebugLog("Monkey found a bad banana checking Bdlg target INDEX!", $COLOR_ERROR)
EndIf
EndIf
Next
If $sErrorText <> "" Then
SetLog("Discard row, " & $sErrorText & ": row " & $iLine + 1)
debugAttackCSV("Discard row, " & $sErrorText & ": row " & $iLine + 1)
Else
DropTroopFromINI($value1, $index1, $index2, $indexArray, $qty1, $qty2, $value4, $delaypoints1, $delaypoints2, $delaydrop1, $delaydrop2, $sleepdrop1, $sleepdrop2, $debug)
EndIf
ReleaseClicks($g_iAndroidAdbClicksTroopDeploySize)
If _Sleep($DELAYRESPOND) Then Return
$iTroopIndex = TroopIndexLookup($value4, "ParseAttackCSV")
$bWardenDrop =($iTroopIndex = $eWarden) And($sleepdrop1 < 1000)
Case "WAIT"
ReleaseClicks()
Local $sleep1, $sleep2, $sleepvect
$sleepvect = StringSplit($value1, "-", 2)
If UBound($sleepvect) > 1 Then
If Int($sleepvect[0]) > 0 And Int($sleepvect[1]) > 0 Then
$sleep1 = Int($sleepvect[0])
$sleep2 = Int($sleepvect[1])
Else
$sleep1 = 1
$sleep2 = 1
EndIf
Else
If Int($value3) > 0 Then
$sleep1 = Int($value1)
$sleep2 = Int($value1)
Else
$sleep1 = 1
$sleep2 = 1
EndIf
EndIf
If $sleep1 <> $sleep2 Then
Local $sleep = Random(Int($sleep1), Int($sleep2), 1)
Else
Local $sleep = Int($sleep1)
EndIf
debugAttackCSV("wait " & $sleep)
Local $Gold = 0
Local $Elixir = 0
Local $DarkElixir = 0
Local $Trophies = 0
Local $exitOneStar = 0
Local $exitTwoStars = 0
Local $exitNoResources = 0
Local $hSleepTimer = __TimerInit()
While __TimerDiff($hSleepTimer) < $sleep
CheckHeroesHealth()
$Gold = getGoldVillageSearch(48, 69)
$Elixir = getElixirVillageSearch(48, 69 + 29)
If _Sleep($DELAYRESPOND) Then Return
$Trophies = getTrophyVillageSearch(48, 69 + 99)
If $Trophies <> "" Then
$DarkElixir = getDarkElixirVillageSearch(48, 69 + 57)
Else
$DarkElixir = ""
$Trophies = getTrophyVillageSearch(48, 69 + 69)
EndIf
CheckHeroesHealth()
If $g_bDebugSetlog Then SetDebugLog("detected [G]: " & $Gold & " [E]: " & $Elixir & " [DE]: " & $DarkElixir, $COLOR_INFO)
If $g_abStopAtkNoResources[$g_iMatchMode] And Number($Gold) = 0 And Number($Elixir) = 0 And Number($DarkElixir) = 0 Then
If NOT $g_bDebugSetlog Then SetDebugLog("detected [G]: " & $Gold & " [E]: " & $Elixir & " [DE]: " & $DarkElixir, $COLOR_INFO)
SetDebugLog("From Attackcsv: Gold & Elixir & DE = 0, end battle ", $COLOR_DEBUG)
$exitNoResources = 1
ExitLoop
EndIf
If $g_abStopAtkTwoStars[$g_iMatchMode] And _CheckPixel($aWonTwoStar, True) Then
SetDebugLog("From Attackcsv: Two Star Reach, exit", $COLOR_SUCCESS)
$exitTwoStars = 1
ExitLoop
EndIf
If $g_abStopAtkOneStar[$g_iMatchMode] And _CheckPixel($aWonOneStar, True) Then
SetDebugLog("From Attackcsv: One Star Reach, exit", $COLOR_SUCCESS)
$exitOneStar = 1
ExitLoop
EndIf
If $g_abStopAtkPctHigherEnable[$g_iMatchMode] And Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)) > Int($g_aiStopAtkPctHigherAmt[$g_iMatchMode]) Then
ExitLoop
EndIf
If _Sleep($DELAYRESPOND) Then Return
WEnd
If $exitOneStar = 1 Or $exitTwoStars = 1 Or $exitNoResources = 1 Then ExitLoop
Case "RECALC"
ReleaseClicks()
PrepareAttack($g_iMatchMode, True)
Case "SIDE"
ReleaseClicks()
SetLog("Calculate main side... ")
Local $heightTopLeft = 0, $heightTopRight = 0, $heightBottomLeft = 0, $heightBottomRight = 0
If StringUpper($value8) = "TOP-LEFT" Or StringUpper($value8) = "TOP-RIGHT" Or StringUpper($value8) = "BOTTOM-LEFT" Or StringUpper($value8) = "BOTTOM-RIGHT" Then
$MAINSIDE = StringUpper($value8)
SetLog("Forced side: " & StringUpper($value8), $COLOR_INFO)
$bForceSideExist = True
Else
For $i = 0 To UBound($g_aiPixelMine) - 1
Local $str = ""
Local $pixel = $g_aiPixelMine[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value1)
Case 3, 4
$heightTopRight += Int($value1)
Case 5, 6
$heightTopLeft += Int($value1)
Case 7, 8
$heightBottomLeft += Int($value1)
EndSwitch
EndIf
Next
For $i = 0 To UBound($g_aiPixelElixir) - 1
Local $str = ""
Local $pixel = $g_aiPixelElixir[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value2)
Case 3, 4
$heightTopRight += Int($value2)
Case 5, 6
$heightTopLeft += Int($value2)
Case 7, 8
$heightBottomLeft += Int($value2)
EndSwitch
EndIf
Next
For $i = 0 To UBound($g_aiPixelDarkElixir) - 1
Local $str = ""
Local $pixel = $g_aiPixelDarkElixir[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value3)
Case 3, 4
$heightTopRight += Int($value3)
Case 5, 6
$heightTopLeft += Int($value3)
Case 7, 8
$heightBottomLeft += Int($value3)
EndSwitch
EndIf
Next
If IsArray($g_aiCSVGoldStoragePos) Then
For $i = 0 To UBound($g_aiCSVGoldStoragePos) - 1
Local $pixel = $g_aiCSVGoldStoragePos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value4)
Case 3, 4
$heightTopRight += Int($value4)
Case 5, 6
$heightTopLeft += Int($value4)
Case 7, 8
$heightBottomLeft += Int($value4)
EndSwitch
EndIf
Next
EndIf
If IsArray($g_aiCSVElixirStoragePos) Then
For $i = 0 To UBound($g_aiCSVElixirStoragePos) - 1
Local $pixel = $g_aiCSVElixirStoragePos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value5)
Case 3, 4
$heightTopRight += Int($value5)
Case 5, 6
$heightTopLeft += Int($value5)
Case 7, 8
$heightBottomLeft += Int($value5)
EndSwitch
EndIf
Next
EndIf
Switch StringLeft(Slice8($g_aiCSVDarkElixirStoragePos), 1)
Case 1, 2
$heightBottomRight += Int($value6)
Case 3, 4
$heightTopRight += Int($value6)
Case 5, 6
$heightTopLeft += Int($value6)
Case 7, 8
$heightBottomLeft += Int($value6)
EndSwitch
Local $pixel = StringSplit($g_iTHx & "-" & $g_iTHy, "-", 2)
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value7)
Case 3, 4
$heightTopRight += Int($value7)
Case 5, 6
$heightTopLeft += Int($value7)
Case 7, 8
$heightBottomLeft += Int($value7)
EndSwitch
EndIf
If $bForceSideExist = False Then
Local $maxValue = $heightBottomRight
Local $sidename = "BOTTOM-RIGHT"
If $heightTopLeft > $maxValue Then
$maxValue = $heightTopLeft
$sidename = "TOP-LEFT"
EndIf
If $heightTopRight > $maxValue Then
$maxValue = $heightTopRight
$sidename = "TOP-RIGHT"
EndIf
If $heightBottomLeft > $maxValue Then
$maxValue = $heightBottomLeft
$sidename = "BOTTOM-LEFT"
EndIf
SetLog("Mainside: " & $sidename & " (top-left:" & $heightTopLeft & " top-right:" & $heightTopRight & " bottom-left:" & $heightBottomLeft & " bottom-right:" & $heightBottomRight)
$MAINSIDE = $sidename
EndIf
Switch $MAINSIDE
Case "BOTTOM-RIGHT"
$FRONT_LEFT = "BOTTOM-RIGHT-DOWN"
$FRONT_RIGHT = "BOTTOM-RIGHT-UP"
$RIGHT_FRONT = "TOP-RIGHT-DOWN"
$RIGHT_BACK = "TOP-RIGHT-UP"
$LEFT_FRONT = "BOTTOM-LEFT-DOWN"
$LEFT_BACK = "BOTTOM-LEFT-UP"
$BACK_LEFT = "TOP-LEFT-DOWN"
$BACK_RIGHT = "TOP-LEFT-UP"
Case "BOTTOM-LEFT"
$FRONT_LEFT = "BOTTOM-LEFT-UP"
$FRONT_RIGHT = "BOTTOM-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-RIGHT-DOWN"
$RIGHT_BACK = "BOTTOM-RIGHT-UP"
$LEFT_FRONT = "TOP-LEFT-DOWN"
$LEFT_BACK = "TOP-LEFT-UP"
$BACK_LEFT = "TOP-RIGHT-UP"
$BACK_RIGHT = "TOP-RIGHT-DOWN"
Case "TOP-LEFT"
$FRONT_LEFT = "TOP-LEFT-UP"
$FRONT_RIGHT = "TOP-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-LEFT-UP"
$RIGHT_BACK = "BOTTOM-LEFT-DOWN"
$LEFT_FRONT = "TOP-RIGHT-UP"
$LEFT_BACK = "TOP-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-RIGHT-UP"
$BACK_RIGHT = "BOTTOM-RIGHT-DOWN"
Case "TOP-RIGHT"
$FRONT_LEFT = "TOP-RIGHT-DOWN"
$FRONT_RIGHT = "TOP-RIGHT-UP"
$RIGHT_FRONT = "TOP-LEFT-UP"
$RIGHT_BACK = "TOP-LEFT-DOWN"
$LEFT_FRONT = "BOTTOM-RIGHT-UP"
$LEFT_BACK = "BOTTOM-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-LEFT-DOWN"
$BACK_RIGHT = "BOTTOM-LEFT-UP"
EndSwitch
Case "SIDEB"
ReleaseClicks()
If $bForceSideExist = False Then
SetLog("Recalculate main side for additional defense buildings... ", $COLOR_INFO)
Switch StringLeft(Slice8($g_aiCSVEagleArtilleryPos), 1)
Case 1, 2
$heightBottomRight += Int($value1)
Case 3, 4
$heightTopRight += Int($value1)
Case 5, 6
$heightTopLeft += Int($value1)
Case 7, 8
$heightBottomLeft += Int($value1)
EndSwitch
If IsArray($g_aiCSVInfernoPos) Then
For $i = 0 To UBound($g_aiCSVInfernoPos) - 1
Local $pixel = $g_aiCSVInfernoPos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value4)
Case 3, 4
$heightTopRight += Int($value4)
Case 5, 6
$heightTopLeft += Int($value4)
Case 7, 8
$heightBottomLeft += Int($value4)
EndSwitch
EndIf
Next
EndIf
If IsArray($g_aiCSVXBowPos) Then
For $i = 0 To UBound($g_aiCSVXBowPos) - 1
Local $pixel = $g_aiCSVXBowPos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value4)
Case 3, 4
$heightTopRight += Int($value4)
Case 5, 6
$heightTopLeft += Int($value4)
Case 7, 8
$heightBottomLeft += Int($value4)
EndSwitch
EndIf
Next
EndIf
If IsArray($g_aiCSVWizTowerPos) Then
For $i = 0 To UBound($g_aiCSVWizTowerPos) - 1
Local $pixel = $g_aiCSVWizTowerPos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value4)
Case 3, 4
$heightTopRight += Int($value4)
Case 5, 6
$heightTopLeft += Int($value4)
Case 7, 8
$heightBottomLeft += Int($value4)
EndSwitch
EndIf
Next
EndIf
If IsArray($g_aiCSVMortarPos) Then
For $i = 0 To UBound($g_aiCSVMortarPos) - 1
Local $pixel = $g_aiCSVMortarPos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value4)
Case 3, 4
$heightTopRight += Int($value4)
Case 5, 6
$heightTopLeft += Int($value4)
Case 7, 8
$heightBottomLeft += Int($value4)
EndSwitch
EndIf
Next
EndIf
If IsArray($g_aiCSVAirDefensePos) Then
For $i = 0 To UBound($g_aiCSVAirDefensePos) - 1
Local $pixel = $g_aiCSVAirDefensePos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value4)
Case 3, 4
$heightTopRight += Int($value4)
Case 5, 6
$heightTopLeft += Int($value4)
Case 7, 8
$heightBottomLeft += Int($value4)
EndSwitch
EndIf
Next
EndIf
Local $maxValue = $heightBottomRight
Local $sidename = "BOTTOM-RIGHT"
If $heightTopLeft > $maxValue Then
$maxValue = $heightTopLeft
$sidename = "TOP-LEFT"
EndIf
If $heightTopRight > $maxValue Then
$maxValue = $heightTopRight
$sidename = "TOP-RIGHT"
EndIf
If $heightBottomLeft > $maxValue Then
$maxValue = $heightBottomLeft
$sidename = "BOTTOM-LEFT"
EndIf
SetLog("New Mainside: " & $sidename & " (top-left:" & $heightTopLeft & " top-right:" & $heightTopRight & " bottom-left:" & $heightBottomLeft & " bottom-right:" & $heightBottomRight, $COLOR_INFO)
$MAINSIDE = $sidename
EndIf
Switch $MAINSIDE
Case "BOTTOM-RIGHT"
$FRONT_LEFT = "BOTTOM-RIGHT-DOWN"
$FRONT_RIGHT = "BOTTOM-RIGHT-UP"
$RIGHT_FRONT = "TOP-RIGHT-DOWN"
$RIGHT_BACK = "TOP-RIGHT-UP"
$LEFT_FRONT = "BOTTOM-LEFT-DOWN"
$LEFT_BACK = "BOTTOM-LEFT-UP"
$BACK_LEFT = "TOP-LEFT-DOWN"
$BACK_RIGHT = "TOP-LEFT-UP"
Case "BOTTOM-LEFT"
$FRONT_LEFT = "BOTTOM-LEFT-UP"
$FRONT_RIGHT = "BOTTOM-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-RIGHT-DOWN"
$RIGHT_BACK = "BOTTOM-RIGHT-UP"
$LEFT_FRONT = "TOP-LEFT-DOWN"
$LEFT_BACK = "TOP-LEFT-UP"
$BACK_LEFT = "TOP-RIGHT-UP"
$BACK_RIGHT = "TOP-RIGHT-DOWN"
Case "TOP-LEFT"
$FRONT_LEFT = "TOP-LEFT-UP"
$FRONT_RIGHT = "TOP-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-LEFT-UP"
$RIGHT_BACK = "BOTTOM-LEFT-DOWN"
$LEFT_FRONT = "TOP-RIGHT-UP"
$LEFT_BACK = "TOP-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-RIGHT-UP"
$BACK_RIGHT = "BOTTOM-RIGHT-DOWN"
Case "TOP-RIGHT"
$FRONT_LEFT = "TOP-RIGHT-DOWN"
$FRONT_RIGHT = "TOP-RIGHT-UP"
$RIGHT_FRONT = "TOP-LEFT-UP"
$RIGHT_BACK = "TOP-LEFT-DOWN"
$LEFT_FRONT = "BOTTOM-RIGHT-UP"
$LEFT_BACK = "BOTTOM-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-LEFT-DOWN"
$BACK_RIGHT = "BOTTOM-LEFT-UP"
EndSwitch
Case Else
Switch StringLeft($command, 1)
Case ";", "#", "'"
debugAttackCSV("comment line")
Case Else
SetLog("attack row bad, discard: row " & $iLine + 1, $COLOR_ERROR)
EndSwitch
EndSwitch
Else
If StringLeft($line, 7) <> "NOTE  |" And StringLeft($line, 7) <> "      |" And StringStripWS(StringUpper($line), 2) <> "" Then SetLog("attack row error, discard: row " & $iLine + 1, $COLOR_ERROR)
EndIf
If $bWardenDrop = True Then
Local $bHold = $g_bCheckWardenPower
$g_bCheckWardenPower = False
CheckHeroesHealth()
$g_bCheckWardenPower = $bHold
Else
CheckHeroesHealth()
EndIf
If _Sleep($DELAYRESPOND) Then Return
Next
ReleaseClicks()
Else
SetLog("Cannot find attack file " & $g_sCSVAttacksPath & "\" & $filename & ".csv", $COLOR_ERROR)
EndIf
EndFunc
Func ParseAttackCSV_Read_SIDE_variables()
$g_bCSVLocateMine = False
$g_bCSVLocateElixir = False
$g_bCSVLocateDrill = False
$g_bCSVLocateStorageGold = False
$g_bCSVLocateStorageElixir = False
$g_bCSVLocateStorageDarkElixir = False
$g_bCSVLocateStorageTownHall = False
$g_bCSVLocateEagle = False
$g_bCSVLocateInferno = False
$g_bCSVLocateXBow = False
$g_bCSVLocateWizTower = False
$g_bCSVLocateMortar = False
$g_bCSVLocateAirDefense = False
If $g_iMatchMode = $DB Then
Local $filename = $g_sAttackScrScriptName[$DB]
Else
Local $filename = $g_sAttackScrScriptName[$LB]
EndIf
Local $f, $line, $acommand, $command
Local $value1, $value2, $value3, $value4, $value5, $value6, $value7, $value8, $value9
Local $bForceSideExist = False
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
Local $aLines = FileReadToArray($g_sCSVAttacksPath & "\" & $filename & ".csv")
If @error Then
SetLog("Attack CSV script not found: " & $g_sCSVAttacksPath & "\" & $filename & ".csv", $COLOR_ERROR)
Return
EndIf
For $iLine = 0 To UBound($aLines) - 1
$line = $aLines[$iLine]
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), $STR_STRIPTRAILING)
If $command <> "SIDE" And $command <> "SIDEB" And $command <> "MAKE" Then ContinueLoop
$value1 = StringStripWS(StringUpper($acommand[2]), $STR_STRIPTRAILING)
$value2 = StringStripWS(StringUpper($acommand[3]), $STR_STRIPTRAILING)
$value3 = StringStripWS(StringUpper($acommand[4]), $STR_STRIPTRAILING)
$value4 = StringStripWS(StringUpper($acommand[5]), $STR_STRIPTRAILING)
$value5 = StringStripWS(StringUpper($acommand[6]), $STR_STRIPTRAILING)
$value6 = StringStripWS(StringUpper($acommand[7]), $STR_STRIPTRAILING)
$value7 = StringStripWS(StringUpper($acommand[8]), $STR_STRIPTRAILING)
$value8 = StringStripWS(StringUpper($acommand[9]), $STR_STRIPTRAILING)
$value9 = StringStripWS(StringUpper($acommand[10]), $STR_STRIPTRAILING)
If $command = "SIDE" And StringUpper($value8) = "TOP-LEFT" Or StringUpper($value8) = "TOP-RIGHT" Or StringUpper($value8) = "BOTTOM-LEFT" Or StringUpper($value8) = "BOTTOM-RIGHT" Then
$bForceSideExist = True
EndIf
Switch $command
Case "SIDE"
If $bForceSideExist = False Then
If Int($value1) > 0 Then $g_bCSVLocateMine = True
If Int($value2) > 0 Then $g_bCSVLocateElixir = True
If Int($value3) > 0 Then $g_bCSVLocateDrill = True
If Int($value4) > 0 Then $g_bCSVLocateStorageGold = True
If Int($value5) > 0 Then $g_bCSVLocateStorageElixir = True
If Int($value6) > 0 Then $g_bCSVLocateStorageDarkElixir = True
If Int($value7) > 0 Then $g_bCSVLocateStorageTownHall = True
EndIf
Case "SIDEB"
If $bForceSideExist = False Then
If Int($value1) > 0 Then $g_bCSVLocateEagle = True
If Int($value2) > 0 Then $g_bCSVLocateInferno = True
If Int($value3) > 0 Then $g_bCSVLocateXBow = True
If Int($value4) > 0 Then $g_bCSVLocateWizTower = True
If Int($value5) > 0 Then $g_bCSVLocateMortar = True
If Int($value6) > 0 Then $g_bCSVLocateAirDefense = True
EndIf
Case "MAKE"
If StringLen(StringStripWS($value8, $STR_STRIPALL)) > 0 Then
Switch $value8
Case "TOWNHALL"
$g_bCSVLocateStorageTownHall = True
Case "EAGLE"
$g_bCSVLocateEagle = True
Case "INFERNO"
$g_bCSVLocateInferno = True
Case "XBOW"
$g_bCSVLocateXBow = True
Case "WIZTOWER"
$g_bCSVLocateWizTower = True
Case "MORTAR"
$g_bCSVLocateMortar = True
Case "AIRDEFENSE"
$g_bCSVLocateAirDefense = True
Case Else
SetDebugLog("Invalid MAKE building target name: " & $value8, $COLOR_WARNING)
debugAttackCSV("Invalid MAKE building target name: " & $value8)
EndSwitch
debugAttackCSV("SIDE Parse MAKE target building= " & $value8)
EndIf
EndSwitch
EndIf
Next
Else
SetLog("Cannot find attack file " & $g_sCSVAttacksPath & "\" & $filename & ".csv", $COLOR_ERROR)
EndIf
EndFunc
Func Slice8($pixel)
If UBound($pixel) < 2 Then Return "0_NO_ARRAY"
Local $Left = $ExternalArea[0][0]
Local $Right = $ExternalArea[1][0]
Local $Top = $ExternalArea[2][1]
Local $Bottom = $ExternalArea[3][1]
Local $LeftY = $ExternalArea[0][1]
Local $RightY = $ExternalArea[1][1]
Local $TopX = $ExternalArea[2][0]
Local $BottomX = $ExternalArea[3][0]
Local $TLX = $ExternalArea[4][0]
Local $TLY = $ExternalArea[4][1]
Local $TRX = $ExternalArea[5][0]
Local $TRY = $ExternalArea[5][1]
Local $BLX = $ExternalArea[6][0]
Local $BLY = $ExternalArea[6][1]
Local $BRX = $ExternalArea[7][0]
Local $BRY = $ExternalArea[7][1]
Local $isIn = 1.01
If $pixel[0] < $Left Or $pixel[0] > $Right Or $pixel[1] < $Top Or $pixel[1] > $Bottom Then
Return "0_O"
Else
If $pixel[0] <= $TopX Then
If $pixel[1] <= $LeftY Then
If $pixel[0] <= $TLX Then
If($TLX - $pixel[0]) /($TLX - $Left) +($LeftY - $pixel[1]) /($LeftY - $TLY) <= $isIn Then
Return "6E"
Else
Return "0_6E"
EndIf
Else
If($pixel[0] - $TLX) /($TopX - $TLX) +($LeftY - $pixel[1]) /($LeftY - $TLY) <= $isIn Then
Return "6_I"
Else
If($TopX - $pixel[0]) /($TopX - $TLX) + Abs($TLY - $pixel[1]) /($LeftY - $TLY) <= $isIn Then
If $pixel[1] <= $TLY Then
Return "5_E"
Else
Return "5_I"
EndIf
Else
Return "O_5"
EndIf
EndIf
EndIf
Else
If $pixel[0] <= $BLX Then
If($BLX - $pixel[0]) /($BLX - $Left) +($pixel[1] - $LeftY) /($BLY - $LeftY) <= $isIn Then
Return "7_E"
Else
Return "0_7"
EndIf
Else
If($pixel[0] - $BLX) /($TopX - $BLX) +($pixel[1] - $LeftY) /($BLY - $LeftY) <= $isIn Then
Return "7_I"
Else
If($TopX - $pixel[0]) /($TopX - $BLX) + Abs($BLY - $pixel[1]) /($BLY - $LeftY) <= $isIn Then
If $pixel[1] <= $BLY Then
Return "8_I"
Else
Return "8_E"
EndIf
Else
Return "0_8"
EndIf
EndIf
EndIf
EndIf
Else
If $pixel[1] <= $RightY Then
If $pixel[0] > $TRX Then
If($pixel[0] - $TRX) /($Right - $TRX) +($RightY - $pixel[1]) /($RightY - $TRY) <= $isIn Then
Return "3_E"
Else
Return "0_3"
EndIf
Else
If($TRX - $pixel[0]) /($TRX - $TopX) +($RightY - $pixel[1]) /($RightY - $TRY) <= $isIn Then
Return "3_I"
Else
If($pixel[0] - $TopX) /($TRX - $TopX) + Abs($TRY - $pixel[1]) /($RightY - $TRY) <= $isIn Then
If $pixel[1] <= $TRY Then
Return "4_E"
Else
Return "4_I"
EndIf
Else
Return "0_4"
EndIf
EndIf
EndIf
Else
If $pixel[0] > $BRX Then
If($pixel[0] - $BRX) /($Right - $BRX) +($pixel[1] - $RightY) /($BRY - $RightY) <= $isIn Then
Return "2_E"
Else
Return "0_2"
EndIf
Else
If($BRX - $pixel[0]) /($BRX - $BottomX) +($pixel[1] - $RightY) /($BRY - $RightY) <= $isIn Then
Return "2_I"
Else
If($pixel[0] - $BottomX) /($BRX - $BottomX) + Abs($BRY - $pixel[1]) /($BRY - $RightY) <= $isIn Then
If $pixel[1] <= $BRY Then
Return "1_I"
Else
Return "1_E"
EndIf
Else
Return "0_1"
EndIf
EndIf
EndIf
EndIf
EndIf
EndIf
EndFunc
Func CleanRedArea(ByRef $InputVect, $side = "")
Local $TempVectStr = ""
For $i = 0 To UBound($InputVect) - 1
Local $pixel = $InputVect[$i]
If isInsideDiamondRedArea($pixel) Then
$TempVectStr &= $pixel[0] & "-" & $pixel[1] & "|"
Else
debugAttackCSV("CleanRedArea removed (" & $pixel[0] & "," & $pixel[1] & ")")
EndIf
Next
If StringLen($TempVectStr) > 0 Then
$TempVectStr = StringLeft($TempVectStr, StringLen($TempVectStr) - 1)
$InputVect = GetListPixel($TempVectStr)
EndIf
EndFunc
Func ChkAttackCSVConfig()
If Not(FileExists($g_sCSVAttacksPath & "\" & $g_sAttackScrScriptName[$DB] & ".csv")) Then
SetLog("Dead base scripted attack file do not exists (renamed, deleted?)", $COLOR_ERROR)
SetLog("Please select a new scripted algorithm from 'scripted attack' tab", $COLOR_ERROR)
PopulateComboScriptsFilesDB()
btnStop()
EndIf
If Not(FileExists($g_sCSVAttacksPath & "\" & $g_sAttackScrScriptName[$LB] & ".csv")) Then
SetLog("Dead base scripted attack file do not exists (renamed, deleted?)", $COLOR_ERROR)
SetLog("Please select a new scripted algorithm from 'scripted attack' tab", $COLOR_ERROR)
PopulateComboScriptsFilesAB()
btnStop()
EndIf
EndFunc
Func ParseAttackCSV_Settings_variables(ByRef $aiCSVTroops, ByRef $aiCSVSpells, ByRef $aiCSVHeros, ByRef $iCSVRedlineRoutineItem, ByRef $iCSVDroplineEdgeItem, ByRef $sCSVCCReq, $sFilename)
If $g_bDebugAttackCSV Then SetLog("ParseAttackCSV_Settings_variables()", $COLOR_DEBUG)
Local $asCommand
If FileExists($g_sCSVAttacksPath & "\" & $sFilename & ".csv") Then
Local $asLine = FileReadToArray($g_sCSVAttacksPath & "\" & $sFilename & ".csv")
If @error Then
SetLog("Attack CSV script not found: " & $g_sCSVAttacksPath & "\" & $sFilename & ".csv", $COLOR_ERROR)
Return
EndIf
Local $sLine
Local $iTHCol = 0, $iTH = 0
Local $iTroopIndex, $iFlexTroopIndex = 999
Local $iCommandCol = 1, $iTroopNameCol = 2, $iFlexCol = 3, $iTHBeginCol = 4
Local $iHeroRadioItemTotal = 3, $iHeroTimedLimit = 99
For $iLine = 0 To UBound($asLine) - 1
$sLine = $asLine[$iLine]
$asCommand = StringSplit($sLine, "|")
If $asCommand[0] >= 8 Then
$asCommand[$iCommandCol] = StringStripWS(StringUpper($asCommand[$iCommandCol]), $STR_STRIPTRAILING)
If $asCommand[$iCommandCol] <> "TRAIN" And $asCommand[$iCommandCol] <> "REDLN" And $asCommand[$iCommandCol] <> "DRPLN" And $asCommand[$iCommandCol] <> "CCREQ" Then ContinueLoop
If $iTHCol = 0 Then
If $g_bDebugAttackCSV Then SetLog("Camp Total Space: " & $g_iTotalCampSpace, $COLOR_DEBUG)
If $g_bDebugAttackCSV Then SetLog("Spell Total Space: " & $g_iTotalSpellValue, $COLOR_DEBUG)
If $g_iTotalCampSpace = 0 Then
SetLog("Has to run bot once first to get correct total camp space", $COLOR_ERROR)
Return
EndIf
If $g_iTotalSpellValue = 0 Then
SetLog("Has to set spell capacity first", $COLOR_ERROR)
Return
EndIf
Switch $g_iTotalCampSpace
Case $g_iMaxCapTroopTH[11] + 5 To $g_iMaxCapTroopTH[12]
$iTHCol = $iTHBeginCol + 6
$iTH = 12
Case $g_iMaxCapTroopTH[10] + 5 To $g_iMaxCapTroopTH[11]
$iTHCol = $iTHBeginCol + 5
$iTH = 11
Case $g_iMaxCapTroopTH[9] + 5 To $g_iMaxCapTroopTH[10]
$iTHCol = $iTHBeginCol + 4
$iTH = 10
Case $g_iMaxCapTroopTH[8] + 5 To $g_iMaxCapTroopTH[9]
$iTHCol = $iTHBeginCol + 3
$iTH = 9
Case $g_iMaxCapTroopTH[6] + 5 To $g_iMaxCapTroopTH[8]
Switch $g_iTotalSpellValue
Case $g_iMaxCapSpellTH[7] + 1 To $g_iMaxCapSpellTH[8]
$iTHCol = $iTHBeginCol + 2
$iTH = 8
Case $g_iMaxCapSpellTH[6] + 1 To $g_iMaxCapSpellTH[7]
$iTHCol = $iTHBeginCol + 1
$iTH = 7
Case Else
SetLog("Invalid spell size ( <" & $g_iMaxCapSpellTH[6] + 1 & " or >" & $g_iMaxCapSpellTH[8] & " ): " & $g_iTotalSpellValue & " for CSV", $COLOR_ERROR)
Return
EndSwitch
Case $g_iMaxCapTroopTH[5] + 5 To $g_iMaxCapTroopTH[6]
$iTHCol = $iTHBeginCol
$iTH = 6
Case Else
SetLog("Invalid camp size ( <" & $g_iMaxCapTroopTH[5] + 5 & " or >" & $g_iMaxCapTroopTH[11] & " ): " & $g_iTotalCampSpace & " for CSV", $COLOR_ERROR)
Return
EndSwitch
EndIf
If $g_bDebugAttackCSV Then SetLog("Line: " & $iLine + 1 & " Command: " & $asCommand[$iCommandCol] &($iTHCol >= $iTHBeginCol ? " Column: " & $iTHCol & " TH" & $iTH : ""), $COLOR_DEBUG)
For $i = 2 To(UBound($asCommand) - 1)
$asCommand[$i] = StringStripWS($asCommand[$i], $STR_STRIPTRAILING)
Next
Switch $asCommand[$iCommandCol]
Case "TRAIN"
$iTroopIndex = TroopIndexLookup($asCommand[$iTroopNameCol], "ParseAttackCSV_Settings_variables")
If $iTroopIndex = -1 Then
SetLog("CSV troop name '" & $asCommand[$iTroopNameCol] & "' is unrecognized - Line: " & $iLine + 1, $COLOR_ERROR)
ContinueLoop
EndIf
If int($asCommand[$iTHCol]) <= 0 Then
If $asCommand[$iTHCol] <> "0" Then SetLog("CSV troop amount/setting '" & $asCommand[$iTHCol] & "' is unrecognized - Line: " & $iLine + 1, $COLOR_ERROR)
ContinueLoop
EndIf
Switch $iTroopIndex
Case $eBarb To $eBowl
$aiCSVTroops[$iTroopIndex] = int($asCommand[$iTHCol])
If int($asCommand[$iFlexCol]) > 0 Then $iFlexTroopIndex = $iTroopIndex
Case $eLSpell To $eSkSpell
$aiCSVSpells[$iTroopIndex - $eLSpell] = int($asCommand[$iTHCol])
Case $eKing To $eWarden
Local $iHeroRadioItem = int(StringLeft($asCommand[$iTHCol], 1))
Local $iHeroTimed = Int(StringTrimLeft($asCommand[$iTHCol], 1))
If $iHeroRadioItem <= 0 Or $iHeroRadioItem > $iHeroRadioItemTotal Or $iHeroTimed < 0 Or $iHeroTimed > $iHeroTimedLimit Then
SetLog("CSV hero ability setting '" & $asCommand[$iTHCol] & "' is unrecognized - Line: " & $iLine + 1, $COLOR_ERROR)
ContinueLoop
EndIf
$aiCSVHeros[$iTroopIndex - $eKing][0] = $iHeroRadioItem
$aiCSVHeros[$iTroopIndex - $eKing][1] = $iHeroTimed * 1000
EndSwitch
If $g_bDebugAttackCSV Then SetLog("Train " & $asCommand[$iTHCol] & "x " & $asCommand[$iTroopNameCol], $COLOR_DEBUG)
Case "REDLN"
$iCSVRedlineRoutineItem = int($asCommand[$iTHCol])
If $g_bDebugAttackCSV Then SetLog("Redline ComboBox #" &($iCSVRedlineRoutineItem > 0 ? $iCSVRedlineRoutineItem : "None"), $COLOR_DEBUG)
Case "DRPLN"
$iCSVDroplineEdgeItem = int($asCommand[$iTHCol])
If $g_bDebugAttackCSV Then SetLog("Dropline ComboBox #" &($iCSVDroplineEdgeItem > 0 ? $iCSVDroplineEdgeItem : "None"), $COLOR_DEBUG)
Case "CCREQ"
$sCSVCCReq = $asCommand[$iTHCol]
If $g_bDebugAttackCSV Then SetLog("CC Request: " & $sCSVCCReq, $COLOR_DEBUG)
EndSwitch
EndIf
Next
If $iTHCol >= $iTHBeginCol Then
Local $iCSVTotalCapTroops = 0, $bTotalInRange = False
For $i = 0 To UBound($aiCSVTroops) - 1
$iCSVTotalCapTroops += $aiCSVTroops[$i] * $g_aiTroopSpace[$i]
Next
If $g_bDebugAttackCSV Then SetLog("CSV troop total: " & $iCSVTotalCapTroops, $COLOR_DEBUG)
If $iCSVTotalCapTroops > 0 Then
If $iTH = 8 Then
If $iCSVTotalCapTroops > $g_iMaxCapTroopTH[$iTH - 2] And $iCSVTotalCapTroops <= $g_iMaxCapTroopTH[$iTH] Then $bTotalInRange = True
Else
If $iCSVTotalCapTroops > $g_iMaxCapTroopTH[$iTH - 1] And $iCSVTotalCapTroops <= $g_iMaxCapTroopTH[$iTH] Then $bTotalInRange = True
EndIf
If $bTotalInRange Then
If $iCSVTotalCapTroops <> $g_iTotalCampSpace Then
Local $iDiff = $iCSVTotalCapTroops - $g_iTotalCampSpace
If $g_bDebugAttackCSV Then SetLog("Camp Total Space: " & $g_iTotalCampSpace, $COLOR_DEBUG)
If $g_bDebugAttackCSV Then SetLog("Difference: " & $iDiff, $COLOR_DEBUG)
If $g_bDebugAttackCSV Then SetLog("Flexible Index: " & $iFlexTroopIndex, $COLOR_DEBUG)
If $iFlexTroopIndex <> 999 And Mod($iDiff, $g_aiTroopSpace[$iFlexTroopIndex]) = 0 Then
Local $iCSVTroopAmount = $aiCSVTroops[$iFlexTroopIndex]
$aiCSVTroops[$iFlexTroopIndex] -= $iDiff / $g_aiTroopSpace[$iFlexTroopIndex]
SetLog("Adjust CSV Train Troop - " & GetTroopName($iFlexTroopIndex) & " amount from " & $iCSVTroopAmount & " to " & $aiCSVTroops[$iFlexTroopIndex], $COLOR_SUCCESS)
Else
SetLog("CSV Troop Total does not equal to Camp Total Space,", $COLOR_ERROR)
SetLog("adjust train settings manually", $COLOR_ERROR)
For $i = 0 to UBound($aiCSVTroops) - 1
$aiCSVTroops[$i] = 0
Next
EndIf
EndIf
Else
SetLog("CSV troops total: " & $iCSVTotalCapTroops & " for TH" & $iTH & " is out of range", $COLOR_ERROR)
For $i = 0 to UBound($aiCSVTroops) - 1
$aiCSVTroops[$i] = 0
Next
EndIf
EndIf
EndIf
Else
SetLog("Cannot find attack file " & $g_sCSVAttacksPath & "\" & $sFilename & ".csv", $COLOR_ERROR)
Return
EndIf
Return 1
EndFunc
Func Alogrithm_MilkingAttack()
If $g_bTHSnipeBeforeEnable[$DB] And $g_iSearchTH = "-" Then FindTownHall(True)
If $g_bTHSnipeBeforeEnable[$DB] Then
If $g_iSearchTH <> "-" Then
If SearchTownHallLoc() Then
SetLogCentered(" TH snipe Before Milking ", Default, $COLOR_INFO)
$g_bTHSnipeUsedKing = False
$g_bTHSnipeUsedQueen = False
AttackTHParseCSV()
Else
SetLog("TH snipe Before Milking skip, TH inside village", $COLOR_INFO)
EndIf
Else
SetLog("TH snipe Before Milking skip, no th detected", $COLOR_INFO)
EndIf
EndIf
$g_bDuringMilkingAttack = True
Local $hTimerTOTAL = __TimerInit()
SetLogCentered(" Milking Attack ", Default, $COLOR_INFO)
If StringLen($g_sMilkFarmObjectivesSTR) > 0 Then
Local $vect = StringSplit($g_sMilkFarmObjectivesSTR, "|", 2)
If $g_bDebugSetlog Then SetDebugLog("MilkFarmObjectivesSTR = <" & $g_sMilkFarmObjectivesSTR & ">.. UBOUND=" & UBound($vect))
If UBound($vect) > 0 Then
If StringLen($vect[0]) > 0 Then
If $g_bDebugSetlog Then SetDebugLog(">Structures to attack: (" & UBound($vect) & ")", $COLOR_DEBUG)
For $i = 0 To UBound($vect) - 1
If $g_bDebugSetlog Then SetDebugLog("> " & $i & " " & $vect[$i], $COLOR_DEBUG)
Next
MilkFarmObjectivesDebugImage($g_sMilkFarmObjectivesSTR, 0)
Local $troopPosition = -1
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][1] <> -1 Then
If $g_avAttackTroops[$i][0] = $eGobl Then
If $g_bDebugSetlog Then SetDebugLog("-*-" & $g_avAttackTroops[$i][0] & " " & NameOfTroop($g_avAttackTroops[$i][0]) & " " & $g_avAttackTroops[$i][1] & " <<---" & $eGobl, $COLOR_SUCCESS)
$troopPosition = $i
Else
If $g_bDebugSetlog Then SetDebugLog("-*-" & $g_avAttackTroops[$i][0] & " " & NameOfTroop($g_avAttackTroops[$i][0]) & " " & $g_avAttackTroops[$i][1] & "", $COLOR_GRAY)
EndIf
EndIf
Next
If $troopPosition >= 0 Then
SelectDropTroop($troopPosition)
If UBound($vect) > 2 Then
Switch $g_iMilkingAttackStructureOrder
Case 1
Local $rnd = _RandomUnique(UBound($vect) - 1, 0, UBound($vect) - 2, 1)
For $i = 0 To UBound($rnd) - 1
If $g_bDebugSetlog Then SetDebugLog("random vect pos " & $i & " value " & $rnd[$i], $COLOR_DEBUG)
Next
Case 2
Local $rnd = _OrderBySideObjectives($vect)
For $i = 0 To UBound($rnd) - 1
If $g_bDebugSetlog Then SetDebugLog("order by side vect pos " & $i & " value " & $rnd[$i], $COLOR_DEBUG)
Next
Case Else
Local $tmpstr = ""
For $k = 0 To UBound($vect) - 1
$tmpstr &= $k & "-"
Next
$tmpstr = StringLeft($tmpstr, StringLen($tmpstr) - 1)
Local $rnd = StringSplit($tmpstr, "-", 2)
For $i = 0 To UBound($rnd) - 1
If $g_bDebugSetlog Then SetDebugLog("as found vect pos " & $i & " value " & $rnd[$i], $COLOR_DEBUG)
Next
EndSwitch
For $i = 0 To UBound($rnd) - 1
Local $vect2 = StringSplit($vect[$i], ".", 2)
If UBound($vect2) > 1 Then
If $g_bDebugSetlog Then SetDebugLog($i & "- Attack structure n. " & $rnd[$i] + 1 & "/" & UBound($vect) & " - " & $vect2[0], $COLOR_DEBUG)
If UBound($vect) > $rnd[$i] Then
MilkingAttackStructure($vect[$rnd[$i]])
Else
If $g_bDebugSetlog Then SetDebugLog($i & " range exceeded of $vect!")
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("Error @18")
EndIf
Next
EndIf
If UBound($vect) = 2 Then
For $i = 0 To 1
If $g_bDebugSetlog Then SetDebugLog($i & "- Attack structure n. " & $i & "/1 ", $COLOR_DEBUG)
MilkingAttackStructure($vect[$i])
Next
EndIf
If UBound($vect) = 1 Then
If $g_bDebugSetlog Then SetDebugLog($i & "- Attack structure n. 0/0 ", $COLOR_DEBUG)
MilkingAttackStructure($vect[0])
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("No Goblins left ")
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("No structures to attack...")
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("No structures to attack..")
EndIf
Else
SetLog("No structures to attack, skip attack structures!")
EndIf
If $g_bMilkAttackAfterTHSnipeEnable Then
FindTownHall(True)
If $g_iSearchTH <> "-" Then
If SearchTownHallLoc() Then
$g_iMatchMode = $TS
SetLogCentered(" Attack TH snipe after Milking Attack ", Default, $COLOR_INFO)
If $g_bMilkAttackAfterScriptedAtkEnable = False Then
PrepareAttack($g_iMatchMode, True)
algorithm_AllTroops()
Else
SetSlotSpecialTroops()
$g_bTHSnipeUsedKing = False
$g_bTHSnipeUsedQueen = False
AttackTHParseCSV()
EndIf
Else
SetLog("TH it is not outside, skip attack", $COLOR_INFO)
EndIf
Else
SetLog("Cannot detect Townhall, skip THsnipe after Milking", $COLOR_INFO)
EndIf
EndIf
If $g_bMilkAttackAfterScriptedAtkEnable Then
SetLogCentered("Scripted Attack after Miliking ", Default, $COLOR_INFO)
Algorithm_AttackCSV(False, False)
EndIf
$g_bDuringMilkingAttack = False
EndFunc
Func _OrderBySideObjectives($vect)
Local $slice1 = ""
Local $slice2 = ""
Local $slice3 = ""
Local $slice4 = ""
Local $slice5 = ""
Local $slice6 = ""
Local $slice7 = ""
Local $slice8 = ""
For $j = 0 To UBound($vect) - 1
Local $structure = StringSplit($vect[$j], ".", 2)
Local $pixel = StringSplit($structure[2], "-", 2)
Switch StringLeft(Slice8($pixel), 1)
Case 1
$slice1 &= $j & "-"
Case 2
$slice2 &= $j & "-"
Case 3
$slice3 &= $j & "-"
Case 4
$slice4 &= $j & "-"
Case 5
$slice5 &= $j & "-"
Case 6
$slice6 &= $j & "-"
Case 7
$slice7 &= $j & "-"
Case Else
$slice8 &= $j & "-"
EndSwitch
Next
Local $result
If $slice7 <> "" Then $result &= $slice7
If $slice8 <> "" Then $result &= $slice8
If $slice1 <> "" Then $result &= $slice1
If $slice2 <> "" Then $result &= $slice2
If $slice3 <> "" Then $result &= $slice3
If $slice4 <> "" Then $result &= $slice4
If $slice5 <> "" Then $result &= $slice5
If $slice6 <> "" Then $result &= $slice6
$result = StringLeft($result, StringLen($result) - 1)
Return StringSplit($result, "-", 2)
EndFunc
Func AmountOfResourcesInStructure($type, $coordinate, $level)
Switch $type
Case "elixir"
If $level <= 8 And $level >= 0 Then
Local $temp = Int($g_aiMilkFarmElixirParam[$level])
If $temp > 0 Then
If $g_iMilkAttackType = 0 Then
Local $capacity = DetectAmountOfResourceInStructure($type, $coordinate, $level, $temp)
If $capacity >= $temp Then
If $g_bDebugSetlog Then SetDebugLog("elixir " & $type & " " & $coordinate & " " & $level & " " & $capacity, $COLOR_DEBUG)
Return True
Else
If $g_bDebugSetlog Then SetDebugLog("Discard, capacity of structure under settings:  liv " & $level & " cap " & $temp & " detected " & $capacity, $COLOR_DEBUG)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("elixir " & $type & " " & $coordinate & " " & $level & " PASSED LOW CPU SETTINGS", $COLOR_DEBUG)
Return True
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("Discard, level settings discard this structure (requested min. " & Int($g_aiMilkFarmElixirParam[$level]) & ")", $COLOR_DEBUG)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("Discard, out of bounds", $COLOR_DEBUG)
EndIf
Return False
Case "mine"
If $level <= 8 And $level >= 0 Then
If $level >= $g_iMilkFarmMineParam Then
Return True
Else
If $g_bDebugSetlog Then SetDebugLog("Discard, level settings discard this structure (level=" & $level & ",filter=" & $g_iMilkFarmMineParam & ")", $COLOR_DEBUG)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("Discard, out of bounds", $COLOR_DEBUG)
EndIf
Return False
Case "drill"
If $level <= 6 And $level >= 1 Then
If $level >= $g_iMilkFarmDrillParam Then
Return True
Else
If $g_bDebugSetlog Then SetDebugLog("Discard, level settings discard this structure (level=" & $level & ",filter=" & $g_iMilkFarmDrillParam & ")", $COLOR_DEBUG)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("Discard, out of bounds", $COLOR_DEBUG)
EndIf
Return False
Case Else
Return False
EndSwitch
EndFunc
Func DetectAmountOfResourceInStructure($type, $coordinate, $level, $mincapacity)
If $type = "elixir" Then
Local $tolerance
Local $posx, $posy
Local $filename
Local $endoffilename
_CaptureRegion($coordinate[0] - 10, $coordinate[1] - 10, $coordinate[0] + 10, $coordinate[1] + 20)
Local $found = 0
For $t = UBound($g_asCapacityStructureElixir[$level]) - 1 To 1 Step -1
Local $a = $g_asCapacityStructureElixir[$level]
$filename = $a[$t]
Local $capacityanalized = StringMid($filename, StringInStr($filename, "_", 0, 2) + 1, StringInStr($filename, "_", 0, 3) - StringInStr($filename, "_", 0, 2) - 1)
$tolerance = StringMid($filename, StringInStr($filename, "_", 0, 3) + 1, StringInStr($filename, "_", 0, 4) - StringInStr($filename, "_", 0, 3) - 1)
If $g_bMilkFarmForceToleranceEnable Then
$endoffilename = StringMid($filename, StringInStr($filename, "_", 0, 4) + 1, 1)
If $endoffilename = "Z" Then
$tolerance = $g_iMilkFarmForceToleranceBoosted
Else
$tolerance = $g_iMilkFarmForceToleranceNormal
EndIf
EndIf
If $capacityanalized < $mincapacity And Not $g_bDebugContinueSearchElixir Then
If $g_bDebugSetlog Then SetDebugLog("IMAGECKECK STOP, capacity < mincapacity " & $filename, $COLOR_DEBUG)
Return -1
ExitLoop
Else
$found = _ImageSearch(@ScriptDir & "\images\CapacityStructure\" & $a[$t], 1, $posx, $posy, $tolerance)
If $found = 1 Then
If $g_bDebugSetlog Then SetDebugLog("IMAGECKECK OK (" & $tolerance & ") " & $filename, $COLOR_DEBUG)
If $g_bDebugImageSave Then DebugImageSave("IMAGECKECK OK (" & $tolerance & ") " & $filename, False)
Return $capacityanalized
ExitLoop
EndIf
EndIf
Next
If $found = 0 Then
If $g_bDebugImageSave Then DebugImageSave("elixir_" & $level & "_", False)
If $g_bDebugSetlog Then SetDebugLog("FAIL STRUCTURE POSITION (" & $coordinate[0] & "," & $coordinate[1] & ") level " & $level & " (" & $level + 4 & ")", $COLOR_DEBUG)
EndIf
Return -1
Else
Return -1
EndIf
EndFunc
Func MilkFarmObjectivesSTR_INSERT($type, $level, $coordinate)
Local $ResourceToInsertQty = 0
Local $ResourceToInsert = ""
$ResourceToInsert = $type
$ResourceToInsert &= "." & $level
$ResourceToInsert &= "." & $coordinate
Local $pixel = StringSplit($coordinate, "-", 2)
Local $diamondx = $g_iMilkFarmOffsetX + $g_iMilkFarmOffsetXStep * $g_iMilkFarmResMaxTilesFromBorder
Local $diamondy = $g_iMilkFarmOffsetY + $g_iMilkFarmOffsetYStep * $g_iMilkFarmResMaxTilesFromBorder
If UBound($pixel) = 2 Then
Switch $type
Case "gomine"
Local $px = StringSplit($g_asMilkFarmOffsetMine[$level], "-", 2)
Case "elixir"
Local $px = StringSplit($g_asMilkFarmOffsetElixir[$level], "-", 2)
Case "ddrill"
Local $px = StringSplit($g_asMilkFarmOffsetDark[$level], "-", 2)
Case Else
Local $px = StringSplit("0-0", "-", 2)
EndSwitch
$pixel[0] += $px[0]
$pixel[1] += $px[1]
Local $vector = $g_aiPixelTopLeft
For $i = 0 To UBound($vector) - 1
Local $pixel2 = $vector[$i]
If UBound($pixel2) = 2 Then
If Abs(($pixel[0] - $pixel2[0]) / $diamondx) + Abs(($pixel[1] - $pixel2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixel2[0] & "-" & $pixel2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("MilkFarmObjectivesSTR_INSERT Discard error #3", $COLOR_ERROR)
EndIf
Next
Local $vector = $g_aiPixelTopRight
For $i = 0 To UBound($vector) - 1
Local $pixel2 = $vector[$i]
If UBound($pixel2) = 2 Then
If Abs(($pixel[0] - $pixel2[0]) / $diamondx) + Abs(($pixel[1] - $pixel2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixel2[0] & "-" & $pixel2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("MilkFarmObjectivesSTR_INSERT Discard error #3", $COLOR_ERROR)
EndIf
Next
Local $vector = $g_aiPixelBottomLeft
For $i = 0 To UBound($vector) - 1
Local $pixel2 = $vector[$i]
If UBound($pixel2) = 2 Then
If Abs(($pixel[0] - $pixel2[0]) / $diamondx) + Abs(($pixel[1] - $pixel2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixel2[0] & "-" & $pixel2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("MilkFarmObjectivesSTR_INSERT Discard error #3", $COLOR_ERROR)
EndIf
Next
Local $vector = $g_aiPixelBottomRight
For $i = 0 To UBound($vector) - 1
Local $pixel2 = $vector[$i]
If UBound($pixel2) = 2 Then
If Abs(($pixel[0] - $pixel2[0]) / $diamondx) + Abs(($pixel[1] - $pixel2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixel2[0] & "-" & $pixel2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("MilkFarmObjectivesSTR_INSERT Discard error #3", $COLOR_ERROR)
EndIf
Next
If $ResourceToInsertQty > 0 Then
If StringLen($g_sMilkFarmObjectivesSTR) > 0 Then $g_sMilkFarmObjectivesSTR &= "|"
$g_sMilkFarmObjectivesSTR &= $ResourceToInsert
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("MilkFarmObjectivesSTR_INSERT Discard error #1 " & $pixel & " " & UBound($pixel), $COLOR_ERROR)
EndIf
Return $ResourceToInsertQty
EndFunc
Func LoadAmountOfResourcesImages()
Local $x
Local $useImages = "*.bmp"
For $t = 0 To 8
$g_asCapacityStructureElixir[$t] = StringSplit("", "")
$x = _FileListToArrayRec(@ScriptDir & "\images\CapacityStructure\", "elixir_" & $t & $useImages, $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($x) > 0 Then $g_asCapacityStructureElixir[$t] = $x
Next
For $t = 0 To 8
$g_asDestroyedMineIMG[$t] = StringSplit("", "")
$x = _FileListToArrayRec(@ScriptDir & "\images\CapacityStructure\", "destroyed_mine_" & $t & $useImages, $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($x) > 0 Then $g_asDestroyedMineIMG[$t] = $x
Next
For $t = 0 To 8
$g_asDestroyedElixirIMG[$t] = StringSplit("", "")
$x = _FileListToArrayRec(@ScriptDir & "\images\CapacityStructure\", "destroyed_elixir_" & $t & $useImages, $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($x) > 0 Then $g_asDestroyedElixirIMG[$t] = $x
If UBound($x) > 0 Then $g_asCapacityStructureElixir[$t] = $x
Next
For $t = 0 To 8
$g_asDestroyedDarkIMG[$t] = StringSplit("", "")
$x = _FileListToArrayRec(@ScriptDir & "\images\CapacityStructure\", "destroyed_dark_" & $t & $useImages, $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($x) > 0 Then $g_asDestroyedDarkIMG[$t] = $x
Next
EndFunc
Func MilkFarmObjectivesDebugImage($vector, $maxtiles = 0)
If $g_bDebugMilkingIMGmake Then
_CaptureRegion()
Local $EditedImage
$EditedImage = $g_hBitmap
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($EditedImage)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
Local $pixel
Local $hPen = _GDIPlus_PenCreate(0xFFFF0000, 2)
For $i = 0 To UBound($g_aiPixelTopLeft) - 1
$pixel = $g_aiPixelTopLeft[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPen)
Next
For $i = 0 To UBound($g_aiPixelTopRight) - 1
$pixel = $g_aiPixelTopRight[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPen)
Next
For $i = 0 To UBound($g_aiPixelBottomLeft) - 1
$pixel = $g_aiPixelBottomLeft[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPen)
Next
For $i = 0 To UBound($g_aiPixelBottomRight) - 1
$pixel = $g_aiPixelBottomRight[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPen)
Next
Local $testx = StringSplit($vector, "|", 2)
For $i = 0 To UBound($testx) - 1
Local $pixel1 = StringSplit($testx[$i], ".", 2)
If UBound($pixel1) >= 2 Then
Local $level = $pixel1[1]
Else
Local $level = 0
EndIf
Local $resourceoffsetx = 0
Local $resourceoffsety = 0
Switch $pixel1[0]
Case "gomine"
Local $px = StringSplit($g_asMilkFarmOffsetMine[$level], "-", 2)
Case "elixir"
Local $px = StringSplit($g_asMilkFarmOffsetElixir[$level], "-", 2)
Case "ddrill"
Local $px = StringSplit($g_asMilkFarmOffsetDark[$level], "-", 2)
Case Else
Local $px = StringSplit("0-0", "-", 2)
EndSwitch
$resourceoffsetx = $px[0]
$resourceoffsety = $px[1]
If UBound($pixel1) >= 2 Then
$pixel = StringSplit($pixel1[2], "-", 2)
If UBound($pixel) = 2 Then
_GDIPlus_PenDispose($hPen)
Local $hPen = _GDIPlus_PenCreate(0xFFFF0000, 1)
Local $x = 20
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $x, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - 10, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + 10, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $x, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $x, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx - 10, $pixel[1] + $resourceoffsety, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx + 10, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx + $x, $pixel[1] + $resourceoffsety, $hPen)
If $maxtiles >= 0 Then
_GDIPlus_PenDispose($hPen)
Local $hPen = _GDIPlus_PenCreate(0xFF0026FF, 1)
Local $multiplier = 0
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $g_iMilkFarmOffsetX - $g_iMilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $g_iMilkFarmOffsetY - $g_iMilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $g_iMilkFarmOffsetX - $g_iMilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $g_iMilkFarmOffsetY + $g_iMilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $g_iMilkFarmOffsetY - $g_iMilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $g_iMilkFarmOffsetX + $g_iMilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $g_iMilkFarmOffsetY + $g_iMilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $g_iMilkFarmOffsetX + $g_iMilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
EndIf
If $maxtiles >= 1 Then
_GDIPlus_PenDispose($hPen)
Local $hPen = _GDIPlus_PenCreate(0xFF00FFFF, 1)
Local $multiplier = 1
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $g_iMilkFarmOffsetX - $g_iMilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $g_iMilkFarmOffsetY - $g_iMilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $g_iMilkFarmOffsetX - $g_iMilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $g_iMilkFarmOffsetY + $g_iMilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $g_iMilkFarmOffsetY - $g_iMilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $g_iMilkFarmOffsetX + $g_iMilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $g_iMilkFarmOffsetY + $g_iMilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $g_iMilkFarmOffsetX + $g_iMilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
EndIf
If $maxtiles >= 2 Then
_GDIPlus_PenDispose($hPen)
Local $hPen = _GDIPlus_PenCreate(0xFFFFD800, 1)
Local $multiplier = 2
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $g_iMilkFarmOffsetX - $g_iMilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $g_iMilkFarmOffsetY - $g_iMilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $g_iMilkFarmOffsetX - $g_iMilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $g_iMilkFarmOffsetY + $g_iMilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $g_iMilkFarmOffsetY - $g_iMilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $g_iMilkFarmOffsetX + $g_iMilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $g_iMilkFarmOffsetY + $g_iMilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $g_iMilkFarmOffsetX + $g_iMilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("MilkFarmObjectivesDebugImage #1", $COLOR_DEBUG)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("MilkFarmObjectivesDebugImage #2", $COLOR_DEBUG)
EndIf
Next
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $savefolder = $g_sProfileTempDebugPath & "MilkFarmDebug_" & "\"
DirCreate($savefolder)
Local $filename = String("MilkFarmDebug_" & $Date & "_" & $Time)
_GDIPlus_ImageSaveToFile($EditedImage, $savefolder & $filename & ".jpg")
_GDIPlus_PenDispose($hPen)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
EndIf
EndFunc
Func MilkingAttackStructure($vectstr)
If $g_bDebugSetlog Then SetDebugLog("###### Attack " & $vectstr & "######")
Local $vect = StringSplit($vectstr, ".", 2)
If UBound($vect) = 4 Then
Else
Local $troopxwave, $pixel
If $g_iMilkFarmTroopForWaveMin = $g_iMilkFarmTroopForWaveMax Then
$troopxwave = $g_iMilkFarmTroopForWaveMin
Else
$troopxwave = Random($g_iMilkFarmTroopForWaveMin, $g_iMilkFarmTroopForWaveMax, 1)
EndIf
If $g_bDebugSetlog Then SetDebugLog("drop n.: " & $troopxwave & " troops | structure:" & $vect[0])
Local $skipdelay = False
For $i = 1 To $g_iMilkFarmTroopMaxWaves
If $g_bDebugSetlog Then SetDebugLog("Wave attack number " & $i)
$skipdelay = False
If IsAttackPage() Then
If $g_bMilkingAttackCheckStructureDestroyedBeforeAttack Then
If MilkingAttackStructureDestroyed($vect[0], $vect[1], $vect[2]) Then
$skipdelay = True
ExitLoop
EndIf
EndIf
If $g_iMilkingAttackDropGoblinAlgorithm = 1 Then
For $j = 1 To $troopxwave
If UBound($vect) = 4 Then
Local $rndpos = 3
Else
Local $rndpos = Random(3, UBound($vect) - 1, 1)
EndIf
$pixel = StringSplit($vect[$rndpos], "-", 2)
Local $delaypoint = 0
If UBound($pixel) = 2 Then
Click($pixel[0], $pixel[1], 1, $delaypoint, "#0777")
Else
If $g_bDebugSetlog Then SetDebugLog("MilkingAttackStructure error #1")
EndIf
Next
Else
If UBound($vect) = 4 Then
Local $rndpos = 3
Else
Local $rndpos = Random(3, UBound($vect) - 1, 1)
EndIf
$pixel = StringSplit($vect[$rndpos], "-", 2)
If UBound($pixel) = 2 Then
Click($pixel[0], $pixel[1], $troopxwave, Random(2, 7, 1), "#0778")
Else
If $g_bDebugSetlog Then SetDebugLog("MilkingAttackStructure error #1")
EndIf
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("You are not in Attack phase")
Return
EndIf
If $skipdelay = False Then
Local $delayfromwaves
If $g_iMilkFarmDelayFromWavesMin = $g_iMilkFarmDelayFromWavesMax Then
$delayfromwaves = $g_iMilkFarmDelayFromWavesMin
Else
$delayfromwaves = Random($g_iMilkFarmDelayFromWavesMin, $g_iMilkFarmDelayFromWavesMax, 1)
EndIf
If $g_bDebugSetlog Then SetDebugLog("wait " & $delayfromwaves)
If _Sleep($delayfromwaves) Then Return
EndIf
Next
If $g_bMilkingAttackCheckStructureDestroyedAfterAttack Then
If MilkingAttackStructureDestroyed($vect[0], $vect[1], $vect[2]) Then Return
EndIf
EndIf
EndFunc
Func MilkingAttackStructureDestroyed($type, $level, $coordinate)
Local $pixel = StringSplit($coordinate, "-", 2)
Switch $type
Case "gomine"
Local $px = StringSplit($g_asMilkFarmOffsetMine[$level], "-", 2)
Local $name = "Mine"
Case "elixir"
Local $px = StringSplit($g_asMilkFarmOffsetElixir[$level], "-", 2)
Local $name = "Elixir"
Case "ddrill"
Local $px = StringSplit($g_asMilkFarmOffsetDark[$level], "-", 2)
Local $name = "Dark"
Case Else
Local $px = StringSplit("0-0", "-", 2)
Local $name = ""
If $g_bDebugSetlog Then SetDebugLog("MilkingAttackStructureDestroyed error #1")
EndSwitch
$pixel[0] += $px[0]
$pixel[1] += $px[1]
If UBound($pixel) = 2 Then
_CaptureRegion($pixel[0] - 15, $pixel[1] - 15, $pixel[0] + 15, $pixel[1] + 15)
Local $found = 0
Local $posx, $posy
Local $aDestroyedImgFilenames = 0
If $name = "Mine" Then
$aDestroyedImgFilenames = $g_asDestroyedMineIMG[$level]
ElseIf $name = "Elixir" Then
$aDestroyedImgFilenames = $g_asDestroyedElixirIMG[$level]
ElseIf $name = "Dark" Then
$aDestroyedImgFilenames = $g_asDestroyedDarkIMG[$level]
EndIf
If $g_bDebugSetlog Then SetDebugLog("##start search in vector Destroyed" & $name & "IMG" & $level & ": numbers of files=" & UBound($aDestroyedImgFilenames), $COLOR_SUCCESS)
For $t = UBound($aDestroyedImgFilenames) - 1 To 1 Step -1
Local $filename = $aDestroyedImgFilenames[$t]
Local $tolerance = Int(StringMid($filename, StringInStr($filename, "_", 0, 3) + 1, StringInStr($filename, "_", 0, 4) - StringInStr($filename, "_", 0, 3) - 1))
If $g_bMilkFarmForceToleranceEnable Then $tolerance = Int($g_iMilkFarmForceToleranceDestroyed)
$found = _ImageSearch(@ScriptDir & "\images\CapacityStructure\" & $filename, 1, $posx, $posy, $tolerance)
If $found = 1 Then
If $g_bDebugSetlog Then SetDebugLog("IMAGECHECK OK " & $filename, $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog(">>Structure Destroyed! (" & $name & "," & $level & "," & $tolerance & ")", $COLOR_ERROR)
Return True
ExitLoop
Else
EndIf
Next
If $found = 0 Then
DebugImageSave("debugMilkingAttackStructureDestroyed_" & $type & "_" & $level & "_", False)
EndIf
Return False
Else
If $g_bDebugSetlog Then SetDebugLog("error MilkingAttackStructureDestroyed #1")
EndIf
EndFunc
Func _RandomUnique($iCount, $nMin, $nMax, $iInt = 0, $nSeed = Default)
Select
Case($iCount < 1)
Return SetError(1, 0, 0)
Case($iCount > 10 ^ 6 - 1)
Return SetError(2, 0, 0)
Case($nMin = $nMax)
Return SetError(3, 0, 0)
Case($nMin > $nMax)
Return SetError(4, 0, 0)
Case(($nMin < -2 ^ 31) Or($nMax > 2 ^ 31 - 1))
Return SetError(5, 0, 0)
EndSelect
If IsNumber($nSeed) Then
If(($nSeed < -2 ^ 31) Or($nSeed > 2 ^ 31 - 1)) Then Return SetError(6, 0, 0)
SRandom($nSeed)
EndIf
Local $iCountInval = 0
If($iInt) Then
If($nMin >= 0) Then
If($iCount >($nMax - $nMin) + 1) Then
$iCountInval = 1
ElseIf($iCount =($nMax - $nMin) + 1) Then
$iCountInval = 3
EndIf
Else
If($iCount >($nMax + Abs($nMin) + 1)) Then
$iCountInval = 2
ElseIf($iCount =($nMax + Abs($nMin) + 1)) Then
$iCountInval = 3
EndIf
EndIf
EndIf
If($iInt And $iCount = 1) Then
Local $aArray[2] = [1, Random($nMin, $nMax, $iInt)]
ElseIf $iCountInval Then
If $iCountInval = 1 Then
$iCount = Int($nMax - $nMin) + 1
ElseIf $iCountInval = 2 Then
$iCount = Int($nMax + Abs($nMin)) + 1
EndIf
If $iCountInval = 3 Then $iCountInval = 0
Local $aTmp, $iA, $iNumber = $nMin, $aArray[$iCount + 1] = [$iCount]
For $i = 1 To $aArray[0]
$aArray[$i] = $iNumber
$iNumber += 1
Next
For $i = 1 To $aArray[0]
$iA = Random($i, $aArray[0], 1)
If $i = $iA Then ContinueLoop
If $iA = 0 Then $iA = $aArray[0]
$aTmp = $aArray[$i]
$aArray[$i] = $aArray[$iA]
$aArray[$iA] = $aTmp
Next
Else
Local $nRnd, $iStep = 0, $aArray[$iCount + 1] = [$iCount]
While($iStep <= $iCount - 1)
$nRnd = Random($nMin, $nMax, $iInt)
If IsDeclared($nRnd) <> -1 Then
$iStep += 1
$aArray[$iStep] = $nRnd
Assign($nRnd, '', 1)
EndIf
WEnd
EndIf
Return SetError(0, Number($iCountInval > 0), $aArray)
EndFunc
Func MilkingDetectElixirExtractors()
If $g_bMilkFarmAttackElixirExtractors And $g_aiCurrentLoot[$eLootElixir] >= $g_iMilkFarmLimitElixir Then
If $g_bDebugSetlog Then SetDebugLog("skip attack of elixir extractors, current elixir (" & $g_aiCurrentLoot[$eLootElixir] & ") >= limit (" & $g_iMilkFarmLimitElixir & ")", $COLOR_DEBUG)
Return 0
Else
If $g_bDebugSetlog Then SetDebugLog("current elixir (" & $g_aiCurrentLoot[$eLootElixir] & ") < limit (" & $g_iMilkFarmLimitElixir & ")", $COLOR_DEBUG)
EndIf
$g_sMilkFarmObjectivesSTR = ""
Local $MilkFarmAtkPixelListSTR = ""
Local $hTimer = __TimerInit()
_CaptureRegion2()
Local $ElixirVect = StringSplit(GetLocationElixirWithLevel(), "~", 2)
Local $elixirfounds = UBound($ElixirVect)
Local $elixirmatch = 0
Local $elixirdiscard = 0
Local $redareapointsnearstructure = ""
For $i = 0 To UBound($ElixirVect) - 1
If $g_bDebugSetlog Then SetDebugLog($i & " : " & $ElixirVect[$i])
Local $temp = StringSplit($ElixirVect[$i], "#", 2)
If UBound($temp) = 2 Then
Local $pixel = StringSplit($temp[1], "-", 2)
If UBound($pixel) = 2 Then
If isInsideDiamondRedArea($pixel) Then
$redareapointsnearstructure = MilkingRedAreaPointsNearStructure("elixir", $temp[0], $temp[1])
If $redareapointsnearstructure <> "" Then
If AmountOfResourcesInStructure("elixir", $pixel, $temp[0]) Then
If $g_bMilkFarmLocateElixir Then
If $g_sMilkFarmObjectivesSTR <> "" Then $g_sMilkFarmObjectivesSTR &= "|"
$g_sMilkFarmObjectivesSTR &= "elixir"
$g_sMilkFarmObjectivesSTR &= "." & $temp[0]
$g_sMilkFarmObjectivesSTR &= "." & $temp[1]
$g_sMilkFarmObjectivesSTR &= $redareapointsnearstructure
$elixirmatch += 1
Else
If $g_bDebugSetlog Then SetDebugLog(" - discard #6 skip locate elixir", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog(" - discard #5 no match condition % amount of elixir", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog(" - discard #4 no redarea points matching conditions", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
If $g_bDebugResourcesOffset Then
Local $resourceoffsetx = 0
Local $resourceoffsety = 0
Local $px = StringSplit($g_asMilkFarmOffsetElixir[$temp[0]], "-", 2)
$resourceoffsetx = $px[0]
$resourceoffsety = $px[1]
_CaptureRegion($pixel[0] + $resourceoffsetx - 30, $pixel[1] + $resourceoffsety - 30, $pixel[0] + $resourceoffsetx + 30, $pixel[1] + $resourceoffsety + 30)
Local $hPen = _GDIPlus_PenCreate(0xFFFFD800, 1)
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($g_hBitmap)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
_GDIPlus_GraphicsDrawLine($hGraphic, 0, 30, 60, 30, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, 30, 0, 30, 60, $hPen)
_GDIPlus_PenDispose($hPen)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
DebugImageSave("debugresourcesoffset_" & "elixir" & "_" & $temp[0] & "_", False)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog(" - discard #3 out of insidediamond", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog(" - discard #2 no pixel coordinate", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog(" - discard #1 no valid point", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Next
If StringLen($MilkFarmAtkPixelListSTR) > 1 Then
$MilkFarmAtkPixelListSTR = StringLeft($MilkFarmAtkPixelListSTR, StringLen($MilkFarmAtkPixelListSTR) - 1)
EndIf
If $g_bDebugSetlog Then SetDebugLog("> Elixir Extractors to attack list: " & $MilkFarmAtkPixelListSTR, $COLOR_DEBUG)
Local $htimerLocateElixir = Round(__TimerDiff($hTimer) / 1000, 2)
If $g_bDebugSetlog Then SetDebugLog("> Elixir Extractors found: " & $elixirfounds & " | match conditions: " & $elixirmatch & " | discard " & $elixirdiscard, $COLOR_INFO)
If $g_bDebugSetlog Then SetDebugLog("> Elixir Extractors position and %full detectecd in " & $htimerLocateElixir & " seconds", $COLOR_INFO)
Return $elixirmatch
EndFunc
Func MilkingDetectMineExtractors()
If $g_bMilkFarmAttackGoldMines And $g_aiCurrentLoot[$eLootGold] >= $g_iMilkFarmLimitGold Then
If $g_bDebugSetlog Then SetDebugLog("skip attack of gold mines, current gold (" & $g_aiCurrentLoot[$eLootGold] & ") >= limit (" & $g_iMilkFarmLimitGold & ")", $COLOR_DEBUG)
Return 0
Else
If $g_bDebugSetlog Then SetDebugLog("current gold (" & $g_aiCurrentLoot[$eLootGold] & ") < limit (" & $g_iMilkFarmLimitGold & ")", $COLOR_DEBUG)
EndIf
Local $MilkFarmAtkPixelListMINESTR = ""
If $g_bMilkFarmLocateMine Then
Local $hTimer = __TimerInit()
_CaptureRegion2()
Local $MineVect = StringSplit(GetLocationMineWithLevel(), "~", 2)
Local $Minefounds = 0
Local $Minematch = 0
Local $Minediscard = 0
For $i = 0 To UBound($MineVect) - 1
Local $temp = StringSplit($MineVect[$i], "#", 2)
If UBound($temp) = 2 Then
Local $pixel = StringSplit($temp[1], "-", 2)
If UBound($pixel) = 2 Then
Local $tempPixel[2] = [$pixel[0], $pixel[1]]
$pixel = $tempPixel
$temp[1] = String($pixel[0] & "-" & $pixel[1])
If isInsideDiamondRedArea($pixel) Then
$Minefounds += 1
If $g_bDebugResourcesOffset Then
Local $level = $temp[0]
Local $type = "mine"
Local $resourceoffsetx = 0
Local $resourceoffsety = 0
Local $px = StringSplit($g_asMilkFarmOffsetMine[$level], "-", 2)
$resourceoffsetx = $px[0]
$resourceoffsety = $px[1]
_CaptureRegion($pixel[0] + $resourceoffsetx - 30, $pixel[1] + $resourceoffsety - 30, $pixel[0] + $resourceoffsetx + 30, $pixel[1] + $resourceoffsety + 30)
Local $hPen = _GDIPlus_PenCreate(0xFFFFD800, 1)
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($g_hBitmap)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
_GDIPlus_GraphicsDrawLine($hGraphic, 0, 30, 60, 30, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, 30, 0, 30, 60, $hPen)
_GDIPlus_PenDispose($hPen)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
DebugImageSave("debugresourcesoffset_" & $type & "_" & $level & "_", False)
EndIf
If AmountOfResourcesInStructure("mine", $pixel, $temp[0]) Then
$MilkFarmAtkPixelListMINESTR &= $temp[1] & "|"
If MilkFarmObjectivesSTR_INSERT("gomine", $temp[0], $temp[1]) Then
$Minematch += 1
Else
$Minediscard += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog(" - discard #4 no match conditions", $COLOR_DEBUG)
$Minediscard += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog(" - discard #3 out of insidediamond", $COLOR_DEBUG)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog(" - discard #2 no pixel coordinate", $COLOR_DEBUG)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog(" - discard #1 no valid point", $COLOR_DEBUG)
$Minediscard += 1
EndIf
Next
If StringLen($MilkFarmAtkPixelListMINESTR) > 1 Then $MilkFarmAtkPixelListMINESTR = StringLeft($MilkFarmAtkPixelListMINESTR, StringLen($MilkFarmAtkPixelListMINESTR) - 1)
If $g_bDebugSetlog Then SetDebugLog("> Mine Extractors to attack list: " & $MilkFarmAtkPixelListMINESTR, $COLOR_DEBUG)
Local $htimerLocateMine = Round(__TimerDiff($hTimer) / 1000, 2)
If $g_bDebugSetlog Then SetDebugLog("> Mine Extractors found: " & $Minefounds & " | match conditions: " & $Minematch & " | discard " & $Minediscard, $COLOR_INFO)
If $g_bDebugSetlog Then SetDebugLog("> Mine Extractors position detectecd in " & $htimerLocateMine & " seconds", $COLOR_INFO)
Return $Minematch
Else
Return 0
EndIf
EndFunc
Func MilkingDetectDarkExtractors()
If $g_bMilkFarmAttackDarkDrills And Number($g_aiCurrentLoot[$eLootDarkElixir]) >= Number($g_iMilkFarmLimitDark) Then
If $g_bDebugSetlog And $g_bMilkFarmAttackDarkDrills Then SetLog("skip attack of dark drills, current dark (" & $g_aiCurrentLoot[$eLootDarkElixir] & ") >= limit (" & $g_iMilkFarmLimitDark & ")", $COLOR_DEBUG)
If $g_bDebugSetlog And $g_bMilkFarmAttackDarkDrills = False Then SetLog("skip attack of dark drills", $COLOR_DEBUG)
Return 0
Else
If $g_bDebugSetlog Then SetDebugLog("current dark (" & $g_aiCurrentLoot[$eLootDarkElixir] & ") < limit (" & $g_iMilkFarmLimitDark & ")", $COLOR_DEBUG)
EndIf
Local $MilkFarmAtkPixelListDRILLSTR = ""
If $g_bMilkFarmLocateDrill Then
Local $hTimer = __TimerInit()
_CaptureRegion2()
Local $DrillVect = StringSplit(GetLocationDarkElixirWithLevel(), "~", 2)
Local $Drillfounds = UBound($DrillVect)
Local $Drillmatch = 0
Local $Drilldiscard = 0
For $i = 0 To UBound($DrillVect) - 1
Local $temp = StringSplit($DrillVect[$i], "#", 2)
If UBound($temp) = 2 Then
Local $pixel = StringSplit($temp[1], "-", 2)
If UBound($pixel) = 2 Then
If isInsideDiamondRedArea($pixel) Then
If $g_bDebugResourcesOffset Then
Local $level = $temp[0]
Local $type = "drill"
Local $resourceoffsetx = 0
Local $resourceoffsety = 0
Local $px = StringSplit($g_asMilkFarmOffsetDark[$level], "-", 2)
$resourceoffsetx = $px[0]
$resourceoffsety = $px[1]
_CaptureRegion($pixel[0] + $resourceoffsetx - 30, $pixel[1] + $resourceoffsety - 30, $pixel[0] + $resourceoffsetx + 30, $pixel[1] + $resourceoffsety + 30)
Local $hPen = _GDIPlus_PenCreate(0xFFFFD800, 1)
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($g_hBitmap)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
_GDIPlus_GraphicsDrawLine($hGraphic, 0, 30, 60, 30, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, 30, 0, 30, 60, $hPen)
_GDIPlus_PenDispose($hPen)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
DebugImageSave("debugresourcesoffset_" & $type & "_" & $level & "_", False)
EndIf
If AmountOfResourcesInStructure("drill", $pixel, $temp[0]) Then
$MilkFarmAtkPixelListDRILLSTR &= $temp[1] & "|"
If MilkFarmObjectivesSTR_INSERT("ddrill", $temp[0], $temp[1]) > 0 Then
$Drillmatch += 1
Else
$Drilldiscard += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog(" - discard #4 no match conditions", $COLOR_DEBUG)
$Drilldiscard += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog(" - discard #3 out of insidediamond", $COLOR_DEBUG)
$Drilldiscard += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog(" - discard #2 no pixel coordinate", $COLOR_DEBUG)
$Drilldiscard += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog(" - discard #1 no valid point", $COLOR_DEBUG)
$Drilldiscard += 1
EndIf
Next
If StringLen($MilkFarmAtkPixelListDRILLSTR) > 1 Then $MilkFarmAtkPixelListDRILLSTR = StringLeft($MilkFarmAtkPixelListDRILLSTR, StringLen($MilkFarmAtkPixelListDRILLSTR) - 1)
If $g_bDebugSetlog Then SetDebugLog("> Drill Extractors to attack list: " & $MilkFarmAtkPixelListDRILLSTR, $COLOR_DEBUG)
Local $htimerLocateDrill = Round(__TimerDiff($hTimer) / 1000, 2)
If $g_bDebugSetlog Then SetDebugLog("> Drill Extractors found: " & $Drillfounds & " | match conditions: " & $Drillmatch & " | discard " & $Drilldiscard, $COLOR_INFO)
If $g_bDebugSetlog Then SetDebugLog("> Drill Extractors position detectecd in " & $htimerLocateDrill & " seconds", $COLOR_INFO)
Return $Drillmatch
Else
Return 0
EndIf
EndFunc
Func MilkingDetectRedArea()
$g_sMilkFarmObjectivesSTR = ""
Local $hTimer = __TimerInit()
_CaptureRegion2()
_GetRedArea()
Local $htimerREDAREA = Round(__TimerDiff($hTimer) / 1000, 2)
If $g_bDebugSetlog Then SetDebugLog("> RedArea completed in " & $htimerREDAREA & " seconds", $COLOR_INFO)
CleanRedArea($g_aiPixelTopLeft)
CleanRedArea($g_aiPixelTopRight)
CleanRedArea($g_aiPixelBottomLeft)
CleanRedArea($g_aiPixelBottomRight)
EndFunc
Func MilkingDebug()
Local $debugselogLocal = $g_bDebugSetlog
Local $MilkingExtractorsMatch
$g_bDebugSetlog = True
SetLog("1 - Zoom out")
CheckZoomOut()
Local $TimeCheckMilkingAttack = __TimerInit()
SetLog("2 - Detect Elixir Collectors")
SetLog("  2.1 Detect RedArea")
MilkingDetectRedArea()
$g_sMilkFarmObjectivesSTR = ""
SetLog("  2.2bis detect elixir extractors2")
$MilkingExtractorsMatch = MilkingDetectElixirExtractors()
SetLog("  2.3 Detect Mine Extractors")
$MilkingExtractorsMatch += MilkingDetectMineExtractors()
SetLog("  2.4 Detect Dark Elixir Extractors")
Local $TimeCheckMilkingAttackSeconds = Round(__TimerDiff($TimeCheckMilkingAttack) / 1000, 2)
SetLog("Computing Time Milking Attack : " & $TimeCheckMilkingAttackSeconds & " seconds", $COLOR_INFO)
$g_bDebugSetlog = $debugselogLocal
SetLog("Make DebugImage")
MilkFarmObjectivesDebugImage($g_sMilkFarmObjectivesSTR, 0)
EndFunc
Func CheckMilkingBaseTest()
Local $MilkingElixirImages = _FileListToArray(@ScriptDir & "\images\Milking\Elixir", "*.*")
If @error = 1 Then
MsgBox(0, "", "Folder" & @ScriptDir & "\images\Milking\Elixir" & " not Found.")
EndIf
If @error = 4 Then
MsgBox(0, "", "No Files in folder " & @ScriptDir & "\images\Milking\Elixir")
EndIf
SetLog("Locate Elixir...")
_CaptureRegion2()
_CaptureRegion()
Local $ElixirVect = StringSplit(GetLocationElixirWithLevel(), "~", 2)
Local $elixirfounds = UBound($ElixirVect)
Local $elixirdiscard = 0
For $i = 0 To UBound($ElixirVect) - 1
Local $temp = StringSplit($ElixirVect[$i], "#", 2)
If UBound($temp) = 2 Then
SetLog("examine elixir vector #" & $i & " placed in " & $ElixirVect[$i], $COLOR_ERROR)
Local $pixelTemp = StringSplit($ElixirVect[$i], "-", 2)
$pixelTemp[0] += 0
$pixelTemp[1] += 10
Local $arrPixelsCloser = _FindPixelCloser($g_aiPixelRedArea, $pixelTemp, 1)
SetLog("pixelcloser=" & $arrPixelsCloser & "ubound = " & UBound($arrPixelsCloser))
For $t = 0 To UBound($arrPixelsCloser) - 1
Local $temp = $arrPixelsCloser[$t]
SetLog("$arrPixelsCloser " & $arrPixelsCloser[$t] & " ubound = " & UBound($temp) & " " & $temp[0] & "-" & $temp[1])
Next
If UBound($arrPixelsCloser) > 1 Then
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog(" - discard #1 no valid point", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
SetLog("............ next ..........")
Next
EndFunc
Func MilkingRedAreaPointsNearStructure($type, $level, $coordinate)
Local $ResourceToInsertQty = 0
Local $ResourceToInsert = ""
Local $pixelCoord = StringSplit($coordinate, "-", 2)
Local $diamondx = $g_iMilkFarmOffsetX + $g_iMilkFarmOffsetXStep * $g_iMilkFarmResMaxTilesFromBorder
Local $diamondy = $g_iMilkFarmOffsetY + $g_iMilkFarmOffsetYStep * $g_iMilkFarmResMaxTilesFromBorder
If UBound($pixelCoord) = 2 Then
Switch $type
Case "gomine"
Local $px = StringSplit($g_asMilkFarmOffsetMine[$level], "-", 2)
Case "elixir"
Local $px = StringSplit($g_asMilkFarmOffsetElixir[$level], "-", 2)
Case "ddrill"
Local $px = StringSplit($g_asMilkFarmOffsetDark[$level], "-", 2)
Case Else
Local $px = StringSplit("0-0", "-", 2)
EndSwitch
$pixelCoord[0] += $px[0]
$pixelCoord[1] += $px[1]
Local $vector = $g_aiPixelTopLeft
For $i = 0 To UBound($vector) - 1
Local $pixelCoord2 = $vector[$i]
If UBound($pixelCoord2) = 2 Then
If Abs(($pixelCoord[0] - $pixelCoord2[0]) / $diamondx) + Abs(($pixelCoord[1] - $pixelCoord2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixelCoord2[0] & "-" & $pixelCoord2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("MilkingRedAreaPointsNearStructure Discard error #3", $COLOR_ERROR)
EndIf
Next
Local $vector = $g_aiPixelTopRight
For $i = 0 To UBound($vector) - 1
Local $pixelCoord2 = $vector[$i]
If UBound($pixelCoord2) = 2 Then
If Abs(($pixelCoord[0] - $pixelCoord2[0]) / $diamondx) + Abs(($pixelCoord[1] - $pixelCoord2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixelCoord2[0] & "-" & $pixelCoord2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("MilkingRedAreaPointsNearStructure Discard error #3", $COLOR_ERROR)
EndIf
Next
Local $vector = $g_aiPixelBottomLeft
For $i = 0 To UBound($vector) - 1
Local $pixelCoord2 = $vector[$i]
If UBound($pixelCoord2) = 2 Then
If Abs(($pixelCoord[0] - $pixelCoord2[0]) / $diamondx) + Abs(($pixelCoord[1] - $pixelCoord2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixelCoord2[0] & "-" & $pixelCoord2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("MilkingRedAreaPointsNearStructure Discard error #3", $COLOR_ERROR)
EndIf
Next
Local $vector = $g_aiPixelBottomRight
For $i = 0 To UBound($vector) - 1
Local $pixelCoord2 = $vector[$i]
If UBound($pixelCoord2) = 2 Then
If Abs(($pixelCoord[0] - $pixelCoord2[0]) / $diamondx) + Abs(($pixelCoord[1] - $pixelCoord2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixelCoord2[0] & "-" & $pixelCoord2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("MilkingRedAreaPointsNearStructure Discard error #3", $COLOR_ERROR)
EndIf
Next
If $g_bDebugSetlog Then SetDebugLog("$ResourceToInsertQty = " & $ResourceToInsertQty & " value " & $ResourceToInsert, $COLOR_DEBUG)
Return $ResourceToInsert
Else
If $g_bDebugSetlog Then SetDebugLog("MilkingRedAreaPointsNearStructure Discard error #1 " & $pixelCoord & " " & UBound($pixelCoord), $COLOR_ERROR)
EndIf
EndFunc
Func CheckMilkingBase($matchDB, $dbBase)
Local $MilkingExtractorsMatch = 0
$g_sMilkFarmObjectivesSTR = ""
$g_bMilkingAttackOutside = False
If $matchDB And $g_aiAttackAlgorithm[$DB] = 2 Then
If(($g_iMilkAttackType = 1 And $dbBase) Or($g_iMilkAttackType = 0)) Then
Local $TimeCheckMilkingAttack = __TimerInit()
If $g_bDebugSetlog Then SetDebugLog("Check Milking...", $COLOR_DEBUG)
MilkingDetectRedArea()
$MilkingExtractorsMatch = MilkingDetectElixirExtractors()
If $MilkingExtractorsMatch > 0 Then
$MilkingExtractorsMatch += MilkingDetectMineExtractors() + MilkingDetectDarkExtractors()
EndIf
If StringLen($g_sMilkFarmObjectivesSTR) > 0 Then
If $g_iMilkAttackType = 1 Then
If $g_bDebugSetlog Then SetDebugLog("Milking match LOW CPU SETTINGS", $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("objectives: " & $g_sMilkFarmObjectivesSTR, $COLOR_DEBUG)
Else
If $g_bDebugSetlog Then SetDebugLog("Milking match HIGH CPU SETTINGS", $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("objectives: " & $g_sMilkFarmObjectivesSTR, $COLOR_DEBUG)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("Milking no match", $COLOR_DEBUG)
If $g_bMilkAttackAfterTHSnipeEnable And $g_bMilkFarmSnipeEvenIfNoExtractorsFound Then
If $g_bDebugSetlog Then SetDebugLog("Milking no match but Snipe even if no structures detected... check...", $COLOR_DEBUG)
If $g_iSearchTH = "-" Then FindTownHall(True)
If $g_iSearchTH <> "-" Then
$g_bMilkingAttackOutside = True
If SearchTownHallLoc() Then
If $g_bDebugSetlog Then SetDebugLog("Milking Attack TH outside match!", $COLOR_DEBUG)
$g_bMilkingAttackOutside = True
Else
If $g_bDebugSetlog Then SetDebugLog("TH it is not outside, skip attack")
EndIf
$g_bMilkingAttackOutside = False
Else
If $g_bDebugSetlog Then SetDebugLog("Cannot detect Townhall, skip THsnipe")
EndIf
EndIf
EndIf
Local $TimeCheckMilkingAttackSeconds = Round(__TimerDiff($TimeCheckMilkingAttack) / 1000, 2)
If $TimeCheckMilkingAttackSeconds >= 23 Then
SetLog("Computing Time Milking Attack too HIGH", $COLOR_ERROR)
SetLog("Your computer it is too slow to use this algorithm :(", $COLOR_ERROR)
SetLog("Please change algorithm", $COLOR_ERROR)
Else
SetLog("Computing Time Milking Attack : " & $TimeCheckMilkingAttackSeconds & " seconds", $COLOR_INFO)
EndIf
EndIf
EndIf
EndFunc
Func _FindPixelCloser($arrPixel, $pixel, $nb = 1)
If IsArray($arrPixel) = False Then Return
Local $arrPixelCloser[0]
For $j = 0 To $nb
Local $PixelCloser = $arrPixel[0]
For $i = 0 To UBound($arrPixel) - 1
Local $alreadyExist = False
Local $arrTemp = $arrPixel[$i]
Local $found = False
If($pixel[0] = -1) Then
If(Abs($arrTemp[1] - $pixel[1]) < Abs($PixelCloser[1] - $pixel[1])) Then
$found = True
EndIf
ElseIf($pixel[1] = -1) Then
If(Abs($arrTemp[0] - $pixel[0]) < Abs($PixelCloser[0] - $pixel[0])) Then
$found = True
EndIf
Else
If((Abs($arrTemp[0] - $pixel[0]) + Abs($arrTemp[1] - $pixel[1])) <(Abs($PixelCloser[0] - $pixel[0]) + Abs($PixelCloser[1] - $pixel[1]))) Then
$found = True
EndIf
EndIf
If($found) Then
For $k = 0 To UBound($arrPixelCloser) - 1
Local $arrTemp2 = $arrPixelCloser[$k]
If($arrTemp[0] = $arrTemp2[0] And $arrTemp[1] = $arrTemp2[1]) Then
$alreadyExist = True
ExitLoop
EndIf
Next
If($alreadyExist = False) Then
$PixelCloser = $arrTemp
EndIf
EndIf
Next
ReDim $arrPixelCloser[UBound($arrPixelCloser) + 1]
$arrPixelCloser[UBound($arrPixelCloser) - 1] = $PixelCloser
Next
Return $arrPixelCloser
EndFunc
Func _GetOffsetTroopFurther($pixel, $eVectorType, $offset)
debugRedArea("_GetOffsetTroopFurther IN")
Local $xMin, $xMax, $yMin, $yMax, $xStep, $yStep, $xOffset, $yOffset
Local $pixelOffset = GetOffestPixelRedArea2($pixel, $eVectorType, $offset)
If($eVectorType = $eVectorLeftTop) Then
$xMin = $InternalArea[0][0] + 2
$yMin = $InternalArea[0][1]
$xMax = $InternalArea[2][0]
$yMax = $InternalArea[2][1] + 2
$xStep = 4
$yStep = -3
$yOffset = -1 * $offset
$xOffset = Floor($yOffset)
ElseIf($eVectorType = $eVectorRightTop) Then
$xMin = $InternalArea[2][0]
$yMin = $InternalArea[2][1] + 2
$xMax = $InternalArea[1][0] - 2
$yMax = $InternalArea[1][1]
$xStep = 4
$yStep = 3
$yOffset = -1 * $offset
$xOffset = Floor($yOffset) * -1
ElseIf($eVectorType = $eVectorLeftBottom) Then
$xMin = $InternalArea[0][0] + 2
$yMin = $InternalArea[0][1]
$xMax = $InternalArea[3][0]
$yMax = $InternalArea[3][1] - 2
$xStep = 4
$yStep = 3
$yOffset = $offset
$xOffset = Floor($yOffset) * -1
Else
$xMin = $InternalArea[3][0]
$yMin = $InternalArea[3][1] - 2
$xMax = $InternalArea[1][0] - 2
$yMax = $InternalArea[1][1]
$xStep = 4
$yStep = -3
$yOffset = $offset
$xOffset = Floor($yOffset)
EndIf
Local $y = $yMin
Local $found = False
For $x = $xMin To $xMax Step $xStep
If($eVectorType = $eVectorRightBottom And $y > $yMax And $pixelOffset[0] > $x And $pixelOffset[1] > $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
ElseIf($eVectorType = $eVectorLeftBottom And $y < $yMax And $pixelOffset[0] < $x And $pixelOffset[1] > $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
ElseIf($eVectorType = $eVectorLeftTop And $y > $yMax And $pixelOffset[0] < $x And $pixelOffset[1] < $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
ElseIf($eVectorType = $eVectorRightTop And $y < $yMax And $pixelOffset[0] > $x And $pixelOffset[1] < $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
EndIf
$y += $yStep
If($found) Then ExitLoop
Next
If $pixelOffset[1] > 555 + $g_iBottomOffsetY Then
$pixelOffset[1] = 555 + $g_iBottomOffsetY
EndIf
debugRedArea("$pixelOffset x : [" & $pixelOffset[0] & "] / y : [" & $pixelOffset[1] & "]")
Return $pixelOffset
EndFunc
Func _GetRedArea($iMode = $REDLINE_IMGLOC, $iMaxAllowedPixelDistance = 25, $fMinSideLengthFactor = 0.65)
Local $nameFunc = "[_GetRedArea] "
debugRedArea($nameFunc & " IN")
Local $colorVariation = 40
Local $xSkip = 1
Local $ySkip = 5
Local $result = 0
Local $listPixelBySide
If $g_iMatchMode = $LB And $g_aiAttackAlgorithm[$LB] = 0 And $g_aiAttackStdDropSides[$LB] = 4 Then
$result = DllCall($g_hLibMyBot, "str", "getRedAreaSideBuilding", "ptr", $g_hHBitmap2, "int", $xSkip, "int", $ySkip, "int", $colorVariation, "int", $eSideBuildingDES)
If $g_bDebugSetlog Then SetDebugLog("Debug: Redline with DES Side chosen")
ElseIf $g_iMatchMode = $LB And $g_aiAttackAlgorithm[$LB] = 0 And $g_aiAttackStdDropSides[$LB] = 5 Then
$result = DllCall($g_hLibMyBot, "str", "getRedAreaSideBuilding", "ptr", $g_hHBitmap2, "int", $xSkip, "int", $ySkip, "int", $colorVariation, "int", $eSideBuildingTH)
If $g_bDebugSetlog Then SetDebugLog("Debug: Redline with TH Side chosen")
Else
Switch $iMode
Case $REDLINE_NONE
Local $a = ["NoRedLine", "", "", "", ""]
$listPixelBySide = $a
Case $REDLINE_IMGLOC_RAW
SearchRedLinesMultipleTimes()
$listPixelBySide = getRedAreaSideBuilding()
Case $REDLINE_IMGLOC
SearchRedLinesMultipleTimes()
Local $dropPoints = GetOffSetRedline("TL") & "|" & GetOffSetRedline("BL") & "|" & GetOffSetRedline("BR") & "|" & GetOffSetRedline("TR")
$listPixelBySide = getRedAreaSideBuilding($dropPoints)
Case $REDLINE_ORIGINAL
Local $result = DllCall($g_hLibMyBot, "str", "getRedArea", "ptr", $g_hHBitmap2, "int", $xSkip, "int", $ySkip, "int", $colorVariation)
EndSwitch
If $g_bDebugSetlog Then SetDebugLog("Debug: Redline chosen")
EndIf
If IsArray($result) Then
$listPixelBySide = StringSplit($result[0], "#")
EndIf
$g_aiPixelTopLeft = GetPixelSide($listPixelBySide, 1)
$g_aiPixelBottomLeft = GetPixelSide($listPixelBySide, 2)
$g_aiPixelBottomRight = GetPixelSide($listPixelBySide, 3)
$g_aiPixelTopRight = GetPixelSide($listPixelBySide, 4)
CleanRedArea($g_aiPixelTopLeft)
CleanRedArea($g_aiPixelTopRight)
CleanRedArea($g_aiPixelBottomLeft)
CleanRedArea($g_aiPixelBottomRight)
debugAttackCSV("RedArea cleaned")
debugAttackCSV("	[" & UBound($g_aiPixelTopLeft) & "] pixels TopLeft")
debugAttackCSV("	[" & UBound($g_aiPixelTopRight) & "] pixels TopRight")
debugAttackCSV("	[" & UBound($g_aiPixelBottomLeft) & "] pixels BottomLeft")
debugAttackCSV("	[" & UBound($g_aiPixelBottomRight) & "] pixels BottomRight")
If _Sleep($DELAYRESPOND) Then Return
Local $coordLeft = [$ExternalArea[0][0], $ExternalArea[0][1]]
Local $coordTop = [$ExternalArea[2][0], $ExternalArea[2][1]]
Local $coordRight = [$ExternalArea[1][0], $ExternalArea[1][1]]
Local $coordBottom = [$ExternalArea[3][0], $ExternalArea[3][1]]
Switch $g_aiAttackScrDroplineEdge[$g_iMatchMode]
Case $DROPLINE_EDGE_FIXED, $DROPLINE_FULL_EDGE_FIXED
Case $DROPLINE_EDGE_FIRST, $DROPLINE_FULL_EDGE_FIRST
Local $newAxis
Local $aPoint1 = GetMaxPoint($g_aiPixelTopLeft, 1)
Local $aPoint2 = GetMinPoint($g_aiPixelBottomLeft, 1)
$newAxis =(($aPoint1[0] < $aPoint2[0]) ?($aPoint1[0]) :($aPoint2[0]))
If Abs($newAxis) < 9999 Then $coordLeft[0] = $newAxis
Local $aPoint1 = GetMaxPoint($g_aiPixelTopLeft, 0)
Local $aPoint2 = GetMinPoint($g_aiPixelTopRight, 0)
$newAxis =(($aPoint1[1] < $aPoint2[1]) ?($aPoint1[1]) :($aPoint2[1]))
If Abs($newAxis) < 9999 Then $coordTop[1] = $newAxis
Local $aPoint1 = GetMaxPoint($g_aiPixelTopRight, 1)
Local $aPoint2 = GetMinPoint($g_aiPixelBottomRight, 1)
$newAxis =(($aPoint1[0] > $aPoint2[0]) ?($aPoint1[0]) :($aPoint2[0]))
If Abs($newAxis) < 9999 Then $coordRight[0] = $newAxis
Local $aPoint1 = GetMaxPoint($g_aiPixelBottomLeft, 0)
Local $aPoint2 = GetMinPoint($g_aiPixelBottomRight, 0)
$newAxis =(($aPoint1[1] > $aPoint2[1]) ?($aPoint1[1]) :($aPoint2[1]))
If Abs($newAxis) < 9999 Then $coordBottom[1] = $newAxis
EndSwitch
Local $StartEndTopLeft = [$coordLeft, $coordTop]
Local $StartEndTopRight = [$coordTop, $coordRight]
Local $StartEndBottomLeft = [$coordLeft, $coordBottom]
Local $StartEndBottomRight = [$coordBottom, $coordRight]
SetDebugLog("_GetRedArea, StartEndTopLeft     = " & PixelArrayToString($StartEndTopLeft, ","))
SetDebugLog("_GetRedArea, StartEndTopRight    = " & PixelArrayToString($StartEndTopRight, ","))
SetDebugLog("_GetRedArea, StartEndBottomLeft  = " & PixelArrayToString($StartEndBottomLeft, ","))
SetDebugLog("_GetRedArea, StartEndBottomRight = " & PixelArrayToString($StartEndBottomRight, ","))
Local $startPoint, $endPoint, $invalid1, $invalid2
Local $totalInvalid = 0
$startPoint = $StartEndTopLeft[0]
$endPoint = $StartEndTopLeft[1]
Local $g_aiPixelTopLeft1 = SortByDistance($g_aiPixelTopLeft, $startPoint, $endPoint, $invalid1)
$startPoint = $StartEndTopLeft[1]
$endPoint = $StartEndTopLeft[0]
Local $g_aiPixelTopLeft2 = SortByDistance($g_aiPixelTopLeft, $startPoint, $endPoint, $invalid2)
$totalInvalid +=(($invalid1 <= $invalid2) ?($invalid1) :($invalid2))
$g_aiPixelTopLeft = SortByDistance((($invalid1 <= $invalid2) ?($g_aiPixelTopLeft1) :($g_aiPixelTopLeft2)), $StartEndTopLeft[0], $StartEndTopLeft[1], $invalid1)
$startPoint = $StartEndTopRight[0]
$endPoint = $StartEndTopRight[1]
Local $g_aiPixelTopRight1 = SortByDistance($g_aiPixelTopRight, $startPoint, $endPoint, $invalid1)
$startPoint = $StartEndTopRight[1]
$endPoint = $StartEndTopRight[0]
Local $g_aiPixelTopRight2 = SortByDistance($g_aiPixelTopRight, $startPoint, $endPoint, $invalid2)
$totalInvalid +=(($invalid1 <= $invalid2) ?($invalid1) :($invalid2))
$g_aiPixelTopRight = SortByDistance((($invalid1 <= $invalid2) ?($g_aiPixelTopRight1) :($g_aiPixelTopRight2)), $StartEndTopRight[0], $StartEndTopRight[1], $invalid1)
$startPoint = $StartEndBottomLeft[0]
$endPoint = $StartEndBottomLeft[1]
Local $g_aiPixelBottomLeft1 = SortByDistance($g_aiPixelBottomLeft, $startPoint, $endPoint, $invalid1)
$startPoint = $StartEndBottomLeft[1]
$endPoint = $StartEndBottomLeft[0]
Local $g_aiPixelBottomLeft2 = SortByDistance($g_aiPixelBottomLeft, $startPoint, $endPoint, $invalid2)
$totalInvalid +=(($invalid1 <= $invalid2) ?($invalid1) :($invalid2))
$g_aiPixelBottomLeft = SortByDistance((($invalid1 <= $invalid2) ?($g_aiPixelBottomLeft1) :($g_aiPixelBottomLeft2)), $StartEndBottomLeft[0], $StartEndBottomLeft[1], $invalid1)
$startPoint = $StartEndBottomRight[0]
$endPoint = $StartEndBottomRight[1]
Local $g_aiPixelBottomRight1 = SortByDistance($g_aiPixelBottomRight, $startPoint, $endPoint, $invalid1)
$startPoint = $StartEndBottomRight[1]
$endPoint = $StartEndBottomRight[0]
Local $g_aiPixelBottomRight2 = SortByDistance($g_aiPixelBottomRight, $startPoint, $endPoint, $invalid2)
$totalInvalid +=(($invalid1 <= $invalid2) ?($invalid1) :($invalid2))
$g_aiPixelBottomRight = SortByDistance((($invalid1 <= $invalid2) ?($g_aiPixelBottomRight1) :($g_aiPixelBottomRight2)), $StartEndBottomRight[0], $StartEndBottomRight[1], $invalid1)
Local $offsetArcher = 15
ReDim $g_aiPixelRedArea[UBound($g_aiPixelTopLeft) + UBound($g_aiPixelBottomLeft) + UBound($g_aiPixelTopRight) + UBound($g_aiPixelBottomRight)]
ReDim $g_aiPixelRedAreaFurther[UBound($g_aiPixelRedArea)]
Local $a
If $g_iMatchMode = $DB And $g_aiAttackAlgorithm[$DB] = 2 Then
If $g_bDebugSetlog Then SetDebugLog("redarea no calc pixel further (quick)", $COLOR_DEBUG)
Local $count = 0
ReDim $g_aiPixelTopLeftFurther[UBound($g_aiPixelTopLeft)]
For $i = 0 To UBound($g_aiPixelTopLeft) - 1
$a = $g_aiPixelTopLeft[$i]
$g_aiPixelTopLeftFurther[$i] = $a
$g_aiPixelRedArea[$count] = $a
$g_aiPixelRedAreaFurther[$count] = $g_aiPixelTopLeftFurther[$i]
$count += 1
Next
ReDim $g_aiPixelBottomLeftFurther[UBound($g_aiPixelBottomLeft)]
For $i = 0 To UBound($g_aiPixelBottomLeft) - 1
$g_aiPixelBottomLeftFurther[$i] = $g_aiPixelBottomLeft[$i]
$g_aiPixelRedArea[$count] = $g_aiPixelBottomLeft[$i]
$g_aiPixelRedAreaFurther[$count] = $g_aiPixelBottomLeftFurther[$i]
$count += 1
Next
ReDim $g_aiPixelTopRightFurther[UBound($g_aiPixelTopRight)]
For $i = 0 To UBound($g_aiPixelTopRight) - 1
$g_aiPixelTopRightFurther[$i] = $g_aiPixelTopRight[$i]
$g_aiPixelRedArea[$count] = $g_aiPixelTopRight[$i]
$g_aiPixelRedAreaFurther[$count] = $g_aiPixelTopRightFurther[$i]
$count += 1
Next
ReDim $g_aiPixelBottomRightFurther[UBound($g_aiPixelBottomRight)]
For $i = 0 To UBound($g_aiPixelBottomRight) - 1
$g_aiPixelBottomRightFurther[$i] = $g_aiPixelBottomRight[$i]
$g_aiPixelRedArea[$count] = $g_aiPixelBottomRight[$i]
$g_aiPixelRedAreaFurther[$count] = $g_aiPixelBottomRightFurther[$i]
$count += 1
Next
Else
If $g_bDebugSetlog Then SetDebugLog("redarea calc pixel further", $COLOR_DEBUG)
Local $count = 0
ReDim $g_aiPixelTopLeftFurther[UBound($g_aiPixelTopLeft)]
For $i = 0 To UBound($g_aiPixelTopLeft) - 1
$g_aiPixelTopLeftFurther[$i] = _GetOffsetTroopFurther($g_aiPixelTopLeft[$i], $eVectorLeftTop, $offsetArcher)
$g_aiPixelRedArea[$count] = $g_aiPixelTopLeft[$i]
$g_aiPixelRedAreaFurther[$count] = $g_aiPixelTopLeftFurther[$i]
$count += 1
Next
ReDim $g_aiPixelBottomLeftFurther[UBound($g_aiPixelBottomLeft)]
For $i = 0 To UBound($g_aiPixelBottomLeft) - 1
$g_aiPixelBottomLeftFurther[$i] = _GetOffsetTroopFurther($g_aiPixelBottomLeft[$i], $eVectorLeftBottom, $offsetArcher)
$g_aiPixelRedArea[$count] = $g_aiPixelBottomLeft[$i]
$g_aiPixelRedAreaFurther[$count] = $g_aiPixelBottomLeftFurther[$i]
$count += 1
Next
ReDim $g_aiPixelTopRightFurther[UBound($g_aiPixelTopRight)]
For $i = 0 To UBound($g_aiPixelTopRight) - 1
$g_aiPixelTopRightFurther[$i] = _GetOffsetTroopFurther($g_aiPixelTopRight[$i], $eVectorRightTop, $offsetArcher)
$g_aiPixelRedArea[$count] = $g_aiPixelTopRight[$i]
$g_aiPixelRedAreaFurther[$count] = $g_aiPixelTopRightFurther[$i]
$count += 1
Next
ReDim $g_aiPixelBottomRightFurther[UBound($g_aiPixelBottomRight)]
For $i = 0 To UBound($g_aiPixelBottomRight) - 1
$g_aiPixelBottomRightFurther[$i] = _GetOffsetTroopFurther($g_aiPixelBottomRight[$i], $eVectorRightBottom, $offsetArcher)
$g_aiPixelRedArea[$count] = $g_aiPixelBottomRight[$i]
$g_aiPixelRedAreaFurther[$count] = $g_aiPixelBottomRightFurther[$i]
$count += 1
Next
EndIf
Local $aSideLength[4]
$aSideLength[0] =((UBound($g_aiPixelTopLeft) >= 10) ?(GetPixelDistance($g_aiPixelTopLeft[0], $g_aiPixelTopLeft[UBound($g_aiPixelTopLeft) - 1])) :(0))
$aSideLength[1] =((UBound($g_aiPixelBottomLeft) >= 10) ?(GetPixelDistance($g_aiPixelBottomLeft[0], $g_aiPixelBottomLeft[UBound($g_aiPixelBottomLeft) - 1])) :(0))
$aSideLength[2] =((UBound($g_aiPixelTopRight) >= 10) ?(GetPixelDistance($g_aiPixelTopRight[0], $g_aiPixelTopRight[UBound($g_aiPixelTopRight) - 1])) :(0))
$aSideLength[3] =((UBound($g_aiPixelBottomRight) >= 10) ?(GetPixelDistance($g_aiPixelBottomRight[0], $g_aiPixelBottomRight[UBound($g_aiPixelBottomRight) - 1])) :(0))
Local $iAvgSideLength = 0
Local $iAvgSideCount = 0
For $i = 0 To 3
$iAvgSideLength += $aSideLength[$i]
If $aSideLength[$i] > 0 Then $iAvgSideCount += 1
Next
$iAvgSideLength = Round($iAvgSideLength / $iAvgSideCount, 0)
SetDebugLog("Average side length: " & $iAvgSideLength)
Local $bNotEnoughPoints, $iSideLength
$bNotEnoughPoints = UBound($g_aiPixelTopLeft) < 10
$iSideLength = Round(GetPixelListDistance($g_aiPixelTopLeft, $iMaxAllowedPixelDistance), 0)
If $bNotEnoughPoints Or $iSideLength / $fMinSideLengthFactor < $iAvgSideLength Then
SetDebugLog("Attack side top-left: fall back to outer green (" &(($bNotEnoughPoints) ?("not enougth points") :("side length " & $iSideLength & " / " & $fMinSideLengthFactor & " < " & $iAvgSideLength)) & ")")
$g_aiPixelTopLeft = _GetVectorOutZone($eVectorLeftTop)
$g_aiPixelTopLeftFurther = $g_aiPixelTopLeft
EndIf
$bNotEnoughPoints = UBound($g_aiPixelBottomLeft) < 10
$iSideLength = Round(GetPixelListDistance($g_aiPixelBottomLeft, $iMaxAllowedPixelDistance), 0)
If $bNotEnoughPoints Or $iSideLength / $fMinSideLengthFactor < $iAvgSideLength Then
SetDebugLog("Attack side bottom-left: fall back to outer green (" &(($bNotEnoughPoints) ?("not enougth points") :("side length " & $iSideLength & " / " & $fMinSideLengthFactor & " < " & $iAvgSideLength)) & ")")
$g_aiPixelBottomLeft = _GetVectorOutZone($eVectorLeftBottom)
$g_aiPixelBottomLeftFurther = $g_aiPixelBottomLeft
EndIf
$bNotEnoughPoints = UBound($g_aiPixelTopRight) < 10
$iSideLength = Round(GetPixelListDistance($g_aiPixelTopRight, $iMaxAllowedPixelDistance), 0)
If $bNotEnoughPoints Or $iSideLength / $fMinSideLengthFactor < $iAvgSideLength Then
SetDebugLog("Attack side top-right: fall back to outer green (" &(($bNotEnoughPoints) ?("not enougth points") :("side length " & $iSideLength & " / " & $fMinSideLengthFactor & " < " & $iAvgSideLength)) & ")")
$g_aiPixelTopRight = _GetVectorOutZone($eVectorRightTop)
$g_aiPixelTopRightFurther = $g_aiPixelTopRight
EndIf
$bNotEnoughPoints = UBound($g_aiPixelBottomRight) < 10
$iSideLength = Round(GetPixelListDistance($g_aiPixelBottomRight, $iMaxAllowedPixelDistance), 0)
If $bNotEnoughPoints Or $iSideLength / $fMinSideLengthFactor < $iAvgSideLength Then
SetDebugLog("Attack side bottom-right: fall back to outer green (" &(($bNotEnoughPoints) ?("not enougth points") :("side length " & $iSideLength & " / " & $fMinSideLengthFactor & " < " & $iAvgSideLength)) & ")")
$g_aiPixelBottomRight = _GetVectorOutZone($eVectorRightBottom)
$g_aiPixelBottomRightFurther = $g_aiPixelBottomRight
EndIf
debugRedArea($nameFunc & "  Size of arr pixel for TopLeft [" & UBound($g_aiPixelTopLeft) & "] /  BottomLeft [" & UBound($g_aiPixelBottomLeft) & "] /  TopRight [" & UBound($g_aiPixelTopRight) & "] /  BottomRight [" & UBound($g_aiPixelBottomRight) & "] ")
debugRedArea($nameFunc & " OUT ")
EndFunc
Func SortRedline($redline, $StartPixel, $EndPixel, $sDelim = ",")
Local $aPoints = StringSplit($redline, "|", $STR_NOCOUNT)
Local $size = UBound($aPoints)
If $size < 2 Then Return StringReplace($redline, $sDelim, "-")
For $i = 0 To $size - 1
Local $sPoint = $aPoints[$i]
Local $aPoint = GetPixel($sPoint, $sDelim)
If UBound($aPoint) > 1 Then $aPoints[$i] = $aPoint
Next
Local $iInvalid = 0
Local $s = PixelArrayToString(SortByDistance($aPoints, $StartPixel, $EndPixel, $iInvalid))
Return $s
EndFunc
Func SortByDistance($PixelList, ByRef $StartPixel, ByRef $EndPixel, ByRef $iInvalid)
If $g_bDebugSetlog Then SetDebugLog("SortByDistance Start = " & PixelToString($StartPixel, ',') & " : " & PixelArrayToString($PixelList, ","))
Local $iMax = UBound($PixelList) - 1
Local $iMin2 = 0
Local $iMax2 = $iMax
Local $Sorted[0]
Local $PrevPixel = $StartPixel
Local $PrevDistance = -1
Local $totalDistances = 0
Local $totalPoints = 0
Local $firstPixel = [-1, -1], $lastPixel = [-1, -1]
Local $avgDistance = 0
$iInvalid = 0
For $i = 0 To $iMax
Local $ClosestIndex = 0
Local $ClosestDistance = 9999
Local $ClosestPixel = [0, 0]
Local $adjustMin = True
Local $adjustMax = 0
For $j = $iMin2 To $iMax2
Local $Pixel = $PixelList[$j]
If IsArray($Pixel) = 0 Then
If $adjustMin Then $iMin2 = $j + 1
If $adjustMax = $iMax Then $adjustMax = $j
ContinueLoop
EndIf
$adjustMin = False
$adjustMax = $iMax
Local $d = GetPixelDistance($PrevPixel, $Pixel)
If $d < $ClosestDistance Then
$ClosestIndex = $j
$ClosestDistance = $d
$ClosestPixel = $Pixel
EndIf
Next
$iMax2 = $adjustMax
$avgDistance = $totalDistances / $totalPoints
Local $invalidPoint = $ClosestPixel[0] < 0 Or $ClosestPixel[1] < 0
If $invalidPoint Or($PrevDistance > -1 And($iMax - $i) / $iMax < 0.20 And($ClosestDistance > $avgDistance * 10 Or($ClosestDistance > $avgDistance * 3 And(GetPixelDistance($PrevPixel, $EndPixel) < 25 Or $ClosestDistance > $totalDistances / 2)))) Then
$iInvalid += 1
Else
If $firstPixel[0] = -1 Then $firstPixel = $ClosestPixel
$lastPixel = $ClosestPixel
$PrevPixel = $ClosestPixel
$PrevDistance = $ClosestDistance
$totalPoints += 1
$totalDistances += $ClosestDistance
ReDim $Sorted[UBound($Sorted) + 1]
$Sorted[UBound($Sorted) - 1] = $ClosestPixel
EndIf
$PixelList[$ClosestIndex] = 0
Next
If $firstPixel[0] > 0 And GetPixelDistance($StartPixel, $firstPixel) > $avgDistance * 3 Then
$StartPixel[0] = $firstPixel[0]
$StartPixel[1] = $firstPixel[1]
EndIf
If $lastPixel[0] > 0 And GetPixelDistance($EndPixel, $lastPixel) > $avgDistance * 3 Then
$EndPixel[0] = $lastPixel[0]
$EndPixel[1] = $lastPixel[1]
EndIf
Return $Sorted
EndFunc
Func PixelArrayToString(Const ByRef $PixelList, $sDelim = "-")
If UBound($PixelList) < 1 Then Return ""
Local $s = ""
For $i = 0 To UBound($PixelList) - 1
Local $Pixel = $PixelList[$i]
$s &= "|" & PixelToString($Pixel, $sDelim)
Next
$s = StringMid($s, 2)
Return $s
EndFunc
Func PixelToString(Const ByRef $Pixel, $sDelim = "-")
If UBound($Pixel) < 2 Then Return ""
Return $Pixel[0] & $sDelim & $Pixel[1]
EndFunc
Func _SortRedline($redline, $sDelim = ",")
Local $aPoints = StringSplit($redline, "|", $STR_NOCOUNT)
Local $size = UBound($aPoints)
If $size < 2 Then Return StringReplace($redline, $sDelim, "-")
Local $a1[$size + 1][2] = [[0, 0]]
For $sPoint In $aPoints
Local $aPoint = GetPixel($sPoint, $sDelim)
If UBound($aPoint) > 1 Then getRedAreaSideBuildingSetPoint($a1, $aPoint)
Next
Local $s = getRedAreaSideBuildingString($a1)
Return $s
EndFunc
Func getRedAreaSideBuildingSetPoint(ByRef $aSide, ByRef $aPoint)
$aSide[0][0] += 1
$aSide[$aSide[0][0]][0] = Int($aPoint[0])
$aSide[$aSide[0][0]][1] = Int($aPoint[1])
EndFunc
Func getRedAreaSideBuildingString(ByRef $aSide)
If UBound($aSide) < 2 Or $aSide[0][0] < 1 Then Return ""
_ArraySort($aSide, 0, 1, $aSide[0][0], 0)
Local $s = ""
For $j = 1 To $aSide[0][0]
$s &=("|" & $aSide[$j][0] & "-" & $aSide[$j][1])
Next
$s = StringMid($s, 2)
Return $s
EndFunc
Func getRedAreaSideBuilding($redline = $g_sImglocRedline)
Local $c = 0
Local $a[5]
Local $aPoints = StringSplit($redline, "|", $STR_NOCOUNT)
Local $size = UBound($aPoints)
Local $a1[$size + 1][2] = [[0, 0]]
Local $a2[$size + 1][2] = [[0, 0]]
Local $a3[$size + 1][2] = [[0, 0]]
Local $a4[$size + 1][2] = [[0, 0]]
For $sPoint In $aPoints
Local $aPoint = GetPixel($sPoint, ",")
If UBound($aPoint) > 1 Then
$c += 1
Local $i = GetPixelSection($aPoint[0], $aPoint[1])
Switch $i
Case 1
getRedAreaSideBuildingSetPoint($a1, $aPoint)
Case 2
getRedAreaSideBuildingSetPoint($a2, $aPoint)
Case 3
getRedAreaSideBuildingSetPoint($a3, $aPoint)
Case 4
getRedAreaSideBuildingSetPoint($a4, $aPoint)
EndSwitch
EndIf
Next
$a[0] = $c
$a[1] = getRedAreaSideBuildingString($a1)
$a[2] = getRedAreaSideBuildingString($a2)
$a[3] = getRedAreaSideBuildingString($a3)
$a[4] = getRedAreaSideBuildingString($a4)
Return $a
EndFunc
Func GetPixelSection($x, $y)
Local $isLeft =($x <= $ExternalArea[2][0])
Local $isTop =($y <= $ExternalArea[0][1])
If $isLeft Then
If $isTop Then Return 1
Return 2
EndIf
If $isTop Then Return 4
Return 3
EndFunc
Func FindClosestToAxis(Const ByRef $PixelList)
Local $Axis = [$ExternalArea[2][0], $ExternalArea[0][1]]
Local $Search[2] = [9999, 9999]
Local $Points[2]
For $Pixel In $PixelList
For $i = 0 To 1
If Abs($Pixel[$i] - $Axis[$i]) < Abs($Search[$i] - $Axis[$i]) Then
$Search[$i] = $Pixel[$i]
$Points[$i] = $Pixel
EndIf
Next
Next
For $i = 0 To 1
If $Search[$i] = 9999 Then $Search[$i] = $Axis[$i]
Next
Return $Search
EndFunc
Func _GetVectorOutZone($eVectorType)
debugRedArea("_GetVectorOutZone IN")
Local $vectorOutZone[0]
Local $iSteps = 100
Local $xMin, $yMin, $xMax, $yMax
If($eVectorType = $eVectorLeftTop) Then
$xMin = $ExternalArea[0][0] + 2
$yMin = $ExternalArea[0][1]
$xMax = $ExternalArea[2][0]
$yMax = $ExternalArea[2][1] + 2
ElseIf($eVectorType = $eVectorRightTop) Then
$xMin = $ExternalArea[2][0]
$yMin = $ExternalArea[2][1] + 2
$xMax = $ExternalArea[1][0] - 2
$yMax = $ExternalArea[1][1]
ElseIf($eVectorType = $eVectorLeftBottom) Then
$xMin = $ExternalArea[0][0] + 2
$yMin = $ExternalArea[0][1]
$xMax = $ExternalArea[3][0]
$yMax = $ExternalArea[3][1] - 2
Else
$xMin = $ExternalArea[3][0]
$yMin = $ExternalArea[3][1] - 2
$xMax = $ExternalArea[1][0] - 2
$yMax = $ExternalArea[1][1]
EndIf
For $i = 0 To $iSteps
Local $pixel = [Round($xMin +(($xMax - $xMin) * $i) / $iSteps), Round($yMin +(($yMax - $yMin) * $i) / $iSteps)]
ReDim $vectorOutZone[UBound($vectorOutZone) + 1]
If $pixel[1] > 555 + $g_iBottomOffsetY Then
$pixel[1] = 555 + $g_iBottomOffsetY
EndIf
$vectorOutZone[UBound($vectorOutZone) - 1] = $pixel
Next
Return $vectorOutZone
EndFunc
Func debugRedArea($string)
If $g_bDebugRedArea Then
Local $hFile = FileOpen($g_sProfileLogsPath & "debugRedArea.log", $FO_APPEND)
_FileWriteLog($hFile, $string)
FileClose($hFile)
EndIf
EndFunc
Func DropOnPixel($troop, $listArrPixel, $number, $slotsPerEdge = 0)
If isProblemAffect(True) Then Return
If Not IsAttackPage() Then Return
Local $nameFunc = "[DropOnPixel]"
debugRedArea($nameFunc & " IN ")
debugRedArea("troop : [" & $troop & "] / size arrPixel [" & UBound($listArrPixel) & "] / number [" & $number & "]/ $slotsPerEdge [" & $slotsPerEdge & "] ")
If($number = 0 Or UBound($listArrPixel) = 0) Then Return
KeepClicks()
If $number = 1 Or $slotsPerEdge = 1 Then
For $i = 0 To UBound($listArrPixel) - 1
debugRedArea("$listArrPixel $i : [" & $i & "] ")
Local $arrPixel = $listArrPixel[$i]
debugRedArea("$arrPixel $UBound($arrPixel) : [" & UBound($arrPixel) & "] ")
If UBound($arrPixel) > 0 Then
Local $pixel = $arrPixel[0]
If $i = Int(UBound($arrPixel) / 2) And $g_bIsHeroesDropped = False Then
$g_aiDeployHeroesPosition[0] = $pixel[0]
$g_aiDeployHeroesPosition[1] = $pixel[1]
debugRedArea("Heroes : $slotsPerEdge = 1 ")
EndIf
If $i = Int(UBound($arrPixel) / 2) And $g_bIsCCDropped = False Then
$g_aiDeployCCPosition[0] = $pixel[0]
$g_aiDeployCCPosition[1] = $pixel[1]
debugRedArea("CC : $slotsPerEdge = 1 ")
EndIf
AttackClick($pixel[0], $pixel[1], $number, $DELAYDROPONPIXEL2, $DELAYDROPONPIXEL1, "#0096")
EndIf
Next
ElseIf $slotsPerEdge = 2 Then
For $i = 0 To UBound($listArrPixel) - 1
Local $arrPixel = $listArrPixel[$i]
If UBound($arrPixel) > 0 Then
Local $pixel = $arrPixel[0]
If $i = Int(UBound($arrPixel) / 2) And $g_bIsHeroesDropped = False Then
$g_aiDeployHeroesPosition[0] = $pixel[0]
$g_aiDeployHeroesPosition[1] = $pixel[1]
debugRedArea("Heroes : $slotsPerEdge = 2 ")
EndIf
If $i = Int(UBound($arrPixel) / 2) And $g_bIsCCDropped = False Then
$g_aiDeployCCPosition[0] = $pixel[0]
$g_aiDeployCCPosition[1] = $pixel[1]
debugRedArea("CC : $slotsPerEdge = 2 ")
EndIf
AttackClick($pixel[0], $pixel[1], $number, SetSleep(0), SetSleep(1), "#0097")
EndIf
Next
Else
For $i = 0 To UBound($listArrPixel) - 1
debugRedArea("$listArrPixel $i : [" & $i & "] ")
Local $nbTroopsLeft = $number
Local $offset = 1
Local $nbTroopByPixel = 1
Local $arrPixel = $listArrPixel[$i]
debugRedArea("UBound($arrPixel) " & UBound($arrPixel) & "$number :" & $number)
While($nbTroopsLeft > 0)
If(UBound($arrPixel) = 0) Then
ExitLoop
EndIf
If(UBound($arrPixel) > $nbTroopsLeft) Then
$offset = UBound($arrPixel) / $nbTroopsLeft
Else
$nbTroopByPixel = Floor($number / UBound($arrPixel))
EndIf
If($offset < 1) Then
$offset = 1
EndIf
If($nbTroopByPixel < 1) Then
$nbTroopByPixel = 1
EndIf
For $j = 0 To UBound($arrPixel) - 1 Step $offset
Local $index = Round($j)
If($index > UBound($arrPixel) - 1) Then
$index = UBound($arrPixel) - 1
EndIf
Local $currentPixel = $arrPixel[Floor($index)]
If $j >= Round(UBound($arrPixel) / 2) And $j <= Round((UBound($arrPixel) / 2) + $offset) And $g_bIsHeroesDropped = False Then
$g_aiDeployHeroesPosition[0] = $currentPixel[0]
$g_aiDeployHeroesPosition[1] = $currentPixel[1]
debugRedArea("Heroes : $slotsPerEdge = else ")
debugRedArea("$offset: " & $offset)
EndIf
If $j >= Round(UBound($arrPixel) / 2) And $j <= Round((UBound($arrPixel) / 2) + $offset) And $g_bIsCCDropped = False Then
$g_aiDeployCCPosition[0] = $currentPixel[0]
$g_aiDeployCCPosition[1] = $currentPixel[1]
debugRedArea("CC : $slotsPerEdge = else ")
debugRedArea("$offset: " & $offset)
EndIf
If Number($currentPixel[1]) > 555 + $g_iBottomOffsetY Then $currentPixel[1] = 555 + $g_iBottomOffsetY
AttackClick($currentPixel[0], $currentPixel[1], $nbTroopByPixel, SetSleep(0), 0, "#0098")
$nbTroopsLeft -= $nbTroopByPixel
Next
WEnd
Next
EndIf
ReleaseClicks()
debugRedArea($nameFunc & " OUT ")
EndFunc
Func DropTroop($troop, $nbSides, $number, $slotsPerEdge = 0, $indexToAttack = -1)
If isProblemAffect(True) Then Return
Local $nameFunc = "[DropTroop]"
debugRedArea($nameFunc & " IN ")
debugRedArea("troop : [" & $troop & "] / nbSides : [" & $nbSides & "] / number : [" & $number & "] / slotsPerEdge [" & $slotsPerEdge & "]")
If($g_abAttackStdSmartAttack[$g_iMatchMode]) Then
If $slotsPerEdge = 0 Or $number < $slotsPerEdge Then $slotsPerEdge = $number
If _Sleep($DELAYDROPTROOP1) Then Return
SelectDropTroop($troop)
If _Sleep($DELAYDROPTROOP2) Then Return
If $nbSides < 1 Then Return
Local $nbTroopsLeft = $number
If($g_abAttackStdSmartNearCollectors[$g_iMatchMode][0] = False And $g_abAttackStdSmartNearCollectors[$g_iMatchMode][1] = False And $g_abAttackStdSmartNearCollectors[$g_iMatchMode][2] = False) Then
If $nbSides = 4 Then
Local $g_aaiEdgeDropPointsPixelToDrop = GetPixelDropTroop($troop, $number, $slotsPerEdge)
For $i = 0 To $nbSides - 3
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i * 2))
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $listEdgesPixelToDrop[2] = [$g_aaiEdgeDropPointsPixelToDrop[$i], $g_aaiEdgeDropPointsPixelToDrop[$i + 2]]
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
Next
Return
EndIf
For $i = 0 To $nbSides - 1
If $nbSides = 1 Or($nbSides = 3 And $i = 2) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i))
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $g_aaiEdgeDropPointsPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
Local $listEdgesPixelToDrop[1] = [$g_aaiEdgeDropPointsPixelToDrop[$i]]
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
$nbTroopsLeft -= $nbTroopsPerEdge
ElseIf($nbSides = 2 And $i = 0) Or($nbSides = 3 And $i <> 1) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i * 2))
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $g_aaiEdgeDropPointsPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
Local $listEdgesPixelToDrop[2] = [$g_aaiEdgeDropPointsPixelToDrop[$i + 3], $g_aaiEdgeDropPointsPixelToDrop[$i + 1]]
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
EndIf
Next
Else
Local $listEdgesPixelToDrop[0]
If($indexToAttack <> -1) Then
Local $nbTroopsPerEdge = $number
Local $maxElementNearCollector = $indexToAttack
Local $startIndex = $indexToAttack
Else
Local $nbTroopsPerEdge = Round($number / UBound($g_aiPixelNearCollector))
Local $maxElementNearCollector = UBound($g_aiPixelNearCollector) - 1
Local $startIndex = 0
EndIf
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
For $i = $startIndex To $maxElementNearCollector
Local $pixel = $g_aiPixelNearCollector[$i]
ReDim $listEdgesPixelToDrop[UBound($listEdgesPixelToDrop) + 1]
If($troop = $eArch Or $troop = $eWiza Or $troop = $eMini Or $troop = $eBarb) Then
$listEdgesPixelToDrop[UBound($listEdgesPixelToDrop) - 1] = _FindPixelCloser($g_aiPixelRedAreaFurther, $pixel, 5)
Else
$listEdgesPixelToDrop[UBound($listEdgesPixelToDrop) - 1] = _FindPixelCloser($g_aiPixelRedArea, $pixel, 5)
EndIf
Next
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
EndIf
Else
DropOnEdges($troop, $nbSides, $number, $slotsPerEdge)
EndIf
debugRedArea($nameFunc & " OUT ")
EndFunc
Func DropTroop2($troop, $nbSides, $number, $slotsPerEdge = 0, $name = "")
Local $nameFunc = "[DropTroop2]"
debugRedArea($nameFunc & " IN ")
debugRedArea("troop : [" & $troop & "] / nbSides : [" & $nbSides & "] / number : [" & $number & "] / slotsPerEdge [" & $slotsPerEdge & "]")
Local $listInfoPixelDropTroop[0]
If($g_abAttackStdSmartAttack[$g_iMatchMode]) Then
If $slotsPerEdge = 0 Or $number < $slotsPerEdge Then $slotsPerEdge = $number
If $nbSides < 1 Then Return
Local $nbTroopsLeft = $number
Local $nbTroopsPerEdge = Round($nbTroopsLeft / $nbSides)
If(($g_abAttackStdSmartNearCollectors[$g_iMatchMode][0] = False And $g_abAttackStdSmartNearCollectors[$g_iMatchMode][1] = False And $g_abAttackStdSmartNearCollectors[$g_iMatchMode][2] = False) Or UBound($g_aiPixelNearCollector) = 0) Then
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
If $nbSides = 4 Then
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 4]
Local $listInfoPixelDropTroop = GetPixelDropTroop($troop, $number, $slotsPerEdge)
Else
For $i = 0 To $nbSides - 1
If $nbSides = 1 Or($nbSides = 3 And $i = 2) Then
Local $g_aaiEdgeDropPointsPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 1]
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 1] = $g_aaiEdgeDropPointsPixelToDrop[$i]
ElseIf($nbSides = 2 And $i = 0) Or($nbSides = 3 And $i <> 1) Then
Local $g_aaiEdgeDropPointsPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 2]
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 2] = $g_aaiEdgeDropPointsPixelToDrop[$i + 3]
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 1] = $g_aaiEdgeDropPointsPixelToDrop[$i + 1]
EndIf
Next
EndIf
Else
Local $nbTroopsPerEdge = Round($number / UBound($g_aiPixelNearCollector))
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $maxElementNearCollector = UBound($g_aiPixelNearCollector) - 1
Local $startIndex = 0
Local $troopFurther = False
If($troop = $eArch Or $troop = $eWiza Or $troop = $eMini Or $troop = $eBarb) Then
$troopFurther = True
EndIf
Local $centerPixel[2] = [430, 338]
For $i = $startIndex To $maxElementNearCollector
Local $pixel = $g_aiPixelNearCollector[$i]
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 1]
Local $arrPixelToSearch
If($pixel[0] < $centerPixel[0] And $pixel[1] < $centerPixel[1]) Then
If($troopFurther) Then
$arrPixelToSearch = $g_aiPixelTopLeftFurther
Else
$arrPixelToSearch = $g_aiPixelTopLeft
EndIf
ElseIf($pixel[0] < $centerPixel[0] And $pixel[1] > $centerPixel[1]) Then
If($troopFurther) Then
$arrPixelToSearch = $g_aiPixelBottomLeftFurther
Else
$arrPixelToSearch = $g_aiPixelBottomLeft
EndIf
ElseIf($pixel[0] > $centerPixel[0] And $pixel[1] > $centerPixel[1]) Then
If($troopFurther) Then
$arrPixelToSearch = $g_aiPixelBottomRightFurther
Else
$arrPixelToSearch = $g_aiPixelBottomRight
EndIf
Else
If($troopFurther) Then
$arrPixelToSearch = $g_aiPixelTopRightFurther
Else
$arrPixelToSearch = $g_aiPixelTopRight
EndIf
EndIf
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 1] = _FindPixelCloser($arrPixelToSearch, $pixel, 1)
Next
EndIf
Else
DropOnEdges($troop, $nbSides, $number, $slotsPerEdge)
EndIf
Local $infoDropTroop[6] = [$troop, $listInfoPixelDropTroop, $nbTroopsPerEdge, $slotsPerEdge, $number, $name]
debugRedArea($nameFunc & " OUT ")
Return $infoDropTroop
EndFunc
Func GetLocationMine()
Local $sDirectory = @ScriptDir & "\imgxml\Storages\GoldMines"
Local $sTxtName = "Mines"
Local $iMaxReturns = 7
If $g_iDetectedImageType = 1 Then
$sDirectory = @ScriptDir & "\imgxml\Storages\Mines_Snow"
$sTxtName = "SnowMines"
EndIf
Local $aTempResult = returnMultipleMatches($sDirectory, $iMaxReturns)
Local $aEndResult = ConvertImgloc2MBR($aTempResult, $iMaxReturns)
If $g_bDebugBuildingPos Then SetLog("#*# GetLocation" & $sTxtName & ": " & $aEndResult, $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult, $sTxtName)
Return GetListPixel($aEndResult)
EndFunc
Func GetLocationElixir()
Local $sDirectory = @ScriptDir & "\imgxml\Storages\Collectors"
Local $sTxtName = "Collectors"
Local $iMaxReturns = 7
If $g_iDetectedImageType = 1 Then
$sDirectory = @ScriptDir & "\imgxml\Storages\Collectors_Snow"
$sTxtName = "SnowCollectors"
EndIf
Local $aTempResult = returnMultipleMatches($sDirectory, $iMaxReturns)
Local $aEndResult = ConvertImgloc2MBR($aTempResult, $iMaxReturns)
If $g_bDebugBuildingPos Then SetLog("#*# GetLocation" & $sTxtName & ": " & $aEndResult, $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult, $sTxtName)
Return GetListPixel($aEndResult)
EndFunc
Func GetLocationDarkElixir()
Local $sDirectory = @ScriptDir & "\imgxml\Storages\Drills"
Local $iMaxReturns = 3
Local $aTempResult = returnMultipleMatches($sDirectory, $iMaxReturns)
Local $aEndResult = ConvertImgloc2MBR($aTempResult, $iMaxReturns)
If $g_bDebugBuildingPos Then SetLog("#*# GetLocationDarkElixir: " & $aEndResult, $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult, "DarkElixir")
Return GetListPixel($aEndResult)
EndFunc
Func GetLocationTownHall()
Local $aEndResult = DllCall($g_hLibMyBot, "str", "getLocationTownHall", "ptr", $g_hHBitmap2)
If $g_bDebugBuildingPos Then SetLog("#*# GetLocationTownHall: " & $aEndResult[0], $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult[0], "TownHall")
Return GetListPixel($aEndResult[0])
EndFunc
Func GetLocationDarkElixirStorageWithLevel()
Local $aEndResult = DllCall($g_hLibMyBot, "str", "getLocationDarkElixirStorageWithLevel", "ptr", $g_hHBitmap2)
If $g_bDebugBuildingPos Then SetLog("#*# GetLocationDarkElixirStorageWithLevel: " & $aEndResult[0], $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult[0], "DarkElixirStorageWithLevel")
Return $aEndResult[0]
EndFunc
Func GetLocationDarkElixirStorage()
Local $aEndResult = DllCall($g_hLibMyBot, "str", "getLocationDarkElixirStorage", "ptr", $g_hHBitmap2)
If $g_bDebugBuildingPos Then SetLog("#*# GetLocationDarkElixirStorage: " & $aEndResult[0], $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult[0], "DarkElixirStorage")
Return GetListPixel($aEndResult[0])
EndFunc
Func GetLocationElixirWithLevel()
If $g_iDetectedImageType = 0 Then
Local $aEndResult = DllCall($g_hLibMyBot, "str", "getLocationElixirExtractorWithLevel", "ptr", $g_hHBitmap2)
If $g_bDebugBuildingPos Then SetLog("#*# getLocationElixirExtractorWithLevel: " & $aEndResult[0], $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult[0], "ElixirExtractorWithLevel")
Else
Local $aEndResult = DllCall($g_hLibMyBot, "str", "getLocationSnowElixirExtractorWithLevel", "ptr", $g_hHBitmap2)
If $g_bDebugBuildingPos Then SetLog("#*# getLocationSnowElixirExtractorWithLevel: " & $aEndResult[0], $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult[0], "SnowElixirExtractorWithLevel")
EndIf
Return $aEndResult[0]
EndFunc
Func GetLocationMineWithLevel()
If $g_iDetectedImageType = 0 Then
Local $aEndResult = DllCall($g_hLibMyBot, "str", "getLocationMineExtractorWithLevel", "ptr", $g_hHBitmap2)
If $g_bDebugBuildingPos Then SetLog("#*# getLocationMineExtractorWithLevel: " & $aEndResult[0], $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult[0], "MineExtractorWithLevel")
Else
Local $aEndResult = DllCall($g_hLibMyBot, "str", "getLocationSnowMineExtractorWithLevel", "ptr", $g_hHBitmap2)
If $g_bDebugBuildingPos Then SetLog("#*# getLocationSnowMineExtractorWithLevel: " & $aEndResult[0], $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult[0], "SnowMineExtractorWithLevel")
EndIf
Return $aEndResult[0]
EndFunc
Func GetLocationDarkElixirWithLevel()
Local $sDirectory = @ScriptDir & "\imgxml\Storages\Drills"
Local $iMaxReturns = 3
Local $aTempResult = returnMultipleMatches($sDirectory, $iMaxReturns)
Local $aEndResult = ConvertImgloc2MBR($aTempResult, $iMaxReturns, True)
If $g_bDebugBuildingPos Then SetLog("#*# getLocationDarkElixirExtractorWithLevel: " & $aEndResult, $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult, "DarkElixirExtractorWithLevel")
Return $aEndResult
EndFunc
Func GetLocationBuilding($iBuildingType, $iAttackingTH = 12, $bForceCaptureRegion = True)
If $g_bDebugSetlog Then SetDebugLog("Begin GetLocationBuilding: " & $g_sBldgNames[$iBuildingType], $COLOR_DEBUG1)
Local $hTimer = __TimerInit()
Local $TotalBuildings = 0
Local $minLevel = 0
Local $fullCocAreas = "DCD"
Local $BuildingXY, $redLines, $bRedLineExists, $aBldgCoord, $sTempCoord, $tmpNumFound
Local $tempNewLevel, $tempExistingLevel, $sLocCoord, $sNearCoord, $sFarCoord, $directory, $iCountUpdate
If $iAttackingTH = "-" Then $iAttackingTH = 12
If _ObjSearch($g_oBldgImages, $iBuildingType & "_" & $g_iDetectedImageType) = True Then
$directory = _ObjGetValue($g_oBldgImages, $iBuildingType & "_" & $g_iDetectedImageType)
If @error Then
_ObjErrMsg("_ObjGetValue $g_oBldgImages " & $g_sBldgNames[$iBuildingType] &($g_iDetectedImageType = 1 ? "Snow " : " "), @error)
SetError(1, 0, -1)
Return
EndIf
Else
$directory = _ObjGetValue($g_oBldgImages, $iBuildingType & "_0")
If @error Then
_ObjErrMsg("_ObjGetValue $g_oBldgImages" & $g_sBldgNames[$iBuildingType], @error)
SetError(1, 0, -1)
Return
EndIf
EndIf
Local $maxReturnPoints = _ObjGetValue($g_oBldgMaxQty, $iBuildingType)[$iAttackingTH - 1]
If @error Then
_ObjErrMsg("_ObjGetValue $g_oBldgMaxQty", @error)
$maxReturnPoints = 20
EndIf
If _ObjSearch($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS") = True Then
If _ObjGetValue($g_oBldgAttackInfo, $eBldgRedLine & "_COUNT") > 50 Then
$redLines = _ObjGetValue($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS")
If @error Then _ObjErrMsg("_ObjGetValue $g_oBldgAttackInfo redline", @error)
If IsString($redLines) And $redLines <> "" And $redLines <> "ECD" Then
$bRedLineExists = True
Else
$redLines = ""
$bRedLineExists = False
EndIf
Else
$redLines = ""
$bRedLineExists = False
EndIf
Else
$redLines = ""
$bRedLineExists = False
EndIf
Local $maxLevel = _ObjGetValue($g_oBldgLevels, $iBuildingType)[$iAttackingTH - 1]
If @error Then
_ObjErrMsg("_ObjGetValue $g_oBldgLevels", @error)
$maxLevel = 20
EndIf
If $bForceCaptureRegion = True Then _CaptureRegion2()
Local $res = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $directory, "str", $fullCocAreas, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
If @error Then _logErrorDLLCall($g_sLibMyBotPath, @error)
If checkImglocError($res, "SearchMultipleTilesBetweenLevels", $directory) = True Then
SetError(2, 1, 1)
Return
EndIf
If $bRedLineExists = False Then
Local $aValue = RetrieveImglocProperty("redline", "")
If $aValue <> "" Then
Local $aCoordsSplit = StringSplit($aValue, "|")
If $aCoordsSplit[0] > 50 Then
$redLines = $aValue
_ObjPutValue($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS", $redLines)
If @error Then _ObjErrMsg("_ObjPutValue $g_oBldgAttackInfo", @error)
Local $redlinesCount = $aCoordsSplit[0]
_ObjPutValue($g_oBldgAttackInfo, $eBldgRedLine & "_COUNT", $redlinesCount)
If @error Then _ObjErrMsg("_ObjSetValue $g_oBldgAttackInfo", @error)
Else
Setdebuglog("> Not enough red line points to save in building dictionary?", $COLOR_WARNING)
EndIf
Else
SetLog("> DLL Error getting Red Lines in GetLocationBuilding", $COLOR_ERROR)
EndIf
EndIf
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($aKeys) - 1
$tempNewLevel = Int(RetrieveImglocProperty($aKeys[$i], "objectlevel"))
$tmpNumFound = Int(RetrieveImglocProperty($aKeys[$i], "totalobjects"))
$sTempCoord = RetrieveImglocProperty($aKeys[$i], "objectpoints")
If $i = 0 And StringLen($sTempCoord) > 7 Then
$iCountUpdate = RemoveDupNearby($sTempCoord)
If $tmpNumFound <> $iCountUpdate And $iCountUpdate <> "" Then $tmpNumFound = $iCountUpdate
EndIf
If _ObjSearch($g_oBldgAttackInfo, $iBuildingType & "_MAXLVLFOUND") Then
$tempExistingLevel = _ObjGetValue($g_oBldgAttackInfo, $iBuildingType & "_MAXLVLFOUND")
Else
$tempExistingLevel = 0
EndIf
If Int($tempNewLevel) > Int($tempExistingLevel) Then
_ObjPutValue($g_oBldgAttackInfo, $iBuildingType & "_MAXLVLFOUND", $tempNewLevel)
If @error Then _ObjErrMsg("_ObjPutValue " & $g_sBldgNames[$iBuildingType] & " _MAXLVLFOUND", @error)
_ObjPutValue($g_oBldgAttackInfo, $iBuildingType & "_NAMEFOUND", $aKeys[$i])
If @error Then _ObjErrMsg("_ObjPutValue " & $g_sBldgNames[$iBuildingType] & " _NAMEFOUND", @error)
EndIf
If UBound($aKeys) > 1 Then
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_LVLFOUND_K" & $i, $tempNewLevel)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iBuildingType] & " _LVLFOUND_K" & $i, @error)
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_FILENAME_K" & $i, $aKeys[$i])
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iBuildingType] & " _FILENAME_K" & $i, @error)
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_COUNT_K" & $i, $tmpNumFound)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iBuildingType] & " _COUNT_K" & $i, @error)
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_OBJECTPOINTS_K" & $i, $sTempCoord)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iBuildingType] & " _OBJECTPOINTS_K" & $i, @error)
EndIf
If $sTempCoord <> "" Then
If $sLocCoord = "" Then
$sLocCoord = $sTempCoord
$TotalBuildings = $tmpNumFound
Else
$iCountUpdate = AddPoints_RemoveDuplicate($sLocCoord, $sTempCoord, $maxReturnPoints)
If $iCountUpdate <> "" Then $TotalBuildings = $iCountUpdate
EndIf
Else
SetDebugLog("> no data in 'objectpoints' request?", $COLOR_WARNING)
EndIf
Next
EndIf
$aBldgCoord = decodeMultipleCoords($sLocCoord)
If $g_bDebugBuildingPos Or $g_bDebugSetlog Then
SetLog("Bldg Loc Coord String: " & $sLocCoord, $COLOR_DEBUG)
Local $sText
Select
Case UBound($aBldgCoord, 1) > 1 And IsArray($aBldgCoord[1])
$sText = PixelArrayToString($aBldgCoord, ",")
Case IsArray($aBldgCoord[0])
Local $aPixelb = $aBldgCoord[0]
$sText = PixelToString($aPixelb, ";")
Case IsArray($aBldgCoord[0]) = 0
$sText = PixelToString($aBldgCoord, ":")
Case Else
$sText = "Monkey ate bad banana!"
EndSelect
SetLog($g_sBldgNames[$iBuildingType] & " $aBldgCoord Array Contents: " & $sText, $COLOR_DEBUG)
EndIf
If IsArray($aBldgCoord) Then
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_OBJECTPOINTS", $sLocCoord)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iBuildingType] & " _OBJECTPOINTS", @error)
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_LOCATION", $aBldgCoord)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iBuildingType] & " _LOCATION", @error)
EndIf
If $TotalBuildings <> 0 Then
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_COUNT", $TotalBuildings)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iBuildingType] & " _COUNT", @error)
EndIf
SetLog("Total " & $g_sBldgNames[$iBuildingType] & " Buildings: " & $TotalBuildings)
Local $iTime = __TimerDiff($hTimer) * 0.001
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_FINDTIME", $iTime)
If @error Then _ObjErrMsg("_ObjAdd" & $g_sBldgNames[$iBuildingType] & " _FINDTIME", @error)
If $g_bDebugBuildingPos Then SetLog("  - Location(s) found in: " & Round($iTime, 2) & " seconds ", $COLOR_DEBUG)
EndFunc
Func DebugImageGetLocation($sVector, $sType, $iBuildingENUM = "")
SetLog("DebugImageGetLocation() Start:")
SetLog("$sVector: " & $sVector)
SetLog("$sType: " & $sType)
Switch $sType
Case "DarkElixirStorageWithLevel", "ElixirExtractorWithLevel", "SnowElixirExtractorWithLevel", "MineExtractorWithLevel", "SnowMineExtractorWithLevel", "DarkElixirExtractorWithLevel"
Local $aVector = StringSplit($sVector, "~", 2)
SetLog("- " & $sType)
For $i = 0 To UBound($aVector) - 1
SetLog($sType & " " & $i & " --> " & $aVector[$i])
Local $temp = StringSplit($aVector[$i], "#", 2)
If UBound($temp) = 2 Then
Local $aPixels = StringSplit($temp[1], "-", 2)
If UBound($aPixels) = 2 Then
If isInsideDiamondRedArea($aPixels) Then
If $g_bDebugSetlog Then SetDebugLog("coordinate inside village (" & $aPixels[0] & "," & $aPixels[1] & ")")
_CaptureRegion($aPixels[0] - 30, $aPixels[1] - 30, $aPixels[0] + 30, $aPixels[1] + 30)
DebugImageSave("DebugImageGetLocation_" & $sType & "_", False)
Else
If $g_bDebugSetlog Then SetDebugLog("coordinate out of village (" & $aPixels[0] & "," & $aPixels[1] & ")")
EndIf
EndIf
EndIf
Next
Case "Mine", "SnowMine", "Elixir", "SnowElixir", "DarkElixir", "TownHall", "DarkElixirStorage", "GoldStorage", "ElixirStorage", "Inferno"
Local $aVector = StringSplit($sVector, "|", 2)
SetLog("- " & $sType)
For $i = 0 To UBound($aVector) - 1
Local $aPixels = StringSplit($aVector[$i], "-", 2)
If UBound($aPixels) = 2 Then
If isInsideDiamondRedArea($aPixels) Then
If $g_bDebugSetlog Then SetDebugLog("coordinate inside village (" & $aPixels[0] & "," & $aPixels[1] & ")")
_CaptureRegion($aPixels[0] - 30, $aPixels[1] - 30, $aPixels[0] + 30, $aPixels[1] + 30)
DebugImageSave("DebugImageGetLocation_" & $sType & "_", False)
Else
If $g_bDebugSetlog Then SetDebugLog("coordinate out of village (" & $aPixels[0] & "," & $aPixels[1] & ")")
EndIf
EndIf
Next
Case "GetBuildings"
If $iBuildingENUM = "" Then
SetLog("DebugImageGetLocation Parameter error!", $COLOR_ERROR)
Return
EndIf
Local $aVector = StringSplit($sVector, "|", 2)
SetLog("- " & $sType)
For $i = 0 To UBound($aVector) - 1
Local $aPixels = StringSplit($aVector[$i], ",", 2)
If UBound($aPixels) = 2 Then
If isInsideDiamondRedArea($aPixels) Then
If $g_bDebugSetlog Then SetDebugLog("coordinate inside village (" & $aPixels[0] & "," & $aPixels[1] & ")")
_CaptureRegion($aPixels[0] - 30, $aPixels[1] - 30, $aPixels[0] + 30, $aPixels[1] + 30)
DebugImageSave("DebugImageGetLocation_" & StringStripWS($g_sBldgNames[$iBuildingENUM], $STR_STRIPALL) & "_", False)
Else
If $g_bDebugSetlog Then SetDebugLog("coordinate out of village (" & $aPixels[0] & "," & $aPixels[1] & ")")
EndIf
EndIf
Next
Case Else
SetDebugLog("Bad Input on DebugImageGetLocation(). $sType does not support: " & $sType)
EndSwitch
EndFunc
Func ConvertImgloc2MBR($aArray, $iMaxPositions, $bLevel = False)
Local $sStringConverted = Null
Local $iMax = 0
If IsArray($aArray) Then
For $i = 1 To UBound($aArray) - 1
Local $aCoord = $aArray[$i][5]
If IsArray($aCoord) Then
For $t = 0 To UBound($aCoord) - 1
If isInsideDiamondXY($aCoord[$t][0], $aCoord[$t][1]) Then
If $bLevel Then $sStringConverted &= $aArray[$i][2] & "#" & $aCoord[$t][0] & "-" & $aCoord[$t][1] & "~"
If Not $bLevel Then $sStringConverted &= $aCoord[$t][0] & "-" & $aCoord[$t][1] & "|"
$iMax += 1
If $iMax = $iMaxPositions Then ExitLoop(2)
EndIf
Next
EndIf
Next
Else
SetLog("Error on ConvertImgLoc2MBR(): First Value is no Array!", $COLOR_ERROR)
EndIf
$sStringConverted = StringTrimRight($sStringConverted, 1)
If $g_bDebugSetlog Then SetDebugLog("$sStringConverted: " & $sStringConverted)
Return $sStringConverted
EndFunc
Func GetOffestPixelRedArea2($pixel, $eVectorType, $offset = 3)
Local $pixelOffest = $pixel
If($eVectorType = $eVectorLeftTop) Then
$pixelOffest[0] = Round($pixel[0] - $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] - $offset
ElseIf($eVectorType = $eVectorRightBottom) Then
$pixelOffest[0] = Round($pixel[0] + $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] + $offset
ElseIf($eVectorType = $eVectorLeftBottom) Then
$pixelOffest[0] = Round($pixel[0] - $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] + $offset
ElseIf($eVectorType = $eVectorRightTop) Then
$pixelOffest[0] = Round($pixel[0] + $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] - $offset
EndIf
If $pixelOffest[1] > 555 + $g_iBottomOffsetY Then
$pixelOffest[1] = 555 + $g_iBottomOffsetY
EndIf
Return $pixelOffest
EndFunc
Func GetPixelDropTroop($troop, $number, $slotsPerEdge)
Local $newPixelTopLeft
Local $newPixelBottomLeft
Local $newPixelTopRight
Local $newPixelBottomRight
If($troop = $eArch Or $troop = $eWiza Or $troop = $eMini Or $troop = $eBarb) Then
If UBound($g_aiPixelTopLeftFurther) > 0 Then
$newPixelTopLeft = $g_aiPixelTopLeftFurther
Else
$newPixelTopLeft = $g_aiPixelTopLeft
EndIf
If UBound($g_aiPixelBottomLeftFurther) > 0 Then
$newPixelBottomLeft = $g_aiPixelBottomLeftFurther
Else
$newPixelBottomLeft = $g_aiPixelBottomLeft
EndIf
If UBound($g_aiPixelTopRightFurther) > 0 Then
$newPixelTopRight = $g_aiPixelTopRightFurther
Else
$newPixelTopRight = $g_aiPixelTopRight
EndIf
If UBound($g_aiPixelBottomRightFurther) Then
$newPixelBottomRight = $g_aiPixelBottomRightFurther
Else
$newPixelBottomRight = $g_aiPixelBottomRight
EndIf
Else
$newPixelTopLeft = $g_aiPixelTopLeft
$newPixelBottomLeft = $g_aiPixelBottomLeft
$newPixelTopRight = $g_aiPixelTopRight
$newPixelBottomRight = $g_aiPixelBottomRight
EndIf
If($slotsPerEdge = 1) Then
$newPixelTopLeft = GetVectorPixelAverage($newPixelTopLeft, 0)
$newPixelBottomLeft = GetVectorPixelAverage($newPixelBottomLeft, 1)
$newPixelTopRight = GetVectorPixelAverage($newPixelTopRight, 1)
$newPixelBottomRight = GetVectorPixelAverage($newPixelBottomRight, 0)
ElseIf($slotsPerEdge = 2) Then
$newPixelTopLeft = GetVectorPixelOnEachSide($newPixelTopLeft, 0)
$newPixelBottomLeft = GetVectorPixelOnEachSide($newPixelBottomLeft, 1)
$newPixelTopRight = GetVectorPixelOnEachSide($newPixelTopRight, 1)
$newPixelBottomRight = GetVectorPixelOnEachSide($newPixelBottomRight, 0)
Else
debugRedArea("GetPixelDropTroop :  $slotsPerEdge [" & $slotsPerEdge & "] ")
$newPixelTopLeft = GetVectorPixelToDeploy($newPixelTopLeft, 0, $slotsPerEdge)
$newPixelBottomLeft = GetVectorPixelToDeploy($newPixelBottomLeft, 1, $slotsPerEdge)
$newPixelTopRight = GetVectorPixelToDeploy($newPixelTopRight, 1, $slotsPerEdge)
$newPixelBottomRight = GetVectorPixelToDeploy($newPixelBottomRight, 0, $slotsPerEdge)
EndIf
Local $g_aaiEdgeDropPointsPixelToDrop[4] = [$newPixelBottomRight, $newPixelTopLeft, $newPixelBottomLeft, $newPixelTopRight]
Return $g_aaiEdgeDropPointsPixelToDrop
EndFunc
Func GetPixelSide($listPixel, $index)
If $g_bDebugSetlog Then SetDebugLog("GetPixelSide " & $index & " = " & StringReplace($listPixel[$index], "-", ","))
Return GetListPixel($listPixel[$index])
EndFunc
Func GetVectorPixelAverage($arrPixel, $vectorDirection)
Local $vectorPixelAverage[1]
debugRedArea("GetVectorPixelAverage IN $vectorDirection [" & $vectorDirection & "]")
If(UBound($arrPixel) > 1) Then
Local $pixelSearch[2] = [-1, -1]
Local $minPixel = $arrPixel[0]
Local $maxPixel = $arrPixel[UBound($arrPixel) - 1]
Local $min = $minPixel[$vectorDirection]
Local $max = $maxPixel[$vectorDirection]
Local $posAverage =($max - $min) / 2
debugRedArea("GetVectorPixelAverage IN $min [" & $min & "]")
debugRedArea("GetVectorPixelAverage IN $max [" & $max & "]")
$pixelSearch[$vectorDirection] = $min + $posAverage
debugRedArea("GetVectorPixelAverage $pixelSearch x : [" & $pixelSearch[0] & "] / y [" & $pixelSearch[1] & "] ")
Local $arrPixelCloser = _FindPixelCloser($arrPixel, $pixelSearch, 1)
Local $arrTemp = $arrPixelCloser[0]
debugRedArea("GetVectorPixelAverage $arrTemp x : [" & $arrTemp[0] & "] / y [" & $arrTemp[1] & "] ")
$vectorPixelAverage[0] = $arrPixelCloser[0]
EndIf
Return $vectorPixelAverage
EndFunc
Func GetVectorPixelOnEachSide($arrPixel, $vectorDirection)
Local $vectorPixelEachSide[2]
If(UBound($arrPixel) > 1) Then
Local $pixelSearch[2] = [-1, -1]
Local $minPixel = $arrPixel[0]
Local $maxPixel = $arrPixel[UBound($arrPixel) - 1]
Local $min = $minPixel[$vectorDirection]
Local $max = $maxPixel[$vectorDirection]
Local $posSide =($max - $min) / 4
$pixelSearch[$vectorDirection] = $min + $posSide
Local $arrPixelCloser = _FindPixelCloser($arrPixel, $pixelSearch, 1)
$vectorPixelEachSide[0] = $arrPixelCloser[0]
$pixelSearch[$vectorDirection] = $min + $posSide * 3
Local $arrPixelCloser = _FindPixelCloser($arrPixel, $pixelSearch, 1)
$vectorPixelEachSide[1] = $arrPixelCloser[0]
EndIf
Return $vectorPixelEachSide
EndFunc
Func GetVectorPixelToDeploy($arrPixel, $vectorDirection, $sizeVector)
Local $vectorPixel[0]
debugRedArea("GetVectorPixelToDeploy IN")
debugRedArea("size " & UBound($arrPixel))
If(UBound($arrPixel) > 1) Then
Local $pixelSearch[2] = [-1, -1]
Local $minPixel = $arrPixel[0]
Local $maxPixel = $arrPixel[UBound($arrPixel) - 1]
Local $min = $minPixel[$vectorDirection]
Local $max = $maxPixel[$vectorDirection]
Local $offset =($max - $min) / $sizeVector
debugRedArea("min : [" & $min & "] / max [" & $max & "] / offset [" & $offset & "]")
If($min <= $max And $offset <= 0) Then
$offset = 1
ElseIf($min >= $max And $offset >= 0) Then
$offset = -1
EndIf
For $i = $min To $max Step $offset
$pixelSearch[$vectorDirection] = $i
Local $arrPixelCloser = _FindPixelCloser($arrPixel, $pixelSearch, 1)
ReDim $vectorPixel[UBound($vectorPixel) + 1]
$vectorPixel[UBound($vectorPixel) - 1] = $arrPixelCloser[0]
Next
EndIf
Return $vectorPixel
EndFunc
Func _IsPointInPoly($x, $y, $aPoints)
Local $bEvenNum = False, $xOnLine, $yMin, $yMax
For $i = 1 To $aPoints[0][0]
$yMin =($aPoints[$i + 1][1] < $aPoints[$i][1] ? $aPoints[$i + 1][1] : $aPoints[$i][1])
$yMax =($aPoints[$i + 1][1] > $aPoints[$i][1] ? $aPoints[$i + 1][1] : $aPoints[$i][1])
$xOnLine = -($y * $aPoints[$i + 1][0] - $y * $aPoints[$i][0] - $aPoints[$i][1] * $aPoints[$i + 1][0] + $aPoints[$i][0] * $aPoints[$i + 1][1]) /(-$aPoints[$i + 1][1] + $aPoints[$i][1])
If($x < $xOnLine) And($y > $yMin) And($y <= $yMax) Then $bEvenNum = Not $bEvenNum
Next
Return $bEvenNum
EndFunc
Func IsPointOnSide($aCoords, $sSide)
If IsArray($aCoords) = False Then
SetLog("IsPointOnSide() coordinates array not recognized", $COLOR_ERROR)
Return SetError(1, 0, "")
EndIf
Switch $sSide
Case "TL", "TOP-LEFT-UP", "TOP-LEFT-DOWN"
Local $aPoints[5][2] = [[3, 0], [425, 345], [5, 345], [425, 30], [425, 345]]
Case "TR", "TOP-RIGHT-UP", "TOP-RIGHT-DOWN"
Local $aPoints[5][2] = [[3, 0], [425, 345], [425, 30], [845, 345], [425, 345]]
Case "BL", "BOTTOM-LEFT-UP", "BOTTOM-LEFT-DOWN"
Local $aPoints[5][2] = [[3, 0], [425, 345], [5, 345], [425, 660], [425, 345]]
Case "BR", "BOTTOM-RIGHT-UP", "BOTTOM-RIGHT-DOWN"
Local $aPoints[5][2] = [[3, 0], [425, 345], [845, 345], [425, 660], [425, 345]]
Case Else
SetLog("IsPointOnSide() 'side' string not recognized", $COLOR_ERROR)
Return SetError(1, 0, "")
EndSwitch
Return _IsPointInPoly($aCoords[0], $aCoords[1], $aPoints)
EndFunc
Func RemoveDupNearby(ByRef $sLocCoord, $iDistance = 8)
SetDebugLog("Begin RemoveDupNearby", $COLOR_DEBUG1)
Local $aCoord = StringSplit($sLocCoord, "|")
Local $aLoc1, $aLoc2, $bRemovedDuplicate = False
Local $sTmpVector = ""
If IsArray($aCoord) Then
For $ep = 1 To $aCoord[0]
If $aCoord[$ep] = "" Then ContinueLoop
$aLoc1 = StringSplit($aCoord[$ep], ",")
If $aLoc1[0] = 2 Then
For $np = 1 To $aCoord[0]
If $np = $ep Then ContinueLoop
$aLoc2 = StringSplit($aCoord[$np], ",")
If $aCoord[$np] = "" Then ContinueLoop
If $aLoc2[0] = 2 Then
If _WinAPI_PtInRectEx($aLoc2[1], $aLoc2[2], $aLoc1[1] - $iDistance, $aLoc1[2] - $iDistance, $aLoc1[1] + $iDistance, $aLoc1[2] + $iDistance) = True Then
SetDebugLog("Duplicate location found, skipping: " & $aLoc2[1] & "," & $aLoc2[2], $COLOR_INFO)
$aCoord[$np] = ""
$bRemovedDuplicate = True
EndIf
Else
SetLog("RemoveDupNearby stringsplit value error!", $COLOR_ERROR)
EndIf
Next
Else
SetLog("RemoveDupNearby string value error!", $COLOR_ERROR)
EndIf
Next
Else
SetLog("RemoveDupNearby location string paramenter error!", $COLOR_ERROR)
EndIf
If $bRemovedDuplicate = True Then
For $np = 1 To $aCoord[0]
If StringStripWS($aCoord[$np], $STR_STRIPALL) = "" Then ContinueLoop
$aLoc1 = StringSplit($aCoord[$np], ",")
If @error Then ContinueLoop
$sTmpVector &= $aLoc1[1] & "," & $aLoc1[2] & "|"
Next
If StringLen($sTmpVector) > 0 Then $sTmpVector = StringLeft($sTmpVector, StringLen($sTmpVector) - 1)
SetDebugLog("Return $sTmpVector= " & $sTmpVector, $COLOR_DEBUG)
If StringInStr($sTmpVector, "|", $STR_NOCASESENSEBASIC) > 0 Then
Local $aCoord2 = StringSplit($sTmpVector, "|")
If @error Then
SetDebugLog("$sTmpVector string split failed: " & $aCoord2[1] & " , skip duplicate removal", $COLOR_WARNING)
Return $aCoord[0]
EndIf
Else
If $sTmpVector <> "" then
Local $aCoord2 = [ 1, $sTmpVector]
Else
SetDebugLog("Impossible error: RemoveDupNearby removed all points!", $COLOR_ERROR)
Return $aCoord[0]
EndIf
EndIf
If $g_bDebugSetlog And $aCoord[0] <> $aCoord2[0] Then
SetDebugLog("Duplicate objectpoints found, removed: " & $aCoord[0] - $aCoord2[0], $COLOR_INFO)
SetDebugLog("Final Coords count= " & $aCoord2[0], $COLOR_DEBUG)
EndIf
$sLocCoord = $sTmpVector
Return $aCoord2[0]
Else
Return $aCoord[0]
EndIf
EndFunc
Func AddPoints_RemoveDuplicate(ByRef $sLoc1Coord, $sLoc2Coord, $iReturnpoints, $iDistance = 8)
If $g_bDebugSetlog Then SetDebugLog("Begin AddPoints_RemoveDuplicate", $COLOR_DEBUG1)
Local $aCoord1 = StringSplit($sLoc1Coord, "|")
Local $aCoord2 = StringSplit($sLoc2Coord, "|")
Local $aLoc1, $aLoc2
Local $iPointsAdded = 0
If IsArray($aCoord1) And IsArray($aCoord2) Then
For $ep = 1 To $aCoord1[0]
$aLoc1 = StringSplit($aCoord1[$ep], ",")
If $aLoc1[0] = 2 Then
For $np = 1 To $aCoord2[0]
If $aCoord2[$np] = "" Then ContinueLoop
$aLoc2 = StringSplit($aCoord2[$np], ",")
If $aLoc2[0] = 2 Then
If _WinAPI_PtInRectEx($aLoc2[1], $aLoc2[2], $aLoc1[1] - $iDistance, $aLoc1[2] - $iDistance, $aLoc1[1] + $iDistance, $aLoc1[2] + $iDistance) = True Then
SetDebugLog("Duplicate location found, skipping: " & $aLoc2[1] & "," & $aLoc2[2], $COLOR_INFO)
$aCoord2[$np] = ""
EndIf
Else
SetLog("RemoveDuplicatePoints New string value error!", $COLOR_ERROR)
EndIf
Next
Else
SetLog("RemoveDuplicatePoints Existing string value error!", $COLOR_ERROR)
EndIf
Next
For $np = 1 To $aCoord2[0]
If $aCoord2[$np] <> "" Then
$aLoc2 = StringSplit($aCoord2[$np], ",")
If $aLoc2[0] = 2 Then
$sLoc1Coord &= "|" & $aLoc2[1] & "," & $aLoc2[2]
$iPointsAdded += 1
EndIf
If($aCoord1[0] + $iPointsAdded) >= $iReturnpoints Then
If $aCoord2[0] > $np And $aCoord2[$np + 1] <> "" Then
SetLog("AddPoints_RemoveDuplicate found more locatons then requested!", $COLOR_ERROR)
SetLog("Location string truncated to max requested: " & $iReturnpoints, $COLOR_ERROR)
ExitLoop
EndIf
EndIf
EndIf
Next
SetDebugLog("Final $sLoc1Coord= "& $sLoc1Coord, $COLOR_DEBUG)
Else
SetLog("RemoveDuplicatePoints location string paramenter error!", $COLOR_ERROR)
EndIf
Return($aCoord1[0] + $iPointsAdded)
EndFunc
Func CheckHeroesHealth()
If $g_bCheckKingPower Or $g_bCheckQueenPower Or $g_bCheckWardenPower Then
ForceCaptureRegion()
Local $aDisplayTime[$eHeroCount] = [0, 0, 0]
If $g_bDebugSetlog Then
SetDebugLog("CheckHeroesHealth() for Queen started ")
If _Sleep($DELAYRESPOND) Then Return
EndIf
If $g_iActivateQueen = 0 Or $g_iActivateQueen = 2 Then
Local $aQueenHealthCopy = $aQueenHealth
$aQueenHealthCopy[0] = GetXPosOfArmySlot($g_iQueenSlot, 68) + 3
If $g_bCheckQueenPower Then
Local $QueenPixelColor = _GetPixelColor($aQueenHealthCopy[0], $aQueenHealthCopy[1], $g_bCapturePixel)
If $g_bDebugSetlog Then SetDebugLog(" Queen _GetPixelColor(" & $aQueenHealthCopy[0] & "," & $aQueenHealthCopy[1] & "): " & $QueenPixelColor, $COLOR_DEBUG)
If Not _CheckPixel2($aQueenHealthCopy, $QueenPixelColor, "Red+Blue") Then
SetLog("Queen is getting weak, Activating Queen's ability", $COLOR_INFO)
SelectDropTroop($g_iQueenSlot)
$g_bCheckQueenPower = False
EndIf
EndIf
EndIf
If $g_iActivateQueen = 1 Or $g_iActivateQueen = 2 Then
If $g_bCheckQueenPower Then
If $g_aHeroesTimerActivation[$eHeroArcherQueen] <> 0 Then
$aDisplayTime[$eHeroArcherQueen] = Ceiling(__TimerDiff($g_aHeroesTimerActivation[$eHeroArcherQueen]) / 1000)
EndIf
If(Int($g_iDelayActivateQueen) / 1000) <= $aDisplayTime[$eHeroArcherQueen] Then
SetLog("Activating Queen's ability after " & $aDisplayTime[$eHeroArcherQueen] & "'s", $COLOR_INFO)
SelectDropTroop($g_iQueenSlot)
$g_bCheckQueenPower = False
$g_aHeroesTimerActivation[$eHeroArcherQueen] = 0
EndIf
EndIf
EndIf
If $g_bDebugSetlog Then
SetDebugLog("CheckHeroesHealth() for King started ")
If _Sleep($DELAYRESPOND) Then Return
EndIf
If $g_iActivateKing = 0 Or $g_iActivateKing = 2 Then
Local $aKingHealthCopy = $aKingHealth
$aKingHealthCopy[0] = GetXPosOfArmySlot($g_iKingSlot, 68) + 2
If $g_bCheckKingPower Then
Local $KingPixelColor = _GetPixelColor($aKingHealthCopy[0], $aKingHealthCopy[1], $g_bCapturePixel)
If $g_bDebugSetlog Then SetDebugLog(" King _GetPixelColor(" & $aKingHealthCopy[0] & "," & $aKingHealthCopy[1] & "): " & $KingPixelColor, $COLOR_DEBUG)
If Not _CheckPixel2($aKingHealthCopy, $KingPixelColor, "Red+Blue") Then
SetLog("King is getting weak, Activating King's ability", $COLOR_INFO)
SelectDropTroop($g_iKingSlot)
$g_bCheckKingPower = False
EndIf
EndIf
EndIf
If $g_iActivateKing = 1 Or $g_iActivateKing = 2 Then
If $g_bCheckKingPower Then
If $g_aHeroesTimerActivation[$eHeroBarbarianKing] <> 0 Then
$aDisplayTime[$eHeroBarbarianKing] = Ceiling(__TimerDiff($g_aHeroesTimerActivation[$eHeroBarbarianKing]) / 1000)
EndIf
If(Int($g_iDelayActivateKing) / 1000) <= $aDisplayTime[$eHeroBarbarianKing] Then
SetLog("Activating King's ability after " & $aDisplayTime[$eHeroBarbarianKing] & "'s", $COLOR_INFO)
SelectDropTroop($g_iKingSlot)
$g_bCheckKingPower = False
$g_aHeroesTimerActivation[$eHeroBarbarianKing] = 0
EndIf
EndIf
EndIf
If $g_bDebugSetlog Then
SetDebugLog("CheckHeroesHealth() for Warden started ")
If _Sleep($DELAYRESPOND) Then Return
EndIf
If $g_iActivateWarden = 0 Or $g_iActivateWarden = 2 Then
Local $aWardenHealthCopy = $aWardenHealth
$aWardenHealthCopy[0] = GetXPosOfArmySlot($g_iWardenSlot, 68)
If $g_bCheckWardenPower Then
Local $WardenPixelColor = _GetPixelColor($aWardenHealthCopy[0], $aWardenHealthCopy[1], $g_bCapturePixel)
If $g_bDebugSetlog Then SetDebugLog(" Grand Warden _GetPixelColor(" & $aWardenHealthCopy[0] & "," & $aWardenHealthCopy[1] & "): " & $WardenPixelColor, $COLOR_DEBUG)
If Not _CheckPixel2($aWardenHealthCopy, $WardenPixelColor, "Red+Blue") Then
SetLog("Grand Warden is getting weak, Activating Warden's ability", $COLOR_INFO)
SelectDropTroop($g_iWardenSlot)
$g_bCheckWardenPower = False
EndIf
EndIf
EndIf
If $g_iActivateWarden = 1 Or $g_iActivateWarden = 2 Then
If $g_bCheckWardenPower Then
If $g_aHeroesTimerActivation[$eHeroGrandWarden] <> 0 Then
$aDisplayTime[$eHeroGrandWarden] = Ceiling(__TimerDiff($g_aHeroesTimerActivation[$eHeroGrandWarden]) / 1000)
EndIf
If(Int($g_iDelayActivateWarden) / 1000) <= $aDisplayTime[$eHeroGrandWarden] Then
SetLog("Activating Warden's ability after " & $aDisplayTime[$eHeroGrandWarden] & "'s", $COLOR_INFO)
SelectDropTroop($g_iWardenSlot)
$g_bCheckWardenPower = False
$g_aHeroesTimerActivation[$eHeroGrandWarden] = 0
EndIf
EndIf
EndIf
If _Sleep($DELAYRESPOND) Then Return
EndIf
EndFunc
Func dropCC($x, $y, $slot)
Local $test1 = False
Local $test2 = False
If $g_iMatchMode = $MA And $g_abAttackDropCC[$DB] Then $test1 = True
If $g_iMatchMode <> $MA Then
If($g_iMatchMode <> $DB And $g_iMatchMode <> $LB And $g_iMatchMode <> $MA) Or $g_abAttackDropCC[$g_iMatchMode] Then $test2 = True
EndIf
If $slot <> -1 And($test1 Or $test2) Then
If $g_bPlannedDropCCHoursEnable = True Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abPlannedDropCCHours[$hour[0]] = False Then
SetLog("Drop CC not Planned, Skipped..", $COLOR_SUCCESS)
Return
EndIf
EndIf
If $g_bUseCCBalanced = True Then
If Number($g_iTroopsReceived) <> 0 Then
If Number(Number($g_iTroopsDonated) / Number($g_iTroopsReceived)) >=(Number($g_iCCDonated) / Number($g_iCCReceived)) Then
SetLog("Dropping Clan Castle, donated (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") >= " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
Click(GetXPosOfArmySlot($slot, 68), 595 + $g_iBottomOffsetY, 1, $DELAYDROPCC2, "#0086")
If _Sleep($DELAYDROPCC1) Then Return
AttackClick($x, $y, 1, 0, 0, "#0087")
Else
SetLog("No Dropping Clan Castle, donated  (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") < " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
EndIf
Else
If Number(Number($g_iTroopsDonated) / 1) >=(Number($g_iCCDonated) / Number($g_iCCReceived)) Then
SetLog("Dropping Clan Castle, donated (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") >= " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
Click(GetXPosOfArmySlot($slot, 68), 595 + $g_iBottomOffsetY, 1, $DELAYDROPCC2, "#0088")
If _Sleep($DELAYDROPCC1) Then Return
AttackClick($x, $y, 1, 0, 0, "#0089")
Else
SetLog("No Dropping Clan Castle, donated  (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") < " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
EndIf
EndIf
Else
SetLog("Dropping Clan Castle", $COLOR_INFO)
Click(GetXPosOfArmySlot($slot, 68), 595 + $g_iBottomOffsetY, 1, $DELAYDROPCC2, "#0090")
If _Sleep($DELAYDROPCC1) Then Return
AttackClick($x, $y, 1, 0, 0, "#0091")
EndIf
EndIf
EndFunc
Func dropHeroes($x, $y, $KingSlot = -1, $QueenSlot = -1, $WardenSlot = -1)
If $g_bDebugSetlog Then SetDebugLog("dropHeroes KingSlot " & $KingSlot & " QueenSlot " & $QueenSlot & " WardenSlot " & $WardenSlot & " matchmode " & $g_iMatchMode, $COLOR_DEBUG)
If _Sleep($DELAYDROPHEROES1) Then Return
Local $bDropKing = False
Local $bDropQueen = False
Local $bDropWarden = False
Local $MatchMode
If $g_iMatchMode = $TS And $g_bDuringMilkingAttack = True Then
$MatchMode = $DB
Else
$MatchMode = $g_iMatchMode
EndIf
If $KingSlot <> -1 And(($MatchMode <> $DB And $MatchMode <> $LB) Or BitAND($g_aiAttackUseHeroes[$MatchMode], $eHeroKing) = $eHeroKing) Then $bDropKing = True
If $QueenSlot <> -1 And(($MatchMode <> $DB And $MatchMode <> $LB) Or BitAND($g_aiAttackUseHeroes[$MatchMode], $eHeroQueen) = $eHeroQueen) Then $bDropQueen = True
If $WardenSlot <> -1 And(($MatchMode <> $DB And $MatchMode <> $LB) Or BitAND($g_aiAttackUseHeroes[$MatchMode], $eHeroWarden) = $eHeroWarden) Then $bDropWarden = True
If $g_bDebugSetlog Then SetDebugLog("drop KING = " & $bDropKing, $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("drop QUEEN = " & $bDropQueen, $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("drop WARDEN = " & $bDropWarden, $COLOR_DEBUG)
If $bDropKing Then
SetLog("Dropping King", $COLOR_INFO)
Click(GetXPosOfArmySlot($KingSlot, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0092")
If _Sleep($DELAYDROPHEROES2) Then Return
AttackClick($x, $y, 1, 0, 0, "#0093")
If Not $g_bDropKing Then
$g_bCheckKingPower = True
Else
SetDebugLog("King dropped 2nd time, Check Power flag not changed")
EndIf
$g_bDropKing = True
If $g_iActivateKing = 1 Or $g_iActivateKing = 2 Then $g_aHeroesTimerActivation[$eHeroBarbarianKing] = __TimerInit()
If _Sleep($DELAYDROPHEROES1) Then Return
EndIf
If _Sleep($DELAYDROPHEROES1) Then Return
If $bDropQueen Then
SetLog("Dropping Queen", $COLOR_INFO)
Click(GetXPosOfArmySlot($QueenSlot, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0094")
If _Sleep($DELAYDROPHEROES2) Then Return
AttackClick($x, $y, 1, 0, 0, "#0095")
If Not $g_bDropQueen Then
$g_bCheckQueenPower = True
Else
SetDebugLog("Queen dropped 2nd time, Check Power flag not changed")
EndIf
$g_bDropQueen = True
If $g_iActivateQueen = 1 Or $g_iActivateQueen = 2 Then $g_aHeroesTimerActivation[$eHeroArcherQueen] = __TimerInit()
If _Sleep($DELAYDROPHEROES1) Then Return
EndIf
If _Sleep($DELAYDROPHEROES1) Then Return
If $bDropWarden Then
SetLog("Dropping Grand Warden", $COLOR_INFO)
Click(GetXPosOfArmySlot($WardenSlot, 68), 595 + $g_iBottomOffsetY, 1, 0, "#X998")
If _Sleep($DELAYDROPHEROES2) Then Return
AttackClick($x, $y, 1, 0, 0, "#x999")
If Not $g_bDropWarden Then
$g_bCheckWardenPower = True
Else
SetDebugLog("Warden dropped 2nd time, Check Power flag not changed")
EndIf
$g_bDropWarden = True
If $g_iActivateWarden = 1 Or $g_iActivateWarden = 2 Then $g_aHeroesTimerActivation[$eHeroGrandWarden] = __TimerInit()
If _Sleep($DELAYDROPHEROES1) Then Return
EndIf
EndFunc
Func DropOnEdge($troop, $edge, $number, $slotsPerEdge = 0, $edge2 = -1, $x = -1)
If isProblemAffect(True) Then Return
If $number = 0 Then Return
If _SleepAttack($DELAYDROPONEDGE1) Then Return
SelectDropTroop($troop)
If _SleepAttack($DELAYDROPONEDGE2) Then Return
If $slotsPerEdge = 0 Or $number < $slotsPerEdge Then $slotsPerEdge = $number
If $number = 1 Or $slotsPerEdge = 1 Then
If $edge2 = -1 Then
AttackClick($edge[2][0], $edge[2][1], $number, $DELAYDROPONEDGE1, $DELAYDROPONEDGE3, "#0102")
Else
AttackClick($edge[2][0], $edge[2][1], $number, $DELAYDROPONEDGE1, 0, "#0102")
AttackClick($edge2[2][0], $edge2[2][1], $number, $DELAYDROPONEDGE1, $DELAYDROPONEDGE3, "#0103")
EndIf
ElseIf $slotsPerEdge = 2 Then
Local $half = Ceiling($number / 2)
AttackClick($edge[1][0], $edge[1][1], $half, SetSleep(0), 0, "#0104")
If $edge2 <> -1 Then
AttackClick($edge2[1][0], $edge2[1][1], $half, SetSleep(0), 0, "#0105")
EndIf
AttackClick($edge[3][0], $edge[3][1], $number - $half, SetSleep(0), 0, "#0106")
If $edge2 <> -1 Then
AttackClick($edge2[3][0], $edge2[3][1], $number - $half, SetSleep(0), 0, "#0107")
EndIf
Else
Local $minX = $edge[0][0]
Local $maxX = $edge[4][0]
Local $minY = $edge[0][1]
Local $maxY = $edge[4][1]
If $edge2 <> -1 Then
Local $minX2 = $edge2[0][0]
Local $maxX2 = $edge2[4][0]
Local $minY2 = $edge2[0][1]
Local $maxY2 = $edge2[4][1]
EndIf
Local $nbTroopsLeft = $number
For $i = 0 To $slotsPerEdge - 1
Local $nbtroopPerSlot = Round($nbTroopsLeft /($slotsPerEdge - $i))
Local $posX = Round($minX +(($maxX - $minX) * $i) /($slotsPerEdge - 1))
Local $posY = Round($minY +(($maxY - $minY) * $i) /($slotsPerEdge - 1))
AttackClick($posX, $posY, $nbtroopPerSlot, SetSleep(0), 0, "#0108")
If $edge2 <> -1 Then
Local $posX2 = Round($maxX2 -(($maxX2 - $minX2) * $i) /($slotsPerEdge - 1))
Local $posY2 = Round($maxY2 -(($maxY2 - $minY2) * $i) /($slotsPerEdge - 1))
AttackClick($posX2, $posY2, $nbtroopPerSlot, SetSleep(0), 0, "#0109")
EndIf
$nbTroopsLeft -= $nbtroopPerSlot
Next
EndIf
EndFunc
Func DropOnEdges($troop, $nbSides, $number, $slotsPerEdge = 0)
If $nbSides = 0 Or $number = 1 Then
OldDropTroop($troop, $g_aaiEdgeDropPoints[0], $number)
Return
EndIf
If $nbSides < 1 Then Return
Local $nbTroopsLeft = $number
If $nbSides = 4 Then
For $i = 0 To $nbSides - 3
KeepClicks()
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i * 2))
DropOnEdge($troop, $g_aaiEdgeDropPoints[$i], $nbTroopsPerEdge, $slotsPerEdge, $g_aaiEdgeDropPoints[$i + 2], $i)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
ReleaseClicks()
Next
Return
EndIf
For $i = 0 To $nbSides - 1
KeepClicks()
If $nbSides = 1 Or($nbSides = 3 And $i = 2) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i))
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] >= 4 Then
DropOnEdge($troop, $g_aaiEdgeDropPoints[$g_iBuildingEdge], $nbTroopsPerEdge, $slotsPerEdge)
Else
DropOnEdge($troop, $g_aaiEdgeDropPoints[$i], $nbTroopsPerEdge, $slotsPerEdge)
EndIf
$nbTroopsLeft -= $nbTroopsPerEdge
ElseIf($nbSides = 2 And $i = 0) Or($nbSides = 3 And $i <> 1) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i * 2))
DropOnEdge($troop, $g_aaiEdgeDropPoints[$i + 3], $nbTroopsPerEdge, $slotsPerEdge, $g_aaiEdgeDropPoints[$i + 1])
$nbTroopsLeft -= $nbTroopsPerEdge * 2
EndIf
ReleaseClicks()
Next
EndFunc
Func MatchTroopDropName($Num)
Switch _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$Num])
Case 0
Return $eBarb
Case 1
Return $eArch
Case 2
Return $eGiant
Case 3
Return $eGobl
Case 4
Return $eWall
Case 5
Return $eBall
Case 6
Return $eWiza
Case 7
Return $eHeal
Case 8
Return $eDrag
Case 9
Return $ePekk
Case 10
Return $eBabyD
Case 11
Return $eMine
case 12
Return $eEDrag
Case 13
Return $eMini
Case 14
Return $eHogs
Case 15
Return $eValk
Case 16
Return $eGole
Case 17
Return $eWitc
Case 18
Return $eLava
Case 19
Return $eBowl
Case 20
Return "CC"
Case 21
Return "HEROES"
EndSwitch
EndFunc
Func MatchSlotsPerEdge($Num)
Switch _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$Num])
Case 0
Return 0
Case 1
Return 0
Case 2
Return $g_iSlotsGiants
Case 3
Return 0
Case 4
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 Then
Return 1
Else
Return 2
EndIf
Case 5
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 Then
Return 0
Else
Return 2
EndIf
Case 6
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 Then
Return 0
Else
Return 2
EndIf
Case 7
Return 1
Case 8
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 Then
Return 0
Else
Return 2
EndIf
Case 9
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 Then
Return 1
Else
Return 2
EndIf
Case 10
Return 1
Case 11
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 Then
Return 0
Else
Return 1
EndIf
Case 12
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 Then
Return 0
Else
Return 2
EndIf
Case 13
Return 0
Case 14
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 Then
Return 1
Else
Return 2
EndIf
Case 15
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 Then
Return 0
Else
Return 2
EndIf
Case 16
Return 2
Case 17
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 Then
Return 1
Else
Return 2
EndIf
Case 18
Return 2
Case 19
Return 0
Case 20
Return 1
Case 21
Return 1
EndSwitch
EndFunc
Func MatchSidesDrop($Num)
Switch _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$Num])
Case 0 To 19
If $g_aiAttackStdDropSides[$g_iMatchMode] = 0 Then Return 1
If $g_aiAttackStdDropSides[$g_iMatchMode] = 1 Then Return 2
If $g_aiAttackStdDropSides[$g_iMatchMode] = 2 Then Return 3
If $g_aiAttackStdDropSides[$g_iMatchMode] = 3 Then Return 4
If $g_aiAttackStdDropSides[$g_iMatchMode] = 4 Then Return 4
If $g_aiAttackStdDropSides[$g_iMatchMode] = 5 Then Return 1
If $g_aiAttackStdDropSides[$g_iMatchMode] = 6 Then Return 1
Case 20
Return 1
Case 21
Return 1
EndSwitch
EndFunc
Func MatchTroopWaveNb($Num)
Return 1
EndFunc
Func GetXPosOfArmySlot($slotNumber, $xOffsetFor11Slot)
Local $CheckSlot12, $SlotPixelColorTemp, $SlotPixelColor1
$xOffsetFor11Slot -= 8
Local $SlotComp =($slotNumber = 7 ? 1 : 0)
If $slotNumber = $g_iKingSlot Or $slotNumber = $g_iQueenSlot Or $slotNumber = $g_iWardenSlot Then $xOffsetFor11Slot += 8
$CheckSlot12 = _ColorCheck(_GetPixelColor(17, 643, True), Hex(0x478AC6, 6), 15) Or  _ColorCheck(_GetPixelColor(17, 643, True), Hex(0x434343, 6), 10)
If $g_bDebugSetlog Then
SetDebugLog(" Slot 0  _ColorCheck 0x478AC6 at (17," & 643 & "): " & $CheckSlot12, $COLOR_DEBUG)
$SlotPixelColorTemp = _GetPixelColor(17, 643, $g_bCapturePixel)
SetDebugLog(" Slot 0  _GetPixelColo(17," & 643 & "): " & $SlotPixelColorTemp, $COLOR_DEBUG)
EndIf
If Not $CheckSlot12 Then
Return $xOffsetFor11Slot + $SlotComp +($slotNumber * 72)
Else
Return $xOffsetFor11Slot + $SlotComp +($slotNumber * 72) - 13
EndIf
EndFunc
Func GetSlotIndexFromXPos($xPos)
For $slot = 0 To 11
If $xPos < 68 +($slot * 72) Then
Return $slot
EndIf
Next
EndFunc
Func LaunchTroop($troopKind, $nbSides, $waveNb, $maxWaveNb, $slotsPerEdge = 0)
Local $troop = -1
Local $troopNb = 0
Local $name = ""
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $troopKind Then
$troop = $i
$troopNb = Ceiling($g_avAttackTroops[$i][1] / $maxWaveNb)
Local $plural = 0
If $troopNb > 1 Then $plural = 1
$name = NameOfTroop($troopKind, $plural)
EndIf
Next
If($troop = -1) Or($troopNb = 0) Then
Return False
EndIf
Local $waveName = "first"
If $waveNb = 2 Then $waveName = "second"
If $waveNb = 3 Then $waveName = "third"
If $maxWaveNb = 1 Then $waveName = "only"
If $waveNb = 0 Then $waveName = "last"
SetLog("Dropping " & $waveName & " wave of " & $troopNb & " " & $name, $COLOR_SUCCESS)
DropTroop($troop, $nbSides, $troopNb, $slotsPerEdge)
Return True
EndFunc
Func LaunchTroop2($listInfoDeploy, $iCC, $iKing, $iQueen, $iWarden)
If $g_bDebugSetlog Then SetDebugLog("LaunchTroop2 with CC " & $iCC & ", K " & $iKing & ", Q " & $iQueen & ", W " & $iWarden, $COLOR_DEBUG)
Local $listListInfoDeployTroopPixel[0]
Local $pixelRandomDrop[2]
Local $pixelRandomDropcc[2]
If($g_abAttackStdSmartAttack[$g_iMatchMode]) Then
For $i = 0 To UBound($listInfoDeploy) - 1
Local $troop = -1
Local $troopNb = 0
Local $name = ""
Local $troopKind = $listInfoDeploy[$i][0]
Local $nbSides = $listInfoDeploy[$i][1]
Local $waveNb = $listInfoDeploy[$i][2]
Local $maxWaveNb = $listInfoDeploy[$i][3]
Local $slotsPerEdge = $listInfoDeploy[$i][4]
If $g_bDebugSetlog Then SetDebugLog("**ListInfoDeploy row " & $i & ": USE " & $troopKind & " SIDES " & $nbSides & " WAVE " & $waveNb & " XWAVE " & $maxWaveNb & " SLOTXEDGE " & $slotsPerEdge, $COLOR_DEBUG)
If(IsNumber($troopKind)) Then
For $j = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$j][0] = $troopKind Then
$troop = $j
$troopNb = Ceiling($g_avAttackTroops[$j][1] / $maxWaveNb)
Local $plural = 0
If $troopNb > 1 Then $plural = 1
$name = NameOfTroop($troopKind, $plural)
EndIf
Next
EndIf
If($troop <> -1 And $troopNb > 0) Or IsString($troopKind) Then
Local $listInfoDeployTroopPixel
If(UBound($listListInfoDeployTroopPixel) < $waveNb) Then
ReDim $listListInfoDeployTroopPixel[$waveNb]
Local $newListInfoDeployTroopPixel[0]
$listListInfoDeployTroopPixel[$waveNb - 1] = $newListInfoDeployTroopPixel
EndIf
$listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$waveNb - 1]
ReDim $listInfoDeployTroopPixel[UBound($listInfoDeployTroopPixel) + 1]
If(IsString($troopKind)) Then
Local $arrCCorHeroes[1] = [$troopKind]
$listInfoDeployTroopPixel[UBound($listInfoDeployTroopPixel) - 1] = $arrCCorHeroes
Else
Local $infoDropTroop = DropTroop2($troop, $nbSides, $troopNb, $slotsPerEdge, $name)
$listInfoDeployTroopPixel[UBound($listInfoDeployTroopPixel) - 1] = $infoDropTroop
EndIf
$listListInfoDeployTroopPixel[$waveNb - 1] = $listInfoDeployTroopPixel
EndIf
Next
If(($g_abAttackStdSmartNearCollectors[$g_iMatchMode][0] Or $g_abAttackStdSmartNearCollectors[$g_iMatchMode][1] Or $g_abAttackStdSmartNearCollectors[$g_iMatchMode][2]) And UBound($g_aiPixelNearCollector) = 0) Then
SetLog("Error, no pixel found near collector => Normal attack near red line")
EndIf
If($g_aiAttackStdSmartDeploy[$g_iMatchMode] = 0) Then
For $numWave = 0 To UBound($listListInfoDeployTroopPixel) - 1
Local $listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$numWave]
For $i = 0 To UBound($listInfoDeployTroopPixel) - 1
Local $infoPixelDropTroop = $listInfoDeployTroopPixel[$i]
If(IsString($infoPixelDropTroop[0]) And($infoPixelDropTroop[0] = "CC" Or $infoPixelDropTroop[0] = "HEROES")) Then
If $g_aiDeployHeroesPosition[0] <> -1 Then
$pixelRandomDrop[0] = $g_aiDeployHeroesPosition[0]
$pixelRandomDrop[1] = $g_aiDeployHeroesPosition[1]
If $g_bDebugSetlog Then SetDebugLog("Deploy Heroes $g_aiDeployHeroesPosition")
Else
$pixelRandomDrop[0] = $g_aaiBottomRightDropPoints[2][0]
$pixelRandomDrop[1] = $g_aaiBottomRightDropPoints[2][1]
If $g_bDebugSetlog Then SetDebugLog("Deploy Heroes $g_aaiBottomRightDropPoints")
EndIf
If $g_aiDeployCCPosition[0] <> -1 Then
$pixelRandomDropcc[0] = $g_aiDeployCCPosition[0]
$pixelRandomDropcc[1] = $g_aiDeployCCPosition[1]
If $g_bDebugSetlog Then SetDebugLog("Deploy CC $g_aiDeployHeroesPosition")
Else
$pixelRandomDropcc[0] = $g_aaiBottomRightDropPoints[2][0]
$pixelRandomDropcc[1] = $g_aaiBottomRightDropPoints[2][1]
If $g_bDebugSetlog Then SetDebugLog("Deploy CC $g_aaiBottomRightDropPoints")
EndIf
If($infoPixelDropTroop[0] = "CC") Then
dropCC($pixelRandomDropcc[0], $pixelRandomDropcc[1], $iCC)
$g_bIsCCDropped = True
ElseIf($infoPixelDropTroop[0] = "HEROES") Then
dropHeroes($pixelRandomDrop[0], $pixelRandomDrop[1], $iKing, $iQueen, $iWarden)
$g_bIsHeroesDropped = True
EndIf
Else
If _Sleep($DELAYLAUNCHTROOP21) Then Return
SelectDropTroop($infoPixelDropTroop[0])
If _Sleep($DELAYLAUNCHTROOP21) Then Return
Local $waveName = "first"
If $numWave + 1 = 2 Then $waveName = "second"
If $numWave + 1 = 3 Then $waveName = "third"
If $numWave + 1 = 0 Then $waveName = "last"
SetLog("Dropping " & $waveName & " wave of " & $infoPixelDropTroop[5] & " " & $infoPixelDropTroop[4], $COLOR_SUCCESS)
DropOnPixel($infoPixelDropTroop[0], $infoPixelDropTroop[1], $infoPixelDropTroop[2], $infoPixelDropTroop[3])
EndIf
If($g_bIsHeroesDropped) Then
If _Sleep($DELAYLAUNCHTROOP22) Then Return
CheckHeroesHealth()
EndIf
If _Sleep(SetSleep(1)) Then Return
Next
Next
Else
For $numWave = 0 To UBound($listListInfoDeployTroopPixel) - 1
Local $listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$numWave]
If(UBound($listInfoDeployTroopPixel) > 0) Then
Local $infoTroopListArrPixel = $listInfoDeployTroopPixel[0]
Local $numberSidesDropTroop = 1
For $i = 0 To UBound($listInfoDeployTroopPixel) - 1
$infoTroopListArrPixel = $listInfoDeployTroopPixel[$i]
If(UBound($infoTroopListArrPixel) > 1) Then
Local $infoListArrPixel = $infoTroopListArrPixel[1]
$numberSidesDropTroop = UBound($infoListArrPixel)
ExitLoop
EndIf
Next
If($numberSidesDropTroop > 0) Then
For $i = 0 To $numberSidesDropTroop - 1
For $j = 0 To UBound($listInfoDeployTroopPixel) - 1
$infoTroopListArrPixel = $listInfoDeployTroopPixel[$j]
If(IsString($infoTroopListArrPixel[0]) And($infoTroopListArrPixel[0] = "CC" Or $infoTroopListArrPixel[0] = "HEROES")) Then
If $g_aiDeployHeroesPosition[0] <> -1 Then
$pixelRandomDrop[0] = $g_aiDeployHeroesPosition[0]
$pixelRandomDrop[1] = $g_aiDeployHeroesPosition[1]
If $g_bDebugSetlog Then SetDebugLog("Deploy Heroes $g_aiDeployHeroesPosition")
Else
$pixelRandomDrop[0] = $g_aaiBottomRightDropPoints[2][0]
$pixelRandomDrop[1] = $g_aaiBottomRightDropPoints[2][1]
If $g_bDebugSetlog Then SetDebugLog("Deploy Heroes $g_aaiBottomRightDropPoints")
EndIf
If $g_aiDeployCCPosition[0] <> -1 Then
$pixelRandomDropcc[0] = $g_aiDeployCCPosition[0]
$pixelRandomDropcc[1] = $g_aiDeployCCPosition[1]
If $g_bDebugSetlog Then SetDebugLog("Deploy CC $g_aiDeployHeroesPosition")
Else
$pixelRandomDropcc[0] = $g_aaiBottomRightDropPoints[2][0]
$pixelRandomDropcc[1] = $g_aaiBottomRightDropPoints[2][1]
If $g_bDebugSetlog Then SetDebugLog("Deploy CC $g_aaiBottomRightDropPoints")
EndIf
If($g_bIsCCDropped = False And $infoTroopListArrPixel[0] = "CC") Then
dropCC($pixelRandomDropcc[0], $pixelRandomDropcc[1], $iCC)
$g_bIsCCDropped = True
ElseIf($g_bIsHeroesDropped = False And $infoTroopListArrPixel[0] = "HEROES" And $i = $numberSidesDropTroop - 1) Then
dropHeroes($pixelRandomDrop[0], $pixelRandomDrop[1], $iKing, $iQueen, $iWarden)
$g_bIsHeroesDropped = True
EndIf
Else
$infoListArrPixel = $infoTroopListArrPixel[1]
Local $listPixel = $infoListArrPixel[$i]
If _Sleep($DELAYLAUNCHTROOP21) Then Return
SelectDropTroop($infoTroopListArrPixel[0])
If _Sleep($DELAYLAUNCHTROOP23) Then Return
SetLog("Dropping " & $infoTroopListArrPixel[2] & "  of " & $infoTroopListArrPixel[5] & " => on each side (side : " & $i + 1 & ")", $COLOR_SUCCESS)
Local $pixelDropTroop[1] = [$listPixel]
DropOnPixel($infoTroopListArrPixel[0], $pixelDropTroop, $infoTroopListArrPixel[2], $infoTroopListArrPixel[3])
EndIf
If($g_bIsHeroesDropped) Then
If _sleep(1000) Then Return
CheckHeroesHealth()
EndIf
Next
Next
EndIf
EndIf
If _Sleep(SetSleep(1)) Then Return
Next
EndIf
For $numWave = 0 To UBound($listListInfoDeployTroopPixel) - 1
Local $listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$numWave]
For $i = 0 To UBound($listInfoDeployTroopPixel) - 1
Local $infoPixelDropTroop = $listInfoDeployTroopPixel[$i]
If Not(IsString($infoPixelDropTroop[0]) And($infoPixelDropTroop[0] = "CC" Or $infoPixelDropTroop[0] = "HEROES")) Then
Local $numberLeft = ReadTroopQuantity($infoPixelDropTroop[0])
If($numberLeft > 0) Then
If _Sleep($DELAYLAUNCHTROOP21) Then Return
SelectDropTroop($infoPixelDropTroop[0])
If _Sleep($DELAYLAUNCHTROOP23) Then Return
SetLog("Dropping last " & $numberLeft & "  of " & $infoPixelDropTroop[5], $COLOR_SUCCESS)
DropOnPixel($infoPixelDropTroop[0], $infoPixelDropTroop[1], Ceiling($numberLeft / UBound($infoPixelDropTroop[1])), $infoPixelDropTroop[3])
EndIf
EndIf
Next
Next
Else
For $i = 0 To UBound($listInfoDeploy) - 1
If(IsString($listInfoDeploy[$i][0]) And($listInfoDeploy[$i][0] = "CC" Or $listInfoDeploy[$i][0] = "HEROES")) Then
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] >= 4 Then
Local $RandomEdge = $g_aaiEdgeDropPoints[$g_iBuildingEdge]
Local $RandomXY = 2
Else
Local $RandomEdge = $g_aaiEdgeDropPoints[Round(Random(0, 3))]
Local $RandomXY = Round(Random(1, 3))
EndIf
If($listInfoDeploy[$i][0] = "CC") Then
dropCC($RandomEdge[$RandomXY][0], $RandomEdge[$RandomXY][1], $iCC)
ElseIf($listInfoDeploy[$i][0] = "HEROES") Then
dropHeroes($RandomEdge[$RandomXY][0], $RandomEdge[$RandomXY][1], $iKing, $iQueen, $iWarden)
EndIf
Else
If $g_bDuringMilkingAttack = False Then
If LaunchTroop($listInfoDeploy[$i][0], $listInfoDeploy[$i][1], $listInfoDeploy[$i][2], $listInfoDeploy[$i][3], $listInfoDeploy[$i][4]) Then
If _Sleep(SetSleep(1)) Then Return
EndIf
Else
If $listInfoDeploy[$i][0] <> $eGobl Then
If LaunchTroop($listInfoDeploy[$i][0], $listInfoDeploy[$i][1], $listInfoDeploy[$i][2], $listInfoDeploy[$i][3], $listInfoDeploy[$i][4]) Then
If _Sleep(SetSleep(1)) Then Return
EndIf
EndIf
EndIf
EndIf
Next
EndIf
Return True
EndFunc
Func NameOfTroop($iKind, $iPlural = 0)
Local $sTroopname
Switch $iKind
Case $eBarb
$sTroopname = "Barbarian"
Case $eArch
$sTroopname = "Archer"
Case $eGobl
$sTroopname = "Goblin"
Case $eGiant
$sTroopname = "Giant"
Case $eWall
$sTroopname = "Wall Breaker"
Case $eWiza
$sTroopname = "Wizard"
Case $eBall
$sTroopname = "Balloon"
Case $eHeal
$sTroopname = "Healer"
Case $eDrag
$sTroopname = "Dragon"
Case $ePekk
$sTroopname = "Pekka"
Case $eBabyD
$sTroopname = "Baby Dragon"
Case $eMine
$sTroopname = "Miner"
Case $eEDrag
$sTroopname = "Electro Dragon"
Case $eMini
$sTroopname = "Minion"
Case $eHogs
$sTroopname = "Hog Rider"
Case $eValk
$sTroopname = "Valkyrie"
Case $eWitc
$sTroopname = "Witch"
Case $eGole
$sTroopname = "Golem"
Case $eLava
$sTroopname = "Lava Hound"
Case $eBowl
$sTroopname = "Bowler"
Case $eKing
$sTroopname = "King"
$iPlural = 0
Case $eQueen
$sTroopname = "Queen"
$iPlural = 0
Case $eWarden
$sTroopname = "Grand Warden"
$iPlural = 0
Case $eCastle
$sTroopname = "Clan Castle"
$iPlural = 0
Case $eLSpell
$sTroopname = "Lightning Spell"
Case $eHSpell
$sTroopname = "Heal Spell"
Case $eRSpell
$sTroopname = "Rage Spell"
Case $eJSpell
$sTroopname = "Jump Spell"
Case $eFSpell
$sTroopname = "Freeze Spell"
Case $eCSpell
$sTroopname = "Clone Spell"
Case $ePSpell
$sTroopname = "Poison Spell"
Case $eESpell
$sTroopname = "Earthquake Spell"
Case $eHaSpell
$sTroopname = "Haste Spell"
Case $eSkSpell
$sTroopname = "Skeleton Spell"
Case Else
Return ""
EndSwitch
If $iPlural = 1 And $iKind = $eWitc Then $sTroopname &= "e"
If $iPlural = 1 Then $sTroopname &= "s"
Return $sTroopname
EndFunc
Func OldDropTroop($troop, $position, $nbperspot)
SelectDropTroop($troop)
If _Sleep($DELAYOLDDROPTROOP1) Then Return
For $i = 0 To 4
Click($position[$i][0], $position[$i][1], $nbperspot, 1, "#0110")
If _Sleep($DELAYOLDDROPTROOP2) Then Return
Next
EndFunc
Func ReadTroopQuantity($Troop, $CheckSelectedSlot = False, $bNeedNewCapture = True)
Local $iAmount
Switch $CheckSelectedSlot
Case False
$iAmount = getTroopCountSmall(GetXPosOfArmySlot($Troop, 40), 640)
If $iAmount = "" Then
$iAmount = getTroopCountBig(GetXPosOfArmySlot($Troop, 40), 633)
EndIf
Case Else
Local $rGetXPosOfArmySlot = GetXPosOfArmySlot($Troop, 40)
Local $isTheSlotSelected = IsSlotSelected($Troop, $bNeedNewCapture)
If Not $isTheSlotSelected Then
$iAmount = Number(getTroopCountSmall($rGetXPosOfArmySlot, 640))
Else
$iAmount = Number(getTroopCountBig($rGetXPosOfArmySlot, 633))
EndIf
EndSwitch
Return Number($iAmount)
EndFunc
Func IsSlotSelected($iSlotIndex, $bNeedNewCapture = Default)
If Not $bNeedNewCapture Then $bNeedNewCapture = True
If $bNeedNewCapture Then
ForceCaptureRegion()
_CaptureRegion()
EndIf
Local $iOffset = 73
Local $iStartX = 75
Local $iY = 724
If $bNeedNewCapture Then
Return _ColorCheck(  _GetPixelColor($iStartX +($iOffset * $iSlotIndex), $iY, False), Hex(0xFFFFFF, 6), 20)
Else
Return _ColorCheck( Hex(_GDIPlus_BitmapGetPixel(_GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2),($iStartX +($iOffset * $iSlotIndex)), $iY), 6), Hex(0xFFFFFF, 6), 20)
EndIf
EndFunc
Func SelectDropTroop($Troop)
If IsAttackPage() Then Click(GetXPosOfArmySlot($Troop, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0111")
EndFunc
Func SetSleep($type)
If IsKeepClicksActive() = True Then Return 0
Local $factor0 = 10
Local $factor1 = 100
If $g_bAndroidAdbClick = True Then
$factor0 = 10
$factor1 = 100
EndIf
Switch $type
Case 0
If $g_abAttackStdRandomizeDelay[$g_iMatchMode] Then
Return Round(Random(1, 10)) * $factor0
Else
Return($g_aiAttackStdUnitDelay[$g_iMatchMode] + 1) * $factor0
EndIf
Case 1
If $g_abAttackStdRandomizeDelay[$g_iMatchMode] Then
Return Round(Random(1, 10)) * $factor1
Else
Return($g_aiAttackStdWaveDelay[$g_iMatchMode] + 1) * $factor1
EndIf
EndSwitch
EndFunc
Func _SleepAttack($iDelay, $iSleep = True)
If $g_bRunState = False Then
ResumeAndroid()
Return True
EndIf
If IsKeepClicksActive() = True Then Return False
Return _Sleep($iDelay, $iSleep)
EndFunc
Func drillSearch()
Local $aReturnResult[0][5]
Local $pixelerror = 15
Local $Maxpositions = 0
Local $aResult = multiMatches($g_sImgSearchDrill, $Maxpositions, "ECD", "ECD")
For $iResult = 1 To UBound($aResult) - 1
If _Sleep(10) Then Return
Local $aTemp[0][2]
_ArrayAdd($aTemp, $aResult[$iResult][5], 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
_ArrayColInsert($aTemp, 2)
_ArrayColInsert($aTemp, 3)
_ArrayColInsert($aTemp, 4)
For $iRow = 0 To UBound($aTemp) - 1
$aTemp[$iRow][2] = $aResult[$iResult][2]
$aTemp[$iRow][4] = 0
Next
_ArrayAdd($aReturnResult, $aTemp, 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
Next
Local $iResult = 0
While $iResult < UBound($aReturnResult)
If _Sleep(10) Then Return
Local $jResult = $iResult + 1
While $jResult < UBound($aReturnResult)
If Abs($aReturnResult[$iResult][0] - $aReturnResult[$jResult][0]) <= $pixelerror And Abs($aReturnResult[$iResult][1] - $aReturnResult[$jResult][1]) <= $pixelerror Then
$aReturnResult[$iResult][2] = _Min(Number($aReturnResult[$iResult][2]), Number($aReturnResult[$jResult][2]))
If $g_bDebugSmartZap = True Then
SetLog("Found Duplicate Dark Elixir Drill: [" & $aReturnResult[$jResult][0] & "," & $aReturnResult[$jResult][1] & "], Level: " & $aReturnResult[$jResult][2], $COLOR_DEBUG)
EndIf
_ArrayDelete($aReturnResult, $jResult)
Else
$jResult += 1
EndIf
WEnd
Local $iDrillLevel = CheckDrillLvl($aReturnResult[$iResult][0], $aReturnResult[$iResult][1])
If $iDrillLevel > 0 And $aReturnResult[$iResult][2] <> $iDrillLevel Then
If $g_bDebugSmartZap = True Then SetLog("Correcting Drill Level, old = " & $aReturnResult[$iResult][2] & ", new = " & $iDrillLevel, $COLOR_DEBUG)
$aReturnResult[$iResult][2] = $iDrillLevel
EndIf
$aReturnResult[$iResult][3] = Ceiling(Number($g_aDrillLevelTotal[$aReturnResult[$iResult][2] - 1] * $g_fDarkStealFactor))
If $g_bDebugSmartZap = True Then
SetLog(($iResult + 1) & ". Valid Drill: [" & $aReturnResult[$iResult][0] & "," & $aReturnResult[$iResult][1] & "], Level: " & $aReturnResult[$iResult][2] & ", Hold: " & $aReturnResult[$iResult][3], $COLOR_DEBUG)
EndIf
$iResult += 1
WEnd
Return $aReturnResult
EndFunc
Func CheckDrillLvl($x, $y)
_CaptureRegion2($x - 25, $y - 25, $x + 25, $y + 25)
Local $aResult = multiMatches($g_sImgSearchDrillLevel, 1, "FV", "FV", "", 0, 1000, False)
If $g_bDebugSmartZap = True Then SetLog("CheckDrillLvl: UBound($aresult) = " & UBound($aResult), $COLOR_DEBUG)
If UBound($aResult) > 1 Then
If $g_bDebugSmartZap = True Then SetLog("CheckDrillLvl: $aresult[" &(UBound($aResult) - 1) & "][2] = " & $aResult[UBound($aResult) - 1][2], $COLOR_DEBUG)
Return $aResult[UBound($aResult) - 1][2]
EndIf
Return 0
EndFunc
Func getDrillCluster(Const ByRef $aDarkDrills)
Local $iMaxMedianDist = 26
Local $aBestCluster[4] = [0, 0, 0, -1]
If UBound($aDarkDrills) < 2 Then Return -1
If UBound($aDarkDrills) > 2 Then
Local $iMedianX = Ceiling(Number(($aDarkDrills[0][0] + $aDarkDrills[1][0] + $aDarkDrills[2][0]) / 3))
Local $iMedianY = Ceiling(Number(($aDarkDrills[0][1] + $aDarkDrills[1][1] + $aDarkDrills[2][1]) / 3))
If $g_bDebugSmartZap = True Then SetLog("TripleDrill Unweighted Median Point: x = " & $iMedianX & ", y = " & $iMedianY, $COLOR_DEBUG)
For $i = 0 To 2
If Abs($aDarkDrills[$i][0] - $iMedianX) > $iMaxMedianDist Or Abs($aDarkDrills[$i][1] - $iMedianY) > $iMaxMedianDist Then
$aBestCluster[3] = -1
ExitLoop
Else
Local $aTemp[3] = [0, 1, 2]
$aBestCluster[3] = $aTemp
EndIf
Next
If $g_bDebugSmartZap = True And $aBestCluster[3] <> -1 Then SetLog("TripleDrill Cluster found." & $aBestCluster[3], $COLOR_DEBUG)
EndIf
If $aBestCluster[3] = -1 Then
Local $iMaxHold = 0
For $i = 0 To UBound($aDarkDrills) - 1
Local $iMedianX = Ceiling(Number(($aDarkDrills[$i][0] + $aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][0]) / 2))
Local $iMedianY = Ceiling(Number(($aDarkDrills[$i][1] + $aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][1]) / 2))
If $g_bDebugSmartZap = True Then SetLog("[" & $i & "," & Mod($i + 1, UBound($aDarkDrills)) & "] DoubleDrill Unweighted Median Point: x = " & $iMedianX & ", y = " & $iMedianY, $COLOR_DEBUG)
If $aDarkDrills[$i][3] + $aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][3] > $iMaxHold Then
If Abs($aDarkDrills[$i][0] - $iMedianX) <= $iMaxMedianDist And Abs($aDarkDrills[$i][1] - $iMedianY) <= $iMaxMedianDist And Abs($aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][0] - $iMedianX) <= $iMaxMedianDist And Abs($aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][1] - $iMedianY) <= $iMaxMedianDist Then
$iMaxHold = $aDarkDrills[$i][3] + $aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][3]
Local $aTemp[2] = [$i, Mod($i + 1, UBound($aDarkDrills))]
$aBestCluster[3] = $aTemp
EndIf
EndIf
Next
If $g_bDebugSmartZap = True And $aBestCluster[3] <> -1 Then SetLog("DoubleDrill Cluster found: [" &($aBestCluster[3])[0] & "," &($aBestCluster[3])[1] & "]", $COLOR_DEBUG)
EndIf
If $aBestCluster[3] = -1 Then
Return -1
Else
Local $iWeightedMedianX = 0
Local $iWeightedMedianY = 0
Local $iWeightedMedianDiv = 0
Local $iTotalHold = 0
For $i = 0 To UBound($aBestCluster[3]) - 1
$iWeightedMedianX += $aDarkDrills[($aBestCluster[3])[$i]][0] * $g_aDrillLevelHP[$aDarkDrills[($aBestCluster[3])[$i]][2] - 1]
$iWeightedMedianY += $aDarkDrills[($aBestCluster[3])[$i]][1] * $g_aDrillLevelHP[$aDarkDrills[($aBestCluster[3])[$i]][2] - 1]
$iWeightedMedianDiv += $g_aDrillLevelHP[$aDarkDrills[($aBestCluster[3])[$i]][2] - 1]
$iTotalHold += $aDarkDrills[($aBestCluster[3])[$i]][3]
Next
$aBestCluster[0] = Ceiling(Number($iWeightedMedianX / $iWeightedMedianDiv))
$aBestCluster[1] = Ceiling(Number($iWeightedMedianY / $iWeightedMedianDiv))
$aBestCluster[2] = $iTotalHold
If $g_bDebugSmartZap = True Then SetLog("Best Cluster: weighted x = " & $aBestCluster[0] & ", weighted y = " & $aBestCluster[1] & ", hold = " & $aBestCluster[2], $COLOR_DEBUG)
Return $aBestCluster
EndIf
EndFunc
Func easyPreySearch()
Local $aReturnResult[0][3]
Local $pixelerror = 10, $iMaxCombDist = 60
For $iLoop = 1 To 3
If $iLoop > 1 Then
If _Sleep(5000) Then Return
EndIf
Local $aResult = multiMatches($g_sImgEasyBuildings, 0, "ECD", "ECD")
If $g_bDebugSmartZap = True Then
If UBound($aResult) = 2 Then
SetLog("1 target type found in " & $iLoop & ". searchround.", $COLOR_DEBUG)
Else
SetLog(UBound($aResult) - 1 & " target types found in " & $iLoop & ". searchround.", $COLOR_DEBUG)
EndIf
EndIf
For $iResult = 1 To UBound($aResult) - 1
If _Sleep(10) Then Return
Local $aTemp[0][2]
_ArrayAdd($aTemp, $aResult[$iResult][5], 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
_ArrayColInsert($aTemp, 2)
For $iRow = 0 To UBound($aTemp) - 1
$aTemp[$iRow][2] = 1
Next
_ArrayAdd($aReturnResult, $aTemp, 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
Next
Next
Local $iResult = 0
While $iResult < UBound($aReturnResult)
If _Sleep(10) Then Return
Local $jResult = $iResult + 1
While $jResult < UBound($aReturnResult)
If Abs($aReturnResult[$iResult][0] - $aReturnResult[$jResult][0]) <= $pixelerror And Abs($aReturnResult[$iResult][1] - $aReturnResult[$jResult][1]) <= $pixelerror Then
If $g_bDebugSmartZap = True Then
SetLog("Found Duplicate Target: [" & $aReturnResult[$jResult][0] & "," & $aReturnResult[$jResult][1] & "]", $COLOR_DEBUG)
EndIf
_ArrayDelete($aReturnResult, $jResult)
Else
$jResult += 1
EndIf
WEnd
$iResult += 1
WEnd
Local $iResult = 0
While $iResult < UBound($aReturnResult)
If _Sleep(10) Then Return
Local $jResult = $iResult + 1
While $jResult < UBound($aReturnResult)
If Abs($aReturnResult[$iResult][0] - $aReturnResult[$jResult][0]) + Abs($aReturnResult[$iResult][1] - $aReturnResult[$jResult][1]) <= $iMaxCombDist Then
If $g_bDebugSmartZap = True Then
SetLog("Found Targets for consolidation: [" & $aReturnResult[$iResult][0] & "," & $aReturnResult[$iResult][1] & "," & $aReturnResult[$iResult][2] & "] & [" & $aReturnResult[$jResult][0] & "," & $aReturnResult[$jResult][1] & "," & $aReturnResult[$jResult][2] & "]", $COLOR_DEBUG)
EndIf
Local $iNewWeight = $aReturnResult[$iResult][2] + $aReturnResult[$jResult][2]
$aReturnResult[$iResult][0] = Ceiling(Number(($aReturnResult[$iResult][0] * $aReturnResult[$iResult][2] + $aReturnResult[$jResult][0] * $aReturnResult[$jResult][2]) / $iNewWeight))
$aReturnResult[$iResult][1] = Ceiling(Number(($aReturnResult[$iResult][1] * $aReturnResult[$iResult][2] + $aReturnResult[$jResult][1] * $aReturnResult[$jResult][2]) / $iNewWeight))
$aReturnResult[$iResult][2] = $iNewWeight
_ArrayDelete($aReturnResult, $jResult)
ContinueLoop 2
EndIf
$jResult += 1
WEnd
$iResult += 1
WEnd
If UBound($aReturnResult) > 1 Then _ArraySort($aReturnResult, 1, 0, 0, 2)
Return $aReturnResult
EndFunc
Func displayZapLog(Const ByRef $aDarkDrills, Const ByRef $Spells)
Local $drillStealableString = "Drills Lvl/Estimated Amount left: "
Local $spellsLeftString = "Spells left: "
For $i = 0 To UBound($aDarkDrills) - 1
If $i = 0 Then
If $aDarkDrills[$i][3] <> -1 Then $drillStealableString &= "Lvl" & $aDarkDrills[$i][2] & "/" & $aDarkDrills[$i][3]
Else
If $aDarkDrills[$i][3] <> -1 Then $drillStealableString &= ", Lvl" & $aDarkDrills[$i][2] & "/" & $aDarkDrills[$i][3]
EndIf
Next
If $Spells[0][4] + $Spells[1][4] + $Spells[2][4] = 0 Then
$spellsLeftString &= "None"
Else
If $Spells[2][4] > 0 Then $spellsLeftString &= $Spells[2][4] & " " & NameOfTroop($Spells[2][1], 1)
If $Spells[2][4] > 0 And $Spells[0][4] + $Spells[1][4] > 0 Then $spellsLeftString &= ", "
If $Spells[0][4] + $Spells[1][4] > 0 Then $spellsLeftString &= $Spells[0][4] + $Spells[1][4] & " " & NameOfTroop($Spells[1][1], 1)
EndIf
If $drillStealableString <> "Drills Lvl/Estimated Amount left: " Then
If $g_bNoobZap = False Then
SetLog($drillStealableString, $COLOR_INFO)
Else
If $g_bDebugSmartZap = True Then SetLog($drillStealableString, $COLOR_DEBUG)
EndIf
EndIf
If $spellsLeftString <> "Spells left: " Then
SetLog($spellsLeftString, $COLOR_INFO)
EndIf
EndFunc
Func getDarkElixir()
Local $g_iSearchDark = "", $iCount = 0
If _CheckPixel($aAtkHasDarkElixir, $g_bCapturePixel, Default, "HasDarkElixir") Or _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x0F0617, 6), 5) Then
While $g_iSearchDark = ""
$g_iSearchDark = getDarkElixirVillageSearch(48, 126)
$iCount += 1
If $iCount > 15 Then ExitLoop
If _Sleep($DELAYSMARTZAP1) Then Return
WEnd
Else
$g_iSearchDark = False
If $g_bDebugSmartZap = True Then SetLog(" - No DE detected.", $COLOR_DEBUG)
EndIf
Return $g_iSearchDark
EndFunc
Func getDrillOffset()
Local $result = -1
Switch $g_iTownHallLevel
Case 0 To 7
$result = 2
Case 8
$result = 1
Case Else
$result = 0
EndSwitch
Return $result
EndFunc
Func getSpellOffset()
Local $result = -1
Switch $g_iTownHallLevel
Case 0 To 4
$result = -1
Case 5, 6
$result = -1
Case 7, 8
$result = 2
Case 9
$result = 1
Case Else
$result = 0
EndSwitch
Return $result
EndFunc
Func smartZap($minDE = -1)
Local $strikeOffsets = [0, 14]
Local $drillLvlOffset, $spellAdjust, $numDrills, $testX, $testY, $tempTestX, $tempTestY, $strikeGain, $expectedDE
Local $g_iSearchDark, $oldSearchDark = 0, $performedZap = False, $dropPoint
Local $aSpells[3][5] = [["Own", $eLSpell, -1, -1, 0] , ["Donated", $eLSpell, -1, -1, 0] , ["Donated", $eESpell, -1, -1, 0]]
Local $bZapDrills = True
If $g_bDebugSmartZap = True Then SetLog("$g_bSmartZapEnable = " & $g_bSmartZapEnable & " | $g_bNoobZap = " & $g_bNoobZap, $COLOR_DEBUG)
If $g_bSmartZapEnable = False Then Return $performedZap
If $bZapDrills Then
If $g_bSmartZapEnable = True And $g_bNoobZap = False Then
SetLog("====== You have activated SmartZap Mode ======", $COLOR_ERROR)
ElseIf $g_bNoobZap = True Then
SetLog("====== You have activated NoobZap Mode ======", $COLOR_ERROR)
EndIf
EndIf
If $minDE = -1 Then $minDE = Number($g_iSmartZapMinDE)
If $bZapDrills Then
$g_iSearchDark = getDarkElixirVillageSearch(48, 126)
If Number($g_iSearchDark) = 0 Then
SetLog("No Dark Elixir!", $COLOR_INFO)
If $g_bDebugSmartZap = True Then SetLog("$g_iSearchDark|Current DE value: " & Number($g_iSearchDark), $COLOR_DEBUG)
$bZapDrills = False
Else
If $g_bDebugSmartZap = True Then SetLog("$g_iSearchDark|Current DE value: " & Number($g_iSearchDark), $COLOR_DEBUG)
EndIf
EndIf
If $bZapDrills Then
If isAtkDarkElixirFull() Then
SetLog("No need to zap!", $COLOR_INFO)
If $g_bDebugSmartZap = True Then SetLog("isAtkDarkElixirFull(): True", $COLOR_DEBUG)
$bZapDrills = False
Else
If $g_bDebugSmartZap = True Then SetLog("isAtkDarkElixirFull(): False", $COLOR_DEBUG)
EndIf
EndIf
If $bZapDrills Then
If $g_iTownHallLevel < 2 Then
SetLog("Your Townhalllevel has yet to be determined.", $COLOR_ERROR)
SetLog("It reads as TH" & $g_iTownHallLevel & ".", $COLOR_ERROR)
SetLog("Locate your Townhall manually at Village->Misc.", $COLOR_ERROR)
$bZapDrills = False
ElseIf $g_iTownHallLevel < 7 Then
SetLog("You do not have the ability to store Dark Elixir!", $COLOR_ERROR)
If $g_bDebugSmartZap = True Then SetLog("Your Town Hall Lvl: " & Number($g_iTownHallLevel), $COLOR_DEBUG)
$bZapDrills = False
Else
If $g_bDebugSmartZap = True Then SetLog("Your Town Hall Lvl: " & Number($g_iTownHallLevel), $COLOR_DEBUG)
EndIf
EndIf
If $bZapDrills Then
If $g_bDebugSmartZap = True Then SetLog("$g_bSmartZapDB = " & $g_bSmartZapDB, $COLOR_DEBUG)
If $g_bSmartZapDB = True And $g_iMatchMode <> $DB Then
SetLog("Not a dead base!", $COLOR_INFO)
$bZapDrills = False
EndIf
EndIf
If $bZapDrills Then
$drillLvlOffset = getDrillOffset()
If $g_bDebugSmartZap = True Then SetLog("Drill Level Offset is: " & Number($drillLvlOffset), $COLOR_DEBUG)
$spellAdjust = getSpellOffset()
If $g_bDebugSmartZap = True Then SetLog("Spell Adjust is: " & Number($spellAdjust), $COLOR_DEBUG)
EndIf
Local $iTroops = PrepareAttack($g_iMatchMode, True)
If $iTroops > 0 Then
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $eLSpell Then
If $aSpells[0][4] = 0 Then
If $g_bDebugSmartZap = True Then SetLog(NameOfTroop($g_avAttackTroops[$i][0], 0) & ": " & $g_avAttackTroops[$i][1], $COLOR_DEBUG)
$aSpells[0][2] = $i
$aSpells[0][3] = Number($g_iLSpellLevel)
$aSpells[0][4] = $g_avAttackTroops[$i][1]
Else
If $g_bDebugSmartZap = True Then SetLog("Donated " & NameOfTroop($g_avAttackTroops[$i][0], 0) & ": " & $g_avAttackTroops[$i][1], $COLOR_DEBUG)
$aSpells[1][2] = $i
$aSpells[1][3] = Number($g_iLSpellLevel)
$aSpells[1][4] = $g_avAttackTroops[$i][1]
EndIf
EndIf
If $g_avAttackTroops[$i][0] = $eESpell Then
If $g_bDebugSmartZap = True Then SetLog(NameOfTroop($g_avAttackTroops[$i][0], 0) & ": " & $g_avAttackTroops[$i][1], $COLOR_DEBUG)
$aSpells[2][2] = $i
$aSpells[2][3] = Number($g_iESpellLevel)
$aSpells[2][4] = $g_avAttackTroops[$i][1]
EndIf
Next
EndIf
If $aSpells[0][4] + $aSpells[1][4] = 0 Then
SetLog("No lightning spells trained, time to go home!", $COLOR_ERROR)
Return $performedZap
Else
If $aSpells[0][4] > 0 Then
SetLog(" - Number of " & NameOfTroop($aSpells[0][1], 1) & " (Lvl " & $aSpells[0][3] & "): " & Number($aSpells[0][4]), $COLOR_INFO)
EndIf
If $aSpells[1][4] > 0 Then
SetLog(" - Number of Donated " & NameOfTroop($aSpells[1][1], 1) & " (Lvl " & $aSpells[1][3] & "): " & Number($aSpells[1][4]), $COLOR_INFO)
EndIf
EndIf
If $aSpells[2][4] > 0 And $g_bEarthQuakeZap = True Then
SetLog(" - Number of " & NameOfTroop($aSpells[2][1], 1) & " (Lvl " & $aSpells[2][3] & "): " & Number($aSpells[2][4]), $COLOR_INFO)
Else
$aSpells[2][4] = 0
EndIf
If $bZapDrills Then
If(Number($g_iSearchDark) < Number($minDE)) And $g_bNoobZap = True Then
SetLog("Dark Elixir is below minimum value [" & Number($g_iSmartZapMinDE) & "]!", $COLOR_INFO)
If $g_bDebugSmartZap = True Then SetLog("$g_iSearchDark|Current DE value: " & Number($g_iSearchDark), $COLOR_DEBUG)
$bZapDrills = False
ElseIf Number($g_iSearchDark) <($g_aDrillLevelTotal[3 - $drillLvlOffset] / $g_aDrillLevelHP[3 - $drillLvlOffset] * $g_fDarkStealFactor * $g_aLSpellDmg[$aSpells[0][3] - 1] * $g_fDarkFillLevel) Then
SetLog("There is less Dark Elixir(" & Number($g_iSearchDark) & ") than", $COLOR_INFO)
SetLog("gain per zap for a single Lvl " & 3 - Number($drillLvlOffset) & " drill(" & Ceiling($g_aDrillLevelTotal[3 - $drillLvlOffset] / $g_aDrillLevelHP[3 - $drillLvlOffset] * $g_fDarkStealFactor * $g_aLSpellDmg[$aSpells[0][3] - 1] * $g_fDarkFillLevel) & ").", $COLOR_INFO)
SetLog("Base is not worth a Zap!", $COLOR_INFO)
$bZapDrills = False
Else
If $g_bDebugSmartZap = True Then SetLog("$g_iSearchDark = " & Number($g_iSearchDark) & " | $g_iSmartZapMinDE = " & Number($g_iSmartZapMinDE), $COLOR_DEBUG)
EndIf
If $g_bDebugSmartZap = True Then
SetLog("$g_iSmartZapExpectedDE| Expected DE value:" & Number($g_iSmartZapExpectedDE), $COLOR_DEBUG)
SetLog("$g_abStopAtkNoLoot1Enable[$DB] = " & $g_abStopAtkNoLoot1Enable[$DB] & ", $g_aiStopAtkNoLoot1Time[$DB] = " & $g_aiStopAtkNoLoot1Time[$DB] & "s", $COLOR_DEBUG)
EndIf
EndIf
If $bZapDrills Then
Local $aDarkDrills = drillSearch()
If UBound($aDarkDrills) = 0 Then
SetLog("No drills found!", $COLOR_INFO)
$bZapDrills = False
Else
SetLog(" - Number of Dark Elixir Drills: " & UBound($aDarkDrills), $COLOR_INFO)
EndIf
_ArraySort($aDarkDrills, 1, 0, 0, 3)
Local $itotalStrikeGain = 0
Local $hTempTimer
EndIf
While IsAttackPage() And $bZapDrills And $aSpells[0][4] + $aSpells[1][4] + $aSpells[2][4] > 0 And UBound($aDarkDrills) > 0 And $spellAdjust <> -1
Local $Spellused = $eLSpell
Local $skippedZap = True
Local $oldSearchDark = $g_iSearchDark
CheckHeroesHealth()
If($g_iSearchDark < Number($g_iSmartZapMinDE)) And $g_bNoobZap = True Then
SetLog("Dark Elixir is below minimum value [" & Number($g_iSmartZapMinDE) & "], Exiting Now!", $COLOR_INFO)
$bZapDrills = False
ExitLoop
EndIf
Local $aCluster = getDrillCluster($aDarkDrills)
If $aCluster <> -1 Then
Local $tLastZap = 0
For $i = 0 To UBound($aCluster[3]) - 1
If $aDarkDrills[($aCluster[3])[$i]][4] <> 0 Then
If $tLastZap = 0 Then
$tLastZap = __TimerDiff($aDarkDrills[($aCluster[3])[$i]][4])
Else
$tLastZap = _Min(__TimerDiff($aDarkDrills[($aCluster[3])[$i]][4]),$tLastZap)
EndIf
EndIf
Next
If $tLastZap > 0 Then
If _Sleep(_Max($DELAYSMARTZAP10 - $tLastZap, 0)) Then Return
Local $sToDelete = ""
Local $iToDelete = 0
For $i = 0 To UBound($aCluster[3]) - 1
If $aDarkDrills[($aCluster[3])[$i]][4] <> 0 Then
If ReCheckDrillExist($aDarkDrills[($aCluster[3])[$i]][0], $aDarkDrills[($aCluster[3])[$i]][1]) Then
$aDarkDrills[($aCluster[3])[$i]][4] = 0
Else
If $sToDelete = "" Then
$sToDelete &=($aCluster[3])[$i]
Else
$sToDelete &= ";" &($aCluster[3])[$i]
EndIf
$iToDelete +=1
EndIf
EndIf
Next
If $iToDelete > 1 Then
SetLog("Removing " & $iToDelete & " destroyed drills from list.", $COLOR_ACTION)
_ArrayDelete($aDarkDrills, $sToDelete)
ContinueLoop
ElseIf $iToDelete > 0 Then
SetLog("Removing 1 destroyed drill from list.", $COLOR_ACTION)
_ArrayDelete($aDarkDrills, $sToDelete)
ContinueLoop
EndIf
EndIf
If $g_bDebugSmartZap = True Then SetLog("Cluster Hold: " & $aCluster[2] & ", First Drill Hold: " & $aDarkDrills[0][3], $COLOR_DEBUG)
If $aCluster[2] < $aDarkDrills[0][3] Then $aCluster = -1
EndIf
If $aCluster = -1 And $aDarkDrills[0][4] <> 0 Then
If _Sleep(_Max($DELAYSMARTZAP10 - __TimerDiff($aDarkDrills[0][4]), 0)) Then Return
If ReCheckDrillExist($aDarkDrills[0][0], $aDarkDrills[0][1]) Then
$aDarkDrills[0][4] = 0
Else
SetLog("Removing 1 destroyed drill from list.", $COLOR_ACTION)
_ArrayDelete($aDarkDrills, 0)
ContinueLoop
EndIf
EndIf
displayZapLog($aDarkDrills, $aSpells)
$hTempTimer = __TimerInit()
If $g_bNoobZap = True Then
SetLog("NoobZap is going to attack any drill.", $COLOR_ACTION)
If $aCluster <> -1 Then
$Spellused = zapBuilding($aSpells, $aCluster[0] + $strikeOffsets[0], $aCluster[1] + $strikeOffsets[1])
For $i = 0 To UBound($aCluster[3]) - 1
$aDarkDrills[($aCluster[3])[$i]][4] = $hTempTimer
Next
Else
$Spellused = zapBuilding($aSpells, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
$aDarkDrills[0][4] = $hTempTimer
EndIf
$performedZap = True
$skippedZap = False
If _Sleep($DELAYSMARTZAP4) Then Return
Else
If $aSpells[0][4] + $aSpells[1][4] + $aSpells[2][4] >(4 - $spellAdjust) Then
SetLog("First condition: More than " & 4 - $spellAdjust & " Spells so attack any drill.", $COLOR_INFO)
If $aCluster <> -1 Then
$Spellused = zapBuilding($aSpells, $aCluster[0] + $strikeOffsets[0], $aCluster[1] + $strikeOffsets[1])
For $i = 0 To UBound($aCluster[3]) - 1
$aDarkDrills[($aCluster[3])[$i]][4] = $hTempTimer
Next
Else
$Spellused = zapBuilding($aSpells, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
$aDarkDrills[0][4] = $hTempTimer
EndIf
$performedZap = True
$skippedZap = False
If _Sleep($DELAYSMARTZAP4) Then Return
ElseIf $aSpells[0][4] + $aSpells[1][4] + $aSpells[2][4] >(3 - $spellAdjust) And $aDarkDrills[0][2] >(3 - $drillLvlOffset) Then
SetLog("Second condition: Attack Lvl " & 4 - Number($drillLvlOffset) & " and greater drills if you have more than " & 3 - Number($spellAdjust) & " spells", $COLOR_INFO)
If $aCluster <> -1 Then
$Spellused = zapBuilding($aSpells, $aCluster[0] + $strikeOffsets[0], $aCluster[1] + $strikeOffsets[1])
For $i = 0 To UBound($aCluster[3]) - 1
$aDarkDrills[($aCluster[3])[$i]][4] = $hTempTimer
Next
Else
$Spellused = zapBuilding($aSpells, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
$aDarkDrills[0][4] = $hTempTimer
EndIf
$performedZap = True
$skippedZap = False
If _Sleep($DELAYSMARTZAP4) Then Return
ElseIf $aDarkDrills[0][2] >(4 - $drillLvlOffset) And($aDarkDrills[0][3] /($g_aDrillLevelTotal[$aDarkDrills[0][2] - 1] * $g_fDarkStealFactor)) > 0.3 Then
SetLog("Third condition: Attack Lvl " & 5 - Number($drillLvlOffset) & " drills with more then 30% estimated DE left", $COLOR_INFO)
If $aCluster <> -1 Then
$Spellused = zapBuilding($aSpells, $aCluster[0] + $strikeOffsets[0], $aCluster[1] + $strikeOffsets[1])
For $i = 0 To UBound($aCluster[3]) - 1
$aDarkDrills[($aCluster[3])[$i]][4] = $hTempTimer
Next
Else
$Spellused = zapBuilding($aSpells, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
$aDarkDrills[0][4] = $hTempTimer
EndIf
$performedZap = True
$skippedZap = False
If _Sleep($DELAYSMARTZAP4) Then Return
ElseIf $aCluster <> -1 Then
If $aCluster[2] >=($g_aDrillLevelTotal[5 - $drillLvlOffset] / $g_aDrillLevelHP[5 - $drillLvlOffset] * $g_fDarkStealFactor * $g_aLSpellDmg[$aSpells[0][3] - 1] * $g_fDarkFillLevel) Then
SetLog("Fourth condition: Attack, when potential left content in cluster is greater than gain for a single Lvl " & 5 - Number($drillLvlOffset) & " drill", $COLOR_INFO)
$Spellused = zapBuilding($aSpells, $aCluster[0] + $strikeOffsets[0], $aCluster[1] + $strikeOffsets[1])
For $i = 0 To UBound($aCluster[3]) - 1
$aDarkDrills[($aCluster[3])[$i]][4] = $hTempTimer
Next
EndIf
$performedZap = True
$skippedZap = False
If _Sleep($DELAYSMARTZAP4) Then Return
Else
$skippedZap = True
SetLog("Drill did not match any attack conditions, so we will remove it from the list.", $COLOR_ACTION)
_ArrayDelete($aDarkDrills, 0)
EndIf
EndIf
$g_iSearchDark = getDarkElixir()
If Not $g_iSearchDark Or $g_iSearchDark = 0 Then
SetLog("No Dark Elixir left!", $COLOR_INFO)
SetDebugLog("$g_iSearchDark = " & Number($g_iSearchDark))
If $skippedZap = False Then
If $Spellused = $eESpell Then
$g_iNumEQSpellsUsed += 1
Else
$g_iNumLSpellsUsed += 1
EndIf
$g_iSmartZapGain += $oldSearchDark
EndIf
$bZapDrills = False
ExitLoop
Else
If $g_bDebugSmartZap = True Then SetLog("$g_iSearchDark = " & Number($g_iSearchDark), $COLOR_DEBUG)
EndIf
If $skippedZap = False Then
If $g_bDebugSmartZap = True Then SetLog("$oldSearchDark = [" & Number($oldSearchDark) & "] - $g_iSearchDark = [" & Number($g_iSearchDark) & "]", $COLOR_DEBUG)
$strikeGain = Number($oldSearchDark - $g_iSearchDark)
If $g_bDebugSmartZap = True Then SetLog("$strikeGain = " & Number($strikeGain), $COLOR_DEBUG)
$expectedDE = -1
If $Spellused = $eESpell Then
$g_iNumEQSpellsUsed += 1
If $aCluster <> -1 Then
For $i = 0 To UBound($aCluster[3]) - 1
$expectedDE = _Max(Number($expectedDE), Ceiling(Number($g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_fDarkStealFactor * $g_aEQSpellDmg[$aSpells[2][3] - 1] * $g_fDarkFillLevel)))
Next
Else
$expectedDE = Ceiling(Number($g_aDrillLevelTotal[$aDarkDrills[0][2] - 1] * $g_fDarkStealFactor * $g_aEQSpellDmg[$aSpells[2][3] - 1] * $g_fDarkFillLevel))
EndIf
Else
$g_iNumLSpellsUsed += 1
If $g_bNoobZap = False Then
If $aCluster <> -1 Then
For $i = 0 To UBound($aCluster[3]) - 1
$expectedDE = _Max(Number($expectedDE), Ceiling(Number($g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] / $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_fDarkStealFactor * $g_aLSpellDmg[$aSpells[0][3] - 1] * $g_fDarkFillLevel)))
Next
Else
$expectedDE = Ceiling(Number($g_aDrillLevelTotal[$aDarkDrills[0][2] - 1] / $g_aDrillLevelHP[$aDarkDrills[0][2] - 1] * $g_fDarkStealFactor * $g_aLSpellDmg[$aSpells[0][3] - 1] * $g_fDarkFillLevel))
EndIf
Else
$expectedDE = $g_iSmartZapExpectedDE
EndIf
EndIf
If $g_bDebugSmartZap = True Then SetLog("$expectedDE = " & Number($expectedDE), $COLOR_DEBUG)
If $strikeGain < $expectedDE And $expectedDE <> -1 Then
SetLog("Gained: " & $strikeGain & ", Expected: " & $expectedDE, $COLOR_INFO)
If $aCluster <> -1 Then
_ArrayDelete($aDarkDrills, _ArrayToString($aCluster[3], ";"))
SetLog("Last zap gained less DE then expected, removing the drills from the list.", $COLOR_ACTION)
Else
_ArrayDelete($aDarkDrills, 0)
SetLog("Last zap gained less DE then expected, removing the drill from the list.", $COLOR_ACTION)
EndIf
Else
If $aCluster <> -1 Then
Local $iSumTotalHP = 0
Local $sToDelete = ""
If UBound($aCluster[3]) = 2 Then
For $i = 0 To 1
$iSumTotalHP += $g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 1, 2)]][2] - 1]
Next
For $i = 0 To 1
Local $iSubGain = Ceiling(Number($strikeGain * $g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 1, 2)]][2] - 1] / $iSumTotalHP))
$aDarkDrills[($aCluster[3])[$i]][3] -= $iSubGain
SetLog(($i + 1) & ".Drill Gained: " & $iSubGain & ", adjusting amount left in this drill.", $COLOR_INFO)
Next
Else
For $i = 0 To 2
$iSumTotalHP += $g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 1, 3)]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 2, 3)]][2] - 1]
Next
For $i = 0 To 2
Local $iSubGain = Ceiling(Number($strikeGain * $g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 1, 3)]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 2, 3)]][2] - 1] / $iSumTotalHP))
$aDarkDrills[($aCluster[3])[$i]][3] -= $iSubGain
SetLog(($i + 1) & ".Drill Gained: " & $iSubGain & ", adjusting amount left in this drill.", $COLOR_INFO)
Next
EndIf
If $sToDelete <> "" Then _ArrayDelete($aDarkDrills, $sToDelete)
Else
$aDarkDrills[0][3] -= $strikeGain
SetLog("Gained: " & Number($strikeGain) & ", adjusting amount left in this drill.", $COLOR_INFO)
EndIf
EndIf
$itotalStrikeGain += $strikeGain
$g_iSmartZapGain += $strikeGain
SetLog("Total DE from SmartZap/NoobZap: " & Number($itotalStrikeGain), $COLOR_INFO)
EndIf
_ArraySort($aDarkDrills, 1, 0, 0, 3)
If $aSpells[0][4] = 0 Then
Local $iTroops = PrepareAttack($g_iMatchMode, True)
If $iTroops > 0 Then
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $eLSpell Then
If $g_bDebugSmartZap = True Then SetLog("Donated " & NameOfTroop($g_avAttackTroops[$i][0], 0) & ": " & $g_avAttackTroops[$i][1], $COLOR_DEBUG)
$aSpells[1][2] = $i
$aSpells[1][3] = Number($g_iLSpellLevel)
$aSpells[1][4] = $g_avAttackTroops[$i][1]
EndIf
Next
EndIf
If $aSpells[1][4] > 0 Then
SetLog("Woohoo, found a donated " & NameOfTroop($aSpells[1][1], 0) & " (Lvl " & $aSpells[1][3] & ").", $COLOR_INFO)
EndIf
EndIf
WEnd
If $g_bSmartZapFTW Then
SetLog("====== SmartZap/NoobZap FTW Mode ======", $COLOR_INFO)
Else
Return $performedZap
EndIf
If _CheckPixel($aWonOneStar, True) Then
SetLog("One Star already reached.", $COLOR_INFO)
Return $performedZap
EndIf
If $aSpells[0][4] + $aSpells[1][4] = 0 Then
SetLog("No lightning spells left, time to go home!", $COLOR_ERROR)
Return $performedZap
Else
If $aSpells[0][4] > 0 Then
SetLog(" - Number of " & NameOfTroop($aSpells[0][1], 1) & " (Lvl " & $aSpells[0][3] & "): " & Number($aSpells[0][4]), $COLOR_INFO)
EndIf
If $aSpells[1][4] > 0 Then
SetLog(" - Number of Donated " & NameOfTroop($aSpells[1][1], 1) & " (Lvl " & $aSpells[1][3] & "): " & Number($aSpells[1][4]), $COLOR_INFO)
EndIf
EndIf
Local $iPercentageNeeded = 50 - getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)
SetLog("Percentage needed: " & $iPercentageNeeded, $COLOR_INFO)
_ArrayDelete($aSpells, 2)
Local $aEasyPrey = easyPreySearch()
If UBound($aEasyPrey) = 0 Then
SetLog("No easy targets found!", $COLOR_INFO)
Return $performedZap
Else
Local $iTargetCount = 0
For $iTargets = 0 To UBound($aEasyPrey) - 1
$iTargetCount += $aEasyPrey[$iTargets][2]
If $g_bDebugSmartZap = True Then
SetLog($iTargets + 1 & ". target: x=" & $aEasyPrey[$iTargets][0] & ",y=" & $aEasyPrey[$iTargets][1] & ",w=" & $aEasyPrey[$iTargets][2], $COLOR_DEBUG)
EndIf
Next
SetLog("Count of easy targets: " & $iTargetCount, $COLOR_INFO)
$iTargetCount = 0
For $iTargets = 0 To _Min(Number(UBound($aEasyPrey) - 1),Number($aSpells[0][4] + $aSpells[1][4]) - 1)
$iTargetCount += $aEasyPrey[$iTargets][2]
Next
SetLog("Easy targets, we can zap: " & $iTargetCount, $COLOR_INFO)
If $iPercentageNeeded > $iTargetCount Then
SetLog("No chance to win!", $COLOR_INFO)
SetLog("Needed percentage (" & $iPercentageNeeded & ") is greater than targets, we can zap (" & $iTargetCount & ")!", $COLOR_INFO)
Return $performedZap
EndIf
EndIf
Local $Spellused = $eLSpell
While IsAttackPage() And $aSpells[0][4] + $aSpells[1][4] > 0 And UBound($aEasyPrey) > 0 And Not _CheckPixel($aWonOneStar, True)
$Spellused = zapBuilding($aSpells, $aEasyPrey[0][0] + 5, $aEasyPrey[0][1] + 5)
_ArrayDelete($aEasyPrey, 0)
If _Sleep(6000) Then Return
Wend
If _CheckPixel($aWonOneStar, True) Then
SetLog("Hooray, One Star reached, we have won!", $COLOR_INFO)
EndIf
Return $performedZap
EndFunc
Func zapBuilding(ByRef $Spells, $x, $y)
Local $iSpell
For $i = 0 To UBound($Spells) - 1
If $Spells[$i][4] > 0 Then
$iSpell = $i
EndIf
Next
If $Spells[$iSpell][2] > -1 Then
SetLog("Dropping " & $Spells[$iSpell][0] & " " & String(NameOfTroop($Spells[$iSpell][1], 0)), $COLOR_ACTION)
SelectDropTroop($Spells[$iSpell][2])
If _Sleep($DELAYCASTSPELL1) Then Return
If IsAttackPage() Then Click($x, $y, 1, 0, "#0029")
$Spells[$iSpell][4] -= 1
Else
If $g_bDebugSmartZap = True Then SetLog("No " & String(NameOfTroop($Spells[$iSpell][1], 0)) & " Found", $COLOR_DEBUG)
EndIf
Return $Spells[$iSpell][1]
EndFunc
Func ReCheckDrillExist($x, $y)
_CaptureRegion2($x - 25, $y - 25, $x + 25, $y + 25)
Local $aResult = multiMatches($g_sImgSearchDrill, 1, "FV", "FV", "", 0, 1000, False)
If UBound($aResult) > 1 Then
If $g_bDebugSmartZap = True Then SetLog("ReCheckDrillExist: Yes| " & UBound($aResult), $COLOR_SUCCESS)
Return True
Else
If $g_bDebugSmartZap = True Then SetLog("ReCheckDrillExist: No| " & UBound($aResult), $COLOR_ERROR)
EndIf
Return False
EndFunc
Func CheckOverviewFullArmy($bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $bOpenArmyWindow Then
ClickP($aAway, 1, 0, "#0346")
If _Sleep($DELAYCHECKFULLARMY1) Then Return
If Not $g_bUseRandomClick Then
Click($aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0, "#0347")
Else
ClickR($aArmyTrainButtonRND, $aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0)
EndIf
If _Sleep($DELAYCHECKFULLARMY2) Then Return
Local $j = 0
While Not _ColorCheck(_GetPixelColor(114, 535 + $g_iMidOffsetY, True), Hex(0xE8E8E0, 6), 20)
If $g_bDebugSetlogTrain Then SetLog("OverView TabColor=" & _GetPixelColor(114, 535 + $g_iMidOffsetY, True), $COLOR_DEBUG)
If _Sleep($DELAYCHECKFULLARMY1) Then Return
$j += 1
If $j > 15 Then ExitLoop
WEnd
If $j > 15 Then
SetLog("Training Overview Window didn't open", $COLOR_ERROR)
Return
EndIf
EndIf
If _sleep($DELAYCHECKFULLARMY2) Then Return
Local $Pixel = _CheckPixel($aIsCampFull, True) And _ColorCheck(_GetPixelColor(128, 176, True), Hex(0x90C030, 6), 20)
If Not $Pixel Then
If _sleep($DELAYCHECKFULLARMY2) Then Return
$Pixel = _CheckPixel($aIsCampFull, True) And _ColorCheck(_GetPixelColor(128, 176, True), Hex(0x90C030, 6), 20)
EndIf
If $g_bDebugSetlogTrain Then SetLog("Checking Overview for full army [!] " & $Pixel & ", " & _GetPixelColor(128, 176, True), $COLOR_DEBUG)
If $Pixel Then
$g_bFullArmy = True
EndIf
$g_bCanRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1] + 20, True), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) And _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5])
If $g_bDebugSetlog Then SetDebugLog("Can Request CC: " & $g_bCanRequestCC, $COLOR_DEBUG)
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0348")
If _Sleep($DELAYCHECKFULLARMY3) Then Return
EndIf
EndFunc
Func CheckFullBarrack()
If _sleep(200) Then Return
Local $Pixel = _CheckPixel($aBarrackFull, True)
If $g_bDebugSetlogTrain Then SetLog("Check Barrack Full color : " & _GetPixelColor($aBarrackFull[0], $aBarrackFull[1], True) & " Expected if Full : " & Hex($aBarrackFull[2], 6), $COLOR_DEBUG)
If $g_bDebugSetlogTrain Then SetLog("Checking for Full Normal or Dark Barrack [!]" & $Pixel, $COLOR_DEBUG)
If $Pixel Then
Return True
Else
Return False
EndIf
EndFunc
Func checkArmyCamp($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bGetHeroesTime = False, $bSetLog = True)
Local $iStopWatchLevel = StopWatchLevel()
Local $Result = _checkArmyCamp($bOpenArmyWindow, $bCloseArmyWindow, $bGetHeroesTime, $bSetLog)
StopWatchReturn($iStopWatchLevel)
Return $Result
EndFunc
Func _checkArmyCamp($bOpenArmyWindow, $bCloseArmyWindow, $bGetHeroesTime, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStart("checkArmyCamp")
If $g_bDebugSetlogTrain Then SetLog("Begin checkArmyCamp:", $COLOR_DEBUG1)
If $g_bDebugFuncTime Then StopWatchStart("IsTrainPage/openArmyOverview")
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "_checkArmyCamp()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
If $g_bDebugFuncTime Then StopWatchStopLog()
If $g_bDebugFuncTime Then StopWatchStart("getArmyTroopsCapacity")
getArmyTroopCapacity(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $g_bDebugFuncTime Then StopWatchStart("getArmyTroops")
getArmyTroops(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $g_bDebugFuncTime Then StopWatchStart("getArmyTroopTime")
getArmyTroopTime(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
Local $HeroesRegenTime
If $g_bDebugFuncTime Then StopWatchStart("getArmyHeroCount")
getArmyHeroCount(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $bGetHeroesTime = True Then
If $g_bDebugFuncTime Then StopWatchStart("getArmyHeroTime")
$HeroesRegenTime = getArmyHeroTime("all", $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
EndIf
If $g_bDebugFuncTime Then StopWatchStart("getArmySpellCapacity")
getArmySpellCapacity(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $g_bDebugFuncTime Then StopWatchStart("getArmySpells")
getArmySpells(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $g_bDebugFuncTime Then StopWatchStart("getArmySpellTime")
getArmySpellTime(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $g_bDebugFuncTime Then StopWatchStart("getArmyCCSpellCapacity")
getArmyCCSpellCapacity(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $g_bDebugFuncTime Then StopWatchStart("getArmyCCStatus")
getArmyCCStatus(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If Not $g_bFullArmy Then
If $g_bDebugFuncTime Then StopWatchStart("DeleteExcessTroops")
DeleteExcessTroops()
If $g_bDebugFuncTime Then StopWatchStopLog()
EndIf
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
If $g_bDebugSetlogTrain Then SetLog("End checkArmyCamp: canRequestCC= " & $g_bCanRequestCC & ", fullArmy= " & $g_bFullArmy, $COLOR_DEBUG)
If $g_bDebugFuncTime Then StopWatchStopLog()
Return $HeroesRegenTime
EndFunc
Func IsTroopToDonateOnly($pTroopType)
If $g_abAttackTypeEnable[$DB] Then
Local $tempArr = $g_aaiTroopsToBeUsed[$g_aiAttackTroopSelection[$DB]]
For $x = 0 To UBound($tempArr) - 1
If $tempArr[$x] = $pTroopType Then
Return False
EndIf
Next
EndIf
If $g_abAttackTypeEnable[$LB] Then
Local $tempArr = $g_aaiTroopsToBeUsed[$g_aiAttackTroopSelection[$LB]]
For $x = 0 To UBound($tempArr) - 1
If $tempArr[$x] = $pTroopType Then
Return False
EndIf
Next
EndIf
Return True
EndFunc
Func DeleteExcessTroops()
Local $SlotTemp, $Delete
Local $IsNecessaryDeleteTroop = 0
Local $CorrectDonation
For $i = 0 To $eTroopCount - 1
$CorrectDonation = 0
If IsTroopToDonateOnly($i) Then
If($g_aiCurrentTroops[$i] * -1) > $g_aiArmyCompTroops[$i] Then
$IsNecessaryDeleteTroop = 1
$g_aiDonateTroops[$i] = 0
EndIf
If($g_aiCurrentTroops[$i] * -1) = $g_aiArmyCompTroops[$i] Then
$g_aiDonateTroops[$i] = 0
EndIf
If($g_aiCurrentTroops[$i] * -1) + $g_aiDonateTroops[$i] >= $g_aiArmyCompTroops[$i] Then
$CorrectDonation = $g_aiCurrentTroops[$i] + $g_aiArmyCompTroops[$i]
$g_aiDonateTroops[$i] = $CorrectDonation
EndIf
EndIf
Next
If $IsNecessaryDeleteTroop = 0 Then Return
If _ColorCheck(_GetPixelColor(670, 485 + $g_iMidOffsetY, True), Hex(0x60B010, 6), 5) Then
Click(670, 485 + $g_iMidOffsetY)
EndIf
SetLog("Troops in excess!...")
If $g_bDebugSetlogTrain Then SetLog("Start-Loop Regular Troops Only To Donate ")
For $i = 0 To $eTroopCount - 1
If IsTroopToDonateOnly($i) Then
If $g_bDebugSetlogTrain Then SetLog("Troop :" & $g_asTroopNames[$i])
If($g_aiCurrentTroops[$i] * -1) > $g_aiArmyCompTroops[$i] Then
$Delete =($g_aiCurrentTroops[$i] * -1) - $g_aiArmyCompTroops[$i]
If $g_bDebugSetlogTrain Then SetLog("$Delete :" & $Delete)
$SlotTemp = $g_aiSlotInArmy[$i]
If $g_bDebugSetlogTrain Then SetLog("$SlotTemp :" & $SlotTemp)
If _Sleep(250) Then Return
If _ColorCheck(_GetPixelColor(170 +(62 * $SlotTemp), 235 + $g_iMidOffsetY, True), Hex(0xD40003, 6), 10) Then
Click(170 +(62 * $SlotTemp), 235 + $g_iMidOffsetY, $Delete, 300)
SetLog("~Deleted " & $Delete & " " & $g_asTroopNames[$i], $COLOR_ERROR)
$g_aiCurrentTroops[$i] += $Delete
EndIf
EndIf
EndIf
Next
If $g_bDebugSetlogTrain Then SetLog("Start-Loop Dark Troops Only To Donate ")
If _ColorCheck(_GetPixelColor(674, 436 + $g_iMidOffsetY, True), Hex(0x60B010, 6), 5) Then
Click(674, 436 + $g_iMidOffsetY)
EndIf
If WaitforPixel(505, 411 + $g_iMidOffsetY, 506, 412 + $g_iMidOffsetY, Hex(0x60B010, 6), 5, 10) Then
Click(505, 411 + $g_iMidOffsetY)
EndIf
EndFunc
Func OpenArmyOverview($bCheckMain = True, $sWhereFrom = "Undefined")
If $bCheckMain Then
If Not IsMainPage() Then
SetLog("Cannot open Army Overview window", $COLOR_ERROR)
SetError(1)
Return False
EndIf
EndIf
If WaitforPixel(28, 505 + $g_iBottomOffsetY, 30, 507 + $g_iBottomOffsetY, Hex(0xEEB145, 6), 5, 10) Then
If $g_bDebugSetlogTrain Then SetLog("Click $aArmyTrainButton" & " (Called from " & $sWhereFrom & ")", $COLOR_SUCCESS)
If Not $g_bUseRandomClick Then
ClickP($aArmyTrainButton, 1, 0, "#0293")
Else
ClickR($aArmyTrainButtonRND, $aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0)
EndIf
EndIf
If _Sleep($DELAYRUNBOT6) Then Return
If Not IsTrainPage() Then
SetError(1)
Return False
EndIf
Return True
EndFunc
Func OpenArmyTab($bSetLog = True, $sWhereFrom = "Undefined")
Return OpenTrainTab("Army Tab", $bSetLog, $sWhereFrom)
EndFunc
Func OpenTroopsTab($bSetLog = True, $sWhereFrom = "Undefined")
Return OpenTrainTab("Train Troops Tab", $bSetLog, $sWhereFrom)
EndFunc
Func OpenSpellsTab($bSetLog = True, $sWhereFrom = "Undefined")
Return OpenTrainTab("Brew Spells Tab", $bSetLog, $sWhereFrom)
EndFunc
Func OpenQuickTrainTab($bSetLog = True, $sWhereFrom = "Undefined")
Return OpenTrainTab("Quick Train Tab", $bSetLog, $sWhereFrom)
EndFunc
Func OpenTrainTab($sTab, $bSetLog = True, $sWhereFrom = "Undefined")
If Not IsTrainPage() Then
SetDebugLog("Error in OpenTrainTab: Cannot find the Army Overview Window", $COLOR_ERROR)
SetError(1)
Return False
EndIf
If $bSetLog Or $g_bDebugSetlogTrain Then SetLog("Open " & $sTab &($g_bDebugSetlogTrain ? " (Called from " & $sWhereFrom & ")" : ""), $COLOR_INFO)
Local $aTabButton = findButton(StringStripWS($sTab, 8), Default, 1, True)
If IsArray($aTabButton) And UBound($aTabButton, 1) = 2 Then
$aIsTabOpen[0] = $aTabButton[0]
If Not _CheckPixel($aIsTabOpen, True) Then
ClickP($aTabButton)
If Not _WaitForCheckPixel($aIsTabOpen, True) Then
SetLog("Error in OpenTrainTab: Cannot open " & $sTab & ". Pixel to check did not appear", $COLOR_ERROR)
SetError(1)
Return False
EndIf
EndIf
Else
SetDebugLog("Error in OpenTrainTab: $aTabButton is no valid Array", $COLOR_ERROR)
SetError(1)
Return False
EndIf
If _Sleep(200) Then Return
Return True
EndFunc
Func SmartWait4Train($iTestSeconds = Default)
Static $ichkCloseWaitSpell = 0, $ichkCloseWaitHero = 0
Local $bTest =($iTestSeconds <> Default)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Begin SmartWait4Train:", $COLOR_DEBUG1)
If Not $g_bCloseWhileTrainingEnable Then Return
Local $iExitCount = 0
If _Sleep($DELAYSMARTWAIT) Then Return
While IsMainPage(1) = False
If _Sleep($DELAYIDLE1) Then Return
$iExitCount += 1
If $iExitCount > 25 Then
SetLog("SmartWait4Train not finding Main Page, skip function!", $COLOR_ERROR)
Return
EndIf
WEnd
If Not $g_bCloseWhileTrainingEnable And Not $g_bCloseWithoutShield Then Return
Local $aResult, $iActiveHero
Local $aHeroResult[3]
Local Const $TRAINWAIT_NOWAIT = 0x00
Local Const $TRAINWAIT_SHIELD = 0x01
Local Const $TRAINWAIT_TROOP = 0x02
Local Const $TRAINWAIT_SPELL = 0x04
Local Const $TRAINWAIT_HERO = 0x08
Local $iTrainWaitCloseFlag = $TRAINWAIT_NOWAIT
Local $sNowTime = "", $sTrainEndTime = ""
Local $iShieldTime = 0, $iDiffDateTime = 0, $iDiffTime = 0
Local $RandomAddPercent = Random(0, $g_iCloseRandomTimePercent / 100)
Local $MinimumTimeClose = Number($g_iCloseMinimumTime * 60)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Random add percent = " & StringFormat("%.4f", $RandomAddPercent), $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("$MinimumTimeClose = " & $MinimumTimeClose & "s", $COLOR_DEBUG)
Local $StopEmulator = False
Local $bFullRestart = False
Local $bSuspendComputer = False
If $g_bCloseRandom Then $StopEmulator = "random"
If $g_bCloseEmulator Then $StopEmulator = True
If $g_bSuspendComputer Then $bSuspendComputer = True
If IsArray($g_asShieldStatus) And(StringInStr($g_asShieldStatus[0], "shield", $STR_NOCASESENSEBASIC) Or StringInStr($g_asShieldStatus[0], "guard", $STR_NOCASESENSEBASIC)) Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Have shield till " & $g_asShieldStatus[2] & ", close game while wait for train)", $COLOR_DEBUG)
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD)
EndIf
If _Sleep($DELAYRESPOND) Then Return
If IsArray($g_asShieldStatus) = 0 Or $g_asShieldStatus[0] = "" Or $g_asShieldStatus[0] = "none" Then
$aResult = getShieldInfo()
If @error Then
SetLog("SmartWait4Train Shield OCR error = " & @error & "Extended = " & @extended, $COLOR_ERROR)
Return False
Else
$g_asShieldStatus = $aResult
EndIf
If IsArray($g_asShieldStatus) And(StringInStr($g_asShieldStatus[0], "shield", $STR_NOCASESENSEBASIC) Or StringInStr($g_asShieldStatus[0], "guard", $STR_NOCASESENSEBASIC)) Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Have shield till " & $g_asShieldStatus[2] & ", close game while wait for train)", $COLOR_DEBUG)
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD)
EndIf
EndIf
If $g_bDebugSetlogTrain Or $g_bDebugSetlog And IsArray($g_asShieldStatus) Then SetLog("Shield Status:" & $g_asShieldStatus[0] & ", till " & $g_asShieldStatus[2], $COLOR_DEBUG)
Local $result = OpenArmyOverview(True, "SmartWait4Train()")
If Not $result Then
If $g_bDebugImageSave Or $g_bDebugSetlogTrain Then DebugImageSave("SmartWait4Troop2_")
EndIf
If _Sleep($DELAYRESPOND) Then Return
If $g_bCloseWithoutShield Or BitAND($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD) = $TRAINWAIT_SHIELD Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$g_bCloseWithoutShield enabled", $COLOR_DEBUG)
getArmyTroopTime()
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("getArmyTroopTime returned: " & $g_aiTimeTrain[0], $COLOR_DEBUG)
If _Sleep($DELAYRESPOND) Then Return
If $g_aiTimeTrain[0] > 0 Then
If $g_bCloseRandomTime Then
$g_aiTimeTrain[0] += $g_aiTimeTrain[0] * $RandomAddPercent
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_TROOP)
EndIf
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", troop time = " & StringFormat("%.2f", $g_aiTimeTrain[0]), $COLOR_DEBUG)
EndIf
If($g_bCloseWithoutShield Or BitAND($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD) = $TRAINWAIT_SHIELD) And IsWaitforSpellsActive() Then
$ichkCloseWaitSpell = 1
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$ichkCloseWaitSpell enabled", $COLOR_DEBUG)
getArmySpellTime()
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("getArmySpellTime returned: " & $g_aiTimeTrain[1], $COLOR_DEBUG)
If _Sleep($DELAYRESPOND) Then Return
If $g_aiTimeTrain[1] > 0 Then
If $g_bCloseRandomTime Then
$g_aiTimeTrain[1] += $g_aiTimeTrain[1] * $RandomAddPercent
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_SPELL)
EndIf
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", spell time = " & StringFormat("%.2f", $g_aiTimeTrain[1]), $COLOR_DEBUG)
Else
$ichkCloseWaitSpell = 0
EndIf
If($g_bCloseWithoutShield Or BitAND($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD) = $TRAINWAIT_SHIELD) And IsWaitforHeroesActive() Then
$ichkCloseWaitHero = 1
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$ichkCloseWaitHero enabled", $COLOR_DEBUG)
For $j = 0 To UBound($aResult) - 1
$aHeroResult[$j] = 0
Next
If _Sleep($DELAYRESPOND) Then Return
$aHeroResult = getArmyHeroTime("all")
If @error Then
SetLog("getArmyHeroTime return error: " & @error & ", exit SmartWait!", $COLOR_ERROR)
Return
EndIf
If Not IsArray($aHeroResult) Then
SetLog("getArmyHeroTime OCR fail, exit SmartWait!", $COLOR_ERROR)
Return
EndIf
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("getArmyHeroTime returned: " & $aHeroResult[0] & ":" & $aHeroResult[1] & ":" & $aHeroResult[2], $COLOR_DEBUG)
If _Sleep($DELAYRESPOND) Then Return
If $aHeroResult[0] > 0 Or $aHeroResult[1] > 0 Or $aHeroResult[2] > 0 Then
For $pTroopType = $eKing To $eWarden
Local $iHeroIdx = $pTroopType - $eKing
For $pMatchMode = $DB To $LB
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then
SetLog("$pTroopType: " & NameOfTroop($pTroopType) & ", $pMatchMode: " & $g_asModeText[$pMatchMode], $COLOR_DEBUG)
SetLog("TroopToBeUsed: " & IsSpecialTroopToBeUsed($pMatchMode, $pTroopType) & ", Hero Wait Status= " & IsSearchModeActiveMini($pMatchMode) & " & " & IsSpecialTroopToBeUsed($pMatchMode, $pTroopType) & " & " &($g_iHeroUpgrading[$iHeroIdx] <> 1) & " & " &($g_iHeroWaitAttackNoBit[$pMatchMode][$iHeroIdx] = 1), $COLOR_DEBUG)
SetLog("$g_aiAttackUseHeroes[" & $pMatchMode & "]= " & $g_aiAttackUseHeroes[$pMatchMode] & ", $g_aiSearchHeroWaitEnable[" & $pMatchMode & "]= " & $g_aiSearchHeroWaitEnable[$pMatchMode] & ", $g_iHeroUpgradingBit=" & $g_iHeroUpgradingBit, $COLOR_DEBUG)
EndIf
$iActiveHero = -1
If IsSearchModeActiveMini($pMatchMode) And IsSpecialTroopToBeUsed($pMatchMode, $pTroopType) And $g_iHeroUpgrading[$iHeroIdx] <> 1 And $g_iHeroWaitAttackNoBit[$pMatchMode][$iHeroIdx] = 1 Then
$iActiveHero = $iHeroIdx
EndIf
If $iActiveHero <> -1 And $aHeroResult[$iActiveHero] > 0 Then
If $g_bCloseRandomTime And $g_aiTimeTrain[2] < $aHeroResult[$iActiveHero] Then
$g_aiTimeTrain[2] = $aHeroResult[$iActiveHero] +($aHeroResult[$iActiveHero] * $RandomAddPercent)
ElseIf $g_bCloseExactTime And $g_aiTimeTrain[2] < $aHeroResult[$iActiveHero] Then
$g_aiTimeTrain[2] = $aHeroResult[$iActiveHero]
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_HERO)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then
SetLog("Wait enabled: " & NameOfTroop($pTroopType) & ":" & $g_asModeText[$pMatchMode] & ", $iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", Hero Time:" & $aHeroResult[$iActiveHero] & ", Wait Time: " & StringFormat("%.2f", $g_aiTimeTrain[2]), $COLOR_DEBUG)
EndIf
EndIf
Next
If _Sleep($DELAYRESPOND) Then Return
Next
Else
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("getArmyHeroTime return all zero hero wait times", $COLOR_DEBUG)
EndIf
If $g_aiTimeTrain[2] > 0 Then
If $g_bCloseRandomTime Then
$g_aiTimeTrain[2] += $g_aiTimeTrain[2] * $RandomAddPercent
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_HERO)
EndIf
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", hero time = " & StringFormat("%.2f", $g_aiTimeTrain[2]), $COLOR_DEBUG)
Else
$ichkCloseWaitHero = 0
$g_aiTimeTrain[2] = 0
EndIf
If $g_iCCRemainTime = 0 And _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1] + 20, True), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) And Not _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5]) Then
getArmyCCStatus()
EndIf
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
If $iTrainWaitCloseFlag = $TRAINWAIT_NOWAIT Then Return
Local $iTrainWaitTime
Switch $iTrainWaitCloseFlag
Case 14 To 15
$iTrainWaitTime = _ArrayMax($g_aiTimeTrain, 1, 0, 2, 0)
Case 12 To 13
$iTrainWaitTime = _Max($g_aiTimeTrain[1], $g_aiTimeTrain[2])
Case 10 To 11
$iTrainWaitTime = _Max($g_aiTimeTrain[0], $g_aiTimeTrain[2])
Case 8 To 9
$iTrainWaitTime = $g_aiTimeTrain[2]
Case 6 To 7
$iTrainWaitTime = _Max($g_aiTimeTrain[0], $g_aiTimeTrain[1])
Case 4 To 5
$iTrainWaitTime = $g_aiTimeTrain[1]
Case 2 To 3
$iTrainWaitTime = $g_aiTimeTrain[0]
Case 1
If $g_aiTimeTrain[0] <= 1 And Not $bTest Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
SetLog("No smart troop wait needed", $COLOR_SUCCESS)
Return
Else
$iTrainWaitTime = $g_aiTimeTrain[0]
EndIf
Case Else
SetLog("SmartWait cannot determine time to close CoC!", $COLOR_ERROR)
Return
EndSwitch
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Or $bTest Then
SetLog("Training time values: " & StringFormat("%.2f", $g_aiTimeTrain[0]) & " : " & StringFormat("%.2f", $g_aiTimeTrain[1]) & " : " & StringFormat("%.2f", $g_aiTimeTrain[2]), $COLOR_DEBUG)
SetLog("$iTrainWaitTime = " & StringFormat("%.2f", $iTrainWaitTime) & " minutes", $COLOR_DEBUG)
SetLog("$iTrainWaitCloseFlag: " & $iTrainWaitCloseFlag)
EndIf
If $g_bRequestTroopsEnable And $g_iCCRemainTime > 0 And $g_iCCRemainTime < $iTrainWaitTime Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Wait time reduced for CC from: " & StringFormat("%.2f", $iTrainWaitTime) & " To " & StringFormat("%.2f", $g_iCCRemainTime), $COLOR_DEBUG)
$iTrainWaitTime = $g_iCCRemainTime
EndIf
$iTrainWaitTime = $iTrainWaitTime * 60
$sNowTime = _NowCalc()
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Train end time: " & _DateAdd("s", Int($iTrainWaitTime), $sNowTime), $COLOR_DEBUG)
If IsArray($g_asShieldStatus) And _DateIsValid($g_asShieldStatus[2]) Then
$iShieldTime = _DateDiff("s", $sNowTime, $g_asShieldStatus[2])
If @error Then _logErrorDateDiff(@error)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Shield time remain: " & $iShieldTime & " seconds", $COLOR_DEBUG)
If $iShieldTime < 45 Then
$iShieldTime = 0
Else
$iShieldTime -= 45
EndIf
EndIf
$iDiffTime = $iShieldTime -($iTrainWaitTime)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Time Train:Shield:Diff " &($iTrainWaitTime) & ":" & $iShieldTime & ":" & $iDiffTime, $COLOR_DEBUG)
If($iTrainWaitTime >= $MinimumTimeClose) Or $bTest Then
If $iShieldTime > 0 Then
If $iDiffTime <= 0 Then
SetLog("Smart wait while shield time = " & StringFormat("%.2f", $iShieldTime / 60) & " Minutes", $COLOR_INFO)
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertSmartWaitTime Then NotifyPushToBoth($g_sNotifyOrigin & " : " & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_01", "Smart Wait While Shield Time = ") & StringFormat("%.2f", $iShieldTime / 60) & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_02", " Minutes") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_03", "Wait For Troops Ready"))
If $bTest Then $iShieldTime = $iTestSeconds
UniversalCloseWaitOpenCoC($iShieldTime * 1000, "SmartWait4Train_", $StopEmulator, $bFullRestart, $bSuspendComputer)
$g_bRestart = True
ResetTrainTimeArray()
Else
SetLog("Smart wait train time = " & StringFormat("%.2f", $iTrainWaitTime / 60) & " Minutes", $COLOR_INFO)
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertSmartWaitTime Then NotifyPushToBoth($g_sNotifyOrigin & " : " & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_04", "Smart Wait Train Time = ") & StringFormat("%.2f", $iTrainWaitTime / 60) & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_02", " Minutes") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_03", "Wait For Troops Ready"))
If $bTest Then $iTrainWaitTime = $iTestSeconds
UniversalCloseWaitOpenCoC($iTrainWaitTime * 1000, "SmartWait4Train_", $StopEmulator, $bFullRestart, $bSuspendComputer)
$g_bRestart = True
ResetTrainTimeArray()
EndIf
ElseIf($g_bCloseWithoutShield And $g_aiTimeTrain[0] > 0) Or($ichkCloseWaitSpell = 1 And $g_aiTimeTrain[1] > 0) Or($ichkCloseWaitHero = 1 And $g_aiTimeTrain[2] > 0) Then
SetLog("Smart Wait time = " & StringFormat("%.2f", $iTrainWaitTime / 60) & " Minutes", $COLOR_INFO)
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertSmartWaitTime Then NotifyPushToBoth($g_sNotifyOrigin & " : " & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_05", "Smart Wait Time = ") & StringFormat("%.2f", $iTrainWaitTime / 60) & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_02", " Minutes") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_03", "Wait For Troops Ready"))
If $bTest Then $iTrainWaitTime = $iTestSeconds
UniversalCloseWaitOpenCoC($iTrainWaitTime * 1000, "SmartWait4TrainNoShield_", $StopEmulator, $bFullRestart, $bSuspendComputer)
$g_bRestart = True
ResetTrainTimeArray()
Else
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$ichkCloseWaitSpell=" & $ichkCloseWaitSpell & ", $g_aiTimeTrain[1]=" & $g_aiTimeTrain[1], $COLOR_DEBUG)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$ichkCloseWaitHero=" & $ichkCloseWaitHero & ", $g_aiTimeTrain[2]=" & $g_aiTimeTrain[2], $COLOR_DEBUG)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Troop training with time remaining not enabled, skip SmartWait game exit", $COLOR_DEBUG)
EndIf
Else
SetLog("Smart Wait Time < Minimum Time Required To Close [" &($MinimumTimeClose / 60) & " Min]", $COLOR_INFO)
SetLog("Wait Train Time = " & StringFormat("%.2f", $iTrainWaitTime / 60) & " Minutes", $COLOR_INFO)
SetLog("Remain Shield Time = " & StringFormat("%.2f", $iShieldTime / 60) & " Minutes", $COLOR_INFO)
SetLog("Not Close CoC Just Wait In The Main Screen", $COLOR_INFO)
If($iShieldTime < $iTrainWaitTime) And($g_bCloseWithoutShield = False) Then
_SleepStatus($iShieldTime * 1000)
Else
_SleepStatus($iTrainWaitTime * 1000)
EndIf
ResetTrainTimeArray()
EndIf
EndFunc
Func ResetTrainTimeArray()
For $i = 0 To UBound($g_aiTimeTrain) - 1
$g_aiTimeTrain[$i] = 0
Next
EndFunc
Func TrainClick($iX, $iY, $iTimes, $iSpeed, $aWatchSpot, $sdebugtxt, $TypeTroops)
If IsTrainPage() Then
If $g_bDebugClick Then
Local $txt = _DecodeDebug($sdebugtxt)
SetLog("TrainClick(" & $iX & "," & $iX & "," & $iTimes & "," & $iSpeed & "," & $sdebugtxt & $txt & "," & $TypeTroops & ")", $COLOR_DEBUG)
EndIf
If $iTimes <> 1 Then
KeepClicks()
If $g_bDebugClick Or $g_bDebugSetlogTrain Then SetLog("KeepClicks: " & KeepClicks() , $COLOR_DEBUG)
If FastCaptureRegion() Then
For $i = 0 To($iTimes - 1)
If isProblemAffect(True) Then checkMainScreen(False)
Local $sLogText = Default
If $g_bDebugSetlogTrain Then $sLogText = "TrainClick " & $iX & "," & $iY & "," & $iTimes
If _CheckPixel($aWatchSpot, True, Default, $sLogText) = True Then
If $g_bDebugClick Or $g_bDebugSetlogTrain Then SetLog("Camp is FULL after " & $i & " clicks", $COLOR_DEBUG)
ExitLoop
EndIf
If Not $g_bUseRandomClick Then
PureClick($iX, $iY)
Else
PureClickR($TypeTroops, $iX, $iY)
EndIf
If _Sleep($iSpeed, False) Then ExitLoop
Next
Else
If isProblemAffect(True) Then checkMainScreen(False)
Local $sLogText = Default
If $g_bDebugSetlogTrain Then $sLogText = "TrainClick " & $iX & "," & $iY & "," & $iTimes
If _CheckPixel($aWatchSpot, True, Default, $sLogText) = True Then
If $g_bDebugClick Or $g_bDebugSetlogTrain Then SetLog("Camp is full", $COLOR_DEBUG)
Return
EndIf
If Not $g_bUseRandomClick Then
PureClick($iX, $iY, $iTimes, $iSpeed)
Else
PureClickR($TypeTroops, $iX, $iY, $iTimes, $iSpeed)
EndIf
If _Sleep($iSpeed, False) Then Return
EndIf
ReleaseClicks()
Else
Local $sLogText = Default
If $g_bDebugSetlogTrain Then $sLogText = "TrainClick " & $iX & "," & $iY & "," & $iTimes
If isProblemAffect(True) Then checkMainScreen(False)
If $g_bDebugSetlogTrain Then SetLog("Full Check=" & _GetPixelColor($aWatchSpot[0], $aWatchSpot[1], False), $COLOR_DEBUG)
If _CheckPixel($aWatchSpot, True, Default, $sLogText) = True Then
If $g_bDebugClick Or $g_bDebugSetlogTrain Then SetLog("Camp is FULL", $COLOR_DEBUG)
Return
EndIf
If Not $g_bUseRandomClick Then
PureClick($iX, $iY)
Else
PureClickR($TypeTroops, $iX, $iY)
EndIf
If _Sleep($iSpeed, False) Then Return
EndIf
Return True
Else
Return False
EndIf
EndFunc
Func TrainClickP($aPoint, $iHowOften, $iSpeed, $aWatchSpot, $sDebugTxt, $TypeTroops)
Return TrainClick($aPoint[0], $aPoint[1], $iHowOften, $iSpeed, $aWatchSpot, $sDebugTxt, $TypeTroops)
EndFunc
Func TrainRevamp()
If Not $g_bTrainEnabled Then
If $g_bDebugSetlogTrain Then SetLog("Halt mode - training disabled", $COLOR_DEBUG)
Return
EndIf
$g_sTimeBeforeTrain = _NowCalc()
StartGainCost()
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) And $g_bFullArmy Then
SetLog("You are in halt attack mode and your Army is prepared!", $COLOR_DEBUG)
If $g_bFirstStart Then $g_bFirstStart = False
Return
EndIf
If Not $g_bQuickTrainEnable Then
TrainRevampOldStyle()
Return
EndIf
If $g_bDebugSetlogTrain Then SetLog(" - Initial Quick train Function")
If $g_bDebugSetlogTrain Then SetLog(" - Line Open Army Window")
CheckIfArmyIsReady()
If Not $g_bRunState Then Return
If $g_bIsFullArmywithHeroesAndSpells Or($g_CurrentCampUtilization = 0 And $g_bFirstStart) Then
If $g_bIsFullArmywithHeroesAndSpells Then SetLog(" - Your Army is Full, let's make troops before Attack!", $COLOR_INFO)
If($g_CurrentCampUtilization = 0 And $g_bFirstStart) Then
SetLog(" - Your Army is Empty, let's make troops before Attack!", $COLOR_ACTION1)
SetLog(" - Go to Train Army Tab and select your Quick Army position!", $COLOR_ACTION1)
EndIf
DeleteQueued("Troops")
If _Sleep(250) Then Return
DeleteQueued("Spells")
If _Sleep(500) Then Return
CheckCamp()
ResetVariables("donated")
If $g_bFirstStart Then $g_bFirstStart = False
If _Sleep(700) Then Return
Else
If $g_bDonationEnabled And $g_bChkDonate Then MakingDonatedTroops()
CheckIsFullQueuedAndNotFullArmy()
If Not $g_bRunState Then Return
If _Sleep($DELAYRESPOND) Then Return
CheckIsEmptyQueuedAndNotFullArmy()
If Not $g_bRunState Then Return
If _Sleep($DELAYRESPOND) Then Return
If $g_bFirstStart Then $g_bFirstStart = False
EndIf
ClickP($aAway, 2, 0, "#0346")
If _Sleep(1000) Then Return
SetLog("Army Window Closed", $COLOR_INFO)
EndGainCost("Train")
checkAttackDisable($g_iTaBChkIdle)
EndFunc
Func CheckCamp($bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $bOpenArmyWindow Then
OpenArmyOverview(True, "CheckCamp()")
If _Sleep(500) Then Return
EndIf
Local $iReturnCamp = TestMaxCamp()
If $iReturnCamp = 1 Then
If Not OpenQuickTrainTab(True, "CheckCamp()") Then Return
If _Sleep(1000) Then Return
TrainArmyNumber($g_bQuickTrainArmy)
If _Sleep(700) Then Return
EndIf
If $iReturnCamp = 0 Then
CheckIsFullQueuedAndNotFullArmy()
CheckIsEmptyQueuedAndNotFullArmy()
EndIf
If $bCloseArmyWindow Then
ClickP($aAway, 2, 0, "#0346")
If _Sleep(250) Then Return
EndIf
EndFunc
Func TestMaxCamp()
Local $ToReturn = 0
If Not OpenTroopsTab(True, "TestMaxCamp()") Then Return
If _Sleep(250) Then Return
Local $ArmyCamp = GetOCRCurrent(48, 160)
If UBound($ArmyCamp) = 3 Then
If $ArmyCamp[2] = 0 Or $ArmyCamp[0] = 0 Or($ArmyCamp[0] = $ArmyCamp[2]) Then
$ToReturn = 1
Else
If $ArmyCamp[1] > 520 Then SetLog(" Your CoC is outdated!!! ", $COLOR_ERROR)
SetLog(" - Your army is: " & $ArmyCamp[0], $COLOR_ACTION)
$ToReturn = 0
EndIf
EndIf
Return $ToReturn
EndFunc
Func TrainRevampOldStyle()
If Not $g_bRunState Then Return
If $g_bDebugSetlogTrain Then SetLog(" - Initial Custom train Function")
If $g_iActiveDonate = -1 Then PrepareDonateCC()
CheckIfArmyIsReady()
If ThSnipesSkiptrain() Then Return
If Not $g_bRunState Then Return
Local $rWhatToTrain = WhatToTrain(True, False)
Local $rRemoveExtraTroops = RemoveExtraTroops($rWhatToTrain)
If $rRemoveExtraTroops = 1 Or $rRemoveExtraTroops = 2 Then
CheckIfArmyIsReady()
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) And $g_bFullArmy Then
SetLog("You are in halt attack mode and your Army is prepared!", $COLOR_DEBUG)
If $g_bFirstStart Then $g_bFirstStart = False
Return
EndIf
EndIf
If Not $g_bRunState Then Return
If $rRemoveExtraTroops = 2 Then
$rWhatToTrain = WhatToTrain(False, False)
TrainUsingWhatToTrain($rWhatToTrain)
EndIf
If _Sleep($DELAYRESPOND) Then Return
If IsQueueEmpty("Troops") Then
If Not $g_bRunState Then Return
If Not OpenArmyTab(True, "TrainRevampOldStyle()") Then Return
$rWhatToTrain = WhatToTrain(False, False)
TrainUsingWhatToTrain($rWhatToTrain)
Else
If Not $g_bRunState Then Return
If Not OpenArmyTab(True, "TrainRevampOldStyle()") Then Return
EndIf
If _Sleep($DELAYRESPOND) Then Return
$rWhatToTrain = WhatToTrain(False, False)
If DoWhatToTrainContainSpell($rWhatToTrain) Then
If IsQueueEmpty("Spells") Then
TrainUsingWhatToTrain($rWhatToTrain, True)
Else
If Not OpenArmyTab(True, "TrainRevampOldStyle()") Then Return
EndIf
EndIf
If _Sleep(250) Then Return
If Not $g_bRunState Then Return
ClickP($aAway, 2, 0, "#0346")
If _Sleep(250) Then Return
EndGainCost("Train")
checkAttackDisable($g_iTaBChkIdle)
EndFunc
Func CheckIfArmyIsReady()
If Not $g_bRunState Then Return
Local $bFullArmyCCSpells = False, $bFullArmyCCTroops = False
Local $iTotalSpellsToBrew = 0
Local $bFullArmyHero = False
$g_bWaitForCCTroopSpell = False
If Not OpenArmyOverview(False, "CheckIfArmyIsReady()") Then Return
If _Sleep(250) Then Return
If Not OpenArmyTab(True, "CheckIfArmyIsReady()") Then Return
If _Sleep(250) Then Return
CheckArmyCamp(False, False, False, True)
If $g_bDebugSetlogTrain Then
SetLog(" - $g_CurrentCampUtilization : " & $g_CurrentCampUtilization)
SetLog(" - $g_iTotalCampSpace : " & $g_iTotalCampSpace)
EndIf
$g_bFullArmySpells = False
For $i = 0 To $eSpellCount - 1
$iTotalSpellsToBrew += $g_aiArmyCompSpells[$i] * $g_aiSpellSpace[$i]
Next
If Number($g_iCurrentSpells) = Number($g_iTotalTrainSpaceSpell) Or Number($g_iCurrentSpells) >= Number($g_iTotalSpellValue) Or(Number($g_iCurrentSpells) >= Number($iTotalSpellsToBrew) And $g_bQuickTrainEnable = False) Then
$g_bFullArmySpells = True
EndIf
$g_bCheckSpells = CheckSpells()
$bFullArmyHero = BitAND($g_aiSearchHeroWaitEnable[$DB], $g_iHeroAvailable) > 0 Or BitAND($g_aiSearchHeroWaitEnable[$LB], $g_iHeroAvailable) > 0 Or($g_aiSearchHeroWaitEnable[$DB] = $eHeroNone And $g_aiSearchHeroWaitEnable[$LB] = $eHeroNone)
$bFullArmyCCSpells = IsFullClanCastleSpells()
$bFullArmyCCTroops = IsFullClanCastleTroops()
If Not IsWaitforHeroesActive() And $g_bDropTrophyUseHeroes Then $bFullArmyHero = True
If Not IsWaitforHeroesActive() And Not $g_bDropTrophyUseHeroes And Not $bFullArmyHero Then
If $g_iHeroAvailable > 0 Or Number($g_aiCurrentLoot[$eLootTrophy]) <= Number($g_iDropTrophyMax) Then
$bFullArmyHero = True
Else
SetLog("Waiting for Heroes to drop trophies!", $COLOR_ACTION)
EndIf
EndIf
If(IsSearchModeActive($DB) And checkCollectors(True, False)) Or IsSearchModeActive($LB) Or IsSearchModeActive($TS) Then
If $g_bFullArmy And $g_bCheckSpells And $bFullArmyHero And $bFullArmyCCSpells And $bFullArmyCCTroops Then
$g_bIsFullArmywithHeroesAndSpells = True
If $g_bFirstStart Then $g_bFirstStart = False
Else
If $g_bDebugSetlog Then
SetDebugLog(" $g_bFullArmy: " & String($g_bFullArmy), $COLOR_DEBUG)
SetDebugLog(" $g_bCheckSpells: " & String($g_bCheckSpells), $COLOR_DEBUG)
SetDebugLog(" $bFullArmyHero: " & String($bFullArmyHero), $COLOR_DEBUG)
SetDebugLog(" $bFullArmyCCSpells: " & String($bFullArmyCCSpells), $COLOR_DEBUG)
SetDebugLog(" $bFullArmyCCTroops: " & String($bFullArmyCCTroops), $COLOR_DEBUG)
EndIf
$g_bIsFullArmywithHeroesAndSpells = False
EndIf
If $g_bFullArmy And $g_bCheckSpells And $bFullArmyHero Then
If Not $bFullArmyCCSpells Or Not $bFullArmyCCTroops Then $g_bWaitForCCTroopSpell = True
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog(" Army not ready: IsSearchModeActive($DB)=" & IsSearchModeActive($DB) & ", checkCollectors(True, False)=" & checkCollectors(True, False) & ", IsSearchModeActive($LB)=" & IsSearchModeActive($LB) & ", IsSearchModeActive($TS)=" & IsSearchModeActive($TS), $COLOR_DEBUG)
$g_bIsFullArmywithHeroesAndSpells = False
EndIf
Local $sLogText = ""
If Not $g_bFullArmy Then $sLogText &= " Troops,"
If Not $g_bCheckSpells Then $sLogText &= " Spells,"
If Not $bFullArmyHero Then $sLogText &= " Heroes,"
If Not $bFullArmyCCTroops Then $sLogText &= " CC Troops,"
If Not $bFullArmyCCSpells Then $sLogText &= " CC Spells,"
If StringRight($sLogText, 1) = "," Then $sLogText = StringTrimRight($sLogText, 1)
If $g_bIsFullArmywithHeroesAndSpells Then
If(($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertCampFull) Then PushMsg("CampFull")
SetLog("Chief, is your Army ready for battle? Yes, it is!", $COLOR_SUCCESS)
Else
SetLog("Chief, is your Army ready for the battle? No, not yet!", $COLOR_ACTION)
If $sLogText <> "" Then SetLog(" -" & $sLogText & " are not Ready!", $COLOR_ACTION)
EndIf
If Not $bFullArmyCCTroops Or Not $bFullArmyCCSpells Then $g_bCanRequestCC = True
If $g_bDebugSetlog Then
SetDebugLog(" $g_bFullArmy: " & String($g_bFullArmy), $COLOR_DEBUG)
SetDebugLog(" $bCheckCCTroops: " & String($bFullArmyCCTroops), $COLOR_DEBUG)
SetDebugLog(" $bCheckCCSpells: " & String($bFullArmyCCSpells), $COLOR_DEBUG)
SetDebugLog(" $g_bIsFullArmywithHeroesAndSpells: " & String($g_bIsFullArmywithHeroesAndSpells), $COLOR_DEBUG)
SetDebugLog(" $g_iTownHallLevel: " & Number($g_iTownHallLevel), $COLOR_DEBUG)
EndIf
EndFunc
Func CheckSpells()
If Not $g_bRunState Then Return
Local $bToReturn = False
If(Not $g_abSearchSpellsWaitEnable[$DB] And Not $g_abSearchSpellsWaitEnable[$LB]) Or($g_bFullArmySpells And($g_abSearchSpellsWaitEnable[$DB] Or $g_abSearchSpellsWaitEnable[$LB])) Then
Return True
EndIf
If(($g_abAttackTypeEnable[$DB] And $g_abSearchSpellsWaitEnable[$DB]) Or($g_abAttackTypeEnable[$LB] And $g_abSearchSpellsWaitEnable[$LB])) And $g_iTownHallLevel >= 5 Then
$bToReturn = $g_bFullArmySpells
Else
$bToReturn = True
EndIf
Return $bToReturn
EndFunc
Func IsFullClanCastleTroops()
If Not $g_bRunState Then Return
If Not $g_abSearchCastleTroopsWaitEnable[$DB] And Not $g_abSearchCastleTroopsWaitEnable[$LB] Then
Return True
EndIf
Local $bColCheck = _ColorCheck(_GetPixelColor(24, 470, True), Hex(0x93C230, 6), 30)
If($g_abAttackTypeEnable[$DB] And $g_abSearchCastleTroopsWaitEnable[$DB]) Or($g_abAttackTypeEnable[$LB] And $g_abSearchCastleTroopsWaitEnable[$LB]) Then
Return $bColCheck
Else
Return True
EndIf
EndFunc
Func IsFullClanCastleSpells($bReturnOnly = False)
Local $sCurCCSpell1 = "", $sCurCCSpell2 = "", $aShouldRemove[2] = [0, 0], $rColCheckFullCCTroops = False
Local $bCCSpellFull = False
Local $ToReturn = False
If Not $g_bRunState Then Return
If(Not $g_abAttackTypeEnable[$DB] Or Not $g_abSearchCastleSpellsWaitEnable[$DB]) And(Not $g_abAttackTypeEnable[$LB] Or Not $g_abSearchCastleSpellsWaitEnable[$LB]) Then
$ToReturn = True
If Not $bReturnOnly Then
Return $ToReturn
Else
Return ""
EndIf
EndIf
If $g_iCurrentCCSpells = $g_iTotalCCSpells And $g_iTotalCCSpells > 0 Then $bCCSpellFull = True
If $bCCSpellFull And(($g_abAttackTypeEnable[$DB] And $g_abSearchCastleSpellsWaitEnable[$DB]) Or($g_abAttackTypeEnable[$LB] And $g_abSearchCastleSpellsWaitEnable[$LB])) Then
If $g_bDebugSetlogTrain Then SetLog("Getting current available spell in Clan Castle.")
If $g_iTotalCCSpells >= 1 Then $sCurCCSpell1 = GetCurCCSpell(1)
If $g_iTotalCCSpells >= 2 Then $sCurCCSpell2 = GetCurCCSpell(2)
If $sCurCCSpell1 = "" And $g_iCurrentCCSpells > 0 Then
If Not $bReturnOnly Then
SetLog("Failed to get current available spell in Clan Castle", $COLOR_ERROR)
Return False
Else
Return ""
EndIf
EndIf
$aShouldRemove = CompareCCSpellWithGUI($sCurCCSpell1, $sCurCCSpell2, $g_iTotalCCSpells)
If $g_iTotalCCSpells >= 2 Then
If $g_bDebugSetlogTrain Then SetLog("Slot 1 to remove: " & $aShouldRemove[0])
If $g_bDebugSetlogTrain Then SetLog("Slot 2 to remove: " & $aShouldRemove[1])
ElseIf $g_iTotalCCSpells = 1 Then
If $g_bDebugSetlogTrain Then SetLog("Slot 1 to remove: " & $aShouldRemove[0])
EndIf
If $aShouldRemove[0] > 0 Or $aShouldRemove[1] > 0 Then
SetLog("Removing unwanted Clancastle Spells!", $COLOR_INFO)
RemoveCastleSpell($aShouldRemove)
If _Sleep(1000) Then Return
$g_bCanRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1] + 20, True), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) And _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5])
If $g_bDebugSetlogTrain Then SetLog(" - Clans Castle button available? " & $g_bCanRequestCC)
If $g_bCanRequestCC Then
$rColCheckFullCCTroops = _ColorCheck(_GetPixelColor(24, 470, True), Hex(0x93C230, 6), 30)
If $rColCheckFullCCTroops Then SetLog("Clan Castle Spell is empty, Requesting for...")
If Not $bReturnOnly Then
RequestCC(False, IIf($rColCheckFullCCTroops Or(Not $g_abSearchCastleTroopsWaitEnable[$DB] And Not $g_abSearchCastleTroopsWaitEnable[$LB]), IIf($g_abSearchCastleSpellsWaitEnable[$LB], IIf(String(GUICtrlRead($g_hCmbABWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbABWaitForCastleSpell) & " Spell")), IIf($g_abSearchCastleSpellsWaitEnable[$DB], IIf(String(GUICtrlRead($g_hCmbDBWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbDBWaitForCastleSpell) & " Spell")), "")), ""))
Else
$ToReturn = IIf($rColCheckFullCCTroops Or(Not $g_abSearchCastleTroopsWaitEnable[$DB] And Not $g_abSearchCastleTroopsWaitEnable[$LB]), IIf($g_abSearchCastleSpellsWaitEnable[$LB], IIf(String(GUICtrlRead($g_hCmbABWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbABWaitForCastleSpell) & " Spell")), IIf($g_abSearchCastleSpellsWaitEnable[$DB], IIf(String(GUICtrlRead($g_hCmbDBWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbDBWaitForCastleSpell) & " Spell")), "")), "")
Return $ToReturn
EndIf
EndIf
$ToReturn = False
ElseIf $aShouldRemove[0] = 0 And $aShouldRemove[1] = 0 Then
$ToReturn = True
EndIf
ElseIf Not $bCCSpellFull And(($g_abAttackTypeEnable[$DB] And $g_abSearchCastleSpellsWaitEnable[$DB]) Or($g_abAttackTypeEnable[$LB] And $g_abSearchCastleSpellsWaitEnable[$LB])) Then
$g_bCanRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1] + 20, True), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) And _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5])
If $g_bCanRequestCC Then
$rColCheckFullCCTroops = _ColorCheck(_GetPixelColor(24, 470, True), Hex(0x93C230, 6), 30)
If $rColCheckFullCCTroops Then SetLog("Clan Castle Spell is empty, Requesting for...")
If Not $bReturnOnly Then
RequestCC(False, IIf($rColCheckFullCCTroops Or(Not $g_abSearchCastleTroopsWaitEnable[$DB] And Not $g_abSearchCastleTroopsWaitEnable[$LB]), IIf($g_abSearchCastleSpellsWaitEnable[$LB], IIf(String(GUICtrlRead($g_hCmbABWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbABWaitForCastleSpell) & " Spell")), IIf($g_abSearchCastleSpellsWaitEnable[$DB], IIf(String(GUICtrlRead($g_hCmbDBWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbDBWaitForCastleSpell) & " Spell")), "")), ""))
Else
$ToReturn = IIf($rColCheckFullCCTroops Or(Not $g_abSearchCastleTroopsWaitEnable[$DB] And Not $g_abSearchCastleTroopsWaitEnable[$LB]), IIf($g_abSearchCastleSpellsWaitEnable[$LB], IIf(String(GUICtrlRead($g_hCmbABWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbABWaitForCastleSpell) & " Spell")), IIf($g_abSearchCastleSpellsWaitEnable[$DB], IIf(String(GUICtrlRead($g_hCmbDBWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbDBWaitForCastleSpell) & " Spell")), "")), "")
Return $ToReturn
EndIf
EndIf
EndIf
If Not $bReturnOnly Then
Return $ToReturn
Else
Return ""
EndIf
EndFunc
Func RemoveCastleSpell($Slots)
If $Slots[0] = 0 And $Slots[1] = 0 Then Return
If Not _ColorCheck(_GetPixelColor(806, 516, True), Hex(0xCEEF76, 6), 25) Then
SetLog("Cannot find/verify 'Edit Army' Button in Army tab", $COLOR_WARNING)
Return False
EndIf
Click(Random(715, 825, 1), Random(507, 545, 1))
If Not $g_bRunState Then Return
If _Sleep(500) Then Return
Local $pos[2] = [575, 575], $pos2[2] = [645, 575]
If $Slots[0] > 0 Then
ClickRemoveTroop($pos, $Slots[0], $g_iTrainClickDelay)
EndIf
If $Slots[1] > 0 Then
ClickRemoveTroop($pos2, $Slots[1], $g_iTrainClickDelay)
EndIf
If _Sleep(400) Then Return
If Not _ColorCheck(_GetPixelColor(806, 567, True), Hex(0xCEEF76, 6), 25) Then
SetLog("Cannot find/verify 'Okay' Button in Army tab", $COLOR_WARNING)
ClickP($aAway, 2, 0, "#0346")
If _Sleep(400) Then OpenArmyOverview(True, "RemoveCastleSpell()")
Return False
EndIf
If _Sleep(700) Then Return
Click(Random(720, 815, 1), Random(558, 589, 1))
If _Sleep(1200) Then Return
If Not _ColorCheck(_GetPixelColor(508, 428, True), Hex(0xFFFFFF, 6), 30) Then
SetLog("Cannot find/verify 'Okay #2' Button in Army tab", $COLOR_WARNING)
ClickP($aAway, 2, 0, "#0346")
Return False
EndIf
Click(Random(445, 583, 1), Random(402, 455, 1))
SetLog("Clan Castle Spell Removed", $COLOR_SUCCESS)
If _Sleep(200) Then Return
Return True
EndFunc
Func CompareCCSpellWithGUI($CCSpell1, $CCSpell2, $CastleCapacity)
If $g_bDebugSetlogTrain Then
For $i = 0 To UBound($CCSpell1, $UBOUND_COLUMNS) - 1
SetLog("$CCSpell1[0][" & $i & "]: " & $CCSpell1[0][$i])
Next
If $CCSpell2 <> "" And $CastleCapacity = 2 And $CCSpell1[0][3] < 2 Then
For $i = 0 To UBound($CCSpell2, $UBOUND_COLUMNS) - 1
SetLog("$CCSpell2[0][" & $i & "]: " & $CCSpell2[0][$i])
Next
EndIf
EndIf
If Not $g_bRunState Then Return
If _Sleep(100) Then Return
Local $sCCSpell, $sCCSpell2, $bCheckDBCCSpell = False, $bCheckABCCSpell = False, $aShouldRemove[2] = [0, 0]
If $CastleCapacity = 0 Or $CastleCapacity = "" Then Return $aShouldRemove
If $g_abAttackTypeEnable[$DB] And $g_abSearchCastleSpellsWaitEnable[$DB] Then
If $g_bDebugSetlogTrain Then SetLog("- Let's compare CC Spells on Dead Bases!", $COLOR_DEBUG)
$bCheckDBCCSpell = True
EndIf
If $g_abAttackTypeEnable[$LB] And $g_abSearchCastleSpellsWaitEnable[$LB] Then
If $g_bDebugSetlogTrain Then SetLog("- Let's compare CC Spells on Active Bases", $COLOR_DEBUG)
$bCheckABCCSpell = True
EndIf
If Not $bCheckDBCCSpell And Not $bCheckABCCSpell Then Return $aShouldRemove
For $Mode = $DB To $LB
If BitOR($g_aiSearchCastleSpellsWaitRegular[$Mode], $g_aiSearchCastleSpellsWaitDark[$Mode]) > 0 Then
Local $txt = "DB"
$txt =($Mode = $LB) ?("LB") :("DB")
If $Mode = $DB And Not $bCheckDBCCSpell Then ContinueLoop
Switch $g_aiSearchCastleSpellsWaitRegular[$Mode]
Case 0
$sCCSpell = "Any"
Case 1
$sCCSpell = "LSpell"
Case 2
$sCCSpell = "HSpell"
Case 3
$sCCSpell = "RSpell"
Case 4
$sCCSpell = "JSpell"
Case 5
$sCCSpell = "FSpell"
Case 6
$sCCSpell = "PSpell"
Case 7
$sCCSpell = "ESpell"
Case 8
$sCCSpell = "HaSpell"
Case 9
$sCCSpell = "SkSpell"
EndSwitch
Switch $g_aiSearchCastleSpellsWaitDark[$Mode]
Case 0
$sCCSpell2 = "Any"
Case 1
$sCCSpell2 = "PSpell"
Case 2
$sCCSpell2 = "ESpell"
Case 3
$sCCSpell2 = "HaSpell"
Case 4
$sCCSpell2 = "SkSpell"
EndSwitch
Switch $CCSpell1[0][3]
Case 1
If($sCCSpell <> $CCSpell1[0][0] And $sCCSpell <> "Any") Then
$aShouldRemove[0] = $CCSpell1[0][3]
EndIf
If $CastleCapacity = 2 And $g_aiSearchCastleSpellsWaitRegular[$Mode] > 5 Then
If $sCCSpell2 <> $CCSpell2[0][0] And $sCCSpell2 <> "Any" Then
$aShouldRemove[1] = $CCSpell2[0][3]
EndIf
EndIf
Case 2
If $g_aiSearchCastleSpellsWaitRegular[$Mode] <= 5 And $g_aiSearchCastleSpellsWaitRegular[$Mode] > 0 Then
$aShouldRemove[0] = $CCSpell1[0][3]
ElseIf($sCCSpell <> $CCSpell1[0][0] And $sCCSpell <> "Any") And($sCCSpell2 <> $CCSpell1[0][0] And $sCCSpell2 <> "Any") Then
$aShouldRemove[0] = $CCSpell1[0][3]
ElseIf($sCCSpell <> $CCSpell1[0][0] And $sCCSpell <> "Any") Or($sCCSpell2 <> $CCSpell1[0][0] And $sCCSpell2 <> "Any") Then
$aShouldRemove[0] = 1
EndIf
Case Else
Return $aShouldRemove
EndSwitch
ExitLoop
EndIf
Next
Return $aShouldRemove
EndFunc
Func GetCurCCSpell($iSpellSlot = 1)
If Not $g_bRunState Then Return
Local $x1 = 451, $x2 = 575, $y1 = 500, $y2 = 585
If $iSpellSlot = 1 Then
ElseIf $iSpellSlot = 2 Then
$x1 = 530
$x2 = 605
Else
If $g_bDebugSetlog Then SetDebugLog("GetCurCCSpell() called with the wrong argument!", $COLOR_ERROR)
Return
EndIf
Local $res = SearchArmy($g_sImgArmyOverviewSpells, $x1, $y1, $x2, $y2, "CCSpells", True)
If ValidateSearchArmyResult($res) Then
For $i = 0 To UBound($res) - 1
SetLog(" - " & $g_asSpellNames[TroopIndexLookup($res[$i][0], "GetCurCCSpell") - $eLSpell], $COLOR_SUCCESS)
Next
Return $res
EndIf
Return ""
EndFunc
Func TrainUsingWhatToTrain($rWTT, $bSpellsOnly = False)
If Not $g_bRunState Then Return
If UBound($rWTT) = 1 And $rWTT[0][0] = "Arch" And $rWTT[0][1] = 0 Then
Return True
EndIf
If Not $bSpellsOnly Then
If Not OpenTroopsTab(True, "TrainUsingWhatToTrain()") Then Return
Else
If Not OpenSpellsTab(True, "TrainUsingWhatToTrain()") Then Return
EndIf
Switch $g_bIsFullArmywithHeroesAndSpells
Case False
For $i = 0 To(UBound($rWTT) - 1)
If Not $g_bRunState Then Return
If $rWTT[$i][1] > 0 Then
If IsSpellToBrew($rWTT[$i][0]) Then
If $bSpellsOnly Then BrewUsingWhatToTrain($rWTT[$i][0], $rWTT[$i][1])
ContinueLoop
Else
If $bSpellsOnly Then ContinueLoop
EndIf
Local $NeededSpace = CalcNeededSpace($rWTT[$i][0], $rWTT[$i][1])
Local $LeftSpace = LeftSpace()
If Not $g_bRunState Then Return
If $NeededSpace <= $LeftSpace Then
If Not DragIfNeeded($rWTT[$i][0]) Then
Return False
EndIf
Local $iTroopIndex = TroopIndexLookup($rWTT[$i][0], "TrainUsingWhatToTrain#1")
Local $sTroopName =($rWTT[$i][1] > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
If CheckValuesCost($rWTT[$i][0], $rWTT[$i][1]) Then
SetLog("Training " & $rWTT[$i][1] & "x " & $sTroopName, $COLOR_SUCCESS)
TrainIt($iTroopIndex, $rWTT[$i][1], $g_iTrainClickDelay)
Else
SetLog("No resources to Train " & $rWTT[$i][1] & "x " & $sTroopName, $COLOR_ACTION)
$g_bOutOfElixir = True
EndIf
Else
Local $CountToTrain = 0
Local $CanAdd = True
Do
$NeededSpace = CalcNeededSpace($rWTT[$i][0], $CountToTrain)
If $NeededSpace <= $LeftSpace Then
$CountToTrain += 1
Else
$CanAdd = False
EndIf
Until $CanAdd = False
If $CountToTrain > 0 Then
If DragIfNeeded($rWTT[$i][0]) = False Then
Return False
EndIf
EndIf
Local $iTroopIndex = TroopIndexLookup($rWTT[$i][0], "TrainUsingWhatToTrain#2")
Local $sTroopName =($CountToTrain > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
If CheckValuesCost($rWTT[$i][0], $CountToTrain) Then
SetLog("Training " & $CountToTrain & "x " & $sTroopName, $COLOR_SUCCESS)
TrainIt($iTroopIndex, $CountToTrain, $g_iTrainClickDelay)
Else
SetLog("No resources to Train " & $CountToTrain & "x " & $sTroopName, $COLOR_ACTION)
$g_bOutOfElixir = True
EndIf
EndIf
EndIf
If _Sleep($DELAYRESPOND) Then Return
Next
Case True
For $i = 0 To(UBound($rWTT) - 1)
If Not $g_bRunState Then Return
If $rWTT[$i][1] > 0 Then
If IsSpellToBrew($rWTT[$i][0]) Then
If $bSpellsOnly Then BrewUsingWhatToTrain($rWTT[$i][0], $rWTT[$i][1])
ContinueLoop
Else
If $bSpellsOnly Then ContinueLoop
EndIf
Local $NeededSpace = CalcNeededSpace($rWTT[$i][0], $rWTT[$i][1])
Local $LeftSpace = LeftSpace(True)
If Not $g_bRunState Then Return
$LeftSpace =($LeftSpace[1] * 2) - $LeftSpace[0]
If $NeededSpace <= $LeftSpace Then
If Not DragIfNeeded($rWTT[$i][0]) Then
Return False
EndIf
Local $iTroopIndex = TroopIndexLookup($rWTT[$i][0], "TrainUsingWhatToTrain#3")
Local $sTroopName =($rWTT[$i][1] > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
If CheckValuesCost($rWTT[$i][0], $rWTT[$i][1]) Then
SetLog("Training " & $rWTT[$i][1] & "x " & $sTroopName, $COLOR_SUCCESS)
TrainIt($iTroopIndex, $rWTT[$i][1], $g_iTrainClickDelay)
Else
SetLog("No resources to Train " & $rWTT[$i][1] & "x " & $sTroopName, $COLOR_ACTION)
$g_bOutOfElixir = True
EndIf
Else
Local $CountToTrain = 0
Local $CanAdd = True
Do
$NeededSpace = CalcNeededSpace($rWTT[$i][0], $CountToTrain)
If $NeededSpace <= $LeftSpace Then
$CountToTrain += 1
Else
$CanAdd = False
EndIf
Until $CanAdd = False
If $CountToTrain > 0 Then
If Not DragIfNeeded($rWTT[$i][0]) Then
Return False
EndIf
EndIf
Local $iTroopIndex = TroopIndexLookup($rWTT[$i][0], "TrainUsingWhatToTrain#4")
Local $sTroopName =($CountToTrain > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
If CheckValuesCost($rWTT[$i][0], $CountToTrain) Then
SetLog("Training " & $CountToTrain & "x " & $sTroopName, $COLOR_SUCCESS)
TrainIt($iTroopIndex, $CountToTrain, $g_iTrainClickDelay)
Else
SetLog("No resources to Train " & $CountToTrain & "x " & $sTroopName, $COLOR_ACTION)
$g_bOutOfElixir = True
EndIf
EndIf
EndIf
If _Sleep($DELAYRESPOND) Then Return
Next
EndSwitch
Return True
EndFunc
Func BrewUsingWhatToTrain($Spell, $Quantity)
Local $iSpellIndex = TroopIndexLookup($Spell, "BrewUsingWhatToTrain")
Local $sSpellName = $g_asSpellNames[$iSpellIndex - $eLSpell]
If $Quantity <= 0 Then Return False
If $Quantity = 9999 Then
SetLog("Brewing " & $sSpellName & " Spell Cancelled " & @CRLF & "                  Reason: Enough as set in GUI " & @CRLF & "                               This Spell not used in Attack")
Return True
EndIf
If Not $g_bRunState Then Return
If Not OpenSpellsTab(True, "BrewUsingWhatToTrain()") Then Return
Select
Case $g_bIsFullArmywithHeroesAndSpells = False
If Not _ColorCheck(_GetPixelColor(230, 208, True), Hex(0x677CB5, 6), 30) Then RemoveExtraTroopsQueue()
Local $NeededSpace = CalcNeededSpace($Spell, $Quantity)
Local $LeftSpace = LeftSpace()
If Not $g_bRunState Then Return
If $NeededSpace <= $LeftSpace Then
If CheckValuesCost($Spell, $Quantity) Then
SetLog("Brewing " & $Quantity & "x " & $sSpellName &($Quantity > 1 ? " Spells" : " Spell"), $COLOR_SUCCESS)
TrainIt($iSpellIndex, $Quantity, $g_iTrainClickDelay)
Else
SetLog("No resources to Brew " & $Quantity & "x " & $sSpellName &($Quantity > 1 ? " Spells" : " Spell"), $COLOR_ACTION)
$g_bOutOfElixir = True
EndIf
EndIf
Case $g_bIsFullArmywithHeroesAndSpells = True
Local $NeededSpace = CalcNeededSpace($Spell, $Quantity)
Local $LeftSpace = LeftSpace(True)
If Not $g_bRunState Then Return
$LeftSpace =($LeftSpace[1] * 2) - $LeftSpace[0]
If $NeededSpace <= $LeftSpace Then
If CheckValuesCost($Spell, $Quantity) Then
SetLog("Brewing " & $Quantity & "x " & $sSpellName &($Quantity > 1 ? " Spells" : " Spell"), $COLOR_SUCCESS)
TrainIt($iSpellIndex, $Quantity, $g_iTrainClickDelay)
Else
SetLog("No resources to Brew " & $Quantity & "x " & $sSpellName &($Quantity > 1 ? " Spells" : " Spell"), $COLOR_ACTION)
$g_bOutOfElixir = True
EndIf
EndIf
EndSelect
EndFunc
Func TotalSpellsToBrewInGUI()
Local $iTotalSpellsInGUI = 0
If $g_iTotalSpellValue = 0 Then Return $iTotalSpellsInGUI
If Not $g_bRunState Then Return
For $i = 0 To $eSpellCount - 1
$iTotalSpellsInGUI += $g_aiArmyCompSpells[$i] * $g_aiSpellSpace[$i]
Next
Return $iTotalSpellsInGUI
EndFunc
Func HowManyTimesWillBeUsed($Spell)
Local $ToReturn = -1
If Not $g_bRunState Then Return
If $g_bForceBrewSpells Then
$ToReturn = 2
Return $ToReturn
EndIf
If $g_abAttackTypeEnable[$DB] Then
If $g_aiAttackAlgorithm[$DB] = 1 Then
If IsGUICheckedForSpell($Spell, $DB) Then
$ToReturn = CountCommandsForSpell($Spell, $DB)
If $ToReturn = 0 Then $ToReturn = -1
Else
$ToReturn = -1
EndIf
Else
$ToReturn = -1
EndIf
EndIf
If $g_abAttackTypeEnable[$LB] Then
If $g_aiAttackAlgorithm[$LB] = 1 Then
If IsGUICheckedForSpell($Spell, $LB) Then
$ToReturn = CountCommandsForSpell($Spell, $LB)
If $ToReturn = 0 Then $ToReturn = -1
EndIf
EndIf
EndIf
Return $ToReturn
EndFunc
Func CountCommandsForSpell($Spell, $Mode)
Local $ToReturn = 0
Local $filename = ""
If Not $g_bRunState Then Return
If $Mode = $DB Then
$filename = $g_sAttackScrScriptName[$DB]
Else
$filename = $g_sAttackScrScriptName[$LB]
EndIf
Local $rownum = 0
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
Local $f, $line, $acommand, $command
Local $value1, $Troop
$f = FileOpen($g_sCSVAttacksPath & "\" & $filename & ".csv", 0)
While 1
$line = FileReadLine($f)
$rownum += 1
If @error = -1 Then ExitLoop
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), 2)
$Troop = StringStripWS(StringUpper($acommand[5]), 2)
If $Troop = $Spell Then $ToReturn += 1
EndIf
WEnd
FileClose($f)
Else
$ToReturn = 0
EndIf
Return $ToReturn
EndFunc
Func IsGUICheckedForSpell($Spell, $Mode)
Local $sSpell = ""
Local $aVal = 0
If Not $g_bRunState Then Return
Switch TroopIndexLookup($Spell, "IsGUICheckedForSpell")
Case $eLSpell
$sSpell = "Lightning"
$aVal = $g_abAttackUseLightSpell
Case $eHSpell
$sSpell = "Heal"
$aVal = $g_abAttackUseHealSpell
Case $eRSpell
$sSpell = "Rage"
$aVal = $g_abAttackUseRageSpell
Case $eJSpell
$sSpell = "Jump"
$aVal = $g_abAttackUseJumpSpell
Case $eFSpell
$sSpell = "Freeze"
$aVal = $g_abAttackUseFreezeSpell
Case $eCSpell
$sSpell = "Clone"
$aVal = $g_abAttackUseCloneSpell
Case $ePSpell
$sSpell = "Poison"
$aVal = $g_abAttackUsePoisonSpell
Case $eESpell
$sSpell = "Earthquake"
$aVal = $g_abAttackUseEarthquakeSpell
Case $eHaSpell
$sSpell = "Haste"
$aVal = $g_abAttackUseHasteSpell
Case $eSkSpell
$sSpell = "Skeleton"
$aVal = $g_abAttackUseSkeletonSpell
EndSwitch
If IsArray($aVal) Then Return $aVal[$Mode]
Return False
EndFunc
Func DragIfNeeded($Troop)
If Not $g_bRunState Then Return
Local $bCheckPixel = False
If IsDarkTroop($Troop) Then
If _ColorCheck(_GetPixelColor(834, 403, True), Hex(0xD3D3CB, 6), 5) Then $bCheckPixel = True
If $g_bDebugSetlogTrain Then SetLog("DragIfNeeded Dark Troops: " & $bCheckPixel)
For $i = 1 To 3
If Not $bCheckPixel Then
ClickDrag(715, 445 + $g_iMidOffsetY, 220, 445 + $g_iMidOffsetY, 2000)
If _Sleep(1500) Then Return
If _ColorCheck(_GetPixelColor(834, 403, True), Hex(0xD3D3CB, 6), 5) Then $bCheckPixel = True
Else
Return True
EndIf
Next
Else
If _ColorCheck(_GetPixelColor(22, 403, True), Hex(0xD3D3CB, 6), 5) Then $bCheckPixel = True
If $g_bDebugSetlogTrain Then SetLog("DragIfNeeded Normal Troops: " & $bCheckPixel)
For $i = 1 To 3
If Not $bCheckPixel Then
ClickDrag(220, 445 + $g_iMidOffsetY, 725, 445 + $g_iMidOffsetY, 2000)
If _Sleep(1500) Then Return
If _ColorCheck(_GetPixelColor(22, 403, True), Hex(0xD3D3CB, 6), 5) Then $bCheckPixel = True
Else
Return True
EndIf
Next
EndIf
SetLog("Failed to Verify Troop " & $g_asTroopNames[TroopIndexLookup($Troop, "DragIfNeeded")] & " Position or Failed to Drag Successfully", $COLOR_ERROR)
Return False
EndFunc
Func DoWhatToTrainContainSpell($rWTT)
For $i = 0 To(UBound($rWTT) - 1)
If Not $g_bRunState Then Return
If IsSpellToBrew($rWTT[$i][0]) Then
If $rWTT[$i][1] > 0 Then Return True
EndIf
Next
Return False
EndFunc
Func IsElixirTroop($Troop)
Local $iIndex = TroopIndexLookup($Troop, "IsElixirTroop")
If $iIndex >= $eBarb And $iIndex <= $eMine Then Return True
Return False
EndFunc
Func IsDarkTroop($Troop)
Local $iIndex = TroopIndexLookup($Troop, "IsDarkTroop")
If $iIndex >= $eMini And $iIndex <= $eBowl Then Return True
Return False
EndFunc
Func IsElixirSpell($Spell)
Local $iIndex = TroopIndexLookup($Spell, "IsElixirSpell")
If $iIndex >= $eLSpell And $iIndex <= $eCSpell Then Return True
Return False
EndFunc
Func IsDarkSpell($Spell)
Local $iIndex = TroopIndexLookup($Spell, "IsDarkSpell")
If $iIndex >= $ePSpell And $iIndex <= $eSkSpell Then Return True
Return False
EndFunc
Func IsSpellToBrew($sName)
Local $iIndex = TroopIndexLookup($sName, "IsSpellToBrew")
If $iIndex >= $eLSpell And $iIndex <= $eSkSpell Then Return True
Return False
EndFunc
Func CalcNeededSpace($Troop, $Quantity)
If Not $g_bRunState Then Return -1
Local $iIndex = TroopIndexLookup($Troop, "CalcNeededSpace")
If $iIndex = -1 Then Return -1
If $iIndex >= $eBarb And $iIndex <= $eBowl Then
Return Number($g_aiTroopSpace[$iIndex] * $Quantity)
EndIf
If $iIndex >= $eLSpell And $iIndex <= $eSkSpell Then
Return Number($g_aiSpellSpace[$iIndex - $eLSpell] * $Quantity)
EndIf
Return -1
EndFunc
Func RemoveExtraTroops($toRemove)
Local $CounterToRemove = 0, $iResult = 0
If UBound($toRemove) = 1 And $toRemove[0][0] = "Arch" And $toRemove[0][1] = 0 Then Return 3
If $g_bIsFullArmywithHeroesAndSpells Or $g_bFullArmy Or($g_iCommandStop = 3 Or $g_iCommandStop = 0) = True And Not $g_iActiveDonate Then Return 3
If UBound($toRemove) > 0 Then
Local $rGetSlotNumber = GetSlotNumber()
Local $rGetSlotNumberSpells = GetSlotNumber(True)
If Not IsQueueEmpty("Troops") Then
If Not OpenTroopsTab(True, "RemoveExtraTroops()") Then Return
For $i = 0 To(UBound($toRemove) - 1)
If Not $g_bRunState Then Return
If IsSpellToBrew($toRemove[$i][0]) Then ExitLoop
$CounterToRemove += 1
If IsAlreadyTraining($toRemove[$i][0]) Then
SetLog($g_asTroopNames[TroopIndexLookup($toRemove[$i][0])] & " Is in Train Tab Queue By Mistake!", $COLOR_INFO)
DeleteQueued("Troops")
$iResult = 2
EndIf
Next
EndIf
If Not IsQueueEmpty("Spells") Then
If TotalSpellsToBrewInGUI() > 0 Then
If Not OpenSpellsTab(True, "RemoveExtraTroops()") Then Return
For $i = $CounterToRemove To(UBound($toRemove) - 1)
If Not $g_bRunState Then Return
If IsAlreadyTraining($toRemove[$i][0], True) Then
SetLog($g_asSpellNames[TroopIndexLookup($toRemove[$i][0]) - $eLSpell] & " Is in Spells Tab Queue By Mistake!", $COLOR_INFO)
DeleteQueued("Spells")
$iResult = 2
EndIf
Next
EndIf
EndIf
If Not OpenArmyTab(True, "RemoveExtraTroops()") Then Return
$toRemove = WhatToTrain(True, False)
$rGetSlotNumber = GetSlotNumber()
$rGetSlotNumberSpells = GetSlotNumber(True)
SetLog("Troops To Remove: ", $COLOR_INFO)
$CounterToRemove = 0
For $i = 0 To(UBound($toRemove) - 1)
If IsSpellToBrew($toRemove[$i][0]) Then ExitLoop
$CounterToRemove += 1
SetLog(" - " & $g_asTroopNames[TroopIndexLookup($toRemove[$i][0])] & ": " & $toRemove[$i][1] & "x", $COLOR_SUCCESS)
Next
If TotalSpellsToBrewInGUI() > 0 Then
If $CounterToRemove <= UBound($toRemove) Then
SetLog("Spells To Remove: ", $COLOR_INFO)
For $i = $CounterToRemove To(UBound($toRemove) - 1)
SetLog(" - " & $g_asSpellNames[TroopIndexLookup($toRemove[$i][0]) - $eLSpell] & ": " & $toRemove[$i][1] & "x", $COLOR_SUCCESS)
Next
EndIf
EndIf
If Not _ColorCheck(_GetPixelColor(806, 516, True), Hex(0xCEEF76, 6), 25) Then
SetLog("Cannot find/verify 'Edit Army' Button in Army tab", $COLOR_WARNING)
Return False
EndIf
Click(Random(715, 825, 1), Random(507, 545, 1))
$CounterToRemove = 0
For $j = 0 To(UBound($toRemove) - 1)
If IsSpellToBrew($toRemove[$j][0]) Then ExitLoop
$CounterToRemove += 1
For $i = 0 To(UBound($rGetSlotNumber) - 1)
If $toRemove[$j][0] = $rGetSlotNumber[$i] Then
Local $pos = GetSlotRemoveBtnPosition($i + 1)
ClickRemoveTroop($pos, $toRemove[$j][1], $g_iTrainClickDelay)
EndIf
Next
Next
If TotalSpellsToBrewInGUI() > 0 Then
For $j = $CounterToRemove To(UBound($toRemove) - 1)
For $i = 0 To(UBound($rGetSlotNumberSpells) - 1)
If $toRemove[$j][0] = $rGetSlotNumberSpells[$i] Then
Local $pos = GetSlotRemoveBtnPosition($i + 1, True)
ClickRemoveTroop($pos, $toRemove[$j][1], $g_iTrainClickDelay)
EndIf
Next
Next
EndIf
If _Sleep(150) Then Return
If Not _ColorCheck(_GetPixelColor(806, 567, True), Hex(0xCEEF76, 6), 25) Then
SetLog("Cannot find/verify 'Okay' Button in Army tab", $COLOR_WARNING)
ClickP($aAway, 2, 0, "#0346")
If _Sleep(400) Then OpenArmyOverview(True, "RemoveExtraTroops()")
Return False
EndIf
If _Sleep(700) Then Return
If Not $g_bRunState Then Return
Click(Random(720, 815, 1), Random(558, 589, 1))
If _Sleep(1200) Then Return
If Not _ColorCheck(_GetPixelColor(508, 428, True), Hex(0xFFFFFF, 6), 30) Then
SetLog("Cannot find/verify 'Okay #2' Button in Army tab", $COLOR_WARNING)
ClickP($aAway, 2, 0, "#0346")
Return False
EndIf
Click(Random(445, 585, 1), Random(402, 455, 1))
SetLog("All Extra troops removed", $COLOR_SUCCESS)
If _Sleep(200) Then Return
If $iResult = 0 Then $iResult = 1
Else
SetLog("No extra troop to remove, Great", $COLOR_SUCCESS)
$iResult = 3
EndIf
Return $iResult
EndFunc
Func DeleteInvalidTroopInArray(ByRef $aTroopArray)
Local $iCounter = 0
Switch(UBound($aTroopArray, 2) > 0)
Case True
Local $bIsValid = True, $i2DBound = UBound($aTroopArray, 2)
For $i = 0 To(UBound($aTroopArray) - 1)
If $aTroopArray[$i][0] Then
If TroopIndexLookup($aTroopArray[$i][0], "DeleteInvalidTroopInArray#1") = -1 Or $aTroopArray[$i][0] = "" Then $bIsValid = False
If $bIsValid Then
For $j = 0 To(UBound($aTroopArray, 2) - 1)
$aTroopArray[$iCounter][$j] = $aTroopArray[$i][$j]
Next
$iCounter += 1
EndIf
EndIf
Next
ReDim $aTroopArray[$iCounter][$i2DBound]
Case Else
For $i = 0 To(UBound($aTroopArray) - 1)
If TroopIndexLookup($aTroopArray[$i], "DeleteInvalidTroopInArray#2") = -1 Or $aTroopArray[$i] = "" Then
$aTroopArray[$iCounter] = $aTroopArray[$i]
$iCounter += 1
EndIf
Next
ReDim $aTroopArray[$iCounter]
EndSwitch
EndFunc
Func RemoveExtraTroopsQueue()
If $g_bIsFullArmywithHeroesAndSpells Then Return True
Local Const $y = 259, $yRemoveBtn = 200, $xDecreaseRemoveBtn = 10
Local $bColorCheck = False, $bGotRemoved = False
For $x = 834 To 58 Step -70
If Not $g_bRunState Then Return
$bColorCheck = _ColorCheck(_GetPixelColor($x, $y, True), Hex(0xD7AFA9, 6), 20)
If $bColorCheck Then
$bGotRemoved = True
Do
Click($x - $xDecreaseRemoveBtn, $yRemoveBtn, 2, $g_iTrainClickDelay)
If _Sleep(20) Then Return
$bColorCheck = _ColorCheck(_GetPixelColor($x, $y, True), Hex(0xD7AFA9, 6), 20)
Until $bColorCheck = False
ElseIf Not $bColorCheck And $bGotRemoved Then
ExitLoop
EndIf
Next
Return True
EndFunc
Func IsAlreadyTraining($Troop, $bSpells = False)
If Not $g_bRunState Then Return
If $bSpells Then
If IsQueueEmpty("Troops") Then Return False
Local $QueueTroops = CheckQueueTroops(False, False)
For $i = 0 To(UBound($QueueTroops) - 1)
If $QueueTroops[$i] = $Troop Then Return True
Next
Else
If IsQueueEmpty("Spells", False, $g_bForceBrewSpells = True ? False : True) Then Return False
Local $QueueSpells = CheckQueueSpells(False, False)
For $i = 0 To(UBound($QueueSpells) - 1)
If $QueueSpells[$i] = $Troop Then Return True
Next
EndIf
Return False
EndFunc
Func IsQueueEmpty($sType = "Troops", $bSkipTabCheck = False, $removeExtraTroopsQueue = True)
Local $iArrowX, $iArrowY
If Not $g_bRunState Then Return
If $sType = "Troops" Then
$iArrowX = $aGreenArrowTrainTroops[0]
$iArrowY = $aGreenArrowTrainTroops[1]
ElseIf $sType = "Spells" Then
$iArrowX = $aGreenArrowBrewSpells[0]
$iArrowY = $aGreenArrowBrewSpells[1]
EndIf
If Not _ColorCheck(_GetPixelColor($iArrowX, $iArrowY, True), Hex(0xa0d077, 6), 30) And Not _ColorCheck(_GetPixelColor($iArrowX, $iArrowY + 4, True), Hex(0x6ab320, 6), 30) Then
Return True
ElseIf _ColorCheck(_GetPixelColor($iArrowX, $iArrowY, True), Hex(0xa0d077, 6), 30) And _ColorCheck(_GetPixelColor($iArrowX, $iArrowY + 4, True), Hex(0x6ab320, 6), 30) And Not $removeExtraTroopsQueue Then
Return False
EndIf
If Not $bSkipTabCheck Then
If $sType = "Troops" Then
If Not OpenTroopsTab(True, "IsQueueEmpty()") Then Return
Else
If Not OpenSpellsTab(True, "IsQueueEmpty()") Then Return
EndIf
EndIf
If Not $g_bIsFullArmywithHeroesAndSpells Then
If $removeExtraTroopsQueue Then
If Not _ColorCheck(_GetPixelColor(230, 208, True), Hex(0x677CB5, 6), 30) Then RemoveExtraTroopsQueue()
EndIf
EndIf
If _ColorCheck(_GetPixelColor(230, 208, True), Hex(0x677CB5, 6), 20) Then Return True
Return False
EndFunc
Func ClickRemoveTroop($pos, $iTimes, $iSpeed)
$pos[0] = Random($pos[0] - 3, $pos[0] + 10, 1)
$pos[1] = Random($pos[1] - 5, $pos[1] + 5, 1)
If Not $g_bRunState Then Return
If _Sleep(400) Then Return
If $iTimes <> 1 Then
If FastCaptureRegion() Then
For $i = 0 To($iTimes - 1)
PureClick($pos[0], $pos[1], 1, $iSpeed)
If _Sleep($iSpeed, False) Then ExitLoop
Next
Else
PureClick($pos[0], $pos[1], $iTimes, $iSpeed)
If _Sleep($iSpeed, False) Then Return
EndIf
Else
PureClick($pos[0], $pos[1], 1, $iSpeed)
If _Sleep($iSpeed, False) Then Return
EndIf
EndFunc
Func GetSlotRemoveBtnPosition($iSlot, $bSpells = False)
Local $iRemoveY = Not $bSpells ? 270 : 417
Local $iRemoveX = Number((74 * $iSlot) - 4)
Local Const $aResult[2] = [$iRemoveX, $iRemoveY]
Return $aResult
EndFunc
Func GetSlotNumber($bSpells = False)
Select
Case $bSpells = False
Local Const $Orders[20] = [$eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine, $eEDrag, $eMini, $eHogs, $eValk, $eGole, $eWitc, $eLava, $eBowl]
Local $allCurTroops[UBound($Orders)]
For $i = 0 To $eTroopCount - 1
If Not $g_bRunState Then Return
If $g_aiCurrentTroops[$i] > 0 Then
For $j = 0 To(UBound($Orders) - 1)
If TroopIndexLookup($g_asTroopShortNames[$i], "GetSlotNumber#1") = $Orders[$j] Then
$allCurTroops[$j] = $g_asTroopShortNames[$i]
EndIf
Next
EndIf
Next
_ArryRemoveBlanks($allCurTroops)
Return $allCurTroops
Case $bSpells = True
Local Const $SpellsOrders[10] = [$eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Local $allCurSpells[UBound($SpellsOrders)]
For $i = 0 To $eSpellCount - 1
If Not $g_bRunState Then Return
If $g_aiCurrentSpells[$i] > 0 Then
For $j = 0 To(UBound($SpellsOrders) - 1)
If TroopIndexLookup($g_asSpellShortNames[$i], "GetSlotNumber#2") = $SpellsOrders[$j] Then
$allCurSpells[$j] = $g_asSpellShortNames[$i]
EndIf
Next
EndIf
Next
_ArryRemoveBlanks($allCurSpells)
Return $allCurSpells
EndSelect
EndFunc
Func WhatToTrain($ReturnExtraTroopsOnly = False, $bSetLog = True)
OpenArmyTab(True, "WhatToTrain()")
Local $ToReturn[1][2] = [["Arch", 0]]
If $g_bIsFullArmywithHeroesAndSpells And Not $ReturnExtraTroopsOnly Then
If $g_iCommandStop = 3 Or $g_iCommandStop = 0 Then
If $g_bFirstStart Then $g_bFirstStart = False
Return $ToReturn
EndIf
SetLog(" - Your Army is Full, let's make troops before Attack!", $COLOR_INFO)
For $i = 0 To $eTroopCount - 1
Local $troopIndex = $g_aiTrainOrder[$i]
If $g_aiArmyCompTroops[$troopIndex] > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asTroopShortNames[$troopIndex]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompTroops[$troopIndex]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
Next
For $i = 0 To $eSpellCount - 1
Local $BrewIndex = $g_aiBrewOrder[$i]
If TotalSpellsToBrewInGUI() = 0 Then ExitLoop
If $g_aiArmyCompSpells[$BrewIndex] > 0 Then
If HowManyTimesWillBeUsed($g_asSpellShortNames[$BrewIndex]) > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$BrewIndex]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompSpells[$BrewIndex]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
Else
getArmySpells(False, False, False, False)
If $g_aiArmyCompSpells[$BrewIndex] - $g_aiCurrentSpells[$BrewIndex] > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$BrewIndex]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompSpells[$BrewIndex] - $g_aiCurrentSpells[$BrewIndex]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
Else
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$BrewIndex]
$ToReturn[UBound($ToReturn) - 1][1] = 9999
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
EndIf
EndIf
Next
Return $ToReturn
EndIf
getArmyTroops(False, False, False, False)
getArmySpells(False, False, False, False)
Switch $ReturnExtraTroopsOnly
Case False
For $ii = 0 To $eTroopCount - 1
Local $troopIndex = $g_aiTrainOrder[$ii]
If $g_aiArmyCompTroops[$troopIndex] > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asTroopShortNames[$troopIndex]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompTroops[$troopIndex] - $g_aiCurrentTroops[$troopIndex]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
Next
For $i = 0 To $eSpellCount - 1
Local $BrewIndex = $g_aiBrewOrder[$i]
If TotalSpellsToBrewInGUI() = 0 Then ExitLoop
If $g_aiArmyCompSpells[$BrewIndex] > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$BrewIndex]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompSpells[$BrewIndex] - $g_aiCurrentSpells[$BrewIndex]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
Next
Case Else
For $ii = 0 To $eTroopCount - 1
Local $troopIndex = $g_aiTrainOrder[$ii]
If $g_aiCurrentTroops[$troopIndex] > 0 Then
If $g_aiArmyCompTroops[$troopIndex] - $g_aiCurrentTroops[$troopIndex] < 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asTroopShortNames[$troopIndex]
$ToReturn[UBound($ToReturn) - 1][1] = Abs($g_aiArmyCompTroops[$troopIndex] - $g_aiCurrentTroops[$troopIndex])
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
EndIf
Next
For $i = 0 To $eSpellCount - 1
Local $BrewIndex = $g_aiBrewOrder[$i]
If TotalSpellsToBrewInGUI() = 0 Then ExitLoop
If $g_aiCurrentSpells[$BrewIndex] > 0 Then
If $g_aiArmyCompSpells[$BrewIndex] - $g_aiCurrentSpells[$BrewIndex] < 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$BrewIndex]
$ToReturn[UBound($ToReturn) - 1][1] = Abs($g_aiArmyCompSpells[$BrewIndex] - $g_aiCurrentSpells[$BrewIndex])
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
EndIf
Next
EndSwitch
DeleteInvalidTroopInArray($ToReturn)
Return $ToReturn
EndFunc
Func TestTroopsCoords()
Local $iCount = 3
$g_bRunState = True
For $i = 0 To $eTroopCount - 1
DragIfNeeded($g_asTroopShortNames[$i])
TrainIt(TroopIndexLookup($g_asTroopShortNames[$i], "TestTroopsCoords"), $iCount, $g_iTrainClickDelay)
Next
$g_bRunState = False
EndFunc
Func TestSpellsCoords()
Local $iCount = 1
$g_bRunState = True
For $i = 0 To $eSpellCount - 1
TrainIt(TroopIndexLookup($g_asTroopShortNames[$i]), $iCount, $g_iTrainClickDelay)
Next
$g_bRunState = False
EndFunc
Func LeftSpace($bReturnAll = False)
Local $aRemainTrainSpace = GetOCRCurrent(48, 160)
If Not $g_bRunState Then Return
If Not $bReturnAll Then
Return Number($aRemainTrainSpace[2])
Else
Return $aRemainTrainSpace
EndIf
EndFunc
Func IsArmyWindow($bSetLog = False, $iTabNumber = 0)
Local $i = 0
Local $_TabNumber[4][4] = [[114, 115, 0xF8F8F8, 5], [284, 115, 0xF8F8F8, 5], [505, 115, 0xF8F8F8, 5], [702, 115, 0xF8F8F8, 5]]
Local $CheckIT[4] = [$_TabNumber[$iTabNumber][0], $_TabNumber[$iTabNumber][1], $_TabNumber[$iTabNumber][2], $_TabNumber[$iTabNumber][3]]
Local $txt = ""
Switch $iTabNumber
Case $ArmyTAB
$txt = "Army Window"
Case $TrainTroopsTAB
$txt = "Train Troops Window"
Case $BrewSpellsTAB
$txt = "Brew Spells Window"
Case $QuickTrainTAB
$txt = "Quick Train Window"
EndSwitch
If _CheckPixel($aIsTrainPgChk1, True) Then
While $i < 1
If Not $g_bRunState Then Return
If $g_bDebugSetlogTrain Then SetLog("$CheckIT[0]: " & $CheckIT[0])
If $g_bDebugSetlogTrain Then SetLog("$CheckIT[1]: " & $CheckIT[1])
If $g_bDebugSetlogTrain Then SetLog("$CheckIT[2]: " & Hex($CheckIT[2], 6))
If $g_bDebugSetlogTrain Then SetLog("$CheckIT[3]: " & $CheckIT[3])
If _ColorCheck(_GetPixelColor($CheckIT[0], $CheckIT[1], True), Hex($CheckIT[2], 6), $CheckIT[3]) Then ExitLoop
If _Sleep($DELAYISTRAINPAGE2) Then ExitLoop
$i += 1
WEnd
Else
$i = 1
If $bSetLog Or $g_bDebugSetlogTrain Then SetLog("Cannot find Red X | TAB " & $txt, $COLOR_ERROR)
EndIf
If $i < 1 Then
If($g_bDebugSetlog Or $g_bDebugClick) Or $bSetLog Or $g_bDebugSetlogTrain Then SetLog("**" & $txt & " OK**", $COLOR_DEBUG)
Return True
Else
If $bSetLog Or $g_bDebugSetlogTrain Then SetLog("You are not in " & $txt & " | TAB " & $iTabNumber, $COLOR_ERROR)
If $g_bDebugImageSave Then DebugImageSave("IsTrainPage")
Return False
EndIf
EndFunc
Func CheckQueueTroops($bGetQuantity = True, $bSetLog = True)
Local $aResult[1] = [""]
If $bSetLog Then SetLog("Checking Troops Queue...", $COLOR_INFO)
Local $aSearchResult = SearchArmy("trainwindow-TrainTroops-bundle", 18, 182, 839, 261)
ReDim $aResult[UBound($aSearchResult)]
For $i = 0 To(UBound($aSearchResult) - 1)
If Not $g_bRunState Then Return
$aResult[$i] = $aSearchResult[$i][0]
Next
_ArrayReverse($aResult)
If $bGetQuantity Then
Local $aQuantities = GetQueueQuantity($aResult)
For $i = 0 To(UBound($aQuantities) - 1)
If $bSetLog Then SetLog("  - " & $g_asTroopNames[TroopIndexLookup($aQuantities[$i][0], "CheckQueueTroops")] & ": " & $aQuantities[$i][1] & "x", $COLOR_SUCCESS)
Next
Return $aQuantities
EndIf
Return $aResult
EndFunc
Func CheckQueueSpells($bGetQuantity = True, $bSetLog = True)
Local $aResult[1] = [""], $sImageDir = "trainwindow-SpellsInQueue-bundle"
If $bSetLog Then SetLog("Checking Spells Queue...", $COLOR_INFO)
Local $aSearchResult = SearchArmy($sImageDir, 18, 182, 839, 261)
ReDim $aResult[UBound($aSearchResult)]
For $i = 0 To(UBound($aSearchResult) - 1)
If Not $g_bRunState Then Return
$aResult[$i] = $aSearchResult[$i][0]
Next
_ArrayReverse($aResult)
If $bGetQuantity Then
Local $aQuantities = GetQueueQuantity($aResult)
For $i = 0 To(UBound($aQuantities) - 1)
If Not $g_bRunState Then Return
If $bSetLog Then SetLog("  - " & $g_asSpellNames[TroopIndexLookup($aQuantities[$i][0], "CheckQueueSpells") - $eLSpell] & ": " & $aQuantities[$i][1] & "x", $COLOR_SUCCESS)
Next
Return $aQuantities
EndIf
Return $aResult
EndFunc
Func GetQueueQuantity($aAvailableTroops)
If IsArray($aAvailableTroops) Then
If $aAvailableTroops[0] = "" Or StringLen($aAvailableTroops[0]) = 0 Then _ArrayDelete($aAvailableTroops, 0)
If $aAvailableTroops[UBound($aAvailableTroops) - 1] = "" Or StringLen($aAvailableTroops[UBound($aAvailableTroops) - 1]) = 0 Then _ArrayDelete($aAvailableTroops, Number(UBound($aAvailableTroops) - 1))
Local $aResult[UBound($aAvailableTroops)][2] = [["", 0]]
Local $x = 770, $y = 189
_CaptureRegion2()
For $i = 0 To(UBound($aAvailableTroops) - 1)
If Not $g_bRunState Then Return
Local $iOCRResult = getQueueTroopsQuantity($x, $y)
$aResult[$i][0] = $aAvailableTroops[$i]
$aResult[$i][1] = $iOCRResult
$x -= 70
Next
Return $aResult
EndIf
Return False
EndFunc
Func SearchArmy($sImageDir = "", $x = 0, $y = 0, $x1 = 0, $y1 = 0, $sArmyType = "", $bSkipReceivedTroopsCheck = False)
Local $aResult[1][4], $aCoordArray[1][2], $aCoords, $aCoordsSplit, $aValue
For $iCount = 0 To 10
If Not $g_bRunState Then Return $aResult
If Not getReceivedTroops(162, 200, $bSkipReceivedTroopsCheck) Then
_CaptureRegion2($x, $y, $x1, $y1)
Local $res = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $sImageDir, "str", "FV", "Int", 0, "str", "FV", "Int", 0, "Int", 1000)
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys)][4]
For $i = 0 To UBound($aKeys) - 1
$aResult[$i][0] = RetrieveImglocProperty($aKeys[$i], "objectname")
$aValue = RetrieveImglocProperty($aKeys[$i], "objectpoints")
$aCoords = StringSplit($aValue, "|", $STR_NOCOUNT)
$aCoordsSplit = StringSplit($aCoords[0], ",", $STR_NOCOUNT)
If UBound($aCoordsSplit) = 2 Then
$aCoordArray[0][0] = $aCoordsSplit[0] + $x
$aCoordArray[0][1] = $aCoordsSplit[1]
Else
$aCoordArray[0][0] = -1
$aCoordArray[0][1] = -1
EndIf
$aResult[$i][1] = Number($aCoordArray[0][0])
$aResult[$i][2] = Number($aCoordArray[0][1])
Next
EndIf
ExitLoop
Else
If $iCount = 1 Then SetLog("You have received castle troops! Wait 5's...")
If _Sleep($DELAYTRAIN8) Then Return $aResult
EndIf
Next
_ArraySort($aResult, 0, 0, 0, 1)
If $sArmyType = "Troops" Then
For $i = 0 To UBound($aResult) - 1
$aResult[$i][3] = Number(getBarracksNewTroopQuantity(Slot($aResult[$i][1], "troop"), 196))
Next
EndIf
If $sArmyType = "Spells" Then
For $i = 0 To UBound($aResult) - 1
$aResult[$i][3] = Number(getBarracksNewTroopQuantity(Slot($aResult[$i][1], "spells"), 341))
Next
EndIf
If $sArmyType = "CCSpells" Then
For $i = 0 To UBound($aResult) - 1
$aResult[$i][3] = Number(getBarracksNewTroopQuantity(Slot($aResult[$i][1], "troop"), 498))
Next
EndIf
If $sArmyType = "Heroes" Then
For $i = 0 To UBound($aResult) - 1
If StringInStr($aResult[$i][0], "Kingqueued") Then
$aResult[$i][3] = getRemainTHero(620, 414)
ElseIf StringInStr($aResult[$i][0], "Queenqueued") Then
$aResult[$i][3] = getRemainTHero(695, 414)
ElseIf StringInStr($aResult[$i][0], "Wardenqueued") Then
$aResult[$i][3] = getRemainTHero(775, 414)
Else
$aResult[$i][3] = 0
EndIf
Next
EndIf
Return $aResult
EndFunc
Func ResetVariables($sArmyType = "")
If $sArmyType = "troops" Or $sArmyType = "all" Then
For $i = 0 To $eTroopCount - 1
If Not $g_bRunState Then Return
$g_aiCurrentTroops[$i] = 0
If _Sleep($DELAYTRAIN6) Then Return
Next
EndIf
If $sArmyType = "Spells" Or $sArmyType = "all" Then
For $i = 0 To $eSpellCount - 1
If Not $g_bRunState Then Return
$g_aiCurrentSpells[$i] = 0
If _Sleep($DELAYTRAIN6) Then Return
Next
EndIf
If $sArmyType = "donated" Or $sArmyType = "all" Then
For $i = 0 To $eTroopCount - 1
If Not $g_bRunState Then Return
$g_aiDonateTroops[$i] = 0
If _Sleep($DELAYTRAIN6) Then Return
Next
For $i = 0 To $eSpellCount - 1
If Not $g_bRunState Then Return
$g_aiDonateSpells[$i] = 0
If _Sleep($DELAYTRAIN6) Then Return
Next
EndIf
EndFunc
Func TrainArmyNumber($Army)
Local $a_TrainArmy[3][4] = [[784, 368, 0x6fb830, 10], [784, 485, 0x72bb2f, 10], [784, 602, 0x71ba2f, 10]]
SetLog("Using Quick Train Tab", $COLOR_INFO)
If Not $g_bRunState Then Return
For $Num = 0 To 2
If $Army[$Num] Then
If _ColorCheck(_GetPixelColor($a_TrainArmy[$Num][0], $a_TrainArmy[$Num][1], True), Hex($a_TrainArmy[$Num][2], 6), $a_TrainArmy[$Num][3]) Then
Click($a_TrainArmy[$Num][0], $a_TrainArmy[$Num][1], 1)
SetLog(" - Making the Army " & $Num + 1, $COLOR_INFO)
If _Sleep(500) Then Return
Else
SetLog(" - Error Clicking On Army: " & $Num + 1 & "| Pixel was :" & _GetPixelColor($a_TrainArmy[$Num][0], $a_TrainArmy[$Num][1], True), $COLOR_ACTION)
SetLog(" - Please 'edit' the Army " & $Num + 1 & " before start the BOT!!!", $COLOR_ERROR)
EndIf
EndIf
Next
EndFunc
Func DeleteQueued($sArmyTypeQueued, $iOffsetQueued = 802)
If $sArmyTypeQueued = "Troops" Then
If Not OpenTroopsTab(True, "DeleteQueued()") Then Return
ElseIf $sArmyTypeQueued = "Spells" Then
If Not OpenSpellsTab(True, "DeleteQueued()") Then Return
Else
Return
EndIf
If _Sleep(500) Then Return
Local $x = 0
While Not IsQueueEmpty($sArmyTypeQueued, True, False)
If $x = 0 Then SetLog(" - Delete " & $sArmyTypeQueued & " Queued!", $COLOR_INFO)
If _Sleep(20) Then Return
If Not $g_bRunState Then Return
Click($iOffsetQueued + 24, 202, 2, 50)
$x += 1
If $x = 270 Then ExitLoop
WEnd
EndFunc
Func MakingDonatedTroops()
Local $avDefaultTroopGroup[19][6] = [ ["Arch", 1, 1, 25, 0, "e"], ["Giant", 2, 5, 120, 0, "e"], ["Wall", 4, 2, 60, 0, "e"], ["Barb", 0, 1, 20, 0, "e"], ["Gobl", 3, 1, 30, 0, "e"], ["Heal", 7, 14, 600, 0, "e"], ["Pekk", 9, 25, 900, 0, "e"], ["Ball", 5, 5, 300, 0, "e"], ["Wiza", 6, 4, 300, 0, "e"], ["Drag", 8, 20, 900, 0, "e"], ["BabyD", 10, 10, 600, 0, "e"], ["Mine", 11, 6, 300, 0, "e"], ["Mini", 0, 2, 45, 0, "d"], ["Hogs", 1, 5, 120, 0, "d"], ["Valk", 2, 8, 300, 0, "d"], ["Gole", 3, 30, 900, 0, "d"], ["Witc", 4, 12, 600, 0, "d"], ["Lava", 5, 30, 900, 0, "d"], ["Bowl", 6, 6, 300, 0, "d"]]
Local $RemainTrainSpace
Local $Plural = 0
Local $areThereDonTroop = 0
Local $areThereDonSpell = 0
For $j = 0 To $eTroopCount - 1
If Not $g_bRunState Then Return
$areThereDonTroop += $g_aiDonateTroops[$j]
Next
For $j = 0 To $eSpellCount - 1
If Not $g_bRunState Then Return
$areThereDonSpell += $g_aiDonateSpells[$j]
Next
If $areThereDonSpell = 0 And $areThereDonTroop = 0 Then Return
SetLog("  making donated troops", $COLOR_ACTION1)
If $areThereDonTroop > 0 Then
For $i = 0 To UBound($avDefaultTroopGroup) - 1
For $j = 0 To $eTroopCount - 1
If $g_asTroopShortNames[$j] = $avDefaultTroopGroup[$i][0] Then
$avDefaultTroopGroup[$i][4] = $g_aiDonateTroops[$j]
$g_aiDonateTroops[$j] = 0
EndIf
Next
Next
If Not OpenTroopsTab(True, "MakingDonatedTroops()") Then Return
For $i = 0 To UBound($avDefaultTroopGroup, 1) - 1
If Not $g_bRunState Then Return
$Plural = 0
If $avDefaultTroopGroup[$i][4] > 0 Then
$RemainTrainSpace = GetOCRCurrent(48, 160)
If $RemainTrainSpace[0] = $RemainTrainSpace[1] Then
For $j = 0 To UBound($avDefaultTroopGroup, 1) - 1
$avDefaultTroopGroup[$j][4] = 0
Next
ExitLoop
EndIf
Local $iTroopIndex = TroopIndexLookup($avDefaultTroopGroup[$i][0], "MakingDonatedTroops")
If $avDefaultTroopGroup[$i][2] * $avDefaultTroopGroup[$i][4] <= $RemainTrainSpace[2] Then
Local $howMuch = $avDefaultTroopGroup[$i][4]
If $avDefaultTroopGroup[$i][5] = "e" Then
TrainIt($iTroopIndex, $howMuch, $g_iTrainClickDelay)
Else
ClickDrag(715, 445 + $g_iMidOffsetY, 220, 445 + $g_iMidOffsetY, 2000)
TrainIt($iTroopIndex, $howMuch, $g_iTrainClickDelay)
ClickDrag(220, 445 + $g_iMidOffsetY, 725, 445 + $g_iMidOffsetY, 2000)
EndIf
If _Sleep($DELAYRESPOND) Then Return
Local $sTroopName =($avDefaultTroopGroup[$i][4] > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
SetLog(" - Trained " & $avDefaultTroopGroup[$i][4] & " " & $sTroopName, $COLOR_ACTION)
$avDefaultTroopGroup[$i][4] = 0
If _Sleep(1000) Then Return
Else
For $z = 0 To $RemainTrainSpace[2] - 1
$RemainTrainSpace = GetOCRCurrent(48, 160)
If $RemainTrainSpace[0] = $RemainTrainSpace[1] Then
For $j = 0 To UBound($avDefaultTroopGroup, 1) - 1
$avDefaultTroopGroup[$j][4] = 0
Next
ExitLoop(2)
EndIf
If $avDefaultTroopGroup[$i][2] <= $RemainTrainSpace[2] And $avDefaultTroopGroup[$i][4] > 0 Then
Local $howMuch = 1
If $iTroopIndex >= $eBarb And $iTroopIndex <= $eMine Then
TrainIt($iTroopIndex, $howMuch, $g_iTrainClickDelay)
Else
ClickDrag(715, 445 + $g_iMidOffsetY, 220, 445 + $g_iMidOffsetY, 2000)
TrainIt($iTroopIndex, $howMuch, $g_iTrainClickDelay)
ClickDrag(220, 445 + $g_iMidOffsetY, 725, 445 + $g_iMidOffsetY, 2000)
EndIf
If _Sleep($DELAYRESPOND) Then Return
Local $sTroopName =($avDefaultTroopGroup[$i][4] > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
SetLog(" - Trained " & $avDefaultTroopGroup[$i][4] & " " & $sTroopName, $COLOR_ACTION)
$avDefaultTroopGroup[$i][4] -= 1
If _Sleep(1000) Then Return
Else
ExitLoop
EndIf
Next
EndIf
EndIf
Next
$RemainTrainSpace = GetOCRCurrent(48, 160)
If $RemainTrainSpace[0] < $RemainTrainSpace[1] Then
Local $howMuch = $RemainTrainSpace[2]
TrainIt($eTroopArcher, $howMuch, $g_iTrainClickDelay)
If $RemainTrainSpace[2] > 0 Then $Plural = 1
SetLog(" - Trained " & $howMuch & " archer(s)!", $COLOR_ACTION)
If _Sleep(1000) Then Return
EndIf
For $j = 0 To UBound($avDefaultTroopGroup, 1) - 1
$avDefaultTroopGroup[$j][4] = 0
Next
EndIf
If $areThereDonSpell > 0 Then
If Not OpenSpellsTab(True, "MakingDonatedTroops()") Then Return
For $i = 0 To $eSpellCount - 1
If Not $g_bRunState Then Return
If $g_aiDonateSpells[$i] > 0 Then
Local $pos = GetTrainPos($i + $eLSpell)
Local $howMuch = $g_aiDonateSpells[$i]
TrainIt($eLSpell + $i, $howMuch, $g_iTrainClickDelay)
If _Sleep($DELAYRESPOND) Then Return
SetLog(" - Brewed " & $howMuch & " " & $g_asSpellNames[$i] &($howMuch > 1 ? " Spells" : " Spell"), $COLOR_ACTION)
$g_aiDonateTroops[$i] -= $howMuch
EndIf
Next
EndIf
If _Sleep(1000) Then Return
$RemainTrainSpace = GetOCRCurrent(48, 160)
SetLog(" - Current Capacity: " & $RemainTrainSpace[0] & "/" &($RemainTrainSpace[1]))
EndFunc
Func GetOCRCurrent($x_start, $y_start)
Local $aResult[3] = [0, 0, 0]
If Not $g_bRunState Then Return $aResult
Local $iOCRResult = getArmyCapacityOnTrainTroops($x_start, $y_start)
If StringInStr($iOCRResult, "#") Then
Local $aTempResult = StringSplit($iOCRResult, "#", $STR_NOCOUNT)
$aResult[0] = Number($aTempResult[0])
$aResult[1] = Number($aTempResult[1])
If $aResult[1] <= 22 Then
If $g_bDebugSetlogTrain Then SetLog("$g_iTotalSpellValue: " & $g_iTotalSpellValue, $COLOR_DEBUG)
$aResult[1] = $g_iTotalSpellValue
$aResult[2] = $g_iTotalSpellValue - $aResult[0]
ElseIf $aResult[1] <> $g_iTotalCampSpace Then
If $g_bDebugSetlogTrain Then SetLog("$g_iTotalCampSpace: " & $g_iTotalCampSpace, $COLOR_DEBUG)
$aResult[1] = $g_iTotalCampSpace
$aResult[2] = $g_iTotalCampSpace - $aResult[0]
EndIf
$aResult[2] = $aResult[1] - $aResult[0]
Else
SetLog("DEBUG | ERROR on GetOCRCurrent", $COLOR_ERROR)
EndIf
Return $aResult
EndFunc
Func CheckIsFullQueuedAndNotFullArmy()
SetLog(" - Checking: FULL Queue and Not Full Army", $COLOR_INFO)
Local $CheckTroop[4] = [824, 243, 0x949522, 20]
If Not $g_bRunState Then Return
If Not OpenTroopsTab(True, "CheckIsFullQueuedAndNotFullArmy()") Then Return
Local $aArmyCamp = GetOCRCurrent(48, 160)
If UBound($aArmyCamp) = 3 And $aArmyCamp[2] < 0 Then
If _ColorCheck(_GetPixelColor($CheckTroop[0], $CheckTroop[1], True), Hex($CheckTroop[2], 6), $CheckTroop[3]) Then
SetLog(" - Conditions met: FULL Queue and Not Full Army")
DeleteQueued("Troops")
If _Sleep(500) Then Return
$aArmyCamp = GetOCRCurrent(48, 160)
Local $ArchToMake = $aArmyCamp[2]
If IsArmyWindow(False, $TrainTroopsTAB) Then TrainIt($eArch, $ArchToMake, $g_iTrainClickDelay)
SetLog("Trained " & $ArchToMake & " archer(s)!")
Else
SetLog(" - Conditions NOT met: FULL queue and Not Full Army")
EndIf
EndIf
EndFunc
Func CheckIsEmptyQueuedAndNotFullArmy()
SetLog(" - Checking: Empty Queue and Not Full Army", $COLOR_ACTION1)
Local $CheckTroop[4] = [825, 204, 0xCFCFC8, 15]
Local $CheckTroop1[4] = [390, 130, 0x78BE2B, 15]
If Not $g_bRunState Then Return
If Not OpenTroopsTab(True, "CheckIsEmptyQueuedAndNotFullArmy()") Then Return
Local $aArmyCamp = GetOCRCurrent(48, 160)
If UBound($aArmyCamp) = 3 And $aArmyCamp[2] > 0 Then
If _ColorCheck(_GetPixelColor($CheckTroop[0], $CheckTroop[1], True), Hex($CheckTroop[2], 6), $CheckTroop[3]) Then
If Not _ColorCheck(_GetPixelColor($CheckTroop1[0], $CheckTroop1[1], True), Hex($CheckTroop1[2], 6), $CheckTroop1[3]) Then
SetLog(" - Conditions met: Empty Queue and Not Full Army")
If _Sleep(500) Then Return
$aArmyCamp = GetOCRCurrent(48, 160)
Local $ArchToMake = $aArmyCamp[2]
If IsArmyWindow(False, $TrainTroopsTAB) Then TrainIt($eArch, $ArchToMake, $g_iTrainClickDelay)
SetLog(" - Trained " & $ArchToMake & " archer(s)!")
Else
SetLog(" - Conditions NOT met: Empty queue and Not Full Army")
EndIf
EndIf
EndIf
EndFunc
Func getReceivedTroops($x_start, $y_start, $bSkipCheck = False)
If $bSkipCheck Or Not $g_bRunState Then Return False
Local $iOCRResult = ""
$iOCRResult = getOcrAndCapture("coc-DonTroops", $x_start, $y_start, 120, 27, True)
If IsString($iOCRResult) <> "" Or IsString($iOCRResult) <> " " Then
If StringInStr($iOCRResult, "you") Then
Return True
Else
Return False
EndIf
Else
Return False
EndIf
EndFunc
Func TestTrainRevamp2()
$g_bRunState = True
$g_bDebugOcr = True
SetLog("Start......OpenArmy Window.....")
Local $timer = __TimerInit()
getArmyTroops(False, False, False, False)
SetLog("Imgloc Troops Time: " & Round(__TimerDiff($timer) / 1000, 2) & "'s")
SetLog("End......OpenArmy Window.....")
$g_bDebugOcr = False
$g_bRunState = False
EndFunc
Func IIf($Condition, $IfTrue, $IfFalse)
If $Condition = True Then
Return $IfTrue
Else
Return $IfFalse
EndIf
EndFunc
Func _ArryRemoveBlanks(ByRef $aArray)
Local $iCounter = 0
For $i = 0 To UBound($aArray) - 1
If $aArray[$i] <> "" Then
$aArray[$iCounter] = $aArray[$i]
$iCounter += 1
EndIf
Next
ReDim $aArray[$iCounter]
EndFunc
Func ValidateSearchArmyResult($aSearchResult, $iIndex = 0)
If IsArray($aSearchResult) Then
If UBound($aSearchResult) > 0 Then
If StringLen($aSearchResult[$iIndex][0]) > 0 Then Return True
EndIf
EndIf
Return False
EndFunc
Func CheckValuesCost($Troop = "Arch", $troopQuantity = 1, $DebugLogs = 0)
Local $TempColorToCheck = ""
Local $nElixirCurrent = 0, $nDarkCurrent = 0, $bLocalDebugOCR = 0
If _Sleep(1000) Then Return
If Not $g_bRunState Then Return
If $g_bDebugSetlogTrain Or $DebugLogs Then
$bLocalDebugOCR = $g_bDebugOcr
$g_bDebugOcr = True
$TempColorToCheck = _GetPixelColor(223, 594, True)
SetLog("CheckValuesCost|ColorToCheck: " & $TempColorToCheck)
EndIf
If _ColorCheck(_GetPixelColor(223, 594, True), Hex(0xE8E8E0, 6), 20) Then
$nElixirCurrent = getResourcesValueTrainPage(315, 594)
Else
$nElixirCurrent = getResourcesValueTrainPage(230, 594)
$nDarkCurrent = getResourcesValueTrainPage(382, 594)
EndIf
If $g_bDebugSetlogTrain Or $DebugLogs Then
SetLog("- Current resources:")
SetLog(" - Elixir: " & _NumberFormat($nElixirCurrent) & " / Dark Elixir: " & _NumberFormat($nDarkCurrent), $COLOR_INFO)
$g_bDebugOcr = $bLocalDebugOCR
EndIf
Local $troopCost = 0
Local $iTroopIndex = TroopIndexLookup($Troop, "CheckValuesCost")
If $iTroopIndex >= $eBarb And $iTroopIndex <= $eBowl Then
$troopCost = $g_aiTroopCostPerLevel[$iTroopIndex][$g_aiTrainArmyTroopLevel[$iTroopIndex]]
ElseIf $iTroopIndex >= $eLSpell And $iTroopIndex <= $eSkSpell Then
$troopCost = $g_aiSpellCostPerLevel[$iTroopIndex - $eLSpell][$g_aiTrainArmySpellLevel[$iTroopIndex - $eLSpell]]
EndIf
If $g_bDebugSetlogTrain Or $DebugLogs Then SetLog("Individual Cost " & $Troop & "= " & $troopCost)
$troopCost *= $troopQuantity
If $g_bDebugSetlogTrain Or $DebugLogs Then SetLog("Total Cost " & $Troop & "= " & $troopCost)
If IsDarkTroop($Troop) Then
If $g_bDebugSetlogTrain Or $DebugLogs Then SetLog("Dark Troop " & $Troop & " Is Dark Troop")
If $troopCost <= $nDarkCurrent Then
Return True
EndIf
Return False
ElseIf IsElixirSpell($Troop) Then
If $g_bDebugSetlogTrain Or $DebugLogs Then SetLog("Spell " & $Troop & " Is Elixir Spell")
If $troopCost <= $nElixirCurrent Then
Return True
EndIf
Return False
ElseIf IsDarkSpell($Troop) Then
If $g_bDebugSetlogTrain Or $DebugLogs Then SetLog("Dark Spell " & $Troop & " Is Dark Spell")
If $troopCost <= $nDarkCurrent Then
Return True
EndIf
Return False
Else
If $troopCost <= $nElixirCurrent Then
If $g_bDebugSetlogTrain Or $DebugLogs Then SetLog("Troop " & $Troop & " Is Elixir Troop")
Return True
EndIf
Return False
EndIf
EndFunc
Func ThSnipesSkiptrain()
Local $iTemp = 0
If IsSearchModeActive($TS) And $g_bIsFullArmywithHeroesAndSpells Then
For $i = 0 To $eTroopCount - 1
If $g_aiArmyCompTroops[$i] > 0 Then $iTemp += 1
Next
If $iTemp = 1 Then Return False
If $iTemp > 1 Then
SetLog("Skipping Training before Attack due to THSnipes!", $COLOR_INFO)
Return True
EndIf
Else
Return False
EndIf
EndFunc
Func TrainIt($iIndex, $iQuantity = 1, $iSleep = 400)
If $g_bDebugSetlogTrain Then SetLog("Func TrainIt $iIndex=" & $iIndex & " $howMuch=" & $iQuantity & " $iSleep=" & $iSleep, $COLOR_DEBUG)
Local $bDark =($iIndex >= $eMini And $iIndex <= $eBowl)
Local $iErrors = 0
For $i = 1 To 5
Local $aTrainPos = GetTrainPos($iIndex)
If IsArray($aTrainPos) And $aTrainPos[0] <> -1 Then
If _ColorCheck(_GetPixelColor($aTrainPos[0], $aTrainPos[1], $g_bCapturePixel), Hex($aTrainPos[2], 6), $aTrainPos[3]) Then
Local $FullName = GetFullName($iIndex, $aTrainPos)
If IsArray($FullName) Then
Local $RNDName = GetRNDName($iIndex, $aTrainPos)
If IsArray($RNDName) Then
TrainClickP($aTrainPos, $iQuantity, $g_iTrainClickDelay, $FullName, "#0266", $RNDName)
If _Sleep($iSleep) Then Return
If $g_bOutOfElixir Then
SetLog("Not enough " &($bDark ? "Dark " : "") & "Elixir to train position " & GetTroopName($iIndex) & " troops!", $COLOR_ERROR)
SetLog("Switching to Halt Attack, Stay Online Mode...", $COLOR_ERROR)
If Not $g_bFullArmy Then $g_bRestart = True
Return
EndIf
Return True
Else
SetLog("TrainIt position " & GetTroopName($iIndex) & " - RNDName did not return array?", $COLOR_ERROR)
Return False
EndIf
Else
SetLog("TrainIt " & GetTroopName($iIndex) & " - FullName did not return array?", $COLOR_ERROR)
Return False
EndIf
Else
Local $sBadPixelColor = _GetPixelColor($aTrainPos[0], $aTrainPos[1], $g_bCapturePixel)
If $g_bDebugSetlogTrain Then SetLog("Positon X: " & $aTrainPos[0] & "| Y : " & $aTrainPos[1] & " |Color get: " & $sBadPixelColor & " | Need: " & $aTrainPos[2])
If StringMid($sBadPixelColor, 1, 2) = StringMid($sBadPixelColor, 3, 2) And StringMid($sBadPixelColor, 1, 2) = StringMid($sBadPixelColor, 5, 2) Then
SetLog("Troop " & GetTroopName($iIndex) & " is not available due to full queue", $COLOR_DEBUG)
Else
If $iErrors = 0 Then
Local $aEmptyArray[4] = [-1,-1,-1,-1]
$aTrainArmy[$iIndex] = $aEmptyArray
$iErrors += 1
Else
If $g_bDebugSetlogTrain Then DebugImageSave("BadPixelCheck_" & GetTroopName($iIndex))
SetLog("Bad pixel check on troop position " & GetTroopName($iIndex), $COLOR_ERROR)
If $g_bDebugSetlogTrain Then SetLog("Train Pixel Color: " & $sBadPixelColor, $COLOR_DEBUG)
$iErrors = 0
EndIf
EndIf
EndIf
Else
If UBound($aTrainPos) > 0 And $aTrainPos[0] = -1 Then
If $i < 5 Then
ForceCaptureRegion()
Else
If $g_bDebugSetlogTrain Then DebugImageSave("TroopIconNotFound_" & GetTroopName($iIndex))
SetLog("TrainIt troop position " & GetTroopName($iIndex) & " did not find icon", $COLOR_ERROR)
EndIf
Else
SetLog("Impossible happened? TrainIt troop position " & GetTroopName($iIndex) & " did not return array", $COLOR_ERROR)
EndIf
EndIf
Next
EndFunc
Func GetTrainPos(Const $iIndex)
If $g_bDebugSetlogTrain Then SetLog("GetTrainPos($iIndex=" & $iIndex & ")", $COLOR_DEBUG)
Local $aTrainPos = $aTrainArmy[$iIndex]
If $aTrainPos[0] <> -1 Then
Return $aTrainPos
Else
If $iIndex >= $eBarb And $iIndex <= $eBowl Then
Local $sFilter = String($g_asTroopShortNames[$iIndex]) & "*"
Local $asImageToUse = _FileListToArray($g_sImgTrainTroops, $sFilter, $FLTA_FILES, True)
If $g_bDebugSetlogTrain Then SetLog("$asImageToUse Troops: " & $asImageToUse[1])
$aTrainPos = GetVariable($asImageToUse[1], $iIndex)
$aTrainArmy[$iIndex] = $aTrainPos
Return $aTrainPos
EndIf
If $iIndex >= $eLSpell And $iIndex <= $eSkSpell Then
Local $sFilter = String($g_asSpellShortNames[$iIndex - $eLSpell]) & "*"
Local $asImageToUse = _FileListToArray($g_sImgTrainSpells, $sFilter, $FLTA_FILES, True)
If $g_bDebugSetlogTrain Then SetLog("$asImageToUse Spell: " & $asImageToUse[1])
$aTrainPos = GetVariable($asImageToUse[1], $iIndex)
$aTrainArmy[$iIndex] = $aTrainPos
Return $aTrainPos
EndIf
EndIf
Return 0
EndFunc
Func GetFullName(Const $iIndex, Const $aTrainPos)
If $g_bDebugSetlogTrain Then SetLog("GetFullName($iIndex=" & $iIndex & ")", $COLOR_DEBUG)
If $iIndex >= $eBarb And $iIndex <= $eBowl Then
Local $sTroopType =($iIndex >= $eMini ? "Dark" : "Normal")
Return GetFullNameSlot($aTrainPos, $sTroopType)
EndIf
If $iIndex >= $eLSpell And $iIndex <= $eSkSpell Then
Return GetFullNameSlot($aTrainPos, "Spell")
EndIf
SetLog("Don't know how to find the full name of troop with index " & $iIndex & " yet")
Local $aTempSlot[4] = [-1, -1, -1, -1]
Return $aTempSlot
EndFunc
Func GetRNDName(Const $iIndex, Const $aTrainPos)
If $g_bDebugSetlogTrain Then SetLog("GetRNDName($iIndex=" & $iIndex & ")", $COLOR_DEBUG)
Local $aTrainPosRND[4]
If $iIndex <> -1 Then
Local $aTempCoord = $aTrainPos
$aTrainPosRND[0] = $aTempCoord[0] - 5
$aTrainPosRND[1] = $aTempCoord[1] - 5
$aTrainPosRND[2] = $aTempCoord[0] + 5
$aTrainPosRND[3] = $aTempCoord[1] + 5
Return $aTrainPosRND
EndIf
SetLog("Don't know how to find the RND name of troop with index " & $iIndex & " yet!", $COLOR_ERROR)
Return 0
EndFunc
Func GetVariable(Const $ImageToUse, Const $iIndex)
Local $aTrainPos[4] = [-1, -1, -1, -1]
_CaptureRegion2(25, 375, 840, 548)
Local $asResult = DllCallMyBot("FindTile", "handle", $g_hHBitmap2, "str", $ImageToUse, "str", "FV", "int", 1)
If @error Then _logErrorDLLCall($g_sLibMyBotPath, @error)
If IsArray($asResult) Then
If $asResult[0] = "0" Then
SetLog("No " & GetTroopName($iIndex) & " Icon found!", $COLOR_ERROR)
ElseIf $asResult[0] = "-1" Then
SetLog("TrainIt.au3 GetVariable(): ImgLoc DLL Error Occured!", $COLOR_ERROR)
ElseIf $asResult[0] = "-2" Then
SetLog("TrainIt.au3 GetVariable(): Wrong Resolution used for ImgLoc Search!", $COLOR_ERROR)
Else
If $g_bDebugSetlogTrain Then SetLog("String: " & $asResult[0])
Local $aResult = StringSplit($asResult[0], "|", $STR_NOCOUNT)
Local $aCoordinates = StringSplit($aResult[1], ",", $STR_NOCOUNT)
Local $iButtonX = 25 + Int($aCoordinates[0])
Local $iButtonY = 375 + Int($aCoordinates[1])
Local $sColorToCheck = "0x" & _GetPixelColor($iButtonX, $iButtonY, $g_bCapturePixel)
Local $iTolerance = 40
Local $aTrainPos[4] = [$iButtonX, $iButtonY, $sColorToCheck, $iTolerance]
If $g_bDebugSetlogTrain Then SetLog("Found: [" & $iButtonX & "," & $iButtonY & "]", $COLOR_SUCCESS)
If $g_bDebugSetlogTrain Then SetLog("$sColorToCheck: " & $sColorToCheck, $COLOR_SUCCESS)
If $g_bDebugSetlogTrain Then SetLog("$iTolerance: " & $iTolerance, $COLOR_SUCCESS)
Return $aTrainPos
EndIf
Else
SetLog("Don't know how to train the troop with index " & $iIndex & " yet")
EndIf
Return $aTrainPos
EndFunc
Func GetFullNameSlot(Const $iTrainPos, Const $sTroopType)
Local $iSlotH, $iSlotV
If $sTroopType = "Spell" Then
Switch $iTrainPos[0]
Case 0 To 101
$iSlotH = 101
Case 105 To 199
$iSlotH = 199
Case 203 To 297
$iSlotH = 297
Case 302 To 395
$iSlotH = 404
Case 400 To 498
$iSlotH = 502
Case 499 To 597
$iSlotH = 597
Case Else
If _ColorCheck(_GetPixelColor($iTrainPos[0], $iTrainPos[1], True), Hex(0xd3d3cb, 6), 5) Then
SetLog("GetFullNameSlot(): It seems that there is no Slot for an Spell on: " & $iTrainPos[0] & "," & $iTrainPos[1] & "!", $COLOR_ERROR)
EndIf
EndSwitch
Switch $iTrainPos[1]
Case 0 To 445
$iSlotV = 387
Case 446 To 550
$iSlotV = 488
EndSwitch
Local $aSlot[4] = [$iSlotH, $iSlotV, 0x9d9d9d, 20]
If $g_bDebugSetlogTrain Then SetLog("GetFullNameSlot(): Spell Icon found on: " & $iSlotH & "," & $iSlotV, $COLOR_DEBUG)
Return $aSlot
EndIf
If $sTroopType = "Normal" Then
Switch $iTrainPos[0]
Case 0 To 101
$iSlotH = 101
Case 105 To 199
$iSlotH = 199
Case 200 To 297
$iSlotH = 297
Case 298 To 395
$iSlotH = 395
Case 396 To 494
$iSlotH = 494
Case 495 To 592
$iSlotH = 592
Case 593 To 690
$iSlotH = 690
Case Else
If _ColorCheck(_GetPixelColor($iTrainPos[0], $iTrainPos[1], True), Hex(0xd3d3cb, 6), 5) Then
SetLog("GetFullNameSlot(): It seems that there is no Slot for an Elixir Troop on: " & $iTrainPos[0] & "," & $iTrainPos[1] & "!", $COLOR_ERROR)
EndIf
EndSwitch
Switch $iTrainPos[1]
Case 0 To 445
$iSlotV = 387
Case 446 To 550
$iSlotV = 488
EndSwitch
Local $aSlot[4] = [$iSlotH, $iSlotV, 0x9F9F9F, 20]
If $g_bDebugSetlogTrain Then SetLog("GetFullNameSlot(): Elixir Troop Icon found on: " & $iSlotH & "," & $iSlotV, $COLOR_DEBUG)
Return $aSlot
EndIf
If $sTroopType = "Dark" Then
Switch $iTrainPos[0]
Case 440 To 517
$iSlotH = 517
Case 518 To 615
$iSlotH = 615
Case 616 To 714
$iSlotH = 714
Case 715 To 812
$iSlotH = 812
Case Else
If _ColorCheck(_GetPixelColor($iTrainPos[0], $iTrainPos[1], True), Hex(0xd3d3cb, 6), 5) Then
SetLog("GetFullNameSlot(): It seems that there is no Slot for a Dark Elixir Troop on: " & $iTrainPos[0] & "," & $iTrainPos[1] & "!", $COLOR_ERROR)
EndIf
EndSwitch
Switch $iTrainPos[1]
Case 0 To 445
$iSlotV = 397
Case 446 To 550
$iSlotV = 498
EndSwitch
Local $aSlot[4] = [$iSlotH, $iSlotV, 0x9f9f9f, 20]
If $g_bDebugSetlogTrain Then SetLog("GetFullNameSlot(): Dark Elixir Troop Icon found on: " & $iSlotH & "," & $iSlotV, $COLOR_DEBUG)
Return $aSlot
EndIf
EndFunc
Func getArmyTroopTime($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = True, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("getArmyTroopTime():", $COLOR_DEBUG1)
$g_aiTimeTrain[0] = 0
If $bCheckWindow Then
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyTroopTime()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
EndIf
Local $sResultTroops = getRemainTrainTimer(495, 169, $bNeedCapture)
$g_aiTimeTrain[0] = ConvertOCRTime("Troops", $sResultTroops, $bSetLog)
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func getArmyTroopCapacity($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = True, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Then SetLog("getArmyTroopsCapacity():", $COLOR_DEBUG1)
If $bCheckWindow Then
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyTroopCapacity()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
EndIf
Local $aGetArmyCap[3] = ["", "", ""]
Local $sArmyInfo = ""
Local $iCount = 0
Local $sInputbox, $iHoldCamp
Local $tmpTotalCamp = 0
Local $tmpCurCamp = 0
$sArmyInfo = getArmyCampCap($aArmyCampSize[0], $aArmyCampSize[1], $bNeedCapture)
While $iCount < 100
$iCount += 1
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
ForceCaptureRegion()
$sArmyInfo = getArmyCampCap($aArmyCampSize[0], $aArmyCampSize[1], $bNeedCapture)
If $g_bDebugSetlogTrain Then SetLog("OCR $sArmyInfo = " & $sArmyInfo, $COLOR_DEBUG)
If StringInStr($sArmyInfo, "#", 0, 1) < 2 Then ContinueLoop
$aGetArmyCap = StringSplit($sArmyInfo, "#")
If IsArray($aGetArmyCap) Then
If $aGetArmyCap[0] > 1 Then
If Number($aGetArmyCap[2]) < 10 Or Mod(Number($aGetArmyCap[2]), 5) <> 0 Then
If $g_bDebugSetlogTrain Then SetLog(" OCR value is not valid camp size", $COLOR_DEBUG)
ContinueLoop
EndIf
$tmpCurCamp = Number($aGetArmyCap[1])
If $g_bDebugSetlogTrain Then SetLog("$tmpCurCamp = " & $tmpCurCamp, $COLOR_DEBUG)
$tmpTotalCamp = Number($aGetArmyCap[2])
If $g_bDebugSetlogTrain Then SetLog("$g_iTotalCampSpace = " & $g_iTotalCampSpace & ", Camp OCR = " & $tmpTotalCamp, $COLOR_DEBUG)
If $iHoldCamp = $tmpTotalCamp Then ExitLoop
$iHoldCamp = $tmpTotalCamp
EndIf
EndIf
WEnd
If $iCount <= 99 Then
$g_CurrentCampUtilization = $tmpCurCamp
If $g_iTotalCampSpace = 0 Then $g_iTotalCampSpace = $tmpTotalCamp
If $g_bDebugSetlogTrain Then SetLog("$g_CurrentCampUtilization = " & $g_CurrentCampUtilization & ", $g_iTotalCampSpace = " & $g_iTotalCampSpace, $COLOR_DEBUG)
Else
SetLog("Army size read error, Troop numbers may not train correctly", $COLOR_ERROR)
$g_CurrentCampUtilization = 0
CheckOverviewFullArmy()
EndIf
If $g_iTotalCampSpace = 0 Or($g_iTotalCampSpace <> $tmpTotalCamp) Then
If $g_bTotalCampForced = False Then
Local $proposedTotalCamp = $tmpTotalCamp
If $g_iTotalCampSpace > $tmpTotalCamp Then $proposedTotalCamp = $g_iTotalCampSpace
$sInputbox = InputBox("Question", "Enter your total Army Camp capacity." & @CRLF & @CRLF & "Please check it matches with total Army Camp capacity" & @CRLF & "you see in Army Overview right now in Android Window:" & @CRLF & $g_sAndroidTitle & @CRLF & @CRLF & "(This window closes in 2 Minutes with value of " & $proposedTotalCamp & ")", $proposedTotalCamp, "", 330, 220, Default, Default, 120, $g_hFrmBot)
Local $error = @error
If $error = 1 Then
SetLog("Army Camp User input cancelled, still using " & $g_iTotalCampSpace, $COLOR_ACTION)
Else
If $error = 2 Then
$g_iTotalCampSpace = $proposedTotalCamp
Else
$g_iTotalCampSpace = Number($sInputbox)
EndIf
If $error = 0 Then
$g_iTotalCampForcedValue = $g_iTotalCampSpace
$g_bTotalCampForced = True
SetLog("Army Camp User input = " & $g_iTotalCampSpace, $COLOR_INFO)
Else
SetLog("Army Camp proposed value = " & $g_iTotalCampSpace, $COLOR_ACTION)
EndIf
EndIf
Else
$g_iTotalCampSpace = Number($g_iTotalCampForcedValue)
EndIf
EndIf
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
If $g_bTotalCampForced = True Then $g_iTotalCampSpace = Number($g_iTotalCampForcedValue)
If $g_iTotalCampSpace > 0 Then
If $bSetLog Then SetLog("Total Army Camp Capacity: " & $g_CurrentCampUtilization & "/" & $g_iTotalCampSpace & " (" & Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100) & "%)")
$g_iArmyCapacity = Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100)
Else
If $bSetLog Then SetLog("Total Army Camp Capacity: " & $g_CurrentCampUtilization & "/" & $g_iTotalCampSpace)
$g_iArmyCapacity = 0
EndIf
If($g_CurrentCampUtilization >=($g_iTotalCampSpace * $g_iTrainArmyFullTroopPct / 100)) Then
$g_bFullArmy = True
Else
$g_bFullArmy = False
EndIf
If $g_CurrentCampUtilization >= $g_iTotalCampSpace * $g_aiSearchCampsPct[$DB] / 100 And $g_abSearchCampsEnable[$DB] And IsSearchModeActive($DB) Then $g_bFullArmy = True
If $g_CurrentCampUtilization >= $g_iTotalCampSpace * $g_aiSearchCampsPct[$LB] / 100 And $g_abSearchCampsEnable[$LB] And IsSearchModeActive($LB) Then $g_bFullArmy = True
If $g_CurrentCampUtilization >= $g_iTotalCampSpace * $g_aiSearchCampsPct[$TS] / 100 And $g_abSearchCampsEnable[$TS] And IsSearchModeActive($TS) Then $g_bFullArmy = True
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func getArmyTroops($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = False, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Then SetLog("getArmyTroops():", $COLOR_DEBUG)
If Not $bOpenArmyWindow Then
If $bCheckWindow And Not IsTrainPage() Then
SetError(1)
Return
EndIf
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyTroops()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
If _CheckPixel($aRecievedTroops, $bNeedCapture) Then
If $bSetLog Then SetLog("Detected Clan Castle Message Blocking Troop Images. Waiting until it's gone", $COLOR_INFO)
_CaptureRegion2()
While _CheckPixel($aRecievedTroops, False)
_Sleep($DELAYTRAIN1)
WEnd
EndIf
Local $sTroopDiamond = GetDiamondFromRect("23,215,585,255")
If $g_bDebugFuncTime Then StopWatchStart("findMultiple, \imgxml\ArmyOverview\Troops")
Local $aCurrentTroops = findMultiple(@ScriptDir & "\imgxml\ArmyOverview\Troops", $sTroopDiamond, $sTroopDiamond, 0, 1000, 0, "objectname,objectpoints", $bNeedCapture)
If $g_bDebugFuncTime Then StopWatchStopLog()
Local $aTempTroopArray, $aTroopCoords
Local $sTroopName = ""
Local $iTroopIndex = -1, $iDropTrophyIndex = -1
Local $aCurrentTroopsEmpty[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $aTroopsForTropyDropEmpty[6][2] = [["Barb", 0], ["Arch", 0], ["Giant", 0], ["Wall", 0], ["Gobl", 0], ["Mini", 0]]
$g_aiCurrentTroops = $aCurrentTroopsEmpty
$g_avDTtroopsToBeUsed = $aTroopsForTropyDropEmpty
If UBound($aCurrentTroops, 1) >= 1 Then
For $i = 0 To UBound($aCurrentTroops, 1) - 1
$aTempTroopArray = $aCurrentTroops[$i]
$iTroopIndex = TroopIndexLookup($aTempTroopArray[0], "getArmyTroops()")
$aTroopCoords = StringSplit($aTempTroopArray[1], ",", $STR_NOCOUNT)
If $iTroopIndex = -1 Then ContinueLoop
$g_aiCurrentTroops[$iTroopIndex] = Number(getBarracksNewTroopQuantity(Slot($aTroopCoords[0], $aTroopCoords[1]), 196, $bNeedCapture))
$iDropTrophyIndex = _ArraySearch($g_avDTtroopsToBeUsed, $aTempTroopArray[0])
If $iDropTrophyIndex <> -1 Then $g_avDTtroopsToBeUsed[$iDropTrophyIndex][1] += $g_aiCurrentTroops[$iTroopIndex]
$sTroopName = $g_aiCurrentTroops[$iTroopIndex] >= 2 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex]
If $bSetLog Then SetLog(" - " & $g_aiCurrentTroops[$iTroopIndex] & " " & $sTroopName & " Available", $COLOR_SUCCESS)
Next
EndIf
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func getArmyHeroCount($bOpenArmyWindow = False, $bCloseArmyWindow = False, $CheckWindow = True, $bSetLog = True)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Begin getArmyHeroCount:", $COLOR_DEBUG)
If $CheckWindow Then
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyHeroCount()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
EndIf
$g_iHeroAvailable = $eHeroNone
Local $iDebugArmyHeroCount = 0
Local $sResult
Local Const $iHeroes = 3
Local $sMessage = ""
For $i = 0 To $iHeroes - 1
$sResult = ArmyHeroStatus($i)
If $sResult <> "" Then
Select
Case StringInStr($sResult, "king", $STR_NOCASESENSEBASIC)
If $bSetLog Then SetLog(" - Barbarian King Available", $COLOR_SUCCESS)
$g_iHeroAvailable = BitOR($g_iHeroAvailable, $eHeroKing)
Case StringInStr($sResult, "queen", $STR_NOCASESENSEBASIC)
If $bSetLog Then SetLog(" - Archer Queen Available", $COLOR_SUCCESS)
$g_iHeroAvailable = BitOR($g_iHeroAvailable, $eHeroQueen)
Case StringInStr($sResult, "warden", $STR_NOCASESENSEBASIC)
If $bSetLog Then SetLog(" - Grand Warden Available", $COLOR_SUCCESS)
$g_iHeroAvailable = BitOR($g_iHeroAvailable, $eHeroWarden)
Case StringInStr($sResult, "heal", $STR_NOCASESENSEBASIC)
If $g_bDebugSetlogTrain Or $iDebugArmyHeroCount = 1 Then
Switch $i
Case 0
$sMessage = "-Barbarian King"
Case 1
$sMessage = "-Archer Queen"
Case 2
$sMessage = "-Grand Warden"
Case Else
$sMessage = "-Very Bad Monkey Needs"
EndSwitch
SetLog("Hero slot#" & $i + 1 & $sMessage & " Healing", $COLOR_DEBUG)
EndIf
Case StringInStr($sResult, "upgrade", $STR_NOCASESENSEBASIC)
Switch $i
Case 0
$sMessage = "-Barbarian King"
If($g_abAttackTypeEnable[$DB] And BitAND($g_aiAttackUseHeroes[$DB], $g_aiSearchHeroWaitEnable[$DB], $eHeroKing) = $eHeroKing) Or($g_abAttackTypeEnable[$LB] And BitAND($g_aiAttackUseHeroes[$LB], $g_aiSearchHeroWaitEnable[$LB], $eHeroKing) = $eHeroKing) Then
If $g_iSearchNotWaitHeroesEnable Then
$g_iHeroAvailable = BitOR($g_iHeroAvailable, $eHeroKing)
Else
SetLog("Warning: King Upgrading & Wait enabled, Disable Wait for King or may never attack!", $COLOR_ERROR)
EndIf
_GUI_Value_STATE("SHOW", $groupKingSleeping)
EndIf
Case 1
$sMessage = "-Archer Queen"
If($g_abAttackTypeEnable[$DB] And BitAND($g_aiAttackUseHeroes[$DB], $g_aiSearchHeroWaitEnable[$DB], $eHeroQueen) = $eHeroQueen) Or($g_abAttackTypeEnable[$LB] And BitAND($g_aiAttackUseHeroes[$LB], $g_aiSearchHeroWaitEnable[$LB], $eHeroQueen) = $eHeroQueen) Then
If $g_iSearchNotWaitHeroesEnable Then
$g_iHeroAvailable = BitOR($g_iHeroAvailable, $eHeroQueen)
Else
SetLog("Warning: Queen Upgrading & Wait enabled, Disable Wait for Queen or may never attack!", $COLOR_ERROR)
EndIf
_GUI_Value_STATE("SHOW", $groupQueenSleeping)
EndIf
Case 2
$sMessage = "-Grand Warden"
If($g_abAttackTypeEnable[$DB] And BitAND($g_aiAttackUseHeroes[$DB], $g_aiSearchHeroWaitEnable[$DB], $eHeroWarden) = $eHeroWarden) Or($g_abAttackTypeEnable[$DB] And BitAND($g_aiAttackUseHeroes[$LB], $g_aiSearchHeroWaitEnable[$LB], $eHeroWarden) = $eHeroWarden) Then
If $g_iSearchNotWaitHeroesEnable Then
$g_iHeroAvailable = BitOR($g_iHeroAvailable, $eHeroWarden)
Else
SetLog("Warning: Warden Upgrading & Wait enabled, Disable Wait for Warden or may never attack!", $COLOR_ERROR)
EndIf
_GUI_Value_STATE("SHOW", $groupWardenSleeping)
EndIf
Case Else
$sMessage = "-Need to Feed Code Monkey some bananas"
EndSwitch
If $g_bDebugSetlogTrain Or $iDebugArmyHeroCount = 1 Then SetLog("Hero slot#" & $i + 1 & $sMessage & " Upgrade in Process", $COLOR_DEBUG)
Case StringInStr($sResult, "none", $STR_NOCASESENSEBASIC)
If $g_bDebugSetlogTrain Or $iDebugArmyHeroCount = 1 Then SetLog("Hero slot#" & $i + 1 & " Empty, stop count", $COLOR_DEBUG)
ExitLoop
Case Else
If $bSetLog Then SetLog("Hero slot#" & $i + 1 & " bad OCR string returned!", $COLOR_ERROR)
EndSelect
Else
If $bSetLog Then SetLog("Hero slot#" & $i + 1 & " status read problem!", $COLOR_ERROR)
EndIf
Next
If $g_bDebugSetlogTrain Or $iDebugArmyHeroCount = 1 Then SetLog("Hero Status K|Q|W : " & BitAND($g_iHeroAvailable, $eHeroKing) & "|" & BitAND($g_iHeroAvailable, $eHeroQueen) & "|" & BitAND($g_iHeroAvailable, $eHeroWarden), $COLOR_DEBUG)
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func ArmyHeroStatus($i)
Local $sImageDir = "trainwindow-HeroStatus-bundle", $sResult = ""
Local Const $aHeroesRect[3][4] = [[655, 340, 680, 365], [730, 340, 755, 365], [805, 340, 830, 365]]
_CaptureRegion2($aHeroesRect[$i][0], $aHeroesRect[$i][1], $aHeroesRect[$i][2], $aHeroesRect[$i][3])
Local $res = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $sImageDir, "str", "FV", "Int", 0, "str", "FV", "Int", 0, "Int", 1000)
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
If StringInStr($aKeys[0], "xml", $STR_NOCASESENSEBASIC) Then
Local $aResult = StringSplit($aKeys[0], "_", $STR_NOCOUNT)
$sResult = $aResult[0]
Select
Case $i = "King" Or $i = 0 Or $i = $eKing
Switch $sResult
Case "heal"
GUICtrlSetState($g_hPicKingGray, $GUI_HIDE)
GUICtrlSetState($g_hPicKingGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicKingRed, $GUI_HIDE)
GUICtrlSetState($g_hPicKingBlue, $GUI_SHOW)
Case "upgrade"
GUICtrlSetState($g_hPicKingGray, $GUI_HIDE)
GUICtrlSetState($g_hPicKingGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicKingBlue, $GUI_HIDE)
GUICtrlSetState($g_hPicKingRed, $GUI_SHOW)
Case "king"
GUICtrlSetState($g_hPicKingGray, $GUI_HIDE)
GUICtrlSetState($g_hPicKingRed, $GUI_HIDE)
GUICtrlSetState($g_hPicKingBlue, $GUI_HIDE)
GUICtrlSetState($g_hPicKingGreen, $GUI_SHOW)
EndSwitch
Case $i = "Queen" Or $i = 1 Or $i = $eQueen
Switch $sResult
Case "heal"
GUICtrlSetState($g_hPicQueenGray, $GUI_HIDE)
GUICtrlSetState($g_hPicQueenGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicQueenRed, $GUI_HIDE)
GUICtrlSetState($g_hPicQueenBlue, $GUI_SHOW)
Case "upgrade"
GUICtrlSetState($g_hPicQueenGray, $GUI_HIDE)
GUICtrlSetState($g_hPicQueenGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicQueenBlue, $GUI_HIDE)
GUICtrlSetState($g_hPicQueenRed, $GUI_SHOW)
Case "queen"
GUICtrlSetState($g_hPicQueenGray, $GUI_HIDE)
GUICtrlSetState($g_hPicQueenRed, $GUI_HIDE)
GUICtrlSetState($g_hPicQueenBlue, $GUI_HIDE)
GUICtrlSetState($g_hPicQueenGreen, $GUI_SHOW)
EndSwitch
Case $i = "Warden" Or $i = 2 Or $i = $eWarden
Switch $sResult
Case "heal"
GUICtrlSetState($g_hPicWardenGray, $GUI_HIDE)
GUICtrlSetState($g_hPicWardenGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicWardenRed, $GUI_HIDE)
GUICtrlSetState($g_hPicWardenBlue, $GUI_SHOW)
Case "upgrade"
GUICtrlSetState($g_hPicWardenGray, $GUI_HIDE)
GUICtrlSetState($g_hPicWardenGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicWardenBlue, $GUI_HIDE)
GUICtrlSetState($g_hPicWardenRed, $GUI_SHOW)
Case "warden"
GUICtrlSetState($g_hPicWardenGray, $GUI_HIDE)
GUICtrlSetState($g_hPicWardenRed, $GUI_HIDE)
GUICtrlSetState($g_hPicWardenBlue, $GUI_HIDE)
GUICtrlSetState($g_hPicWardenGreen, $GUI_SHOW)
EndSwitch
EndSelect
Return $sResult
EndIf
EndIf
Switch $i
Case 0
GUICtrlSetState($g_hPicKingGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicKingRed, $GUI_HIDE)
GUICtrlSetState($g_hPicKingBlue, $GUI_HIDE)
GUICtrlSetState($g_hPicKingGray, $GUI_SHOW)
Return "none"
Case 1
GUICtrlSetState($g_hPicQueenGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicQueenRed, $GUI_HIDE)
GUICtrlSetState($g_hPicQueenBlue, $GUI_HIDE)
GUICtrlSetState($g_hPicQueenGray, $GUI_SHOW)
Return "none"
Case 2
GUICtrlSetState($g_hPicWardenGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicWardenRed, $GUI_HIDE)
GUICtrlSetState($g_hPicWardenBlue, $GUI_HIDE)
GUICtrlSetState($g_hPicWardenGray, $GUI_SHOW)
Return "none"
EndSwitch
EndFunc
Func LabGuiDisplay()
ClickP($aAway, 2, 0, "#0346")
If _Sleep(1500) Then Return
If $g_aiLaboratoryPos[0] <= 0 Or $g_aiLaboratoryPos[1] <= 0 Then
SetLog("Laboratory Location not found!", $COLOR_ERROR)
LocateLab()
If $g_aiLaboratoryPos[0] = 0 Or $g_aiLaboratoryPos[1] = 0 Then
SetLog("Problem locating Laboratory, train laboratory position before proceeding", $COLOR_ERROR)
GUICtrlSetState($g_hPicLabGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicLabRed, $GUI_HIDE)
GUICtrlSetState($g_hPicLabGray, $GUI_SHOW)
Return
EndIf
EndIf
BuildingClickP($g_aiLaboratoryPos, "#0197")
If _Sleep(1500) Then Return
If QuickMIS("BC1", @ScriptDir & "\imgxml\Lab\Research", 200, 620, 700, 700) Then
Click($g_iQuickMISX + 200, $g_iQuickMISY + 620)
If _Sleep($DELAYLABORATORY1) Then Return
Else
Setlog("Trouble finding research button, try again...", $COLOR_WARNING)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0199")
GUICtrlSetState($g_hPicLabGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicLabRed, $GUI_HIDE)
GUICtrlSetState($g_hPicLabGray, $GUI_SHOW)
Return
EndIf
If _ColorCheck(_GetPixelColor(730, 200, True), Hex(0xA2CB6C, 6), 20) Then
SetLog("Laboratory is Running. ", $COLOR_INFO)
GUICtrlSetState($g_hPicLabGray, $GUI_HIDE)
GUICtrlSetState($g_hPicLabRed, $GUI_HIDE)
GUICtrlSetState($g_hPicLabGreen, $GUI_SHOW)
If _Sleep($DELAYLABORATORY2) Then Return
ClickP($aAway, 2, $DELAYLABORATORY4, "#0359")
Return True
ElseIf _ColorCheck(_GetPixelColor(730, 200, True), Hex(0x8088B0, 6), 20) Then
SetLog("Laboratory has Stopped", $COLOR_INFO)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0359")
GUICtrlSetState($g_hPicLabGray, $GUI_HIDE)
GUICtrlSetState($g_hPicLabGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicLabRed, $GUI_SHOW)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0359")
Return
Else
SetLog("Unable to determine Lab Status", $COLOR_INFO)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0359")
GUICtrlSetState($g_hPicLabGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicLabRed, $GUI_HIDE)
GUICtrlSetState($g_hPicLabGray, $GUI_SHOW)
Return
EndIf
EndFunc
Func getArmyHeroTime($iHeroType, $bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Begin getArmyHeroTime:", $COLOR_DEBUG)
If $iHeroType <> $eHeroKing And $iHeroType <> $eHeroQueen And $iHeroType <> $eHeroWarden And StringInStr($iHeroType, "all", $STR_NOCASESENSEBASIC) = 0 Then
SetLog("getHeroTime slipped on banana, get doctor, tell him: " & $iHeroType, $COLOR_ERROR)
SetError(1)
Return
EndIf
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(2)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyHeroTime()") Then
SetError(3)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
Local $iRemainTrainHeroTimer = 0, $sResultHeroTime
Local $sResult
Local $aResultHeroes[3] = ["", "", ""]
Local Const $aHeroRemainData[3][4] = [[619, 414, "King", $eHeroKing], [691, 414, "Queen", $eHeroQueen], [764, 414, "Warden", $eHeroWarden]]
For $index = 0 To UBound($aHeroRemainData) - 1
If StringInStr($iHeroType, "all", $STR_NOCASESENSEBASIC) = 0 And $iHeroType <> $aHeroRemainData[$index][3] Then ContinueLoop
$sResult = ArmyHeroStatus($index)
If $sResult <> "" Then
If StringInStr($sResult, "heal", $STR_NOCASESENSEBASIC) = 0 Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then
SetLog("Hero slot#" & $index + 1 & " status: " & $sResult & " :skip time read", $COLOR_PURPLE)
EndIf
ContinueLoop
Else
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Hero slot#" & $index + 1 & " status: " & $sResult, $COLOR_DEBUG)
EndIf
Else
SetLog("Hero slot#" & $index + 1 & " Status read problem!", $COLOR_ERROR)
EndIf
$sResult = getRemainTHero($aHeroRemainData[$index][0], $aHeroRemainData[$index][1])
If $sResult <> "" Then
$aResultHeroes[$index] = ConvertOCRTime($aHeroRemainData[$index][2] & " recover" , $sResult, False)
If _DateDiff("h", $g_aiHeroBoost[$index], _NowCalc()) < 1 Then $aResultHeroes[$index] /= 4
SetLog("Remaining " & $aHeroRemainData[$index][2] & " recover time: " & StringFormat("%.2f", $aResultHeroes[$index]), $COLOR_INFO)
If $iHeroType = $aHeroRemainData[$index][3] Then
$iRemainTrainHeroTimer = Number($aResultHeroes[$index])
ExitLoop
EndIf
Else
If $iHeroType = $aHeroRemainData[$index][3] Then
SetLog("Can not read remaining " & $aHeroRemainData[$index][2] & " recover time", $COLOR_RED)
Else
For $pMatchMode = $DB To $g_iMatchMode - 1
If IsSpecialTroopToBeUsed($pMatchMode, $aHeroRemainData[$index][3]) And BitAND($g_aiAttackUseHeroes[$pMatchMode], $g_aiSearchHeroWaitEnable[$pMatchMode]) = $g_aiSearchHeroWaitEnable[$pMatchMode] Then
SetLog("Can not read remaining " & $aHeroRemainData[$index][2] & " train time", $COLOR_ERROR)
ExitLoop
Else
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Bad read remain " & $aHeroRemainData[$index][2] & " recover time, but not enabled", $COLOR_DEBUG)
EndIf
Next
EndIf
EndIf
Next
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
If $iHeroType = $eHeroKing Or $iHeroType = $eHeroQueen Or $iHeroType = $eHeroWarden Then
Return $iRemainTrainHeroTimer
ElseIf StringInStr($iHeroType, "all", $STR_NOCASESENSEBASIC) > 0 Then
Return $aResultHeroes
EndIf
EndFunc
Func getArmySpellTime($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = True, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Then SetLog("getArmySpellTime():", $COLOR_DEBUG1)
$g_aiTimeTrain[1] = 0
If $bCheckWindow Then
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not openArmyOverview(True, "getArmySpellTime()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
EndIf
Local $sResultSpells = getRemainTrainTimer(495, 315, $bNeedCapture)
$g_aiTimeTrain[1] = ConvertOCRTime("Spells", $sResultSpells, $bSetLog)
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func getArmySpells($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = False, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Then SetLog("getArmySpells():", $COLOR_DEBUG)
If Not $bOpenArmyWindow Then
If $bCheckWindow And Not IsTrainPage() Then
SetError(1)
Return
EndIf
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmySpells()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
Local $sSpellDiamond = GetDiamondFromRect("23,366,585,400")
Local $aCurrentSpells = findMultiple(@ScriptDir & "\imgxml\ArmyOverview\Spells", $sSpellDiamond, $sSpellDiamond, 0, 1000, 0,"objectname,objectpoints", $bNeedCapture)
Local $aTempSpellArray, $aSpellCoords
Local $sSpellName = ""
Local $iSpellIndex = -1
Local $aCurrentSpellsEmpty[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
$g_aiCurrentSpells = $aCurrentSpellsEmpty
If UBound($aCurrentSpells, 1) >= 1 Then
For $i = 0 To UBound($aCurrentSpells, 1) - 1
$aTempSpellArray = $aCurrentSpells[$i]
$iSpellIndex = TroopIndexLookup($aTempSpellArray[0], "getArmySpells()") - $eLSpell
If $iSpellIndex = -1 Then ContinueLoop
$aSpellCoords = StringSplit($aTempSpellArray[1], ",", $STR_NOCOUNT)
$g_aiCurrentSpells[$iSpellIndex] = Number(getBarracksNewTroopQuantity(Slot($aSpellCoords[0], $aSpellCoords[1]), 341, $bNeedCapture))
$sSpellName = $g_aiCurrentSpells[$iSpellIndex] >= 2 ? $g_asSpellNames[$iSpellIndex] & " Spells" : $g_asSpellNames[$iSpellIndex] & " Spell"
If $bSetLog Then SetLog(" - " & $g_aiCurrentSpells[$iSpellIndex] & " " & $sSpellName & " Brewed", $COLOR_SUCCESS)
Next
EndIf
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func getArmySpellCapacity($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = True, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("getArmySpellCapacity():", $COLOR_DEBUG1)
If $bCheckWindow Then
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmySpellCapacity()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
EndIf
Local $g_iTotalSpells = 0
Local $aGetSpellCap[3] = ["", "", ""]
Local $iCount
Local $sSpellsInfo = ""
If $g_iTotalSpellValue > 0 Then
$sSpellsInfo = getArmyCampCap($aArmySpellSize[0], $aArmySpellSize[1], $bNeedCapture)
$iCount = 0
While $sSpellsInfo = ""
$sSpellsInfo = getArmyCampCap($aArmySpellSize[0], $aArmySpellSize[1], $bNeedCapture)
$iCount += 1
If $iCount > 10 Then ExitLoop
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
WEnd
If $g_bDebugSetlogTrain Then SetLog("$sSpellsInfo= " & $sSpellsInfo, $COLOR_DEBUG)
$aGetSpellCap = StringSplit($sSpellsInfo, "#")
If IsArray($aGetSpellCap) Then
If $aGetSpellCap[0] > 1 Then
$g_iTotalSpells = Number($aGetSpellCap[2])
$g_iCurrentSpells = Number($aGetSpellCap[1])
Else
SetLog("Error in getArmySpellCapacity: Couldn't reall all Capacity Values", $COLOR_ERROR)
$g_iCurrentSpells = 0
$g_iTotalSpells = $g_iTotalSpellValue
EndIf
Else
SetLog("Error in getArmySpellCapacity: $aGetCCSpell is not an Array", $COLOR_ERROR)
$g_iCurrentSpells = 0
$g_iTotalSpells = $g_iTotalSpellValue
EndIf
If $bSetLog Then SetLog("Total Spell Factory Capacity: " & $g_iCurrentSpells & "/" & $g_iTotalSpells)
EndIf
If $g_iTotalSpells <> $g_iTotalSpellValue And $bSetLog Then SetLog("Warning: Total Spell Capacity is not the same as in GUI", $COLOR_WARNING)
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func GetCurTotalSpell()
Local $iCount = 0
For $i = 0 To $eSpellCount - 1
$iCount += $g_aiCurrentSpells[$i]
Next
Return $iCount
EndFunc
Func GetCurTotalDarkSpell()
Local $iCount = 0
For $i = $eSpellPoison To $eSpellSkeleton - 1
$iCount += $g_aiCurrentSpells[$i]
Next
Return $iCount
EndFunc
Func getArmyCCStatus($bOpenArmyWindow = False, $bCloseArmyWindow = False, $CheckWindow = True, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Begin getArmyCCStatus:", $COLOR_DEBUG1)
$g_iCCRemainTime = 0
If $CheckWindow Then
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyCCStatus()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
EndIf
$g_bCanRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1] + 20, $bNeedCapture), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) And _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], $bNeedCapture), Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5])
If $g_bDebugSetlogTrain Then SetLog("Can Request CC: " & $g_bCanRequestCC, $COLOR_DEBUG)
If Not $g_bCanRequestCC Then
If _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1] + 20, $bNeedCapture), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) And Not _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], $bNeedCapture), Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5]) Then
If $bSetLog Then SetLog(" - Clan Castle request already made.", $COLOR_INFO)
EndIf
If _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1] + 20, $bNeedCapture), Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5]) And _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], $bNeedCapture), Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5]) Then
If $bSetLog Then SetLog("Clan Castle Full/No Clan.", $COLOR_INFO)
EndIf
EndIf
If _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1] + 20, $bNeedCapture), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) And Not _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], $bNeedCapture), Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5]) Then
Local $sResultCC = getRequestRemainTime($aArmyCCRemainTime[0], $aArmyCCRemainTime[1])
If $g_bDebugSetlogTrain Then SetLog("getArmyCampCap returned: " & $sResultCC, $COLOR_DEBUG)
$g_iCCRemainTime = ConvertOCRTime("CC request", $sResultCC, $bSetLog)
EndIf
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func getArmyCCSpellCapacity($bOpenArmyWindow = False, $bCloseArmyWindow = False, $CheckWindow = True, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Begin getArmyCCSpellCapacity:", $COLOR_DEBUG1)
If $CheckWindow Then
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyCCSpellCapacity()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
EndIf
Local $aGetCCSpellsSize[3] = ["", "", ""]
Local $iCount
Local $sCCSpellsInfo = ""
If $g_abSearchCastleSpellsWaitEnable[$DB] Or $g_abSearchCastleSpellsWaitEnable[$LB] Then
$sCCSpellsInfo = getArmyCampCap($g_aArmyCCSpellSize[0], $g_aArmyCCSpellSize[1], $bNeedCapture)
$iCount = 0
While $sCCSpellsInfo = ""
$sCCSpellsInfo = getArmyCampCap($g_aArmyCCSpellSize[0], $g_aArmyCCSpellSize[1], $bNeedCapture)
$iCount += 1
If $iCount > 10 Then ExitLoop
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
WEnd
If $g_bDebugSetlogTrain Then SetLog("$sCCSpellsInfo = " & $sCCSpellsInfo, $COLOR_DEBUG)
$aGetCCSpellsSize = StringSplit($sCCSpellsInfo, "#")
If IsArray($aGetCCSpellsSize) Then
If $aGetCCSpellsSize[0] > 1 Then
$g_iTotalCCSpells = Number($aGetCCSpellsSize[2])
$g_iCurrentCCSpells = Number($aGetCCSpellsSize[1])
Else
SetLog("CC Spells size read error.", $COLOR_ERROR)
$g_iTotalCCSpells = 0
$g_iCurrentCCSpells = 0
EndIf
Else
SetLog("CC Spells size read error.", $COLOR_ERROR)
$g_iTotalCCSpells = 0
$g_iCurrentCCSpells = 0
EndIf
If $bSetLog Then SetLog("Total Clan Castle Spells: " & $g_iCurrentCCSpells & "/" & $g_iTotalCCSpells)
EndIf
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func _ImageSearch($findImage, $resultPosition, ByRef $x, ByRef $y, $Tolerance)
Return _ImageSearchArea($findImage, $resultPosition, 0, 0, 840, 720, $x, $y, $Tolerance)
EndFunc
Func _ImageSearchArea($findImage, $resultPosition, $x1, $y1, $right, $bottom, ByRef $x, ByRef $y, $Tolerance)
Local $HBMP = $g_hHBitmap
If $g_bChkBackgroundMode = False Then
$HBMP = 0
$x1 += $g_aiBSpos[0]
$y1 += $g_aiBSpos[1]
$right += $g_aiBSpos[0]
$bottom += $g_aiBSpos[1]
EndIf
Local $result
If IsString($findImage) Then
If $Tolerance > 0 Then $findImage = "*" & $Tolerance & " " & $findImage
If $HBMP = 0 Then
$result = DllCallMyBot("ImageSearch", "int", $x1, "int", $y1, "int", $right, "int", $bottom, "str", $findImage)
Else
$result = DllCallMyBot("ImageSearchEx", "int", $x1, "int", $y1, "int", $right, "int", $bottom, "str", $findImage, "ptr", $HBMP)
EndIf
Else
$result = DllCallMyBot("ImageSearchExt", "int", $x1, "int", $y1, "int", $right, "int", $bottom, "int", $Tolerance, "ptr", $findImage, "ptr", $HBMP)
EndIf
If @error Then _logErrorDLLCall($g_sLibImageSearchPath, @error)
If IsArray($result) Then
If $result[0] = "0" Then Return 0
Else
SetLog("Error: Image Search not working...", $COLOR_ERROR)
Return 1
EndIf
Local $array = StringSplit($result[0], "|")
If(UBound($array) >= 4) Then
$x = Int(Number($array[2]))
$y = Int(Number($array[3]))
If $resultPosition = 1 Then
$x = $x + Int(Number($array[4]) / 2)
$y = $y + Int(Number($array[5]) / 2)
EndIf
$x -= $x1
$y -= $y1
Return 1
EndIf
EndFunc
Func hasElixirStorage($bForceCapture = False)
Local $has = False
Local $result = findMultiple($g_sImgElixirStorage, "ECD", $g_sImglocRedline, 0, 1000, 0, "objectname,objectpoints,objectlevel", $bForceCapture)
If IsArray($result) Then
For $matchedValues In $result
Local $aPoints = StringSplit($matchedValues[1], "|", $STR_NOCOUNT)
Local $found = UBound($aPoints)
If $found > 0 Then
$has = True
ExitLoop
EndIf
Next
EndIf
Return $has
EndFunc
Func setZombie($RaidedElixir = -1, $AvailableElixir = -1, $Matched = -1, $SearchIdx = -1, $redline = "", $Timestamp = @YEAR & "-" & @MON & "-" & @MDAY & "_" & StringReplace(_NowTime(5), ":", "-"))
If TestCapture() Then Return ""
If $RaidedElixir = -1 And $AvailableElixir = -1 And $Matched = -1 And $SearchIdx = -1 Then
$g_aZombie[0] = ""
$g_aZombie[1] = 0
$g_aZombie[2] = 0
$g_aZombie[3] = 0
$g_aZombie[4] = 0
$g_aZombie[5] = ""
$g_aZombie[6] = ""
Else
If $RaidedElixir >= 0 Then $g_aZombie[1] = Number($RaidedElixir)
If $AvailableElixir >= 0 Then $g_aZombie[2] = Number($AvailableElixir)
If $Matched >= 0 Then $g_aZombie[3] = Number($Matched)
If $SearchIdx >= 0 Then $g_aZombie[4] = Number($SearchIdx)
If $g_aZombie[5] = "" Then $g_aZombie[5] = $Timestamp
If $g_aZombie[6] = "" Then $g_aZombie[6] = $redline
Local $dbFound = $g_aZombie[3] >= $g_iCollectorMatchesMin
Local $path = $g_sProfileTempDebugPath &(($dbFound) ?("Zombies\") :("SkippedZombies\"))
Local $availK = Round($g_aZombie[2] / 1000)
If $g_aZombie[0] = "" And $g_aZombie[4] > 0 Then
Local $create = $g_aZombie[0] = "" And($dbFound = True Or($g_aZombie[8] = -1 And $g_aZombie[9] = -1) Or($availK >= $g_aZombie[8] And hasElixirStorage() = False) Or $availK >= $g_aZombie[9])
If $create = True Then
Local $ZombieFilename = "DebugDB_" & StringFormat("%04i", $availK) & "k_" & $g_sProfileCurrentName & "_search_" & StringFormat("%03i", $g_aZombie[4]) & "_matched_" & $g_aZombie[3] & "_" & $g_aZombie[5] & ".png"
SetDebugLog("Saving enemy village screenshot for deadbase validation: " & $ZombieFilename)
SetDebugLog("Redline was: " & $g_aZombie[6])
$g_aZombie[0] = $ZombieFilename
Local $g_hBitmapZombie = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
_GDIPlus_ImageSaveToFile($g_hBitmapZombie, $path & $g_aZombie[0])
_GDIPlus_BitmapDispose($g_hBitmapZombie)
EndIf
ElseIf $g_aZombie[0] <> "" Then
Local $raidPct = 0
If $g_aZombie[2] > 0 And $g_aZombie[2] >= $g_aZombie[1] Then
$raidPct = Round((100 * $g_aZombie[1]) / $g_aZombie[2])
EndIf
If $g_aZombie[7] <> -1 And $raidPct >= $g_aZombie[7] And($g_aZombie[10] = -1 Or $g_aZombie[2] >= $g_aZombie[10]) Then
SetDebugLog("Delete enemy village screenshot as base seems dead: " & $g_aZombie[0])
FileDelete($path & $g_aZombie[0])
Else
Local $ZombieFilename = "DebugDB_" & StringFormat("%03i", $raidPct) & "%_" & $g_sProfileCurrentName & "_search_" & StringFormat("%03i", $g_aZombie[4]) & "_matched_" & $g_aZombie[3] & "_" & StringFormat("%04i", $availK) & "k_" & StringFormat("%04i", Round($g_aZombie[1] / 1000)) & "k_" & $g_aZombie[5] & ".png"
SetDebugLog("Rename enemy village screenshot as base seems live: " & $ZombieFilename)
FileMove($path & $g_aZombie[0], $path & $ZombieFilename)
EndIf
setZombie()
Else
setZombie()
EndIf
EndIf
Return $g_aZombie[0]
EndFunc
Func checkDeadBaseNew()
If $g_bCollectorFilterDisable Then
Return True
EndIf
Local $minCollectorLevel = 0
Local $maxCollectorLevel = 0
Local $anyFillLevel[2] = [False, False]
If $g_bDebugSetlog Then SetDebugLog("Checking Deadbase With IMGLOC START", $COLOR_WARNING)
For $i = 6 To 12
If $g_abCollectorLevelEnabled[$i] Then
If $minCollectorLevel = 0 Then $minCollectorLevel = $i
If $i > $maxCollectorLevel Then $maxCollectorLevel = $i
$anyFillLevel[$g_aiCollectorLevelFill[$i]] = True
EndIf
Next
If $maxCollectorLevel = 0 Then
Return True
EndIf
If $g_bDebugSetlog Then SetDebugLog("Checking Deadbase With IMGLOC START", $COLOR_WARNING)
Local $TotalMatched = 0
Local $Matched[2] = [-1, -1]
Local $aPoints[0]
_CaptureRegion2()
If $anyFillLevel[0] = True Then
$Matched[0] = imglocIsDeadBase($aPoints, 50, $minCollectorLevel, $maxCollectorLevel, True, False)
If $Matched[0] > 0 Then $TotalMatched += $Matched[0]
EndIf
If $TotalMatched < $g_iCollectorMatchesMin Then
$Matched[1] = imglocIsDeadBase($aPoints, 100, $minCollectorLevel, $maxCollectorLevel, True, False)
If $Matched[1] > 0 Then $TotalMatched += $Matched[1]
EndIf
Local $dbFound = $TotalMatched >= $g_iCollectorMatchesMin
If $dbFound Then
If $g_bDebugSetlog Then SetDebugLog("IMGLOC : FOUND DEADBASE !!! Matched: " & $TotalMatched & "/" & $g_iCollectorMatchesMin & ": " & UBound($aPoints), $COLOR_GREEN)
Else
If $g_bDebugSetlog Then
If $Matched[0] = -1 And $Matched[1] = -1 Then
SetDebugLog("IMGLOC : NOT A DEADBASE!!! ", $COLOR_INFO)
Else
SetDebugLog("IMGLOC : DEADBASE NOT MATCHED Matched: " & $TotalMatched & "/" & $g_iCollectorMatchesMin, $COLOR_WARNING)
EndIf
EndIf
EndIf
$g_aZombie[3] = $TotalMatched
If $g_bDebugDeadBaseImage Then
setZombie(0, $g_iSearchElixir, $TotalMatched, $g_iSearchCount, $g_sImglocRedline)
EndIf
Return $dbFound
EndFunc
Func checkDeadBase()
Return checkDeadBaseSuperNew(False)
EndFunc
Func GetCollectorIndexByFillLevel($level)
If Number($level) >= 85 Then Return 1
Return 0
EndFunc
Func imglocIsDeadBase(ByRef $aPos, $FillLevel = 100, $minCollectorLevel = 0, $maxCollectorLevel = 1000, $CheckConfig = False, $bForceCapture = True)
Local $sCocDiamond = "ECD"
Local $redLines = $g_sImglocRedline
Local $minLevel = $minCollectorLevel
Local $maxLevel = $maxCollectorLevel
Local $maxReturnPoints = 0
Local $returnProps = "objectname,objectpoints,objectlevel"
Local $sDirectory = @ScriptDir & "\imgxml\deadbase\elix\" & $FillLevel & "\"
Local $matchedValues
Local $TotalMatched = 0
Local $fillIndex = GetCollectorIndexByFillLevel($FillLevel)
If $g_bDebugSetlog Then SetDebugLog("IMGLOC : Searching Deadbase for FillLevel/MinLevel/MaxLevel: " & $FillLevel & "/" & $minLevel & "/" & $maxLevel & " using " & $sDirectory, $COLOR_INFO)
Local $result = findMultiple($sDirectory, $sCocDiamond, $redLines, $minLevel, $maxLevel, $maxReturnPoints, $returnProps, $bForceCapture)
If IsArray($result) Then
For $matchedValues In $result
Local $aPoints = StringSplit($matchedValues[1], "|", $STR_NOCOUNT)
Local $found = UBound($aPoints)
If $CheckConfig = True Then
Local $level = Number($matchedValues[2])
If $g_abCollectorLevelEnabled[$level] Then
If $fillIndex < $g_aiCollectorLevelFill[$level] Then
$found = 0
EndIf
Else
$found = 0
EndIf
EndIf
If $found > 0 Then
For $sPoint In $aPoints
Local $aP = StringSplit($sPoint, ",", $STR_NOCOUNT)
Local $bSkipPoint = False
For $bP In $aPos
Local $a = $aP[1] - $bP[1]
Local $b = $aP[0] - $bP[0]
Local $c = Sqrt($a * $a + $b * $b)
If $c < 25 Then
If $g_bDebugSetlog Then SetDebugLog("IMGLOC : Searching Deadbase ignore duplicate collector " & $matchedValues[0] & " at " & $aP[0] & ", " & $aP[1], $COLOR_INFO)
$bSkipPoint = True
$found -= 1
ExitLoop
EndIf
Next
If $bSkipPoint = False Then
Local $i = UBound($aPos)
ReDim $aPos[$i + 1]
$aPos[$i] = $aP
EndIf
Next
EndIf
$TotalMatched += $found
Next
Else
$TotalMatched = -1
EndIf
Return $TotalMatched
EndFunc
Func checkDeadBaseSuperNew($bForceCapture = True, $sFillDirectory = @ScriptDir & "\imgxml\deadbase\elix\fill\", $sLvlDirectory = @ScriptDir & "\imgxml\deadbase\elix\lvl\")
If $g_bCollectorFilterDisable Then
Return True
EndIf
Local $minCollectorLevel = 0
Local $maxCollectorLevel = 0
Local $anyFillLevel[2] = [False, False]
If $g_bDebugSetlog Then SetDebugLog("Checking Deadbase With IMGLOC START (super new)", $COLOR_WARNING)
For $i = 6 To 12
If $g_abCollectorLevelEnabled[$i] Then
If $minCollectorLevel = 0 Then $minCollectorLevel = $i
If $i > $maxCollectorLevel Then $maxCollectorLevel = $i
$anyFillLevel[$g_aiCollectorLevelFill[$i]] = True
EndIf
Next
If $maxCollectorLevel = 0 Then
Return True
EndIf
If $g_bDebugSetlog Then SetDebugLog("Checking Deadbase With IMGLOC START", $COLOR_WARNING)
Local $TotalMatched = 0
Local $aPoints[0]
Local $aPos[0]
Local $sCocDiamond = "ECD"
Local $redLines = $g_sImglocRedline
Local $minLevel = 0
Local $maxLevel = 1000
Local $maxReturnPoints = 0
Local $returnProps = "objectname,objectpoints,objectlevel,fillLevel"
Local $matchedValues
Local $TotalMatched = 0
Local $x, $y, $lvl, $fill
Local $result = findMultiple($sFillDirectory, $sCocDiamond, $redLines, $minLevel, $maxLevel, $maxReturnPoints, $returnProps, $bForceCapture)
Local $foundFilledCollectors = IsArray($result) = 1
If $foundFilledCollectors = True Then
For $matchedValues In $result
Local $aPoints = StringSplit($matchedValues[1], "|", $STR_NOCOUNT)
Local $found = UBound($aPoints)
If $found > 0 Then
$lvl = Number($matchedValues[3])
For $sPoint In $aPoints
Local $aP = StringSplit($sPoint, ",", $STR_NOCOUNT)
ReDim $aP[4]
$aP[3] = 0
$aP[2] = $lvl
Local $bSkipPoint = False
For $i = 0 To UBound($aPos) - 1
Local $bP = $aPos[$i]
Local $a = $aP[1] - $bP[1]
Local $b = $aP[0] - $bP[0]
Local $c = Sqrt($a * $a + $b * $b)
If $c < 25 Then
If $aP[2] > $bP[2] Then
$aPos[$i] = $aP
$aP = $bP
EndIf
If $g_bDebugSetlog Then SetDebugLog("IMGLOC : Searching Deadbase ignore duplicate collector with fill level " & $aP[2] & " at " & $aP[0] & ", " & $aP[1], $COLOR_INFO)
$bSkipPoint = True
$found -= 1
ExitLoop
EndIf
Next
If $bSkipPoint = False Then
Local $i = UBound($aPos)
ReDim $aPos[$i + 1]
$aPos[$i] = $aP
EndIf
Next
EndIf
Next
For $aP In $aPos
$x = $aP[0]
$y = $aP[1]
$fill = $aP[2]
$lvl = $aP[3]
$sCocDiamond =($x - 20) & "," &($y - 25) & "|" &($x + 20) & "," &($y - 25) & "|" &($x + 20) & "," &($y + 15) & "|" &($x - 20) & "," &($y + 15)
$redLines = $sCocDiamond
$result = findMultiple($sLvlDirectory, $sCocDiamond, $redLines, $minLevel, $maxLevel, $maxReturnPoints, $returnProps, $bForceCapture)
$bForceCapture = False
If IsArray($result) Then
For $matchedValues In $result
Local $aPoints = StringSplit($matchedValues[1], "|", $STR_NOCOUNT)
If UBound($aPoints) > 0 Then
$lvl = Number($matchedValues[2])
If $lvl > $aP[3] Then $aP[3] = $lvl
EndIf
Next
EndIf
$lvl = $aP[3]
If $lvl = 0 Then
If $g_bDebugSetlog Then SetDebugLog("IMGLOC : Searching Deadbase no collector identified with fill level " & $fill & " at " & $x & ", " & $y, $COLOR_INFO)
ContinueLoop
EndIf
If $g_abCollectorLevelEnabled[$lvl] Then
Local $fillIndex = GetCollectorIndexByFillLevel($fill)
If $fillIndex < $g_aiCollectorLevelFill[$lvl] Then
If $g_bDebugSetlog Then SetDebugLog("IMGLOC : Searching Deadbase collector level " & $lvl & " found but not enough elixir, fill level " & $fill & " at " & $x & ", " & $y, $COLOR_INFO)
ContinueLoop
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("IMGLOC : Searching Deadbase collector level " & $lvl & " found but not enabled, fill level " & $fill & " at " & $x & ", " & $y, $COLOR_INFO)
ContinueLoop
EndIf
$TotalMatched += 1
Next
EndIf
Local $dbFound = $TotalMatched >= $g_iCollectorMatchesMin
If $g_bDebugSetlog Then
If $foundFilledCollectors = False Then
SetDebugLog("IMGLOC : NOT A DEADBASE!!!", $COLOR_INFO)
ElseIf $dbFound = False Then
SetDebugLog("IMGLOC : DEADBASE NOT MATCHED: " & $TotalMatched & "/" & $g_iCollectorMatchesMin, $COLOR_WARNING)
Else
SetDebugLog("IMGLOC : FOUND DEADBASE !!! Matched: " & $TotalMatched & "/" & $g_iCollectorMatchesMin & ": " & UBound($aPoints), $COLOR_GREEN)
EndIf
EndIf
$g_aZombie[3] = $TotalMatched
If $g_bDebugDeadBaseImage Then
setZombie(0, $g_iSearchElixir, $TotalMatched, $g_iSearchCount, $g_sImglocRedline)
EndIf
Return $dbFound
EndFunc
Func checkDeadBaseFolder($directory, $executeOldCode = "checkDeadBaseNew()", $executeNewCode = "checkDeadBaseSuperNew()")
Local $aFiles = _FileListToArray($directory, "*.png", $FLTA_FILES)
If IsArray($aFiles) = 0 Then Return False
If $aFiles[0] = 0 Then Return False
Local $wasDebugsetlog = $g_bDebugSetlog
$g_bDebugSetlog = True
SetLog("Checking " & $aFiles[0] & " village screenshots for dead base...")
DirCreate($directory & "\better")
DirCreate($directory & "\worse")
DirCreate($directory & "\same")
Local $iTotalMsSuperNew = 0
Local $iTotalMsNew = 0
Local $iSuperNewFound = 0
Local $iNewFound = 0
Local $iBetter = 0
Local $iWorse = 0
Local $iSame = 0
For $i = 1 To $aFiles[0]
Local $sFile = $aFiles[$i]
Local $srcFile = $directory & "\" & $sFile
Local $hBMP = _GDIPlus_BitmapCreateFromFile($directory & "\" & $sFile)
Local $hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap($hBMP)
_GDIPlus_BitmapDispose($hBMP)
TestCapture($hHBMP)
$g_sImglocRedline = ""
SearchRedLines()
SearchZoomOut(False, True, "checkDeadBaseFolder", False, False)
ConvertInternalExternArea()
For $j = 1 To 2
If Mod($i + $j, 2) = 0 Then
Local $hTimer = __TimerInit()
Execute($executeOldCode)
Local $iMsNew = __TimerDiff($hTimer)
$iTotalMsNew += $iMsNew
$iMsNew = Round($iMsNew)
Local $new = $g_aZombie[3]
$iNewFound += $new
Else
$hTimer = __TimerInit()
Execute($executeNewCode)
Local $iMsSuperNew = __TimerDiff($hTimer)
$iTotalMsSuperNew += $iMsSuperNew
$iMsSuperNew = Round($iMsSuperNew)
Local $superNew = $g_aZombie[3]
$iSuperNewFound += $superNew
EndIf
Next
_WinAPI_DeleteObject($hHBMP)
TestCapture(0)
Local $result = ""
If $superNew > $new Then
SetLog(StringFormat("%5i/%5i", $i, $aFiles[0]) & ": Dead base result: BETTER : " & $superNew & " > " & $new & " (" & StringFormat("%4i/%4i", $iMsSuperNew, $iMsNew) & " ms.) " & $srcFile)
$result = "better"
$iBetter += 1
ElseIf $superNew < $new Then
SetLog(StringFormat("%5i/%5i", $i, $aFiles[0]) & ": Dead base result: WORSE  : " & $superNew & " < " & $new & " (" & StringFormat("%4i/%4i", $iMsSuperNew, $iMsNew) & " ms.) " & $srcFile)
$result = "worse"
$iWorse += 1
Else
SetLog(StringFormat("%5i/%5i", $i, $aFiles[0]) & ": Dead base result: SAME   : " & $superNew & " = " & $new & " (" & StringFormat("%4i/%4i", $iMsSuperNew, $iMsNew) & " ms.) " & $srcFile)
$result = "same"
$iSame += 1
EndIf
Local $dstFile = $directory & "\" & $result & "\" & $sFile
FileMove($srcFile, $dstFile)
Next
SetLog("Checking dead base completed")
SetLog("Super new image detection BETTER : " & $iBetter)
SetLog("Super new image detection WORSE  : " & $iWorse)
SetLog("Super new image detection SAME   : " & $iSame)
SetLog("Collectos found (Super new/new)  : " & $iSuperNewFound & " / " & $iNewFound)
SetLog("Duration in ms. (Super new/new)  : " & Round($iTotalMsSuperNew) & " / " & Round($iTotalMsNew))
$g_bDebugSetlog = $wasDebugsetlog
Return True
EndFunc
Func CheckTombs()
If Not TestCapture() Then
If Not $g_bChkTombstones Then Return False
If Not $g_abNotNeedAllTime[1] Then Return
EndIf
Local $hTimer = __TimerInit()
Local $return[7] = ["None", "None", 0, 0, 0, "", ""]
Local $TombsXY[2] = [0, 0]
Local $aResult = returnSingleMatchOwnVillage($g_sImgClearTombs)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][2]) > Number($return[2]) Then
$return[0] = $aResult[$i][0]
$return[1] = $aResult[$i][1]
$return[4] = $aResult[$i][4]
$return[5] = $aResult[$i][5]
EndIf
Next
$TombsXY = $return[5]
If $g_bDebugSetlog Then SetDebugLog("Filename :" & $return[0])
If $g_bDebugSetlog Then SetDebugLog("Type :" & $return[1])
If $g_bDebugSetlog Then SetDebugLog("Total Objects :" & $return[4])
Local $bRemoved = False
If IsArray($TombsXY) Then
For $j = 0 To UBound($TombsXY) - 1
If isInsideDiamondXY($TombsXY[$j][0], $TombsXY[$j][1]) Then
If $g_bDebugSetlog Then SetDebugLog("Coords :" & $TombsXY[$j][0] & "," & $TombsXY[$j][1])
If IsMainPage() Then
Click($TombsXY[$j][0], $TombsXY[$j][1], 1, 0, "#0430")
If $bRemoved = False Then $bRemoved = IsMainPage()
EndIf
EndIf
Next
EndIf
If $bRemoved Then
SetLog("Tombs removed!", $COLOR_DEBUG1)
$g_abNotNeedAllTime[1] = False
Else
SetLog("Tombs not removed, please do manually!", $COLOR_WARNING)
EndIf
Else
SetLog("No Tombs Found!", $COLOR_SUCCESS)
$g_abNotNeedAllTime[1] = False
EndIf
checkMainScreen(False)
EndFunc
Func CleanYard()
If Not $g_bChkCleanYard And Not $g_bChkGemsBox And Not TestCapture() Then Return
Local $hObstaclesTimer = __TimerInit()
If Not getBuilderCount() Then Return
If _Sleep($DELAYRESPOND) Then Return
Local $Filename = ""
Local $Locate = 0
Local $CleanYardXY
Local $sCocDiamond = $CocDiamondECD
Local $redLines = $sCocDiamond
Local $bNoBuilders = $g_iFreeBuilderCount < 1
If $g_iFreeBuilderCount > 0 And $g_bChkCleanYard = True And Number($g_aiCurrentLoot[$eLootElixir]) > 50000 Then
Local $aResult = findMultiple($g_iDetectedImageType = 1 ? $g_sImgCleanYardSnow : $g_sImgCleanYard, $sCocDiamond, $redLines, 0, 1000, 10, "objectname,objectlevel,objectpoints", True)
If IsArray($aResult) Then
For $matchedValues In $aResult
Local $aPoints = decodeMultipleCoords($matchedValues[2])
$Filename = $matchedValues[0]
For $i = 0 To UBound($aPoints) - 1
$CleanYardXY = $aPoints[$i]
If UBound($CleanYardXY) > 1 And isInsideDiamondXY($CleanYardXY[0], $CleanYardXY[1]) Then
If $g_bDebugSetlog Then SetDebugLog($Filename & " found (" & $CleanYardXY[0] & "," & $CleanYardXY[1] & ")", $COLOR_SUCCESS)
If IsMainPage() Then Click($CleanYardXY[0], $CleanYardXY[1], 1, 0, "#0430")
$Locate = 1
If _Sleep($DELAYCOLLECT3) Then Return
If IsMainPage() Then GemClick($aCleanYard[0], $aCleanYard[1], 1, 0, "#0431")
If _Sleep($DELAYCHECKTOMBS2) Then Return
ClickP($aAway, 2, 300, "#0329")
If _Sleep($DELAYCHECKTOMBS1) Then Return
If getBuilderCount() = False Then Return
If _Sleep($DELAYRESPOND) Then Return
If $g_iFreeBuilderCount = 0 Then
SetLog("No More Builders available")
If _Sleep(2000) Then Return
ExitLoop(2)
EndIf
EndIf
Next
Next
EndIf
EndIf
Local $return[7] = ["None", "None", 0, 0, 0, "", ""]
Local $GemBoxXY[2] = [0, 0]
If($g_iFreeBuilderCount > 0 And $g_bChkGemsBox And Number($g_aiCurrentLoot[$eLootElixir]) > 50000) Or TestCapture() Then
Local $aResult = multiMatches($g_sImgGemBox, 1, $sCocDiamond, $sCocDiamond)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][2]) > Number($return[2]) Then
$return[0] = $aResult[$i][0]
$return[1] = $aResult[$i][1]
$return[4] = $aResult[$i][4]
$return[5] = $aResult[$i][5]
EndIf
Next
$GemBoxXY = $return[5]
If $g_bDebugSetlog Then SetDebugLog("Filename :" & $return[0])
If $g_bDebugSetlog Then SetDebugLog("Type :" & $return[1])
If $g_bDebugSetlog Then SetDebugLog("Total Objects :" & $return[4])
If IsArray($GemBoxXY) Then
For $j = 0 To UBound($GemBoxXY) - 1
If $g_bDebugSetlog Then SetDebugLog("Coords :" & $GemBoxXY[$j][0] & "," & $GemBoxXY[$j][1])
If isInsideDiamondXY($GemBoxXY[$j][0], $GemBoxXY[$j][1]) Then
If IsMainPage() Then Click($GemBoxXY[$j][0], $GemBoxXY[$j][1], 1, 0, "#0430")
If _Sleep($DELAYCHECKTOMBS2) Then Return
$Locate = 1
If _Sleep($DELAYCOLLECT3) Then Return
If IsMainPage() Then Click($aCleanYard[0], $aCleanYard[1], 1, 0, "#0431")
If _Sleep($DELAYCHECKTOMBS2) Then Return
ClickP($aAway, 2, 300, "#0329")
If _Sleep($DELAYCHECKTOMBS1) Then Return
If getBuilderCount() = False Then Return
If _Sleep($DELAYRESPOND) Then Return
If $g_iFreeBuilderCount = 0 Then
SetLog("No More Builders available")
If _Sleep(2000) Then Return
ExitLoop
EndIf
EndIf
Next
EndIf
SetLog("GemBox removed!", $COLOR_DEBUG1)
Else
SetLog("No GemBox Found!", $COLOR_SUCCESS)
EndIf
EndIf
If $bNoBuilders Then
SetLog("No Builders available to remove Obstacles!")
Else
If $Locate = 0 And $g_bChkCleanYard And Number($g_aiCurrentLoot[$eLootElixir]) > 50000 Then SetLog("No Obstacles found, Yard is clean!", $COLOR_SUCCESS)
If $g_bDebugSetlog Then SetDebugLog("Time: " & Round(__TimerDiff($hObstaclesTimer) / 1000, 2) & "'s", $COLOR_SUCCESS)
EndIf
UpdateStats()
ClickP($aAway, 1, 300, "#0329")
EndFunc
Func decodeMultipleCoords($coords, $iDedupX = -1, $iDedupY = -1, $iSorted = -1)
Local $retCoords
Local $aEmpty[1] = [""]
Local $p, $pOff = 0
Local $aCoordsSplit = StringSplit($coords, "|", $STR_NOCOUNT)
If StringInStr($aCoordsSplit[0], ",") > 0 Then
Local $retCoords[UBound($aCoordsSplit)]
Else
$pOff = 1
Local $retCoords[Number($aCoordsSplit[0])]
EndIf
For $p = 0 To UBound($retCoords) - 1
$retCoords[$p] = decodeSingleCoord($aCoordsSplit[$p + $pOff])
Next
If UBound($retCoords) = 0 Then Return $aEmpty
If UBound($retCoords) = 1 Or($iDedupX < 1 And $iDedupY < 1 And $iSorted = -1) Then Return $retCoords
If $iDedupX > 0 Or $iDedupY > 0 Then
Local $aFinalCoords[1] = [$retCoords[0]]
Local $c1, $c2, $k, $inX, $inY
For $i = 1 To UBound($retCoords) - 1
$c1 = $retCoords[$i]
$k = UBound($aFinalCoords) - 1
For $j = 0 To $k
$c2 = $aFinalCoords[$j]
$inX = Abs($c1[0] - $c2[0]) < $iDedupX
$inY = Abs($c1[1] - $c2[1]) < $iDedupY
If($iDedupY < 1 And $inX) Or($iDedupX < 1 And $inY) Or($inX And $inY) Then
ContinueLoop 2
EndIf
Next
ReDim $aFinalCoords[$k + 2]
$aFinalCoords[$k + 1] = $c1
Next
Else
Local $aFinalCoords = $retCoords
EndIf
If $iSorted = 0 Or $iSorted = 1 Then
Local $a[UBound($aFinalCoords)][2]
For $i = 0 To UBound($aFinalCoords) - 1
$c1 = $aFinalCoords[$i]
$a[$i][0] = $c1[0]
$a[$i][1] = $c1[1]
Next
_ArraySort($a, 0, 0, 0, $iSorted)
For $i = 0 To UBound($a) - 1
$c1 = $aFinalCoords[$i]
$c1[0] = $a[$i][0]
$c1[1] = $a[$i][1]
$aFinalCoords[$i] = $c1
Next
EndIf
Return $aFinalCoords
EndFunc
Func decodeSingleCoord($coords)
Local $aCoordsSplit = StringSplit($coords, ",", $STR_NOCOUNT)
If UBound($aCoordsSplit) > 1 Then
$aCoordsSplit[0] = Int($aCoordsSplit[0])
$aCoordsSplit[1] = Int($aCoordsSplit[1])
EndIf
Return $aCoordsSplit
EndFunc
Func RetrieveImglocProperty($key, $property)
Local $aValue = DllCall($g_hLibMyBot, "str", "GetProperty", "str", $key, "str", $property)
If @error Then _logErrorDLLCall($g_sLibMyBotPath, @error)
If UBound($aValue) = 0 Then
Return ""
EndIf
Return $aValue[0]
EndFunc
Func checkImglocError(ByRef $imglocvalue, $funcName, $sTileSource = "")
If IsArray($imglocvalue) Then
If $imglocvalue[0] = "0" Or $imglocvalue[0] = "" Then
If $g_bDebugSetlog Then SetDebugLog($funcName & " imgloc search returned no results" &($sTileSource ? " for '" & $sTileSource & "' !" : "!"), $COLOR_WARNING)
Return True
ElseIf StringLeft($imglocvalue[0], 2) = "-1" Then
If $g_bDebugSetlog Then SetDebugLog($funcName & " - Imgloc DLL Error: " + $imglocvalue[0], $COLOR_ERROR)
Return True
ElseIf StringLeft($imglocvalue[0], 2) = "-2" Then
SetLog($funcName & " - Imgloc DLL Critical Error", $COLOR_RED)
SetLog(StringMid($imglocvalue[0], 4), $COLOR_RED)
SetLog("Restart bot in 3 Minutes...", $COLOR_GREEN)
If _SleepStatus(180000) = False Then
RestartBot(False, True)
EndIf
Return True
Else
Return False
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog($funcName & " - Imgloc  Error: Not an Array Result", $COLOR_ERROR)
Return True
EndIf
EndFunc
Func findButton($sButtonName, $buttonTileArrayOrPatternOrFullPath = Default, $maxReturnPoints = 1, $bForceCapture = True)
If $buttonTileArrayOrPatternOrFullPath = Default Then $buttonTileArrayOrPatternOrFullPath = $sButtonName & "*"
Local $error, $extError
Local $searchArea = GetButtonDiamond($sButtonName)
Local $aCoords = ""
Local $aButtons
Local $sButtons = ""
If IsString($buttonTileArrayOrPatternOrFullPath) Then
$sButtons = $buttonTileArrayOrPatternOrFullPath
If StringInStr($buttonTileArrayOrPatternOrFullPath, "*") > 0 Then
Local $aFiles = _FileListToArray($g_sImgImgLocButtons, $sButtons, $FLTA_FILES, True)
If UBound($aFiles) < 2 Or $aFiles[0] < 1 Then
Return SetError(1, 1, "No files in " & $g_sImgImgLocButtons)
EndIf
Local $a[0], $j
$j = 0
For $i = 1 To $aFiles[0]
If StringRegExp($aFiles[$i], ".+[.](xml|png|bmp)$") Then
$j += 1
ReDim $a[$j]
$a[$i - 1] = $aFiles[$i]
EndIf
Next
$aButtons = $a
Else
Local $a[1] = [$sButtons]
$aButtons = $a
EndIf
ElseIf IsArray($buttonTileArrayOrPatternOrFullPath) Then
$aButtons = $buttonTileArrayOrPatternOrFullPath
$sButtons = _ArrayToString($aButtons)
Else
Return SetError(1, 2, "Bad Input Values : " & $buttonTileArrayOrPatternOrFullPath)
EndIf
If Not IsString($sButtonName) Or UBound($aButtons) < 1 Then
Return SetError(1, 3, "Bad Input Values : " & $sButtons)
EndIf
For $buttonTile In $aButtons
If FileExists($buttonTile) = 0 Then
Return SetError(1, 4, "Bad Input Values : Button Image NOT FOUND : " & $buttonTile)
EndIf
If $bForceCapture Then _CaptureRegion2()
If $g_bDebugSetlog Then SetDebugLog(" imgloc searching for: " & $sButtonName & " : " & $buttonTile)
Local $result = DllCallMyBot("FindTile", "handle", $g_hHBitmap2, "str", $buttonTile, "str", $searchArea, "Int", $maxReturnPoints)
$error = @error
$extError = @extended
If $error Then
_logErrorDLLCall($g_sLibMyBotPath, $error)
SetDebugLog(" imgloc DLL Error imgloc " & $error & " --- " & $extError)
Return SetError(2, 1, $extError)
EndIf
If $result[0] <> "" And checkImglocError($result, "imglocFindButton", $buttonTile) = False Then
If $g_bDebugSetlog Then SetDebugLog($sButtonName & " Button Image Found in: " & $result[0])
$aCoords = StringSplit($result[0], "|", $STR_NOCOUNT)
If $maxReturnPoints = 1 Then
Return StringSplit($aCoords[1], ",", $STR_NOCOUNT)
Else
Return $result[0]
EndIf
EndIf
Next
SetDebugLog($sButtonName & " Button Image(s) NOT FOUND : " & $sButtons, $COLOR_ERROR)
Return $aCoords
EndFunc
Func GetButtonDiamond($sButtonName)
Local $btnDiamond = "FV"
Switch $sButtonName
Case "FindMatch"
$btnDiamond = "133,515|360,515|360,620|133,620"
Case "CloseFindMatch"
$btnDiamond = "780,15|830,15|830,60|780,60"
Case "CloseFindMatch"
$btnDiamond = "780,15|830,15|830,60|780,60"
Case "Attack"
$btnDiamond = "15,620|112,620|112,715|15,715"
Case "OpenTrainWindow"
$btnDiamond = "15,560|65,560|65,610|15,610"
Case "OK"
$btnDiamond = "440,395|587,395|587,460|440,460"
Case "CANCEL"
$btnDiamond = "272,395|420,395|420,460|272,460"
Case "ReturnHome"
$btnDiamond = "357,545|502,545|502,607|357,607"
Case "Next"
$btnDiamond = "697,542|850,542|850,610|697,610"
Case "ObjectButtons", "BoostOne", "BoostCT"
$btnDiamond = GetDiamondFromRect("200,617(460,83)")
Case "GEM", "BOOSTBtn"
$btnDiamond = GetDiamondFromRect("359,412(148,66)")
Case "EnterShop"
$btnDiamond = GetDiamondFromRect("359,392(148,66)")
Case "EndBattleSurrender"
$btnDiamond = "12,577|125,577|125,615|12,615"
Case "ExpandChat"
$btnDiamond = "2,330|35,350|35,410|2,430"
Case "CollapseChat"
$btnDiamond = "315,334|350,350|350,410|315,430"
Case "ChatOpenRequestPage"
$btnDiamond = "5,688|65,688|65,615|5,725"
Case "Profile"
$btnDiamond = "172,15|205,15|205,48|172,48"
Case "DonateWindow"
$btnDiamond = "310,0|360,0|360,732|310,732"
Case "DonateButton"
$btnDiamond = "200,85|305,85|305,680|200,680"
Case "UpDonation"
$btnDiamond = "282,85|306,85|306,130|282,130"
Case "DownDonation"
$btnDiamond = "282,635|306,635|306,680|282,680"
Case "Treasury"
$btnDiamond = "125,610|740,610|740,715|125,715"
Case "Collect"
$btnDiamond = "350,450|505,450|505,521|350,521"
Case "BoostBarrack", "BarrackBoosted"
$btnDiamond = GetDiamondFromRect("630,280,850,360")
Case "ArmyTab", "TrainTroopsTab", "BrewSpellsTab", "BuildSiegeMachinesTab", "QuickTrainTab"
$btnDiamond = GetDiamondFromRect("18,100,800,150")
Case Else
$btnDiamond = "FV"
EndSwitch
Return $btnDiamond
EndFunc
Func UpdateImgeTile(ByRef $sImageTile, $AndroidTag = Default)
Local $iMinimumAndroidVersion = Int($AndroidTag)
If $iMinimumAndroidVersion > 1 And $g_iAndroidVersionAPI < $iMinimumAndroidVersion Then
Return False
EndIf
If Not IsBool($AndroidTag) Then
If $iMinimumAndroidVersion > 0 Then
$AndroidTag = True
Else
$AndroidTag = False
EndIf
EndIf
If $AndroidTag Then
$sImageTile = StringReplace($sImageTile, "[Android]", GetAndroidCodeName())
If $iMinimumAndroidVersion > 1 And @extended = 0 Then
SetDebugLog("Android Code Name cannot be added to title: " & $sImageTile, $COLOR_ERROR)
EndIf
EndIf
Return True
EndFunc
Func findImage($sImageName, $sImageTile, $sImageArea, $maxReturnPoints = 1, $bForceCapture = True, $AndroidTag = Default)
If $AndroidTag = Default Then $AndroidTag = True
Local $aCoords = ""
Local $iPattern = StringInStr($sImageTile, "*")
If Not UpdateImgeTile($sImageTile, $AndroidTag) Then Return $aCoords
If $iPattern > 0 Then
Local $dir = ""
Local $pat = $sImageTile
Local $iLastBS = StringInStr($sImageTile, "\", 0, -1)
If $iLastBS > 0 Then
$dir = StringLeft($sImageTile, $iLastBS)
$pat = StringMid($sImageTile, $iLastBS + 1)
EndIf
Local $files = _FileListToArray($dir, $pat, $FLTA_FILES, True)
If @error Or UBound($files) < 2 Then
If $g_bDebugSetlog Then SetDebugLog("findImage files not found : " & $sImageTile, $COLOR_ERROR)
SetError(1, 0, $aCoords)
Return
EndIf
For $i = 1 To $files[0]
$aCoords = findImage($sImageName, $files[$i], $sImageArea, $maxReturnPoints, $bForceCapture)
If UBound(decodeSingleCoord($aCoords)) > 1 Then Return $aCoords
Next
Return $aCoords
EndIf
Local $error, $extError
If Not FileExists($sImageTile) Then
If $g_bDebugSetlog Then SetDebugLog("findImage file not found : " & $sImageTile, $COLOR_ERROR)
SetError(1, 1, $aCoords)
Return
EndIf
If $bForceCapture Then _CaptureRegion2()
Local $result = DllCallMyBot("FindTile", "handle", $g_hHBitmap2, "str", $sImageTile, "str", $sImageArea, "Int", $maxReturnPoints)
$error = @error
$extError = @extended
If $error Then
_logErrorDLLCall($g_sLibMyBotPath, $error)
If $g_bDebugSetlog Then SetDebugLog(" imgloc DLL Error imgloc " & $error & " --- " & $extError)
SetError(2, $extError, $aCoords)
Return
EndIf
If checkImglocError($result, "findImage", $sImageTile) = True Then
If $g_bDebugSetlog And $g_bDebugImageSave Then DebugImageSave("findImage_" & $sImageName, True)
Return $aCoords
EndIf
If $result[0] <> "" Then
If $g_bDebugSetlog Then SetDebugLog("findImage : " & $sImageName & " Found in: " & $result[0])
$aCoords = StringSplit($result[0], "|", $STR_NOCOUNT)
If $maxReturnPoints = 1 Then
Return $aCoords[1]
Else
Return $result[0]
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("findImage : " & $sImageName & " NOT FOUND " & $sImageTile)
If $g_bDebugSetlog And $g_bDebugImageSave Then DebugImageSave("findImage_" & $sImageName, True)
Return $aCoords
EndIf
EndFunc
Func GetDeployableNextTo($sPoints, $distance = 3, $redlineoverride = "")
Local $result = DllCall($g_hLibMyBot, "str", "GetDeployableNextTo", "str", $sPoints, "int", $distance, "str", $redlineoverride)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_sLibMyBotPath, $error)
If $g_bDebugSetlog Then SetDebugLog(" imgloc DLL Error imgloc " & $error & " --- " & $extError)
SetError(2, $extError, "")
Return ""
EndIf
If UBound($result) = 0 Then Return ""
If $g_bDebugSetlog Then SetDebugLog("GetDeployableNextTo : " & $sPoints & ", dist. = " & $distance & " : " & $result[0], $COLOR_ORANGE)
Return $result[0]
EndFunc
Func GetOffsetRedline($sArea = "TL", $distance = 3)
Local $result = DllCall($g_hLibMyBot, "str", "GetOffSetRedline", "str", $sArea, "int", $distance)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_sLibMyBotPath, $error)
If $g_bDebugSetlog Then SetDebugLog(" imgloc DLL Error imgloc " & $error & " --- " & $extError)
SetError(2, $extError, "")
Return ""
EndIf
If UBound($result) = 0 Then Return ""
If $g_bDebugSetlog Then SetDebugLog("GetOffSetRedline : " & $sArea & ", dist. = " & $distance & " : " & $result[0], $COLOR_ORANGE)
Return $result[0]
EndFunc
Func findMultiple($directory, $sCocDiamond, $redLines, $minLevel = 0, $maxLevel = 1000, $maxReturnPoints = 0, $returnProps = "objectname,objectlevel,objectpoints", $bForceCapture = True)
If $g_bDebugSetlog Then
SetDebugLog("******** findMultiple *** START ***", $COLOR_ORANGE)
SetDebugLog("findMultiple : directory : " & $directory, $COLOR_ORANGE)
SetDebugLog("findMultiple : sCocDiamond : " & $sCocDiamond, $COLOR_ORANGE)
SetDebugLog("findMultiple : redLines : " & $redLines, $COLOR_ORANGE)
SetDebugLog("findMultiple : minLevel : " & $minLevel, $COLOR_ORANGE)
SetDebugLog("findMultiple : maxLevel : " & $maxLevel, $COLOR_ORANGE)
SetDebugLog("findMultiple : maxReturnPoints : " & $maxReturnPoints, $COLOR_ORANGE)
SetDebugLog("findMultiple : returnProps : " & $returnProps, $COLOR_ORANGE)
SetDebugLog("******** findMultiple *** START ***", $COLOR_ORANGE)
EndIf
Local $error, $extError
Local $aCoords = ""
Local $returnData = StringSplit($returnProps, ",", $STR_NOCOUNT)
Local $returnLine[UBound($returnData)]
Local $returnValues[0]
If $bForceCapture Then _CaptureRegion2()
Local $result = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $directory, "str", $sCocDiamond, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
$error = @error
$extError = @extended
If $error Then
_logErrorDLLCall($g_sLibMyBotPath, $error)
If $g_bDebugSetlog Then SetDebugLog(" imgloc DLL Error : " & $error & " --- " & $extError)
SetError(2, $extError, $aCoords)
Return ""
EndIf
If checkImglocError($result, "findMultiple", $directory) = True Then
If $g_bDebugSetlog Then SetDebugLog("findMultiple Returned Error or No values : ", $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("******** findMultiple *** END ***", $COLOR_ORANGE)
Return ""
Else
If $g_bDebugSetlog Then SetDebugLog("findMultiple found : " & $result[0])
EndIf
If $result[0] <> "" Then
Local $resultArr = StringSplit($result[0], "|", $STR_NOCOUNT)
ReDim $returnValues[UBound($resultArr)]
For $rs = 0 To UBound($resultArr) - 1
For $rD = 0 To UBound($returnData) - 1
$returnLine[$rD] = RetrieveImglocProperty($resultArr[$rs], $returnData[$rD])
If $g_bDebugSetlog Then SetDebugLog("findMultiple : " & $resultArr[$rs] & "->" & $returnData[$rD] & " -> " & $returnLine[$rD])
Next
$returnValues[$rs] = $returnLine
Next
If $redLines = "" Then
$g_sImglocRedline = RetrieveImglocProperty("redline", "")
If $g_bDebugSetlog Then SetDebugLog("findMultiple : Redline argument is emty, seting global Redlines")
EndIf
If $g_bDebugSetlog Then SetDebugLog("******** findMultiple *** END ***", $COLOR_ORANGE)
Return $returnValues
Else
If $g_bDebugSetlog Then SetDebugLog(" ***  findMultiple has no result **** ", $COLOR_ORANGE)
If $g_bDebugSetlog Then SetDebugLog("******** findMultiple *** END ***", $COLOR_ORANGE)
Return ""
EndIf
EndFunc
Func GetRectArray($rect, $bLogError = True)
Local $a = []
Local $RectValues = StringSplit($rect, ",", $STR_NOCOUNT)
If UBound($RectValues) = 3 Then
ReDim $RectValues[4]
$i = StringInStr($RectValues[2], ")")
If $i = 0 Then
If $bLogError Then SetDebugLog("GetRectArray : Bad Input Values : " & $rect, $COLOR_ERROR)
Return SetError(1, 1, $a)
EndIf
$RectValues[3] = $RectValues[1] + StringLeft($RectValues[2], $i - 1)
$i = StringInStr($RectValues[1], "(")
If $i = 0 Then
If $bLogError Then SetDebugLog("GetRectArray : Bad Input Values : " & $rect, $COLOR_ERROR)
Return SetError(1, 2, $a)
EndIf
$RectValues[2] = $RectValues[0] + StringMid($RectValues[1], $i + 1)
$RectValues[1] = StringLeft($RectValues[1], $i - 1)
EndIf
If UBound($RectValues) < 4 Then
If $bLogError Then SetDebugLog("GetRectArray : Bad Input Values : " & $rect, $COLOR_ERROR)
Return SetError(1, 3, $a)
EndIf
Return SetError(0, 0, $RectValues)
EndFunc
Func GetDiamondFromRect($rect)
SetError(0)
Local $returnvalue = "", $i
Local $RectValues = IsArray($rect) ? $rect : GetRectArray($rect, False)
Local $error = @error, $extended = @extended
If UBound($RectValues) < 4 Then
If $error = 0 Then $error = 1
SetDebugLog("GetDiamondFromRect : Bad Input Values : " & $rect, $COLOR_ERROR)
Return SetError($error, $extended, $returnvalue)
EndIf
Local $DiamdValues[4]
Local $X = Number($RectValues[0])
Local $Y = Number($RectValues[1])
Local $Ex = Number($RectValues[2])
Local $Ey = Number($RectValues[3])
$DiamdValues[0] = $X & "," & $Y
$DiamdValues[1] = $Ex & "," & $Y
$DiamdValues[2] = $Ex & "," & $Ey
$DiamdValues[3] = $X & "," & $Ey
$returnvalue = $DiamdValues[0] & "|" & $DiamdValues[1] & "|" & $DiamdValues[2] & "|" & $DiamdValues[3]
Return $returnvalue
EndFunc
Func FindImageInPlace($sImageName, $sImageTile, $place, $bForceCaptureRegion = True, $AndroidTag = Default)
If $g_bDebugSetlog Then SetDebugLog("FindImageInPlace : > " & $sImageName & " - " & $sImageTile & " - " & $place, $COLOR_INFO)
Local $returnvalue = ""
Local $aPlaces = GetRectArray($place)
Local $sImageArea = GetDiamondFromRect($aPlaces)
If $bForceCaptureRegion = True Then
$sImageArea = "FV"
_CaptureRegion2(Number($aPlaces[0]), Number($aPlaces[1]), Number($aPlaces[2]), Number($aPlaces[3]))
EndIf
Local $coords = findImage($sImageName, $sImageTile, $sImageArea, 1, False, $AndroidTag)
Local $aCoords = decodeSingleCoord($coords)
If UBound($aCoords) < 2 Then
If $g_bDebugSetlog Then SetDebugLog("FindImageInPlace : " & $sImageName & " NOT Found", $COLOR_INFO)
Return ""
EndIf
If $bForceCaptureRegion Then
$returnvalue = Number($aCoords[0]) + Number($aPlaces[0]) & "," & Number($aCoords[1]) + Number($aPlaces[1])
Else
$returnvalue = Number($aCoords[0]) & "," & Number($aCoords[1])
EndIf
If $g_bDebugSetlog Then SetDebugLog("FindImageInPlace : < " & $sImageName & " Found in " & $returnvalue, $COLOR_INFO)
Return $returnvalue
EndFunc
Func SearchRedLines($sCocDiamond = "ECD")
If $g_sImglocRedline <> "" Then Return $g_sImglocRedline
Local $result = DllCallMyBot("SearchRedLines", "handle", $g_hHBitmap2, "str", $sCocDiamond)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_sLibMyBotPath, $error)
If $g_bDebugSetlog Then SetDebugLog(" imgloc DLL Error : " & $error & " --- " & $extError)
SetError(2, $extError)
Return ""
EndIf
If checkImglocError($result, "SearchRedLines") = True Then
If $g_bDebugSetlog Then SetDebugLog("SearchRedLines Returned Error or No values : ", $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("******** SearchRedLines *** END ***", $COLOR_ORANGE)
Return ""
Else
If $g_bDebugSetlog Then SetDebugLog("SearchRedLines found : " & $result[0])
EndIf
$g_sImglocRedline = $result[0]
Return $g_sImglocRedline
EndFunc
Func SearchRedLinesMultipleTimes($sCocDiamond = "ECD", $iCount = 3, $iDelay = 300)
Local $bHBitmap_synced =($g_hHBitmap = $g_hHBitmap2)
Local $g_hHBitmap2_old = $g_hHBitmap2
Local $g_sImglocRedline_old
SearchRedLines($sCocDiamond)
Local $iRedlinePoints = [UBound(StringSplit($g_sImglocRedline, "|", $STR_NOCOUNT)), 0]
SetDebugLog("Initial # of redline points: " & $iRedlinePoints[0])
$g_hHBitmap2 = 0
Local $iCaptureTime = 0
Local $iRedlineTime = 0
Local $aiTotals = [0, 0]
Local $iBest = 0
For $i = 1 To $iCount
$g_sImglocRedline_old = $g_sImglocRedline
Local $hTimer = __TimerInit()
ForceCaptureRegion()
_CaptureRegion2()
$iCaptureTime = __TimerDiff($hTimer)
$g_sImglocRedline = ""
SearchRedLines($sCocDiamond)
$iRedlineTime = __TimerDiff($hTimer) - $iCaptureTime
$aiTotals[0] += $iCaptureTime
$aiTotals[1] += $iRedlineTime
$iRedlinePoints[1] = UBound(StringSplit($g_sImglocRedline, "|", $STR_NOCOUNT))
SetDebugLog($i & ". # of redline points: " & $iRedlinePoints[1])
If $iRedlinePoints[1] > $iRedlinePoints[0] Then
$iRedlinePoints[0] = $iRedlinePoints[1]
$iBest = $i
Else
$g_sImglocRedline = $g_sImglocRedline_old
EndIf
If $i < $iCount Then
Local $iDelayCompensated = $iDelay - __TimerDiff($hTimer)
If $iDelayCompensated >= 10 Then Sleep($iDelayCompensated)
EndIf
Next
If $iBest = 0 Then
SetDebugLog("Using initial redline with " & $iRedlinePoints[0] & " points")
Else
SetDebugLog("Using " & $iBest & ". redline with " & $iRedlinePoints[0] & " points (capture/redline avg. time: " & Int($aiTotals[0] / $iCount) & "/" & Int($aiTotals[1] / $iCount) & ")")
EndIf
GdiDeleteHBitmap($g_hHBitmap2)
If $bHBitmap_synced Then
_CaptureRegion2Sync()
Else
$g_hHBitmap2 = $g_hHBitmap2_old
EndIf
Return $g_sImglocRedline
EndFunc
Func decodeTroopEnum($tEnum)
Switch $tEnum
Case $eBarb
Return "Barbarian"
Case $eArch
Return "Archer"
Case $eBall
Return "Balloon"
Case $eDrag
Return "Dragon"
Case $eGiant
Return "Giant"
Case $eGobl
Return "Goblin"
Case $eGole
Return "Golem"
Case $eHeal
Return "Healer"
Case $eHogs
Return "HogRider"
Case $eKing
Return "King"
Case $eLava
Return "LavaHound"
Case $eMini
Return "Minion"
Case $ePekk
Return "Pekka"
Case $eQueen
Return "Queen"
Case $eValk
Return "Valkyrie"
Case $eWall
Return "WallBreaker"
Case $eWarden
Return "Warden"
Case $eWitc
Return "Witch"
Case $eWiza
Return "Wizard"
Case $eBabyD
Return "BabyDragon"
Case $eMine
Return "Miner"
Case $eEDrag
Return "ElectroDragon"
Case $eBowl
Return "Bowler"
Case $eESpell
Return "EarthquakeSpell"
Case $eFSpell
Return "FreezeSpell"
Case $eHaSpell
Return "HasteSpell"
Case $eHSpell
Return "HealSpell"
Case $eJSpell
Return "JumpSpell"
Case $eLSpell
Return "LightningSpell"
Case $ePSpell
Return "PoisonSpell"
Case $eRSpell
Return "RageSpell"
Case $eSkSpell
Return "SkeletonSpell"
Case $eCSpell
Return "CloneSpell"
Case $eCastle
Return "Castle"
EndSwitch
EndFunc
Func decodeTroopName($sName)
Switch $sName
Case "Barbarian"
Return $eBarb
Case "Archer"
Return $eArch
Case "Balloon"
Return $eBall
Case "Dragon"
Return $eDrag
Case "Giant"
Return $eGiant
Case "Goblin"
Return $eGobl
Case "Golem"
Return $eGole
Case "Healer"
Return $eHeal
Case "HogRider"
Return $eHogs
Case "King"
Return $eKing
Case "LavaHound"
Return $eLava
Case "Minion"
Return $eMini
Case "Pekka"
Return $ePekk
Case "Queen"
Return $eQueen
Case "Valkyrie"
Return $eValk
Case "WallBreaker"
Return $eWall
Case "Warden"
Return $eWarden
Case "Witch"
Return $eWitc
Case "Wizard"
Return $eWiza
Case "BabyDragon"
Return $eBabyD
Case "Miner"
Return $eMine
Case "ElectroDragon"
Return $eEDrag
Case "Bowler"
Return $eBowl
Case "EarthquakeSpell"
Return $eESpell
Case "FreezeSpell"
Return $eFSpell
Case "HasteSpell"
Return $eHaSpell
Case "HealSpell"
Return $eHSpell
Case "JumpSpell"
Return $eJSpell
Case "LightningSpell"
Return $eLSpell
Case "PoisonSpell"
Return $ePSpell
Case "RageSpell"
Return $eRSpell
Case "SkeletonSpell"
Return $eSkSpell
Case "CloneSpell"
Return $eCSpell
Case "Castle"
Return $eCastle
EndSwitch
EndFunc
Func Slot($iX, $iY)
If $iY < 490 Then
Switch $iX
Case 0 To 94
If $iY < 315 Then Return 35
If $iY > 315 Then Return 40
Case 95 To 170
If $iY < 315 Then Return 111
If $iY > 315 Then Return 120
Case 171 To 243
If $iY < 315 Then Return 184
If $iY > 315 Then Return 195
Case 244 To 307
If $iY < 315 Then Return 255
If $iY > 315 Then Return 272
Case 308 To 392
If $iY < 315 Then Return 330
If $iY > 315 Then Return 341
Case 393 To 464
If $iY < 315 Then Return 403
If $iY > 315 Then Return 415
Case 465 To 537
If $iY < 315 Then Return 477
If $iY > 315 Then Return 485
Case 538 To 610
Return 551
Case 611 To 682
If $iY < 315 Then Return 625
If $iY > 315 Then Return 619
Case 683 To 752
If $iY < 315 Then Return 694
If $iY > 315 Then Return 691
Case 753 To 825
Return 764
EndSwitch
Else
Switch $iX
Case 0 To 94
Return 35
Case 95 To 170
Return 111
Case 171 To 243
Return 184
Case 244 To 307
Return 255
Case 308 To 392
Return 330
Case 393 To 464
Return 403
Case 510 To 580
Return 533
Case 581 To 599
Return 578
Case 600 To 660
Return 610
EndSwitch
EndIf
EndFunc
Func GetDummyRectangle($sCoords, $ndistance)
Local $aCoords = StringSplit($sCoords, ",", $STR_NOCOUNT)
Return Number($aCoords[0]) - $ndistance & "," & Number($aCoords[1]) - $ndistance & "," & Number($aCoords[0]) + $ndistance & "," & Number($aCoords[1]) + $ndistance
EndFunc
Func imglocCheckWall()
Local $iXClickOffset = 0
Local $iYClickOffset = 0
Local $iXRange = 16
Local $iYRange = 14
Local $iLastGoodWallx = $g_aiLastGoodWallPos[0]
Local $iLastGoodWally = $g_aiLastGoodWallPos[1]
ConvertToVillagePos($iLastGoodWallx, $iLastGoodWally)
If _Sleep(500) Then Return
Local $levelWall = $g_iCmbUpgradeWallsLevel + 4
Switch $levelWall
Case 10
$iXClickOffset = 2
$iYClickOffset = 2
Case 11
$iXClickOffset = 1
$iYClickOffset = -2
EndSwitch
SetLog("Searching for Wall(s) level: " & $levelWall & ". Using imgloc: ", $COLOR_SUCCESS)
Local $FoundWalls[1]
$FoundWalls[0] = ""
If($g_aiLastGoodWallPos[0] > 0) And($g_aiLastGoodWallPos[1] > 0) Then
_CaptureRegion2($iLastGoodWallx - $iXRange, $iLastGoodWally - $iYRange, $iLastGoodWallx + $iXRange, $iLastGoodWally + $iYRange)
$FoundWalls = imglocFindWalls($levelWall, "FV", "FV", 4)
If $g_bDebugImageSave Then DebugImageSave("WallUpgrade", False)
EndIf
If($FoundWalls[0] = "") Then
$g_aiLastGoodWallPos[0] = -1
$g_aiLastGoodWallPos[1] = -1
SetLog("No wall(s) next to previously upgraded found.", $COLOR_ERROR)
SetLog("Looking further away.", $COLOR_SUCCESS)
_CaptureRegion2()
$FoundWalls = imglocFindWalls($levelWall, "ECD", "ECD", 10)
EndIf
ClickP($aAway, 1, 0, "#0505")
If($FoundWalls[0] = "") Then
SetLog("No wall(s) level: " & $levelWall & " found.", $COLOR_ERROR)
Else
For $i = 0 To UBound($FoundWalls) - 1
Local $WallCoordsArray = decodeMultipleCoords($FoundWalls[$i])
SetLog("Found: " & UBound($WallCoordsArray) & " possible Wall position: " & $FoundWalls[$i], $COLOR_SUCCESS)
If($g_aiLastGoodWallPos[0] > 0) And($g_aiLastGoodWallPos[1] > 0) Then
SetLog("relative to " &($iLastGoodWallx - $iXRange) & ", " &($iLastGoodWally - $iYRange) & ".", $COLOR_SUCCESS)
EndIf
For $fc = 0 To UBound($WallCoordsArray) - 1
Local $aCoord = $WallCoordsArray[$fc]
If($g_aiLastGoodWallPos[0] > 0) And($g_aiLastGoodWallPos[1] > 0) Then
$aCoord[0] = $aCoord[0] + $iLastGoodWallx - $iXRange
$aCoord[1] = $aCoord[1] + $iLastGoodWally - $iYRange
EndIf
$aCoord[0] = $aCoord[0] + $iXClickOffset
$aCoord[1] = $aCoord[1] + $iYClickOffset
SetLog("Checking if found position is a Wall and of desired level.", $COLOR_SUCCESS)
GemClick($aCoord[0], $aCoord[1])
If _Sleep(500) Then Return
Local $aResult = BuildingInfo(245, 520 + $g_iBottomOffsetY)
If $aResult[0] = 2 Then
If StringInStr($aResult[1], "wall") = True And Number($aResult[2]) = $levelWall Then
SetLog("Position : " & $aCoord[0] & ", " & $aCoord[1] & " is a Wall Level: " & $levelWall & ".")
$g_aiLastGoodWallPos[0] = $aCoord[0]
$g_aiLastGoodWallPos[1] = $aCoord[1]
ConvertFromVillagePos($g_aiLastGoodWallPos[0],$g_aiLastGoodWallPos[1])
Return True
Else
ClickP($aAway, 1, 0, "#0931")
If $g_bDebugSetlog Then
SetDebugLog("Position : " & $aCoord[0] & ", " & $aCoord[1] & " is not a Wall Level: " & $levelWall & ". It was: " & $aResult[1] & ", " & $aResult[2] & " !", $COLOR_DEBUG)
Else
SetLog("Position : " & $aCoord[0] & ", " & $aCoord[1] & " is not a Wall Level: " & $levelWall & ".", $COLOR_ERROR)
SetDebugLog("It was: " & $aResult[1] & ", " & $aResult[2], $COLOR_DEBUG, True)
EndIf
EndIf
Else
ClickP($aAway, 1, 0, "#0932")
EndIf
Next
Next
$g_aiLastGoodWallPos[0] = -1
$g_aiLastGoodWallPos[1] = -1
EndIf
Return False
EndFunc
Func imglocFindWalls($walllevel, $searcharea = "DCD", $redline = "", $maxreturn = 0)
Local $FoundWalls[1] = [""]
Local $redLines = $redline
Local $minLevel = $walllevel
Local $maxLevel = $walllevel
Local $maxReturnPoints = $maxreturn
Local $result = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $g_sImgCheckWallDir, "str", $searcharea, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_sLibMyBotPath, $error)
SetLog(" imgloc DLL Error imgloc " & $error & " --- " & $extError, $COLOR_RED)
SetError(2, $extError, $error)
Return
EndIf
If checkImglocError($result, "imglocFindWalls", $g_sImgCheckWallDir) = True Then
Return $FoundWalls
EndIf
If $result[0] <> "" Then
If $g_bDebugSetlog Then SetDebugLog(" imglocFindMyWall search returned : " & $result[0])
Local $aKeys = StringSplit($result[0], "|", $STR_NOCOUNT)
ReDim $FoundWalls[UBound($aKeys)]
For $i = 0 To UBound($aKeys) - 1
Local $aCoords = RetrieveImglocProperty($aKeys[$i], "objectpoints")
$FoundWalls[$i] = $aCoords
Next
EndIf
Return $FoundWalls
EndFunc
Global $IMGLOCTHLOCATION
Global $IMGLOCTHNEAR
Global $IMGLOCTHFAR
Global $IMGLOCTHRDISTANCE
Func imglocTHSearch($bReTest = False, $myVillage = False, $bForceCapture = True)
Local $xdirectory = "imglocth-bundle"
Local $xdirectoryb = "imglocth2-bundle"
Local $sCocDiamond = "ECD"
Local $redLines = ""
Local $minLevel = 6
Local $maxLevel = 100
Local $maxReturnPoints = 1
Local $returnProps = "objectname,objectlevel,objectpoints,nearpoints,farpoints,redlinedistance"
Local $iFindTime = 0
If $myVillage = False Then
ResetTHsearch()
$redLines = "ECD"
Else
$redLines = "ECD"
EndIf
Local $propsNames = StringSplit($returnProps, ",", $STR_NOCOUNT)
If $g_bDebugSetlog Then SetDebugLog("imgloc TH search Start", $COLOR_DEBUG)
Local $numRetry = 1
For $retry = 0 To $numRetry
Local $iLvlFound = 0
If $retry > 0 Then $xdirectory = $xdirectoryb
If $g_iDetectedImageType = 1 Then
$xdirectory = "snow-" & $xdirectory
EndIf
If $retry > 0 And $g_sImglocRedline <> "" Then
EndIf
Local $hTimer = __TimerInit()
Local $result = findMultiple($xdirectory, $sCocDiamond, $redLines, $minLevel, $maxLevel, $maxReturnPoints, $returnProps, $bForceCapture)
If IsArray($result) Then
If $g_sImglocRedline <> "" Then
_ObjPutValue($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS", $g_sImglocRedline)
If @error Then _ObjErrMsg("_ObjPutValue $g_oBldgAttackInfo imglocTHSearch", @error)
Local $aCoordsSplit = StringSplit($g_sImglocRedline, "|")
Local $redlinesCount = $aCoordsSplit[0]
_ObjPutValue($g_oBldgAttackInfo, $eBldgRedLine & "_COUNT", $redlinesCount)
If @error Then _ObjErrMsg("_ObjPutValue $g_oBldgAttackInfo imglocTHSearch", @error)
EndIf
Local $iBestResult = 0
If UBound($result) > 1 Then
If $g_bDebugSetlog Then SetDebugLog("imgloc Found Multiple TH : " & UBound($result), $COLOR_INFO)
Local $iHighestLvl = 0
For $iResult = 0 To UBound($result) - 1
Local $propsValues = $result[$iResult]
For $pv = 0 To UBound($propsValues) - 1
Switch $propsNames[$pv]
Case "objectlevel"
Local $iLvl = Number($propsValues[$pv])
If $iLvl > $iHighestLvl Then
$iHighestLvl = $iLvl
$iBestResult = $iResult
EndIF
EndSwitch
Next
Next
If $g_bDebugSetlog Then SetDebugLog("imgloc Found Multiple TH : Using index " & $iBestResult, $COLOR_INFO)
EndIf
If UBound($result) > 0 Then
If $g_bDebugSetlog Then SetDebugLog("imgloc Found TH : ", $COLOR_INFO)
Local $propsValues = $result[$iBestResult]
For $pv = 0 To UBound($propsValues) - 1
If $g_bDebugSetlog Then SetDebugLog("imgloc Found : " & $propsNames[$pv] & " - " & $propsValues[$pv], $COLOR_INFO)
Switch $propsNames[$pv]
Case "objectname"
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_NAMEFOUND", $propsValues[$pv])
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_NAMEFOUND", @error)
Local $PathFile = $propsValues[$pv]
Case "objectlevel"
$iLvlFound = Number($propsValues[$pv])
If $myVillage = False Then
$g_iImglocTHLevel = $iLvlFound
$g_aiTownHallDetails[2] = Number($propsValues[$pv])
$g_iSearchTH = Number($propsValues[$pv])
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_MAXLEVELFOUND", $propsValues[$pv])
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_MAXLEVELFOUND", @error)
Else
$g_iTownHallLevel = $iLvlFound
EndIf
Case "objectpoints"
If $propsValues[$pv] = "0" Then
DebugImageSave("imglocTHSearch_NoTHFound_", True)
ResetTHsearch()
Return
EndIf
If $myVillage = False Then
$IMGLOCTHLOCATION = decodeSingleCoord($propsValues[$pv])
$g_aiTownHallDetails[0] = Number($IMGLOCTHLOCATION[0])
$g_aiTownHallDetails[1] = Number($IMGLOCTHLOCATION[1])
$g_iTHx = Number($IMGLOCTHLOCATION[0])
$g_iTHy = Number($IMGLOCTHLOCATION[1])
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_OBJECTPOINTS", $propsValues[$pv])
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_OBJECTPOINTS", @error)
Local $aTHLoc = decodeMultipleCoords($propsValues[$pv])
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_LOCATION", $aTHLoc)
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_LOCATION", @error)
If $g_bDebugImageSave And $retry > 0 Then
_CaptureRegion()
Local $editedImage = $g_hBitmap
Local $subDirectory = $g_sProfileTempDebugPath & "\Thdetection\"
DirCreate($subDirectory)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $fileName = "Thdetection_" & $retry & "_" & $Date & "_" & $Time & ".png"
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPen = _GDIPlus_PenCreate(0xFFFF0000, 2)
addInfoToDebugImage($hGraphic, $hPen, String($PathFile & "_" & $g_iImglocTHLevel), $g_iTHx, $g_iTHy)
_GDIPlus_ImageSaveToFile($editedImage, $subDirectory & $fileName)
_GDIPlus_PenDispose($hPen)
_GDIPlus_GraphicsDispose($hGraphic)
EndIf
Else
$g_aiTownHallPos = decodeSingleCoord($propsValues[$pv])
ConvertFromVillagePos($g_aiTownHallPos[0], $g_aiTownHallPos[1])
EndIf
Case "nearpoints"
If $myVillage = False Then
$IMGLOCTHNEAR = $propsValues[$pv]
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_NEARPOINTS", $propsValues[$pv])
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_NEARPOINTS", @error)
EndIf
Case "farpoints"
If $myVillage = False Then
$IMGLOCTHFAR = $propsValues[$pv]
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_FARPOINTS", $propsValues[$pv])
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_FARPOINTS", @error)
EndIf
Case "redlinedistance"
If $myVillage = False Then
$IMGLOCTHRDISTANCE = $propsValues[$pv]
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_REDLINEDISTANCE", $propsValues[$pv])
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_REDLINEDISTANCE", @error)
EndIf
EndSwitch
If $myVillage = False Then
$g_aiTownHallDetails[3] = 1
EndIf
Next
If $iLvlFound > 0 Then
ExitLoop
EndIf
EndIf
Else
If $g_bDebugSetlog And $retry > 0 Then SetLog("imgloc Could not find TH", $COLOR_WARNING)
If $g_bDebugSetlog And $retry > 0 Then SetLog("imgloc THSearch Calculated  (in " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds) :")
EndIf
If $iLvlFound > 0 Then
$iFindTime += __TimerDiff($hTimer)
If $g_bDebugSetlog Then SetDebugLog("imgloc THSearch Calculated  (in " & Round($iFindTime / 1000, 2) & " seconds) :")
ExitLoop
Else
If $g_bDebugImageSave And $retry > 0 Then DebugImageSave("imglocTHSearch_NoTHFound_", True)
If $g_bDebugSetlog Then SetDebugLog("imgloc THSearch Notfound, Retry:  " & $retry)
EndIf
Next
If $iFindTime <> 0 Then
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_FINDTIME", $iFindTime * 0.001)
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_FINDTIME", @error)
EndIf
EndFunc
Func ResetTHsearch()
$g_sImglocRedline = ""
$g_iImglocTHLevel = 0
$IMGLOCTHLOCATION = StringSplit(",", ",", $STR_NOCOUNT)
$IMGLOCTHNEAR = ""
$IMGLOCTHFAR = ""
$IMGLOCTHRDISTANCE = ""
$g_aiTownHallDetails[0] = -1
$g_aiTownHallDetails[1] = -1
$g_aiTownHallDetails[2] = -1
$g_aiTownHallDetails[3] = -1
$g_iTHx = 0
$g_iTHy = 0
$g_iSearchTH = "-"
Local $string
Local $iKeys = $g_oBldgAttackInfo.Keys
For $string In $iKeys
If StringInStr($string, $eBldgTownHall & "_", $STR_NOCASESENSEBASIC) > 0 Then $g_oBldgAttackInfo.Remove($string)
Next
EndFunc
Func imgloccheckTownHallADV2($limit = 0, $tolerancefix = 0, $captureRegion = True)
imglocTHSearch(True, False, $captureRegion)
If $g_iImglocTHLevel = 0 Then
Return "-"
Else
Return $g_iImglocTHLevel
EndIf
EndFunc
Func TestImglocTroopBar()
$g_bRunState = True
$g_bDebugSetlog = True
$g_bDebugOcr = True
$g_bDebugImageSave = True
SetLog("=========== Imgloc ============")
PrepareAttack($DB)
$g_bDebugSetlog = False
$g_bDebugOcr = False
$g_bDebugImageSave = False
$g_bRunState = False
EndFunc
Func AttackBarCheck($Remaining = False)
Local $x = 0, $y = 659, $x1 = 853, $y1 = 698
Static Local $CheckSlot12 = False
Static Local $CheckSlotwHero = False
If Not $Remaining Then
$CheckSlot12 = False
$CheckSlotwHero = False
EndIf
$g_iLSpellLevel = 1
$g_iESpellLevel = 1
Local $aResult[1][6], $aCoordArray[1][2], $aCoords, $aCoordsSplit, $aValue
If Not $g_bRunState Then Return
_CaptureRegion2($x, $y, $x1, $y1)
Local $strinToReturn = ""
Local $res = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $g_sImgAttackBarDir, "str", "FV", "Int", 0, "str", "FV", "Int", 0, "Int", 1000)
If IsArray($res) Then
If $res[0] = "0" Or $res[0] = "" Then
SetLog("Imgloc|AttackBarCheck not found!", $COLOR_RED)
ElseIf StringLeft($res[0], 2) = "-1" Then
SetLog("DLL Error: " & $res[0] & ", AttackBarCheck", $COLOR_RED)
Else
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys)][6]
Local $iResultAddDup = 0
For $i = 0 To UBound($aKeys) - 1
If $g_bRunState = False Then Return
$aResult[$i + $iResultAddDup][0] = RetrieveImglocProperty($aKeys[$i], "objectname")
$aValue = RetrieveImglocProperty($aKeys[$i], "objectpoints")
$aCoords = decodeMultipleCoords($aValue, 50)
$aCoordsSplit = $aCoords[0]
If UBound($aCoordsSplit) = 2 Then
$aCoordArray[0][0] = $aCoordsSplit[0]
$aCoordArray[0][1] = $aCoordsSplit[1]
Else
$aCoordArray[0][0] = -1
$aCoordArray[0][1] = -1
EndIf
If $g_bDebugSetlog Then SetDebugLog($aResult[$i + $iResultAddDup][0] & " | $aCoordArray: " & $aCoordArray[0][0] & "-" & $aCoordArray[0][1])
$aResult[$i + $iResultAddDup][1] = Number($aCoordArray[0][0])
$aResult[$i + $iResultAddDup][2] = Number($aCoordArray[0][1])
Local $iMultipleCoords = UBound($aCoords)
If $iMultipleCoords > 1 And StringInStr($aResult[$i + $iResultAddDup][0], "Spell") <> 0 Then
If $g_bDebugSetlog Then SetDebugLog($aResult[$i + $iResultAddDup][0] & " detected " & $iMultipleCoords & " times!")
Local $aCoordsSplit2 = $aCoords[1]
If UBound($aCoordsSplit2) = 2 Then
$iResultAddDup += 1
ReDim $aResult[UBound($aKeys) + $iResultAddDup][6]
$aResult[$i + $iResultAddDup][0] = $aResult[$i + $iResultAddDup - 1][0]
$aResult[$i + $iResultAddDup][1] = $aCoordsSplit2[0]
$aResult[$i + $iResultAddDup][2] = $aCoordsSplit2[1]
If $g_bDebugSetlog Then SetDebugLog($aResult[$i + $iResultAddDup][0] & " | $aCoordArray: " & $aResult[$i + $iResultAddDup][1] & "-" & $aResult[$i + $iResultAddDup][2])
Else
EndIf
EndIf
Next
_ArraySort($aResult, 0, 0, 0, 1)
If Not $Remaining Then
$CheckSlot12 = _ColorCheck(_GetPixelColor(17, 643, True), Hex(0x478AC6, 6), 15) Or  _ColorCheck(_GetPixelColor(17, 643, True), Hex(0x434343, 6), 10)
If $g_bDebugSetlog Then
SetDebugLog(" Slot > 12 _ColorCheck 0x478AC6 at (17," & 643 & "): " & $CheckSlot12, $COLOR_DEBUG)
Local $CheckSlot12Color = _GetPixelColor(17, 643, $g_bCapturePixel)
SetDebugLog(" Slot > 12 _GetPixelColor(17," & 643 & "): " & $CheckSlot12Color, $COLOR_DEBUG)
EndIf
For $i = 0 To UBound($aResult) - 1
If $aResult[$i][0] = "King" Or $aResult[$i][0] = "Queen" Or $aResult[$i][0] = "Warden" Then
$CheckSlotwHero = True
EndIf
Next
EndIf
Local $iSlotCompensation = -8
For $i = 0 To UBound($aResult) - 1
Local $Slottemp
If $aResult[$i][1] > 0 Then
If $g_bDebugSetlog Then SetDebugLog("SLOT : " & $i, $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("Detection : " & $aResult[$i][0] & "|x" & $aResult[$i][1] & "|y" & $aResult[$i][2], $COLOR_DEBUG)
$Slottemp = SlotAttack(Number($aResult[$i][1]), $CheckSlot12, $CheckSlotwHero)
If $g_bRunState = False Then Return
If _Sleep(20) Then Return
If UBound($Slottemp) = 2 Then
If $g_bDebugSetlog Then SetDebugLog("OCR : " & $Slottemp[0] & "|SLOT: " & $Slottemp[1], $COLOR_DEBUG)
If $CheckSlotwHero Then $iSlotCompensation = 10
If $aResult[$i][0] = "Castle" Or $aResult[$i][0] = "King" Or $aResult[$i][0] = "Queen" Or $aResult[$i][0] = "Warden" Then
$aResult[$i][3] = 1
$aResult[$i][4] = $Slottemp[1]
Else
If StringInStr($aResult[$i][0], "Spell") <> 0 And $CheckSlotwHero = True then
$Slottemp[0] = $Slottemp[0] + 13
$iSlotCompensation = -6
EndIf
$aResult[$i][3] = Number(getTroopCountBig(Number($Slottemp[0]), 633))
$aResult[$i][4] = $Slottemp[1]
If $aResult[$i][3] = "" Or $aResult[$i][3] = 0 Then
$aResult[$i][3] = Number(getTroopCountSmall(Number($Slottemp[0]), 640))
$aResult[$i][4] = $Slottemp[1]
EndIf
If StringInStr($aResult[$i][0], "ESpell") <> 0 And $g_bSmartZapEnable = True Then
$aResult[$i][5] = getTroopsSpellsLevel(Number($Slottemp[0]) + $iSlotCompensation, 704)
If $aResult[$i][5] <> "" Then $g_iESpellLevel = $aResult[$i][5]
If $g_bDebugSmartZap = True Then SetLog("EarthQuake Detected with level " & $aResult[$i][5], $COLOR_DEBUG)
EndIf
If StringInStr($aResult[$i][0], "LSpell") <> 0 And $g_bSmartZapEnable = True Then
$aResult[$i][5] = getTroopsSpellsLevel(Number($Slottemp[0]) + $iSlotCompensation, 704)
If $aResult[$i][5] <> "" Then $g_iLSpellLevel = $aResult[$i][5]
If $g_bDebugSmartZap = True Then SetLog("Lightning Detected with level " & $aResult[$i][5], $COLOR_DEBUG)
EndIf
EndIf
Else
SetLog("Problem with Attack bar detection!", $COLOR_RED)
SetLog("Detection : " & $aResult[$i][0] & "|x" & $aResult[$i][1] & "|y" & $aResult[$i][2], $COLOR_DEBUG)
$aResult[$i][3] = -1
$aResult[$i][4] = -1
EndIf
$strinToReturn &= "|" & TroopIndexLookup($aResult[$i][0]) & "#" & $aResult[$i][4] & "#" & $aResult[$i][3]
EndIf
Next
EndIf
EndIf
If $g_bDebugImageSave Then
Local $x = 0, $y = 659, $x1 = 853, $y1 = 698
_CaptureRegion2($x, $y, $x1, $y1)
Local $subDirectory = $g_sProfileTempDebugPath & "AttackBarDetection"
DirCreate($subDirectory)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = String($Date & "_" & $Time & "_.png")
Local $editedImage = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPenRED = _GDIPlus_PenCreate(0xFFFF0000, 3)
For $i = 0 To UBound($aResult) - 1
addInfoToDebugImage($hGraphic, $hPenRED, $aResult[$i][0], $aResult[$i][1], $aResult[$i][2])
Next
_GDIPlus_ImageSaveToFile($editedImage, $subDirectory & "\" & $filename)
_GDIPlus_PenDispose($hPenRED)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($editedImage)
EndIf
$strinToReturn = StringTrimLeft($strinToReturn, 1)
Return $strinToReturn
EndFunc
Func SlotAttack($PosX, $CheckSlot12, $CheckSlotwHero)
Local $Slottemp[2] = [0, 0]
For $i = 0 To 12
If $PosX >= 32 +($i * 73) And $PosX < 105 +($i * 73) Then
$Slottemp[0] = 37 +($i * 73)
$Slottemp[1] = $i
If $CheckSlot12 = True Then
$Slottemp[0] -= 13
ElseIf $CheckSlotwHero = False Then
$Slottemp[0] += 10
EndIf
If $g_bDebugSetlog Then SetDebugLog("Slot: " & $i & " | $x > " & 25 +($i * 73) & " and $x < " & 98 +($i * 73))
If $g_bDebugSetlog Then SetDebugLog("Slot: " & $i & " | $PosX: " & $PosX & " |  OCR x position: " & $Slottemp[0] & " | OCR Slot: " & $Slottemp[1])
Return $Slottemp
EndIf
If $g_bRunState = False Then Return
Next
Return $Slottemp
EndFunc
Func QuickMIS($ValueReturned, $directory, $Left = 0, $Top = 0, $Right = $g_iGAME_WIDTH, $Bottom = $g_iGAME_HEIGHT, $bNeedCapture = True, $Debug = False)
If($ValueReturned <> "BC1") And($ValueReturned <> "CX") And($ValueReturned <> "N1") And($ValueReturned <> "NX") And($ValueReturned <> "Q1") And($ValueReturned <> "QX") Then
SetLog("Bad parameters during QuickMIS call for MultiSearch...", $COLOR_RED)
Return
EndIf
If $bNeedCapture Then _CaptureRegion2($Left, $Top, $Right, $Bottom)
Local $Res = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $directory, "str", "FV", "Int", 0, "str", "FV", "Int", 0, "Int", 1000)
If @error Then _logErrorDLLCall($g_sLibMyBotPath, @error)
If $g_bDebugImageSave Then DebugImageSave("QuickMIS_" & $ValueReturned, False)
If IsArray($Res) Then
If $g_bDebugSetlog Then SetDebugLog("DLL Call succeeded " & $Res[0], $COLOR_PURPLE)
If $Res[0] = "" Or $Res[0] = "0" Then
If $g_bDebugSetlog Then SetDebugLog("No Button found")
Switch $ValueReturned
Case "BC1"
Return False
Case "CX"
Return -1
Case "N1"
Return "none"
Case "NX"
Return "none"
Case "Q1"
Return 0
Case "QX"
Return 0
EndSwitch
ElseIf StringInStr($Res[0], "-1") <> 0 Then
SetLog("DLL Error", $COLOR_RED)
Else
Switch $ValueReturned
Case "BC1"
Local $Result = "" , $Name = ""
Local $KeyValue = StringSplit($Res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($KeyValue) - 1
Local $DLLRes = DllCallMyBot("GetProperty", "str", $KeyValue[$i], "str", "objectpoints")
$Result &= $DLLRes[0] & "|"
Next
If StringRight($Result, 1) = "|" Then $Result = StringLeft($Result,(StringLen($Result) - 1))
Local $aCords = decodeMultipleCoords($Result, 60, 10, 1)
Local $aCord = $aCords[0]
$g_iQuickMISX = $aCord[0]
$g_iQuickMISY = $aCord[1]
$Name = RetrieveImglocProperty($KeyValue[0], "objectname")
If $g_bDebugSetlog Or $Debug Then
SetDebugLog($ValueReturned & " Found: " & $Result & ", using " & $g_iQuickMISX & "," & $g_iQuickMISY, $COLOR_PURPLE)
If $g_bDebugImageSave Then DebugQuickMIS($Left, $Top, "BC1_detected[" & $Name & "_" & $g_iQuickMISX + $Left & "x" & $g_iQuickMISY + $Top & "]")
EndIf
Return True
Case "CX"
Local $Result = ""
Local $KeyValue = StringSplit($Res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($KeyValue) - 1
Local $DLLRes = DllCallMyBot("GetProperty", "str", $KeyValue[$i], "str", "objectpoints")
$Result &= $DLLRes[0] & "|"
Next
If StringRight($Result, 1) = "|" Then $Result = StringLeft($Result,(StringLen($Result) - 1))
If $g_bDebugSetlog Then SetDebugLog($ValueReturned & " Found: " & $Result, $COLOR_PURPLE)
Local $CoordsInArray = StringSplit($Result, "|", $STR_NOCOUNT)
Return $CoordsInArray
Case "N1"
Local $MultiImageSearchResult = StringSplit($Res[0], "|")
Local $FilenameFound = StringSplit($MultiImageSearchResult[1], "_")
Return $FilenameFound[1]
Case "NX"
Local $AllFilenamesFound = ""
Local $MultiImageSearchResult = StringSplit($Res[0], "|")
For $i = 1 To $MultiImageSearchResult[0]
Local $FilenameFound = StringSplit($MultiImageSearchResult[$i], "_")
$AllFilenamesFound &= $FilenameFound[1] & "|"
Next
If StringRight($AllFilenamesFound, 1) = "|" Then $AllFilenamesFound = StringLeft($AllFilenamesFound,(StringLen($AllFilenamesFound) - 1))
Return $AllFilenamesFound
Case "Q1"
Local $Result = ""
Local $KeyValue = StringSplit($Res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($KeyValue) - 1
Local $DLLRes = DllCallMyBot("GetProperty", "str", $KeyValue[$i], "str", "totalobjects")
$Result &= $DLLRes[0] & "|"
Next
If StringRight($Result, 1) = "|" Then $Result = StringLeft($Result,(StringLen($Result) - 1))
If $g_bDebugSetlog Then SetDebugLog($ValueReturned & " Found: " & $Result, $COLOR_PURPLE)
Local $QuantityInArray = StringSplit($Result, "|", $STR_NOCOUNT)
Return $QuantityInArray[0]
Case "QX"
Local $MultiImageSearchResult = StringSplit($Res[0], "|", $STR_NOCOUNT)
Return UBound($MultiImageSearchResult)
EndSwitch
EndIf
EndIf
EndFunc
Func DebugQuickMIS($x, $y, $DebugText)
_CaptureRegion2()
Local $subDirectory = $g_sProfileTempDebugPath & "QuickMIS"
DirCreate($subDirectory)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = String($Date & "_" & $Time & "_" & $DebugText & "_.png")
Local $editedImage = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPenRED = _GDIPlus_PenCreate(0xFFFF0000, 3)
_GDIPlus_GraphicsDrawRect($hGraphic, $g_iQuickMISX - 5 + $x, $g_iQuickMISY - 5 + $y, 10, 10, $hPenRED)
_GDIPlus_ImageSaveToFile($editedImage, $subDirectory & "\" & $filename)
_GDIPlus_PenDispose($hPenRED)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($editedImage)
EndFunc
Func checkMainScreen($bSetLog = Default, $bBuilderBase = Default)
FuncEnter(checkMainScreen)
Return FuncReturn(_checkMainScreen($bSetLog, $bBuilderBase))
EndFunc
Func _checkMainScreen($bSetLog = Default, $bBuilderBase = Default)
If $bSetLog = Default Then $bSetLog = True
If $bBuilderBase = Default Then $bBuilderBase = False
Local $i, $iErrorCount, $iCheckBeforeRestartAndroidCount, $bObstacleResult, $bContinue
Local $aPixelToCheck = $aIsMain
If $bSetLog Then
SetLog("Trying to locate Main Screen")
EndIf
If Not TestCapture() Then
If CheckAndroidRunning(False) = False Then Return False
getBSPos()
WinGetAndroidHandle()
If Not $g_bChkBackgroundMode And $g_hAndroidWindow <> 0 Then
AndroidToFront(Default, "checkMainScreen")
EndIf
If $g_bAndroidAdbScreencap = False And _WinAPI_IsIconic($g_hAndroidWindow) Then WinSetState($g_hAndroidWindow, "", @SW_RESTORE)
EndIf
$i = 0
$iErrorCount = 0
$iCheckBeforeRestartAndroidCount = 3
If $bBuilderBase Then $aPixelToCheck = $aIsOnBuilderBase
Local $bLocated
While _CaptureRegions() And Not _checkMainScreenImage($bLocated, $aPixelToCheck)
$i += 1
If TestCapture() Then
SetLog("Main Screen not Located", $COLOR_ERROR)
ExitLoop
EndIf
WinGetAndroidHandle()
$bObstacleResult = checkObstacles($bBuilderBase)
SetDebugLog("CheckObstacles[" & $i & "] Result = " & $bObstacleResult, $COLOR_DEBUG)
$bContinue = False
If Not $bObstacleResult Then
If $g_bMinorObstacle Then
$g_bMinorObstacle = False
$bContinue = True
Else
If $i > $iCheckBeforeRestartAndroidCount Then
DebugImageSave("checkMainScreen_RestartCoC", False)
RestartAndroidCoC()
$bContinue = True
EndIf
EndIf
Else
$g_bRestart = True
$bContinue = True
EndIf
If $bContinue Then
waitMainScreen()
If Not $g_bRunState Then Return False
If @extended Then Return SetError(1, 1, False)
If @error Then $iErrorCount += 1
If $iErrorCount > 2 Then
SetLog("Unable to fix the window error", $COLOR_ERROR)
CloseCoC(True)
ExitLoop
EndIf
Else
If _Sleep($DELAYCHECKMAINSCREEN1) Then Return
EndIf
WEnd
If $bLocated Then ZoomOut()
If Not $g_bRunState Then Return False
If $bSetLog Then
If $bLocated Then
SetLog("Main Screen located", $COLOR_SUCCESS)
Else
SetLog("Main Screen not located", $COLOR_ERROR)
EndIf
EndIf
DisposeWindows()
NotifyPendingActions()
Return $bLocated
EndFunc
Func _checkMainScreenImage(ByRef $bLocated, $aPixelToCheck)
$bLocated = _CheckPixel($aPixelToCheck, $g_bNoCapturePixel) And Not checkObstacles_Network(False, False)
Return $bLocated
EndFunc
Func checkObstacles($bBuilderBase = False)
FuncEnter(checkObstacles)
Static $checkObstaclesActive = False
If TestCapture() = False And WinGetAndroidHandle() = 0 Then
Return FuncReturn(True)
EndIf
If _ColorCheck(_GetPixelColor(383, 405), Hex(0xF0BE70, 6), 20) Then
SetLog("Found Switch Account dialog...!", $COLOR_INFO)
PureClick(383, 375 + $g_iMidOffsetY, 1, 0, "Click Cancel")
EndIf
Local $wasForce = OcrForceCaptureRegion(False)
Local $checkObstaclesWasActive = $checkObstaclesActive
$checkObstaclesActive = True
Local $Result = _checkObstacles($bBuilderBase, $checkObstaclesWasActive)
OcrForceCaptureRegion($wasForce)
$checkObstaclesActive = $checkObstaclesWasActive
Return FuncReturn($Result)
EndFunc
Func _checkObstacles($bBuilderBase = False, $bRecursive = False)
Local $msg, $x, $y, $Result
$g_bMinorObstacle = False
_CaptureRegions()
If Not $bRecursive Then
If checkObstacles_Network() Then Return True
If checkObstacles_GfxError() Then Return True
EndIf
Local $bIsOnBuilderIsland = _CheckPixel($aIsOnBuilderBase, $g_bNoCapturePixel)
If $bBuilderBase = False And $bIsOnBuilderIsland = True Then
SetLog("Detected Builder Base, trying to switch back to Main Village")
If SwitchBetweenBases(False) Then
$g_bMinorObstacle = True
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
Return False
EndIf
EndIf
If $g_sAndroidGameDistributor <> $g_sGoogle Then
Local $aXButton = FindAdsXButton()
If IsArray($aXButton) Then
SetDebugLog("checkObstacles: Found " & $g_sAndroidGameDistributor & " ADS X button to close")
PureClickP($aXButton)
$g_bMinorObstacle = True
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
Return False
EndIf
EndIf
Local $aMessage = _PixelSearch($aIsReloadError[0], $aIsReloadError[1], $aIsReloadError[0] + 3, $aIsReloadError[1] + 11, Hex($aIsReloadError[2], 6), $aIsReloadError[3], $g_bNoCapturePixel)
If IsArray($aMessage) Or(UBound(decodeSingleCoord(FindImageInPlace("Error", $g_sImgError, "680,300(2,20)", False, $g_iAndroidLollipop))) > 1) Then
If $g_bDebugSetlog Then SetDebugLog("(DC=" & _GetPixelColor($aIsConnectLost[0], $aIsConnectLost[1]) & ")(OoS=" & _GetPixelColor($aIsCheckOOS[0], $aIsCheckOOS[1]) & ")", $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("(Maintenance=" & _GetPixelColor($aIsMaintenance[0], $aIsMaintenance[1]) & ")(RateCoC=" & ")", $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("33B5E5=>true, 282828=>false", $COLOR_DEBUG)
$Result = getOcrMaintenanceTime(184, 325 + $g_iMidOffsetY, "Another Device OCR:")
Local $sRegion = "220,330(80,60)"
If StringInStr($Result, "device", $STR_NOCASESENSEBASIC) Or UBound(decodeSingleCoord(FindImageInPlace("Device", $g_sImgAnotherDevice, $sRegion, False))) > 1 Then
If TestCapture() Then Return "Another Device has connected"
If $g_iAnotherDeviceWaitTime > 3600 Then
SetLog("Another Device has connected, waiting " & Floor(Floor($g_iAnotherDeviceWaitTime / 60) / 60) & " hours " & Floor(Mod(Floor($g_iAnotherDeviceWaitTime / 60), 60)) & " minutes " & Floor(Mod($g_iAnotherDeviceWaitTime, 60)) & " seconds", $COLOR_ERROR)
PushMsg("AnotherDevice3600")
ElseIf $g_iAnotherDeviceWaitTime > 60 Then
SetLog("Another Device has connected, waiting " & Floor(Mod(Floor($g_iAnotherDeviceWaitTime / 60), 60)) & " minutes " & Floor(Mod($g_iAnotherDeviceWaitTime, 60)) & " seconds", $COLOR_ERROR)
PushMsg("AnotherDevice60")
Else
SetLog("Another Device has connected, waiting " & Floor(Mod($g_iAnotherDeviceWaitTime, 60)) & " seconds", $COLOR_ERROR)
PushMsg("AnotherDevice")
EndIf
If _SleepStatus($g_iAnotherDeviceWaitTime * 1000) Then Return
checkObstacles_ReloadCoC($aReloadButton, "#0127", $bRecursive)
If $g_bForceSinglePBLogoff Then $g_bGForcePBTUpdate = True
checkObstacles_ResetSearch()
Return True
EndIf
If UBound(decodeSingleCoord(FindImageInPlace("Break", $g_sImgPersonalBreak, "165,287,335,325", False))) > 1 Then
SetLog("Village must take a break, wait ...", $COLOR_ERROR)
If TestCapture() Then Return "Village must take a break"
PushMsg("TakeBreak")
If _SleepStatus($DELAYCHECKOBSTACLES4) Then Return
checkObstacles_ReloadCoC($aReloadButton, "#0128", $bRecursive)
If $g_bForceSinglePBLogoff Then $g_bGForcePBTUpdate = True
checkObstacles_ResetSearch()
Return True
EndIf
Select
Case UBound(decodeSingleCoord(FindImageInPlace("AnyoneThere", $g_sImgAnyoneThere, "440,340,580,390", False))) > 1
SetLog("Village was Inactive, Reloading CoC...", $COLOR_ERROR)
If $g_bForceSinglePBLogoff Then $g_bGForcePBTUpdate = True
Case _CheckPixel($aIsConnectLost, $g_bNoCapturePixel)
$Result = getOcrMaintenanceTime(171, 358 + $g_iMidOffsetY, "Check Obstacles OCR 'policy at super'=")
If StringInStr($Result, "policy", $STR_NOCASESENSEBASIC) Then
$msg = "Sorry but account has been banned, Bot must stop!!"
BanMsgBox()
Return checkObstacles_StopBot($msg)
EndIf
$Result = getOcrMaintenanceTime(171, 337 + $g_iMidOffsetY, "Check Obstacles OCR 'prohibited 3rd'= ")
If StringInStr($Result, "3rd", $STR_NOCASESENSEBASIC) Then
$msg = "Sorry but account has been banned, Bot must stop!!"
BanMsgBox()
Return checkObstacles_StopBot($msg)
EndIf
SetLog("Connection lost, Reloading CoC...", $COLOR_ERROR)
If $g_bChkSharedPrefs And HaveSharedPrefs() Then
SetLog("Please wait for loading CoC...!")
PushSharedPrefs()
OpenCoC()
EndIf
Case _CheckPixel($aIsCheckOOS, $g_bNoCapturePixel) Or(UBound(decodeSingleCoord(FindImageInPlace("OOS", $g_sImgOutOfSync, "355,335,435,395", False, $g_iAndroidLollipop))) > 1)
SetLog("Out of Sync Error, Reloading CoC...", $COLOR_ERROR)
Case _CheckPixel($aIsMaintenance, $g_bNoCapturePixel)
$Result = getOcrMaintenanceTime(171, 345 + $g_iMidOffsetY, "Check Obstacles OCR Maintenance Break=")
Local $iMaintenanceWaitTime = 0
Select
Case $Result = ""
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES4
Case StringInStr($Result, "few", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES4
Case StringInStr($Result, "10", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES6
Case StringInStr($Result, "15", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES6
Case StringInStr($Result, "20", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES7
Case StringInStr($Result, "30", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES8
Case StringInStr($Result, "45", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES9
Case StringInStr($Result, "hour", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES10
Case Else
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES4
SetLog("Error reading Maintenance Break time?", $COLOR_ERROR)
EndSelect
SetLog("Maintenance Break, waiting: " & $iMaintenanceWaitTime / 60000 & " minutes....", $COLOR_ERROR)
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertMaintenance = True Then NotifyPushToBoth("Maintenance Break, waiting: " & $iMaintenanceWaitTime / 60000 & " minutes....")
If $g_bForceSinglePBLogoff Then $g_bGForcePBTUpdate = True
If _SleepStatus($iMaintenanceWaitTime) Then Return
checkObstacles_ResetSearch()
Case Else
If $g_bDebugImageSave Then DebugImageSave("ChkObstaclesReloadMsg_", False)
Local $sRegion = "220,420(60,25)"
If $g_iAndroidVersionAPI >= $g_iAndroidLollipop Then
$sRegion = "555,400(60,25)"
EndIf
$Result = decodeSingleCoord(FindImageInPlace("RateNever", $g_sImgAppRateNever, $sRegion, False, True))
If UBound($Result) > 1 Then
SetLog("Clash feedback window found, permanently closed!", $COLOR_ERROR)
PureClick($Result[0] + 5, $Result[1] + 5, 1, 0, "#9999")
$g_bMinorObstacle = True
Return True
EndIf
$Result = getOcrMaintenanceTime(171, 325 + $g_iMidOffsetY, "Check Obstacles OCR 'Good News!'=")
If StringInStr($Result, "new", $STR_NOCASESENSEBASIC) Then
If Not $g_bAutoUpdateGame Then
$msg = "Game Update is required, Bot must stop!!"
Return checkObstacles_StopBot($msg)
Else
Switch UpdateGame()
Case True, Default
If Not $bRecursive Then Return checkObstacles_ReloadCoC()
Case False
$msg = "Game Update failed, Bot must stop!!"
Return checkObstacles_StopBot($msg)
EndSwitch
EndIf
ElseIf StringInStr($Result, "rate", $STR_NOCASESENSEBASIC) Then
SetLog("Clash feedback window found, permanently closed!", $COLOR_ERROR)
PureClick(248, 408 + $g_iMidOffsetY, 1, 0, "#9999")
$g_bMinorObstacle = True
Return True
EndIf
$Result = getOcrMaintenanceTime(171, 358 + $g_iMidOffsetY, "Check Obstacles OCR 'policy at super'=")
If StringInStr($Result, "policy", $STR_NOCASESENSEBASIC) Then
$msg = "Sorry but account has been banned, Bot must stop!!"
BanMsgBox()
Return checkObstacles_StopBot($msg)
EndIf
$Result = getOcrMaintenanceTime(171, 337 + $g_iMidOffsetY, "Check Obstacles OCR 'prohibited 3rd'= ")
If StringInStr($Result, "3rd", $STR_NOCASESENSEBASIC) Then
$msg = "Sorry but account has been banned, Bot must stop!!"
BanMsgBox()
Return checkObstacles_StopBot($msg)
EndIf
SetLog("Warning: Can not find type of Reload error message", $COLOR_ERROR)
EndSelect
If TestCapture() Then Return "Village is out of sync or inactivity or connection lost or maintenance"
Return checkObstacles_ReloadCoC($aReloadButton, "#0131", $bRecursive)
EndIf
If TestCapture() = 0 And GetAndroidProcessPID() = 0 Then
Return checkObstacles_ReloadCoC(Default, "", $bRecursive)
EndIf
Local $bHasTopBlackBar = _ColorCheck(_GetPixelColor(10, 3), Hex(0x000000, 6), 1) And _ColorCheck(_GetPixelColor(300, 6), Hex(0x000000, 6), 1) And _ColorCheck(_GetPixelColor(600, 9), Hex(0x000000, 6), 1)
If _ColorCheck(_GetPixelColor(235, 209 + $g_iMidOffsetY), Hex(0x9E3826, 6), 20) Then
SetDebugLog("checkObstacles: Found Window to close")
PureClick(429, 493 + $g_iMidOffsetY, 1, 0, "#0132")
$g_abNotNeedAllTime[0] = True
$g_abNotNeedAllTime[1] = True
$g_bMinorObstacle = True
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
Return False
EndIf
If Not $bHasTopBlackBar And _CheckPixel($aIsMainGrayed, $g_bNoCapturePixel) Then
SetDebugLog("checkObstacles: Found gray Window to close")
PureClickP($aAway, 1, 0, "#0133")
$g_bMinorObstacle = True
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
Return False
EndIf
If _ColorCheck(_GetPixelColor(792, 39), Hex(0xDC0408, 6), 20) Then
SetDebugLog("checkObstacles: Found Window with Close Button to close")
PureClick(792, 39, 1, 0, "#0134")
$g_bMinorObstacle = True
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
Return False
EndIf
If _CheckPixel($aCancelFight, $g_bNoCapturePixel) Or _CheckPixel($aCancelFight2, $g_bNoCapturePixel) Then
SetDebugLog("checkObstacles: Found Cancel Fight to close")
PureClickP($aCancelFight, 1, 0, "#0135")
$g_bMinorObstacle = True
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
Return False
EndIf
If _CheckPixel($aChatTab, $g_bNoCapturePixel) Then
SetDebugLog("checkObstacles: Found Chat Tab to close")
PureClickP($aChatTab, 1, 0, "#0136")
$g_bMinorObstacle = True
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
Return False
EndIf
If _CheckPixel($aEndFightSceneBtn, $g_bNoCapturePixel) Then
SetDebugLog("checkObstacles: Found End Fight Scene to close")
PureClickP($aEndFightSceneBtn, 1, 0, "#0137")
Return True
EndIf
If _CheckPixel($aSurrenderButton, $g_bNoCapturePixel) Then
SetDebugLog("checkObstacles: Found End Battle to close")
ReturnHome(False, False)
Return True
EndIf
If _CheckPixel($aNoCloudsAttack, $g_bNoCapturePixel) Then
$aMessage = _PixelSearch(23, 566 + $g_iBottomOffsetY, 36, 580 + $g_iBottomOffsetY, Hex(0xF4F7E3, 6), 10, False)
If IsArray($aMessage) Then
SetDebugLog("checkObstacles: Found Return Home button")
PureClick(67, 602 + $g_iBottomOffsetY, 1, 0, "#0138")
If _Sleep($DELAYCHECKOBSTACLES2) Then Return
Return True
EndIf
EndIf
If IsPostDefenseSummaryPage(False) Then
$aMessage = _PixelSearch(23, 566 + $g_iBottomOffsetY, 36, 580 + $g_iBottomOffsetY, Hex(0xE0E1CE, 6), 10, False)
If IsArray($aMessage) Then
SetDebugLog("checkObstacles: Found Post Defense Summary to close")
PureClick(67, 602 + $g_iBottomOffsetY, 1, 0, "#0138")
If _Sleep($DELAYCHECKOBSTACLES2) Then Return
Return True
EndIf
EndIf
Local $CSFoundCoords = decodeSingleCoord(FindImageInPlace("CocStopped", $g_sImgCocStopped, "250,358,618,432", False))
If UBound($CSFoundCoords) > 1 Then
SetLog("CoC Has Stopped Error .....", $COLOR_ERROR)
If TestCapture() Then Return "CoC Has Stopped Error ....."
PushMsg("CoCError")
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
PureClick($CSFoundCoords[0], $CSFoundCoords[1], 1, 0, "#0129")
If _Sleep($DELAYCHECKOBSTACLES2) Then Return
Return checkObstacles_ReloadCoC(Default, "", $bRecursive)
EndIf
If $bHasTopBlackBar Then
SetDebugLog("checkObstacles: Found Black Android Screen")
EndIf
If Not CheckGoogleSelectAccount() Then
CheckLoginWithSupercellID()
EndIf
Return False
EndFunc
Func checkObstacles_ReloadCoC($point = Default, $debugtxt = "", $bRecursive = False)
If TestCapture() Then Return "Reload CoC"
ForceCaptureRegion(True)
OcrForceCaptureRegion(True)
If $point = Default Then
If Not $bRecursive Then CloseCoC(True)
Else
If UBound($point) > 1 Then
PureClickP($point, 1, 0, $debugtxt)
EndIf
If Not $bRecursive Then OpenCoC()
EndIf
If _Sleep($DELAYCHECKOBSTACLES3) Then Return
Return True
EndFunc
Func checkObstacles_RebootAndroid()
If TestCapture() Then Return "Reboot Android"
ForceCaptureRegion(True)
OcrForceCaptureRegion(True)
$g_bGfxError = True
CheckAndroidReboot()
Return True
EndFunc
Func checkObstacles_StopBot($msg)
SetLog($msg, $COLOR_ERROR)
If TestCapture() Then Return $msg
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertMaintenance = True Then NotifyPushToBoth($msg)
OcrForceCaptureRegion(True)
Btnstop()
Return True
EndFunc
Func checkObstacles_ResetSearch()
$g_bIsClientSyncError = False
$g_bIsSearchLimit = False
$g_abNotNeedAllTime[0] = True
$g_abNotNeedAllTime[1] = True
$g_bRestart = True
EndFunc
Func BanMsgBox()
Local $MsgBox
Local $stext = "Sorry, your account is banned!!" & @CRLF & "Bot will stop now..."
If TestCapture() Then Return $stext
While 1
PushMsg("BAN")
_ExtMsgBoxSet(4, 1, 0x004080, 0xFFFF00, 20, "Comic Sans MS", 600)
$MsgBox = _ExtMsgBox(48, "Ok", "Banned", $stext, 1)
If $MsgBox = 1 Then Return
_ExtMsgBoxSet(4, 1, 0xFFFF00, 0x004080, 20, "Comic Sans MS", 600)
$MsgBox = _ExtMsgBox(48, "Ok", "Banned", $stext, 1)
If $MsgBox = 1 Then Return
WEnd
EndFunc
Func checkObstacles_Network($bForceCapture = False, $bReloadCoC = True)
Static $hCocReconnectingTimer = 0
If UBound(decodeSingleCoord(FindImageInPlace("CocReconnecting", $g_sImgCocReconnecting, "420,355,440,375", $bForceCapture))) > 1 Then
If $hCocReconnectingTimer = 0 Then
SetLog("Network Connection lost...", $COLOR_ERROR)
$hCocReconnectingTimer = __TimerInit()
ElseIf __TimerDiff($hCocReconnectingTimer) > $g_iCoCReconnectingTimeout Then
SetLog("Network Connection really lost, Reloading CoC...", $COLOR_ERROR)
$hCocReconnectingTimer = 0
If $bReloadCoC = True Then Return checkObstacles_ReloadCoC()
Return True
Else
SetLog("Network Connection lost, waiting...", $COLOR_ERROR)
EndIf
Else
$hCocReconnectingTimer = 0
EndIf
Return False
EndFunc
Func checkObstacles_GfxError($bForceCapture = False, $bRebootAndroid = True)
Local $aResult = decodeMultipleCoords(FindImage("GfxError", $g_sImgGfxError, "ECD", 100, $bForceCapture), 100, 100)
If UBound($aResult) >= 8 Then
SetLog(UBound($aResult) & " Gfx Errors detected, Reloading Android...", $COLOR_ERROR)
DebugImageSave("GfxError", False)
If $bRebootAndroid Then Return checkObstacles_RebootAndroid()
Return True
EndIf
Return False
EndFunc
Func UpdateGame()
SetLog("Open Play Store for Game Update...")
OpenPlayStoreGame()
EndFunc
Global Const $g_iDPI_Ratio = 1
Func GUISetFont_DPI($isize, $iweight = "", $iattribute = "", $sfontname = "")
GUISetFont($isize / $g_iDPI_Ratio, $iweight, $iattribute, $sfontname)
EndFunc
Func SetDPI()
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = "My Bot needs to change your DPI settinng to continue!" & @CRLF & @CRLF & "You will be required to reboot your PC when done" & @CRLF & @CRLF & "Please close other programs and save you work NOW!" & @CRLF & @CRLF & "Hit OK to change settings and reboot, or cancel to exit bot"
Local $MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Settings_Error", "Display Settings Error"), $stext, 120)
If $MsgBox = 1 Then
Local $aRet = DllCall("syssetup.dll", "int", "SetupChangeFontSize", "int_ptr", 0, "wstr", "96")
If @error Then Return SetError(2, @extended, 0)
If $aRet = 0 Then
SetLog("Your Display DPI has been changed!!  Must logoff or restart to complete the chamge!", $COLOR_WARNING)
_Sleep(5000)
Shutdown($SD_REBOOT)
Else
SetLog("Your DPI has not been changed due some unknown error, Return= " & $aRet, $COLOR_WARNING)
EndIf
EndIf
EndFunc
Func isGemOpen($bNeedCaptureRegion = False)
_Sleep($DELAYISGEMOPEN1)
If _CheckPixel($aIsGemWindow1, $bNeedCaptureRegion) Then
If $g_bDebugSetlog Then SetDebugLog("Gemclick Red X detect", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0140")
Return True
ElseIf _CheckPixel($aIsGemWindow2, $bNeedCaptureRegion) And  _CheckPixel($aIsGemWindow3, $bNeedCaptureRegion) And  _CheckPixel($aIsGemWindow4, $bNeedCaptureRegion) Then
If $g_bDebugSetlog Then SetDebugLog("Gemclick Red Line detect", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0141")
Return True
EndIf
Return False
EndFunc
Func isNoUpgradeLoot($bNeedCaptureRegion = False)
If _ColorCheck(_GetPixelColor(460, 492 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xFF887F, 6), 20) And  _ColorCheck(_GetPixelColor(460, 494 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xFF887F, 6), 20) And  _ColorCheck(_GetPixelColor(460, 498 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xFF887F, 6), 20) Then
If $g_bDebugSetlog Then SetDebugLog("isNoUpgradeLoot Red Zero found", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0142")
Return True
ElseIf _ColorCheck(_GetPixelColor(691, 523 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xFF887F, 6), 20) And  _ColorCheck(_GetPixelColor(691, 527 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xFF887F, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xFF887F, 6), 20) Then
If $g_bDebugSetlog Then SetDebugLog("IsNoUpgradeLoot Hero Red Zero Found", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0143")
Return True
EndIf
Return False
EndFunc
Func isProblemAffect($bNeedCaptureRegion = False)
Local $iGray = 0x282828
If $g_iAndroidVersionAPI >= $g_iAndroidLollipop Then $iGray = 0x424242
If Not _ColorCheck(_GetPixelColor(253, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex($iGray, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(373, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex($iGray, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(473, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex($iGray, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(283, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex($iGray, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(320, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex($iGray, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(594, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex($iGray, 6), 10) Then
Return False
ElseIf _ColorCheck(_GetPixelColor(823, 32, $bNeedCaptureRegion), Hex(0xF8FCFF, 6), 10) Then
Return False
Else
Return True
EndIf
EndFunc
Func checkAttackDisable($iSource, $Result = "")
Local $i = 0, $iCount = 0
Local $iModSource
If $g_bDisableBreakCheck = True Then Return
If $g_bForceSinglePBLogoff And _DateIsValid($g_sPBStartTime) Then
Local $iTimeTillPBTstartSec = Int(_DateDiff('s', $g_sPBStartTime, _NowCalc()))
If $g_bDebugSetlog Then SetDebugLog("PB starts in: " & $iTimeTillPBTstartSec & " Seconds", $COLOR_DEBUG)
If $iTimeTillPBTstartSec >= 0 Then
$iModSource = $g_iTaBChkTime
Else
$g_abPBActive[$g_iCurAccount] = False
Return
EndIf
Else
$iModSource = $iSource
EndIf
Switch $iModSource
Case $g_iTaBChkAttack
While $Result = "" Or(StringLen($Result) < 3)
$i += 1
If _Sleep($DELAYATTACKDISABLE100) Then Return
$Result = getAttackDisable(346, 182)
If $i >= 3 Then ExitLoop
WEnd
If $g_bDebugSetlog Then SetDebugLog("Attack Personal Break OCR result = " & $Result, $COLOR_DEBUG)
If $Result <> "" Then
If StringInStr($Result, "disable") <> 0 Or StringInStr($Result, "for") <> 0 Or StringInStr($Result, "after") <> 0 Or StringInStr($Result, "have") <> 0 Then
SetLog("Attacking disabled, Personal Break detected...", $COLOR_ERROR)
If _CheckPixel($aSurrenderButton, $g_bCapturePixel) Then
If TestCapture() Then
SetLog("checkAttackDisable: ReturnHome")
Else
ReturnHome(False, False)
EndIf
Else
If TestCapture() Then
SetLog("checkAttackDisable: CloseCoC")
Else
CloseCoC()
EndIf
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("wrong text string", $COLOR_DEBUG)
If TestCapture() Then Return "wrong text string"
Return
EndIf
Else
If TestCapture() Then Return "take a break text not found"
Return
EndIf
Case $g_iTaBChkIdle
If $Result = "" Then $Result = getAttackDisable(180, 156 + $g_iMidOffsetY)
If _Sleep($DELAYATTACKDISABLE500) Then Return
If $Result = "" Or(StringLen($Result) < 3) Then $Result = getAttackDisable(180, 156 + $g_iMidOffsetY)
If $g_bDebugSetlog Then SetDebugLog("Personal Break OCR result = " & $Result, $COLOR_DEBUG)
If $Result <> "" Then
If StringInStr($Result, "been") <> 0 Or StringInStr($Result, "after") <> 0 Or StringInStr($Result, "have") <> 0 Then
SetLog("Online too long, Personal Break detected....", $COLOR_ERROR)
checkMainScreen()
Else
If $g_bDebugSetlog Then SetDebugLog("wrong text string", $COLOR_DEBUG)
If TestCapture() Then Return "wrong text string #2"
$g_abPBActive[$g_iCurAccount] = False
Return
EndIf
Else
If TestCapture() Then Return "take a break text not found #2"
$g_abPBActive[$g_iCurAccount] = False
Return
EndIf
Case $g_iTaBChkTime
If $iSource = $g_iTaBChkAttack Then
While _CheckPixel($aIsAttackPage, $g_bCapturePixel) = False
If _Sleep($DELAYATTACKDISABLE500) Then Return
$iCount += 1
If $g_bDebugSetlog Then SetDebugLog("wait end battle button " & $iCount, $COLOR_DEBUG)
If $iCount > 40 Or isProblemAffect(True) Then
checkObstacles()
ExitLoop
EndIf
WEnd
If _CheckPixel($aIsAttackPage, $g_bCapturePixel) Then
If TestCapture() Then
SetLog("checkAttackDisable: ReturnHome #2")
Else
ReturnHome(False, False)
EndIf
EndIf
EndIf
If $iSource = $g_iTaBChkIdle Then
While _CheckPixel($aIsMain, $g_bCapturePixel) = False
If _Sleep($DELAYATTACKDISABLE500) Then Return
ClickP($aAway, 1, 0, "#0000")
$iCount += 1
If $g_bDebugSetlog Then SetDebugLog("wait main page" & $iCount, $COLOR_DEBUG)
If $iCount > 5 Or isProblemAffect(True) Then
checkObstacles()
ExitLoop
EndIf
WEnd
If _Sleep($DELAYATTACKDISABLE500) Then Return
EndIf
If $g_asShieldStatus[0] = "guard" Then
SetLog("Unable to Force PB, Guard shield present", $COLOR_INFO)
Else
SetLog("Forcing Early Personal Break Now!!", $COLOR_SUCCESS)
EndIf
Case Else
SetLog("Misformed $sSource parameter, silly programmer made a mistake!", $COLOR_DEBUG)
Return False
EndSwitch
SetLog("Prepare base before Personal Break..", $COLOR_INFO)
CheckBaseQuick(True)
$g_bIsClientSyncError = False
$g_bIsSearchLimit = False
$g_bRestart = True
If ProfileSwitchAccountEnabled() Then
SetLog("Adding the PB time to remain time of the current account.", $COLOR_INFO)
If $g_aiRemainTrainTime[$g_iCurAccount] < $g_iSinglePBForcedLogoffTime Then
$g_aiRemainTrainTime[$g_iCurAccount] = $g_iSinglePBForcedLogoffTime
$g_abPBActive[$g_iCurAccount] = True
EndIf
Local $iAllcounts = 0, $iAllAccountsPBactive = 0
For $i = 0 To $g_iTotalAcc
If $g_abAccountNo[$i] = True Then
If SwitchAccountEnabled($i) Then
$iAllcounts +=1
If $g_abPBActive[$i] = True Then $iAllAccountsPBactive+=1
EndIf
EndIf
Next
If $iAllcounts <> $iAllAccountsPBactive Then
checkSwitchAcc()
Return
Else
SetLog("All Accounts are in PB Time!!", $COLOR_INFO)
EndIf
EndIf
SetLog("Time for break, exit now..", $COLOR_INFO)
If TestCapture() Then
SetLog("checkAttackDisable: PoliteCloseCoC")
Else
PoliteCloseCoC("AttackDisable_")
EndIf
If _Sleep(1000) Then Return
PushMsg("TakeBreak")
If $iModSource = $g_iTaBChkTime And $g_asShieldStatus[0] <> "guard" Then
SetLog("Personal Break Reset log off: " & $g_iSinglePBForcedLogoffTime & " Minutes", $COLOR_INFO)
If TestCapture() Then
SetLog("checkAttackDisable: WaitnOpenCoC")
Else
WaitnOpenCoC($g_iSinglePBForcedLogoffTime * 60 * 1000, True)
EndIf
Else
If TestCapture() Then
SetLog("checkAttackDisable: WaitnOpenCoC")
Else
WaitnOpenCoC(20000, True)
EndIf
EndIf
$g_sPBStartTime = ""
For $i = 0 To UBound($g_asShieldStatus) - 1
$g_asShieldStatus[$i] = ""
Next
For $i = 0 To $g_iTotalAcc
If $g_abAccountNo[$i] = True Then
If SwitchAccountEnabled($i) Then
$g_abPBActive[$i] = False
EndIf
EndIF
Next
EndFunc
Func RemoveGhostTrayIcons($IconTextPart_notUsedAnymore = "")
Local $iGhostCount = 0
Local $i, $handle, $pid
Local $count = _SysTrayIconCount()
For $i = $count - 1 To 0 Step -1
$handle = _SysTrayIconHandle($i)
$pid = WinGetProcess($handle)
If $pid = -1 Then
$iGhostCount += 1
_SysTrayIconRemove($i)
EndIf
Next
If _FindTrayToolbarWindow(2) <> -1 Then
Local $countwin7 = _SysTrayIconCount(2)
For $i = $countwin7 - 1 To 0 Step -1
$handle = _SysTrayIconHandle($i, 2)
$pid = WinGetProcess($handle)
If $pid = -1 Then
$iGhostCount += 1
_SysTrayIconRemove($i, 2)
EndIf
Next
EndIf
If $iGhostCount > 0 And $g_bDebugSetlog Then SetLog("Removed " & $iGhostCount & " Ghost icon successfully", $COLOR_SUCCESS)
EndFunc
Func _SysTrayIconCount($iWin = 1)
Local Const $TB_BUTTONCOUNT = 1048
Local $hWnd = _FindTrayToolbarWindow($iWin)
If $hWnd = -1 Then Return -1
Local $count = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", $TB_BUTTONCOUNT, "wparam", 0, "lparam", 0)
If @error Then Return -1
Return $count[0]
EndFunc
Func _SysTrayIconTitles($iWin = 1)
Local $count = _SysTrayIconCount($iWin)
If $count <= 0 Then Return -1
Local $titles[$count]
For $i = 0 To $count - 1
$titles[$i] = WinGetTitle(_SysTrayIconHandle($i, $iWin))
Next
Return $titles
EndFunc
Func _SysTrayIconPids($iWin = 1)
Local $count = _SysTrayIconCount($iWin)
If $count <= 0 Then Return -1
Local $processes[$count]
For $i = 0 To $count - 1
$processes[$i] = WinGetProcess(_SysTrayIconHandle($i, $iWin))
Next
Return $processes
EndFunc
Func _SysTrayIconProcesses($iWin = 1)
Local $pids = _SysTrayIconPids($iWin)
If Not IsArray($pids) Then Return -1
Local $processes[UBound($pids)]
Local $list = ProcessList()
For $i = 0 To UBound($pids) - 1
For $j = 1 To $list[0][0]
If $pids[$i] = $list[$j][1] Then
$processes[$i] = $list[$j][0]
ExitLoop
EndIf
Next
Next
Return $processes
EndFunc
Func _SysTrayIconIndex($test, $mode = 0, $iWin = 1)
Local $ret = -1, $compare = -1
If $mode < 0 Or $mode > 2 Or Not IsInt($mode) Then Return -1
Switch $mode
Case 0
$compare = _SysTrayIconProcesses($iWin)
Case 1
$compare = _SysTrayIconTitles($iWin)
Case 2
$compare = _SysTrayIconPids($iWin)
EndSwitch
If Not IsArray($compare) Then Return -1
For $i = 0 To UBound($compare) - 1
If $compare[$i] = $test Then
$ret = $i
ExitLoop
EndIf
Next
Return $ret
EndFunc
Func _SysTrayGetButtonInfo($iIndex, $iWin = 1, $iInfo = 1)
Local Const $TB_GETBUTTON = 1047
Local Const $TB_GETITEMRECT = 1053
Local Const $ACCESS = BitOR(0x0008, 0x0010, 0x0400)
Local $TBBUTTON
If @OSArch = "X86" Then
$TBBUTTON = DllStructCreate("int iBitmap;int idCommand;byte fsState;byte fsStyle;byte bReserved[2];dword dwData;int iString")
Else
$TBBUTTON = DllStructCreate("int iBitmap;int idCommand;byte fsState;byte fsStyle;byte bReserved[6];uint64 dwData;int64 iString")
EndIf
Local $TRAYDATA
If @OSArch = "X86" Then
$TRAYDATA = DllStructCreate("hwnd hwnd;uint uID;uint uCallbackMessage;dword Reserved[2];handle hIcon")
Else
$TRAYDATA = DllStructCreate("uint64 hwnd;uint uID;uint uCallbackMessage;dword Reserved[2];uint64 hIcon")
EndIf
Local $trayHwnd = _FindTrayToolbarWindow($iWin)
If $trayHwnd = -1 Then Return SetError(1, 0, -1)
Local $return, $err = 0
Local $ret = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $trayHwnd, "dword*", 0)
If @error Or Not $ret[2] Then SetError(2, 0, -1)
Local $pid = $ret[2]
Local $procHandle = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $ACCESS, "bool", False, "dword", $pid)
If @error Or Not $procHandle[0] Then Return SetError(3, 0, -1)
Local $lpData = DllCall("kernel32.dll", "ptr", "VirtualAllocEx", "handle", $procHandle[0], "ptr", 0, "ulong", DllStructGetSize($TBBUTTON), "dword", 0x1000, "dword", 0x04)
If Not @error And $lpData[0] Then
$ret = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $trayHwnd, "uint", $TB_GETBUTTON, "wparam", $iIndex, "lparam", $lpData[0])
If Not @error And $ret[0] Then
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", $lpData[0], "struct*", $TBBUTTON, "ulong", DllStructGetSize($TBBUTTON), "ulong*", 0)
Switch $iInfo
Case 2
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", DllStructGetData($TBBUTTON, 6), "struct*", $TRAYDATA, "ulong", DllStructGetSize($TRAYDATA), "ulong*", 0)
$return = $TRAYDATA
Case 3
$return = ""
If BitShift(DllStructGetData($TBBUTTON, 7), 16) <> 0 Then
Local $intTip = DllStructCreate("wchar[1024]")
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", DllStructGetData($TBBUTTON, 7), "struct*", $intTip, "ulong", DllStructGetSize($intTip), "ulong*", 0)
$return = DllStructGetData($intTip, 1)
$intTip = 0
EndIf
Case 4
If Not BitAND(DllStructGetData($TBBUTTON, 3), 8) Then
Local $pos[2], $RECT = DllStructCreate("int;int;int;int")
DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $trayHwnd, "uint", $TB_GETITEMRECT, "wparam", $iIndex, "lparam", $lpData[0])
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", $lpData[0], "struct*", $RECT, "ulong", DllStructGetSize($RECT), "ulong*", 0)
$ret = DllCall("user32.dll", "int", "MapWindowPoints", "hwnd", $trayHwnd, "ptr", 0, "struct*", $RECT, "uint", 2)
$pos[0] = DllStructGetData($RECT, 1)
$pos[1] = DllStructGetData($RECT, 2)
$return = $pos
$RECT = 0
Else
$return = -1
EndIf
Case Else
$return = $TBBUTTON
EndSwitch
Else
$err = 5
EndIf
DllCall("kernel32.dll", "bool", "VirtualFreeEx", "handle", $procHandle[0], "ptr", $lpData[0], "ulong", 0, "dword", 0x8000)
Else
$err = 4
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $procHandle[0])
If $err Then
Return SetError($err, 0, -1)
Else
Return $return
EndIf
EndFunc
Func _SysTrayIconHandle($iIndex, $iWin = 1)
Local $TRAYDATA = _SysTrayGetButtonInfo($iIndex, $iWin, 2)
If @error Then
Return SetError(@error, 0, -1)
Else
Return Ptr(DllStructGetData($TRAYDATA, 1))
EndIf
EndFunc
Func _SysTrayIconTooltip($iIndex, $iWin = 1)
Local $ret = _SysTrayGetButtonInfo($iIndex, $iWin, 3)
If @error Then
Return SetError(@error, 0, -1)
Else
Return $ret
EndIf
EndFunc
Func _SysTrayIconPos($iIndex, $iWin = 1)
Local $ret = _SysTrayGetButtonInfo($iIndex, $iWin, 4)
If @error Then
Return SetError(@error, 0, -1)
Else
If $ret = -1 Then
Return SetError(-1, 0, -1)
Else
Return $ret
EndIf
EndIf
EndFunc
Func _SysTrayIconVisible($iIndex, $iWin = 1)
Local $TBBUTTON = _SysTrayGetButtonInfo($iIndex, $iWin, 1)
If @error Then
Return SetError(@error, 0, -1)
Else
Return Not BitAND(DllStructGetData($TBBUTTON, 3), 8)
EndIf
EndFunc
Func _SysTrayIconHide($index, $iFlag, $iWin = 1)
Local $TBBUTTON = _SysTrayGetButtonInfo($index, $iWin, 1)
If @error Then Return SetError(@error, 0, -1)
Local $visible = Not BitAND(DllStructGetData($TBBUTTON, 3), 8)
If($iFlag And Not $visible) Or(Not $iFlag And $visible) Then
Return 0
Else
Local $TRAYDATA = _SysTrayGetButtonInfo($index, $iWin, 2)
If @error Then Return SetError(@error, 0, -1)
Local $NOTIFYICONDATA = DllStructCreate("dword cbSize;hwnd hWnd;uint uID;uint uFlags;uint uCallbackMessage;handle hIcon;wchar szTip[128];" & "dword dwState;dword dwStateMask;wchar szInfo[256];uint uVersion;wchar szInfoTitle[64];dword dwInfoFlags;" & "STRUCT;ulong;ushort;ushort;byte[8];ENDSTRUCT;handle hBalloonIcon")
DllStructSetData($NOTIFYICONDATA, 1, DllStructGetSize($NOTIFYICONDATA))
DllStructSetData($NOTIFYICONDATA, 2, Ptr(DllStructGetData($TRAYDATA, 1)))
DllStructSetData($NOTIFYICONDATA, 3, DllStructGetData($TRAYDATA, 2))
DllStructSetData($NOTIFYICONDATA, 4, 8)
DllStructSetData($NOTIFYICONDATA, 8, $iFlag)
DllStructSetData($NOTIFYICONDATA, 9, 1)
Local $ret = DllCall("shell32.dll", "bool", "Shell_NotifyIconW", "dword", 0x1, "struct*", $NOTIFYICONDATA)
DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", WinGetHandle("[CLASS:Shell_TrayWnd]"), "uint", 0x001A, "wparam", 0, "lparam", 0)
$NOTIFYICONDATA = 0
If IsArray($ret) And $ret[0] Then
Return 1
Else
Return 0
EndIf
EndIf
EndFunc
Func _SysTrayIconMove($curPos, $newPos, $iWin = 1)
Local Const $TB_MOVEBUTTON = 0x0452
Local $iconCount = _SysTrayIconCount($iWin)
If $curPos < 0 Or $newPos < 0 Or $curPos > $iconCount - 1 Or $newPos > $iconCount - 1 Or Not IsInt($curPos) Or Not IsInt($newPos) Then Return SetError(1, 0, -1)
Local $hWnd = _FindTrayToolbarWindow($iWin)
If $hWnd = -1 Then Return SetError(2, 0, -1)
Local $ret = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", $TB_MOVEBUTTON, "wparam", $curPos, "lparam", $newPos)
If @error Or Not $ret[0] Then
Return 0
Else
Return 1
EndIf
EndFunc
Func _SysTrayIconRemove($index, $iWin = 1)
Local $TRAYDATA = _SysTrayGetButtonInfo($index, $iWin, 2)
If @error Then Return SetError(@error, 0, -1)
Local $NOTIFYICONDATA = DllStructCreate("dword cbSize;hwnd hWnd;uint uID;uint uFlags;uint uCallbackMessage;handle hIcon;wchar szTip[128];" & "dword dwState;dword dwStateMask;wchar szInfo[256];uint uVersion;wchar szInfoTitle[64];dword dwInfoFlags;" & "STRUCT;ulong;ushort;ushort;byte[8];ENDSTRUCT;handle hBalloonIcon")
DllStructSetData($NOTIFYICONDATA, 1, DllStructGetSize($NOTIFYICONDATA))
DllStructSetData($NOTIFYICONDATA, 2, Ptr(DllStructGetData($TRAYDATA, 1)))
DllStructSetData($NOTIFYICONDATA, 3, DllStructGetData($TRAYDATA, 2))
Local $ret = DllCall("shell32.dll", "bool", "Shell_NotifyIconW", "dword", 0x2, "struct*", $NOTIFYICONDATA)
DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", WinGetHandle("[CLASS:Shell_TrayWnd]"), "uint", 0x001A, "wparam", 0, "lparam", 0)
$NOTIFYICONDATA = 0
If IsArray($ret) And $ret[0] Then
Return 1
Else
Return 0
EndIf
EndFunc
Func _FindTrayToolbarWindow($iWin = 1)
Local $hWnd, $ret = -1
If $iWin = 1 Then
$hWnd = DllCall("user32.dll", "hwnd", "FindWindow", "str", "Shell_TrayWnd", "ptr", 0)
If @error Then Return -1
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "TrayNotifyWnd", "ptr", 0)
If @error Then Return -1
If @OSVersion <> "WIN_2000" Then
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "SysPager", "ptr", 0)
If @error Then Return -1
EndIf
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "ToolbarWindow32", "ptr", 0)
If @error Then Return -1
$ret = $hWnd[0]
ElseIf $iWin = 2 Then
$hWnd = DllCall("user32.dll", "hwnd", "FindWindow", "str", "NotifyIconOverflowWindow", "ptr", 0)
If @error Then Return -1
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "ToolbarWindow32", "ptr", 0)
If @error Then Return -1
$ret = $hWnd[0]
EndIf
Return $ret
EndFunc
Func waitMainScreen()
If Not $g_bRunState Then Return
Local $iCount
SetLog("Waiting for Main Screen")
$iCount = 0
For $i = 0 To 105
If Not $g_bRunState Then Return
If $g_bDebugSetlog Then SetDebugLog("waitMainScreen ChkObstl Loop = " & $i & ", ExitLoop = " & $iCount, $COLOR_DEBUG)
$iCount += 1
Local $hWin = $g_hAndroidWindow
If TestCapture() = False Then
If WinGetAndroidHandle() = 0 Then
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
Return
EndIf
getBSPos()
EndIf
_CaptureRegion()
If _CheckPixel($aIsMain, $g_bNoCapturePixel) Then
If $g_bDebugSetlog Then SetDebugLog("Screen cleared, WaitMainScreen exit", $COLOR_DEBUG)
Return
Else
If Not TestCapture() And _Sleep($DELAYWAITMAINSCREEN1) Then Return
If checkObstacles() Then $i = 0
EndIf
If Mod($i, 5) = 0 Then
If $g_bDebugImageSave Then DebugImageSave("WaitMainScreen_", False)
EndIf
If($i > 105) Or($iCount > 120) Then ExitLoop
If TestCapture() Then
Return "Main screen not available"
EndIf
Next
CloseCoC(True)
If _CheckPixel($aIsMain, True) Then Return
$iCount = 0
While 1
If Not $g_bRunState Then Return
SetLog("Unable to load CoC, attempt to fix it...", $COLOR_ERROR)
If $g_bDebugSetlog Then SetDebugLog("Restart Loop = " & $iCount, $COLOR_DEBUG)
CloseAndroid("waitMainScreen")
If _Sleep(1000) Then Return
OpenAndroid(True)
If @extended Then
SetError(1, 1, -1)
Return
EndIf
If _CheckPixel($aIsMain, $g_bCapturePixel) = True Then ExitLoop
CheckObstacles()
$iCount += 1
If $iCount > 2 Then
SetLog("Stuck trying to Restart " & $g_sAndroidEmulator & "...", $COLOR_ERROR)
SetError(1, 0, 0)
Return
EndIf
If _CheckPixel($aIsMain, $g_bCapturePixel) = True Then ExitLoop
WEnd
EndFunc
Func waitMainScreenMini()
If Not $g_bRunState Then Return
Local $iCount = 0
Local $hTimer = __TimerInit()
SetDebugLog("waitMainScreenMini")
If TestCapture() = False Then getBSPos()
SetLog("Waiting for Main Screen after " & $g_sAndroidEmulator & " restart", $COLOR_INFO)
For $i = 0 To 60
If Not $g_bRunState Then Return
If Not TestCapture() And WinGetAndroidHandle() = 0 Then ExitLoop
If $g_bDebugSetlog Then SetDebugLog("waitMainScreenMini ChkObstl Loop = " & $i & " ExitLoop = " & $iCount, $COLOR_DEBUG)
$iCount += 1
_CaptureRegion()
If Not _CheckPixel($aIsMain, $g_bNoCapturePixel) Then
If Not TestCapture() And _Sleep(1000) Then Return
If CheckObstacles() Then $i = 0
Else
SetLog("CoC main window took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_SUCCESS)
Return
EndIf
_StatusUpdateTime($hTimer, "Main Screen")
If($i > 60) Or($iCount > 80) Then ExitLoop
If TestCapture() Then
Return "Main screen not available"
EndIf
Next
Return SetError(1, 0, -1)
EndFunc
Func isOnBuilderBase($bNeedCaptureRegion = False)
_Sleep($DELAYISBUILDERBASE)
If _CheckPixel($aIsOnBuilderBase, $bNeedCaptureRegion) Then
If $g_bDebugSetlog Then SetDebugLog("Builder Base Builder detected", $COLOR_DEBUG)
Return True
Else
Return False
EndIf
EndFunc
Func AndroidBackButton($bCheckRunState = True)
If(IsDeclared("bCheckRunState") <> 0 And $bCheckRunState) And Not $g_bRunState Then Return False
AndroidAdbSendShellCommand("input keyevent 4")
If $g_bDebugAndroid Then SetDebugLog("Used Adb to press back button", $COLOR_INFO)
Return True
EndFunc
Func AndroidHomeButton($bCheckRunState = True)
If(IsDeclared("bCheckRunState") <> 0 And $bCheckRunState) And Not $g_bRunState Then Return False
AndroidAdbSendShellCommand("input keyevent 3")
If $g_bDebugAndroid Then SetDebugLog("Used Adb to press home button", $COLOR_INFO)
Return True
EndFunc
Func CloseCoC($ReOpenCoC = False, $bCheckRunState = True)
FuncEnter(CloseCoC)
$g_bSkipFirstZoomout = False
ResumeAndroid()
If $bCheckRunState And Not $g_bRunState Then Return FuncReturn()
If $ReOpenCoC Then
SetLog("Please wait for CoC restart......", $COLOR_ERROR)
Else
SetLog("Closing CoC......", $COLOR_ERROR)
EndIf
WinGetAndroidHandle()
If $bCheckRunState And Not $g_bRunState Then Return FuncReturn()
AndroidAdbSendShellCommand("am force-stop " & $g_sAndroidGamePackage, Default, Default, False)
ResetAndroidProcess()
If $bCheckRunState And Not $g_bRunState Then Return FuncReturn()
If $ReOpenCoC Then
OpenCoC()
$g_bRestart = True
EndIf
FuncReturn()
EndFunc
Func OpenCoC()
FuncEnter(OpenCoC)
ResumeAndroid()
If Not $g_bRunState Then Return FuncReturn()
Local $RunApp = "", $iCount = 0
WinGetAndroidHandle()
If _Sleep(500) Then Return FuncReturn()
If Not StartAndroidCoC() Then Return FuncReturn()
If Not $g_bRunState Then Return FuncReturn()
While _CheckPixel($aIsMain, True) = False
$iCount += 1
If _Sleep(100) Then Return FuncReturn()
If checkObstacles() Then $iCount += 1
If $iCount > 250 Then ExitLoop
WEnd
FuncReturn()
EndFunc
Func WaitnOpenCoC($iWaitTime, $bFullRestart = False, $bSuspendComputer = False, $bLockBotSlot = False)
FuncEnter(WaitnOpenCoC)
Return FuncReturn(_WaitnOpenCoC($iWaitTime, $bFullRestart, $bSuspendComputer, $bLockBotSlot))
EndFunc
Func _WaitnOpenCoC($iWaitTime, $bFullRestart = False, $bSuspendComputer = False, $bLockBotSlot = False)
ResumeAndroid()
If Not $g_bRunState Then Return
Local $sWaitTime = ""
Local $iMin, $iSec, $iHour, $iWaitSec
WinGetAndroidHandle()
$iWaitSec = Round($iWaitTime / 1000)
$iHour = Floor(Floor($iWaitSec / 60) / 60)
$iMin = Floor(Mod(Floor($iWaitSec / 60), 60))
$iSec = Floor(Mod($iWaitSec, 60))
If $iHour > 0 Then $sWaitTime &= $iHour & " hours "
If $iMin > 0 Then $sWaitTime &= $iMin & " minutes "
If $iSec > 0 Then $sWaitTime &= $iSec & " seconds "
SetLog("Waiting " & $sWaitTime & "before starting CoC", $COLOR_SUCCESS)
ReduceBotMemory()
Local $hTimer = __TimerInit()
If $bSuspendComputer Then SuspendComputer($iWaitTime)
If _SleepStatus($iWaitTime, True, True, True, $hTimer) Then Return False
If $bLockBotSlot = True Then
LockBotSlot(True)
EndIf
If Not $g_bRunState Then Return
If Not StartAndroidCoC() Then Return
If Not $g_bRunState Then Return
If $g_bDebugSetlog Then SetDebugLog("CoC Restarted, Waiting for completion", $COLOR_DEBUG)
If $bFullRestart Then
checkMainScreen()
$g_bRestart = True
Else
waitMainScreen()
EndIf
EndFunc
Func PoliteCloseCoC($sSource = "Unknown_", $bPoliteCloseCoC = $g_bPoliteCloseCoC)
$g_bSkipFirstZoomout = False
If $bPoliteCloseCoC Then
If $g_sAndroidGameDistributor = $g_sGoogle Then
Local $i = 0
While 1
checkObstacles()
AndroidBackButton()
If _Sleep($DELAYCLOSEOPEN1000) Then Return
If ClickOkay("ExitOkay_" & $sSource, True) = True Then ExitLoop
If $i > 10 Then
SetLog("Can not find Okay button to exit CoC, Forcefully Closing CoC", $COLOR_ERROR)
If $g_bDebugImageSave Then DebugImageSave($sSource)
CloseCoC()
ExitLoop
EndIf
$i += 1
WEnd
Else
Local $btnExit
Local $i = 0
While 1
checkObstacles()
AndroidBackButton()
If _Sleep($DELAYCLOSEOPEN1000) Then Return
Switch $g_sAndroidGameDistributor
Case "Kunlun", "Huawei", "Kaopu", "Microvirt", "Yeshen", "Qihoo", "Baidu", "OPPO", "Anzhi", "Lenovo", "Aiyouxi"
$btnExit = FindExitButton($g_sAndroidGameDistributor)
If IsArray($btnExit) Then
Click($btnExit[0], $btnExit[1])
ExitLoop
EndIf
Case "9game"
If _Sleep($DELAYCLOSEOPEN2000) Then Return
$btnExit = FindExitButton($g_sAndroidGameDistributor)
If IsArray($btnExit) Then
Click($btnExit[0] + 71, $btnExit[1] + 64)
If $g_bDebugSetlog Then SetDebugLog($g_sAndroidGameDistributor & " Click offset X|Y = 71|64", $COLOR_DEBUG)
ExitLoop
EndIf
Case "VIVO", "Xiaomi"
$btnExit = FindExitButton($g_sAndroidGameDistributor)
If IsArray($btnExit) Then
Click($btnExit[0], $btnExit[1], 2, $DELAYCLOSEOPEN3000)
ExitLoop
EndIf
Case "Guopan"
$btnExit = FindExitButton($g_sAndroidGameDistributor)
If IsArray($btnExit) Then
Click($btnExit[0], $btnExit[1])
EndIf
If _Sleep($DELAYCLOSEOPEN2000) Then Return
$btnExit = FindExitButton("Kunlun")
If IsArray($btnExit) Then
Click($btnExit[0], $btnExit[1])
ExitLoop
EndIf
Case "Wandoujia/Downjoy", "Haimawan", "Leshi", "Tencent"
ContinueCase
Case Else
SetLog("Polite Close Unsupported - " & $g_sAndroidGameDistributor & ", Forcefully Closing CoC", $COLOR_ERROR)
If $g_bDebugImageSave Then DebugImageSave($sSource)
CloseCoC()
ExitLoop
EndSwitch
If $i > 10 Then
SetLog("Can not find exit button: " & $g_sAndroidGameDistributor & ", Forcefully Closing CoC", $COLOR_ERROR)
If $g_bDebugImageSave Then DebugImageSave($sSource)
CloseCoC()
ExitLoop
EndIf
$i += 1
WEnd
EndIf
Else
CloseCoC()
EndIf
ResetAndroidProcess()
ReduceBotMemory()
EndFunc
Global $g_aiSearchZoomOutCounter[2] = [0, 1]
Func ZoomOut()
$g_aiSearchZoomOutCounter[0] = 0
$g_aiSearchZoomOutCounter[1] = 1
ResumeAndroid()
WinGetAndroidHandle()
getBSPos()
If Not $g_bRunState Then
SetDebugLog("Exit ZoomOut, bot not running")
Return
EndIf
Local $Result
If $g_bAndroidEmbedded = False Or $g_iAndroidEmbedMode = 1 Then
$Result = Execute("ZoomOut" & $g_sAndroidEmulator & "()")
If $Result = "" And @error <> 0 Then
$Result = AndroidOnlyZoomOut()
EndIf
$g_bSkipFirstZoomout = True
Return $Result
EndIf
$Result = AndroidOnlyZoomOut()
$g_bSkipFirstZoomout = True
Return $Result
EndFunc
Func ZoomOutBlueStacks()
Return ZoomOutCtrlClick(False, False, False, False, 250)
EndFunc
Func ZoomOutBlueStacks2()
If $__BlueStacks2Version_2_5_or_later = False Then
Return ZoomOutCtrlClick(False, False, False, False, 250)
Else
Return DefaultZoomOut("{DOWN}", 0, True)
EndIf
EndFunc
Func ZoomOutMEmu()
Return DefaultZoomOut("{F3}", 0, True)
EndFunc
Func ZoomOutDroid4X()
Return ZoomOutCtrlWheelScroll(True, True, True, True, Default, -5, 250)
EndFunc
Func ZoomOutNox()
Return ZoomOutCtrlWheelScroll(True, True, True, True, Default, -5, 250)
EndFunc
Func DefaultZoomOut($ZoomOutKey = "{DOWN}", $tryCtrlWheelScrollAfterCycles = 40, $bAndroidZoomOut = True)
Local $sFunc = "DefaultZoomOut"
Local $result0, $result1, $i = 0
Local $exitCount = 80
Local $delayCount = 20
ForceCaptureRegion()
Local $aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
If StringInStr($aPicture[0], "zoomou") = 0 Then
If $g_bDebugSetlog Then
SetDebugLog("Zooming Out (" & $sFunc & ")", $COLOR_INFO)
Else
SetLog("Zooming Out", $COLOR_INFO)
EndIf
If _Sleep($DELAYZOOMOUT1) Then Return
If $bAndroidZoomOut Then
AndroidZoomOut(False)
ForceCaptureRegion()
$aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
EndIf
Local $tryCtrlWheelScroll = False
While StringInStr($aPicture[0], "zoomou") = 0 and Not $tryCtrlWheelScroll
AndroidShield("DefaultZoomOut")
If $bAndroidZoomOut Then
AndroidZoomOut(False, $i)
If @error <> 0 Then $bAndroidZoomOut = False
EndIf
If Not $bAndroidZoomOut Then
If $g_bDebugSetlog Then SetDebugLog("Index = "&$i, $COLOR_DEBUG)
If _Sleep($DELAYZOOMOUT2) Then Return
If $g_bChkBackgroundMode = False And $g_bNoFocusTampering = False Then
$Result0 = ControlFocus($g_hAndroidWindow, "", "")
Else
$Result0 = 1
EndIf
$Result1 = ControlSend($g_hAndroidWindow, "", "", $ZoomOutKey)
If $g_bDebugSetlog Then SetDebugLog("ControlFocus Result = "&$Result0 & ", ControlSend Result = "&$Result1& "|" & "@error= " & @error, $COLOR_DEBUG)
If $Result1 = 1 Then
$i += 1
Else
SetLog("Warning ControlSend $Result = "&$Result1, $COLOR_DEBUG)
EndIf
EndIF
If $i > $delayCount Then
If _Sleep($DELAYZOOMOUT3) Then Return
EndIf
If $tryCtrlWheelScrollAfterCycles > 0 And $i > $tryCtrlWheelScrollAfterCycles Then $tryCtrlWheelScroll = True
If $i > $exitCount Then Return
If $g_bRunState = False Then ExitLoop
If IsProblemAffect(True) Then
SetLog($g_sAndroidEmulator & " Error window detected", $COLOR_ERROR)
If checkObstacles() = True Then SetLog("Error window cleared, continue Zoom out", $COLOR_INFO)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
WEnd
If $tryCtrlWheelScroll Then
SetLog($g_sAndroidEmulator & " zoom-out with key " & $ZoomOutKey & " didn't work, try now Ctrl+MouseWheel...", $COLOR_INFO)
Return ZoomOutCtrlWheelScroll(False, False, False, False)
EndIf
Return True
EndIf
Return False
EndFunc
Func ZoomOutCtrlWheelScroll($CenterMouseWhileZooming = True, $GlobalMouseWheel = True, $AlwaysControlFocus = False, $AndroidZoomOut = True, $hWin = Default, $ScrollSteps = -5, $ClickDelay = 250)
Local $sFunc = "ZoomOutCtrlWheelScroll"
Local $exitCount = 80
Local $delayCount = 20
Local $result[4], $i = 0, $j
Local $ZoomActions[4] = ["ControlFocus", "Ctrl Down", "Mouse Wheel Scroll Down", "Ctrl Up"]
If $hWin = Default Then $hWin =($g_bAndroidEmbedded = False ? $g_hAndroidWindow : $g_aiAndroidEmbeddedCtrlTarget[1])
ForceCaptureRegion()
Local $aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
If StringInStr($aPicture[0], "zoomou") = 0 Then
If $g_bDebugSetlog Then
SetDebugLog("Zooming Out (" & $sFunc & ")", $COLOR_INFO)
Else
SetLog("Zooming Out", $COLOR_INFO)
EndIf
AndroidShield("ZoomOutCtrlWheelScroll")
If _Sleep($DELAYZOOMOUT1) Then Return
If $AndroidZoomOut Then
AndroidZoomOut(False)
ForceCaptureRegion()
$aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
EndIf
Local $aMousePos = MouseGetPos()
While StringInStr($aPicture[0], "zoomou") = 0
If $AndroidZoomOut Then
AndroidZoomOut(False, $i)
If @error <> 0 Then $AndroidZoomOut = False
EndIf
If Not $AndroidZoomOut Then
If $g_bDebugSetlog Then SetDebugLog("Index = " & $i, $COLOR_DEBUG)
If _Sleep($DELAYZOOMOUT2) Then ExitLoop
If($g_bChkBackgroundMode = False And $g_bNoFocusTampering = False) Or $AlwaysControlFocus Then
$Result[0] = ControlFocus($hWin, "", "")
Else
$Result[0] = 1
EndIf
$Result[1] = ControlSend($hWin, "", "", "{CTRLDOWN}")
If $CenterMouseWhileZooming Then MouseMove($g_aiBSpos[0] + Int($g_iDEFAULT_WIDTH / 2), $g_aiBSpos[1] + Int($g_iDEFAULT_HEIGHT / 2), 0)
If $GlobalMouseWheel Then
$Result[2] = MouseWheel(($ScrollSteps < 0 ? "down" : "up"), Abs($ScrollSteps))
Else
Local $WM_WHEELMOUSE = 0x020A, $MK_CONTROL = 0x0008
Local $wParam = BitOR($ScrollSteps * 0x10000, BitAND($MK_CONTROL, 0xFFFF))
Local $lParam = BitOR(($g_aiBSpos[1] + Int($g_iDEFAULT_HEIGHT / 2)) * 0x10000, BitAND(($g_aiBSpos[0] + Int($g_iDEFAULT_WIDTH / 2)), 0xFFFF))
_WinAPI_PostMessage($hWin, $WM_WHEELMOUSE, $wParam, $lParam)
$Result[2] =(@error = 0 ? 1 : 0)
EndIf
If _Sleep($ClickDelay) Then ExitLoop
$Result[3] = ControlSend($hWin, "", "", "{CTRLUP}{SPACE}")
If $g_bDebugSetlog Then SetDebugLog("ControlFocus Result = " & $Result[0] & ", " & $ZoomActions[1] & " = " & $Result[1] & ", " & $ZoomActions[2] & " = " & $Result[2] & ", " & $ZoomActions[3] & " = " & $Result[3] & " | " & "@error= " & @error, $COLOR_DEBUG)
For $j = 1 To 3
If $Result[$j] = 1 Then
$i += 1
ExitLoop
EndIf
Next
For $j = 1 To 3
If $Result[$j] = 0 Then
SetLog("Warning " & $ZoomActions[$j] & " = " & $Result[1], $COLOR_DEBUG)
EndIf
Next
EndIf
If $i > $delayCount Then
If _Sleep($DELAYZOOMOUT3) Then ExitLoop
EndIf
If $i > $exitCount Then ExitLoop
If $g_bRunState = False Then ExitLoop
If IsProblemAffect(True) Then
SetLog($g_sAndroidEmulator & " Error window detected", $COLOR_ERROR)
If checkObstacles() = True Then SetLog("Error window cleared, continue Zoom out", $COLOR_INFO)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
WEnd
If $CenterMouseWhileZooming And $AndroidZoomOut = False Then MouseMove($aMousePos[0], $aMousePos[1], 0)
Return True
EndIf
Return False
EndFunc
Func ZoomOutCtrlClick($ZoomOutOverWaters = False, $CenterMouseWhileZooming = False, $AlwaysControlFocus = False, $AndroidZoomOut = True, $ClickDelay = 250)
Local $sFunc = "ZoomOutCtrlClick"
Local $exitCount = 80
Local $delayCount = 20
Local $result[4], $i, $j
Local $SendCtrlUp = False
Local $ZoomActions[4] = ["ControlFocus", "Ctrl Down", "Click", "Ctrl Up"]
ForceCaptureRegion()
Local $aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
If StringInStr($aPicture[0], "zoomou") = 0 Then
If $g_bDebugSetlog Then
SetDebugLog("Zooming Out (" & $sFunc & ")", $COLOR_INFO)
Else
SetLog("Zooming Out", $COLOR_INFO)
EndIf
AndroidShield("ZoomOutCtrlClick")
If $ZoomOutOverWaters Then
If $AndroidZoomOut Then
AndroidZoomOut(False)
ForceCaptureRegion()
$aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
Else
For $i = 1 To 3
_PostMessage_ClickDrag(100, 600, 600, 100, "left")
Next
EndIf
EndIf
If _Sleep($DELAYZOOMOUT1) Then Return
Local $aMousePos = MouseGetPos()
$i = 0
While StringInStr($aPicture[0], "zoomou") = 0
If $AndroidZoomOut Then
AndroidZoomOut(False, $i)
If @error <> 0 Then $AndroidZoomOut = False
EndIf
If Not $AndroidZoomOut Then
If $g_bDebugSetlog Then SetDebugLog("Index = " & $i, $COLOR_DEBUG)
If _Sleep($DELAYZOOMOUT2) Then ExitLoop
If($g_bChkBackgroundMode = False And $g_bNoFocusTampering = False) Or $AlwaysControlFocus Then
$Result[0] = ControlFocus($g_hAndroidWindow, "", "")
Else
$Result[0] = 1
EndIf
$Result[1] = ControlSend($g_hAndroidWindow, "", "", "{CTRLDOWN}")
$SendCtrlUp = True
If $CenterMouseWhileZooming Then MouseMove($g_aiBSpos[0] + Int($g_iDEFAULT_WIDTH / 2), $g_aiBSpos[1] + Int($g_iDEFAULT_HEIGHT / 2), 0)
$Result[2] = _ControlClick(Int($g_iDEFAULT_WIDTH / 2), 600)
If _Sleep($ClickDelay) Then ExitLoop
$Result[3] = ControlSend($g_hAndroidWindow, "", "", "{CTRLUP}{SPACE}")
$SendCtrlUp = False
If $g_bDebugSetlog Then SetDebugLog("ControlFocus Result = " & $Result[0] & ", " & $ZoomActions[1] & " = " & $Result[1] & ", " & $ZoomActions[2] & " = " & $Result[2] & ", " & $ZoomActions[3] & " = " & $Result[3] & " | " & "@error= " & @error, $COLOR_DEBUG)
For $j = 1 To 3
If $Result[$j] = 1 Then
ExitLoop
EndIf
Next
For $j = 1 To 3
If $Result[$j] = 0 Then
SetLog("Warning " & $ZoomActions[$j] & " = " & $Result[1], $COLOR_DEBUG)
EndIf
Next
EndIf
If $i > $delayCount Then
If _Sleep($DELAYZOOMOUT3) Then ExitLoop
EndIf
If $i > $exitCount Then ExitLoop
If $g_bRunState = False Then ExitLoop
If IsProblemAffect(True) Then
SetLog($g_sAndroidEmulator & " Error window detected", $COLOR_RED)
If checkObstacles() = True Then SetLog("Error window cleared, continue Zoom out", $COLOR_BLUE)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
WEnd
If $SendCtrlUp Then ControlSend($g_hAndroidWindow, "", "", "{CTRLUP}{SPACE}")
If $CenterMouseWhileZooming Then MouseMove($aMousePos[0], $aMousePos[1], 0)
Return True
EndIf
Return False
EndFunc
Func AndroidOnlyZoomOut()
Local $sFunc = "AndroidOnlyZoomOut"
Local $i = 0
Local $exitCount = 80
ForceCaptureRegion()
Local $aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
If StringInStr($aPicture[0], "zoomou") = 0 Then
If $g_bDebugSetlog Then
SetDebugLog("Zooming Out (" & $sFunc & ")", $COLOR_INFO)
Else
SetLog("Zooming Out", $COLOR_INFO)
EndIf
AndroidZoomOut(False)
ForceCaptureRegion()
$aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
While StringInStr($aPicture[0], "zoomou") = 0
AndroidShield("AndroidOnlyZoomOut")
AndroidZoomOut(False, $i)
If $i > $exitCount Then Return
If Not $g_bRunState Then ExitLoop
If IsProblemAffect(True) Then
SetLog($g_sAndroidEmulator & " Error window detected", $COLOR_ERROR)
If checkObstacles() Then SetLog("Error window cleared, continue Zoom out", $COLOR_INFO)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
WEnd
Return True
EndIf
Return False
EndFunc
Func SearchZoomOut($CenterVillageBoolOrScrollPos = $aCenterHomeVillageClickDrag, $UpdateMyVillage = True, $sSource = "", $CaptureRegion = True, $DebugLog = False)
If $sSource <> "" Then $sSource = " (" & $sSource & ")"
Local $bCenterVillage = $CenterVillageBoolOrScrollPos
If $bCenterVillage = Default Or $g_bDebugDisableVillageCentering Then $bCenterVillage =(Not $g_bDebugDisableVillageCentering)
Local $aScrollPos[2] = [0, 0]
If UBound($CenterVillageBoolOrScrollPos) >= 2 Then
$aScrollPos[0] = $CenterVillageBoolOrScrollPos[0]
$aScrollPos[1] = $CenterVillageBoolOrScrollPos[1]
$bCenterVillage =(Not $g_bDebugDisableVillageCentering)
EndIf
Local $x, $y, $z, $stone[2]
Local $villageSize = 0
If $CaptureRegion Then _CaptureRegion2()
Local $aResult = ["", 0, 0, 0, 0]
Local $village
If $g_aiSearchZoomOutCounter[0] = 10 Then SetLog("Try secondary village measuring...", $COLOR_INFO)
If $g_aiSearchZoomOutCounter[0] < 10 Then
$village = GetVillageSize($DebugLog, "stone", "tree")
Else
$village = GetVillageSize($DebugLog, "2stone", "2tree")
EndIf
If $g_aiSearchZoomOutCounter[0] > 0 Then
If _Sleep(1000) Then Return $aResult
EndIf
If IsArray($village) = 1 Then
$villageSize = $village[0]
If $villageSize < 500 Or $g_bDebugDisableZoomout Then
$z = $village[1]
$x = $village[2]
$y = $village[3]
$stone[0] = $village[4]
$stone[1] = $village[5]
$aResult[0] = "zoomout:" & $village[6]
$aResult[1] = $x
$aResult[2] = $y
If $bCenterVillage And($x <> 0 Or $y <> 0) And($UpdateMyVillage = False Or $x <> $g_iVILLAGE_OFFSET[0] Or $y <> $g_iVILLAGE_OFFSET[1]) Then
If $DebugLog Then SetDebugLog("Center Village" & $sSource & " by: " & $x & ", " & $y)
If $aScrollPos[0] = 0 And $aScrollPos[1] = 0 Then
$aScrollPos[0] = 650
$aScrollPos[1] = 600
EndIf
ClickDrag($aScrollPos[0], $aScrollPos[1], $aScrollPos[0] - $x, $aScrollPos[1] - $y)
If _Sleep(250) Then Return $aResult
Local $aResult2 = SearchZoomOut(False, $UpdateMyVillage)
$aResult2[3] = $aResult2[1] - $aResult[1]
$aResult2[4] = $aResult2[2] - $aResult[2]
If $DebugLog Then SetDebugLog("Centered Village Offset" & $sSource & ": " & $aResult2[1] & ", " & $aResult2[2] & ", change: " & $aResult2[3] & ", " & $aResult2[4])
Return $aResult2
EndIf
If $UpdateMyVillage Then
If $x <> $g_iVILLAGE_OFFSET[0] Or $y <> $g_iVILLAGE_OFFSET[1] Or $z <> $g_iVILLAGE_OFFSET[2] Then
If $DebugLog Then SetDebugLog("Village Offset" & $sSource & " updated to " & $x & ", " & $y & ", " & $z)
EndIf
setVillageOffset($x, $y, $z)
ConvertInternalExternArea()
EndIf
EndIf
EndIf
If $UpdateMyVillage Then
If $aResult[0] = "" Then
If $g_aiSearchZoomOutCounter[0] > 20 Then
$g_aiSearchZoomOutCounter[0] = 0
SetLog("Restart CoC to reset zoom" & $sSource & "...", $COLOR_INFO)
PoliteCloseCoC("Zoomout" & $sSource)
If _Sleep(1000) Then Return $aResult
CloseCoC()
OpenCoC()
Return SearchZoomOut()
Else
$g_aiSearchZoomOutCounter[0] += 1
EndIf
Else
If Not $g_bDebugDisableZoomout And $villageSize > 480 Then
If Not $g_bSkipFirstZoomout Then
$aResult[0] = ""
ElseIf $g_aiSearchZoomOutCounter[1] > 0 And $g_aiSearchZoomOutCounter[0] > 0 Then
$g_aiSearchZoomOutCounter[1] -= 1
$aResult[0] = ""
EndIf
EndIf
EndIf
$g_bSkipFirstZoomout = True
EndIf
Return $aResult
EndFunc
Func InitAndroidTimeLag($bResetProblemCounter = True)
$g_aiAndroidTimeLag[0] = 0
$g_aiAndroidTimeLag[1] = 0
$g_aiAndroidTimeLag[2] = 0
$g_aiAndroidTimeLag[3] = 0
If $bResetProblemCounter = True Then
$g_aiAndroidTimeLag[4] = 0
$g_aiAndroidTimeLag[5] = 0
EndIf
EndFunc
Func CheckAndroidTimeLag($bRebootAndroid = True)
SetError(0, 0)
If $g_bAndroidCheckTimeLagEnabled = False Then Return SetError(1, 0, False)
Local $androidUTC = $g_aiAndroidTimeLag[1]
Local $hostTimer = $g_aiAndroidTimeLag[2]
If $hostTimer <> 0 And __TimerDiff($hostTimer) / 1000 < 60 Then
Return SetError(3, 0, False)
EndIf
If $g_aiAndroidTimeLag[4] > 0 And $g_aiAndroidTimeLag[5] <> 0 And __TimerDiff($g_aiAndroidTimeLag[5]) > $g_iAndroidTimeLagResetProblemCountMinutes * 60000 Then
SetDebugLog("Time lag problems count of " & $g_aiAndroidTimeLag[4] & " reset to 0 due to " & Round(__TimerDiff($g_aiAndroidTimeLag[5]) / 1000, 0) & " Seconds with an incident")
$g_aiAndroidTimeLag[4] = 0
$g_aiAndroidTimeLag[5] = 0
EndIf
Local $s = AndroidAdbSendShellCommand("date +%s")
If @error <> 0 Then Return SetError(4, 0, False)
Local $curr_androidUTC = Number($s)
Local $curr_hostTimer = __TimerInit()
If $curr_androidUTC < 1 Then
InitAndroidTimeLag(False)
Return SetError(5, 0, False)
EndIf
If $androidUTC = 0 Or $hostTimer = 0 Then
$g_aiAndroidTimeLag[1] = $curr_androidUTC
$g_aiAndroidTimeLag[2] = $curr_hostTimer
$g_aiAndroidTimeLag[3] = 0
Return SetError(2, 0, False)
EndIf
Local $hostSeconds = Int(__TimerDiff($hostTimer) / 1000)
Local $hostMinutes = $hostSeconds / 60
Local $androidSeconds = $curr_androidUTC - $androidUTC
Local $lagTotal = $hostSeconds - $androidSeconds
Local $lagComp = Int($g_aiAndroidTimeLag[3] / 1000)
$lagTotal -= $lagComp
Local $lagPerMin = Int($lagTotal / $hostMinutes)
SetDebugLog($g_sAndroidEmulator & " time lag is " &($lagPerMin > 0 ? "> " : "") & $lagPerMin & " sec/min (avg for " & $hostSeconds & " sec, Android suspend time was " & $lagComp & " sec)")
If $androidSeconds <= 0 Then
InitAndroidTimeLag(False)
Return SetError(6, 0, False)
EndIf
If $lagPerMin < 0 Then $lagPerMin = 0
$g_aiAndroidTimeLag[0] = $lagPerMin
$g_aiAndroidTimeLag[1] = $curr_androidUTC
$g_aiAndroidTimeLag[2] = $curr_hostTimer
$g_aiAndroidTimeLag[3] = 0
If $lagPerMin > $g_iAndroidTimeLagThreshold Then
$g_aiAndroidTimeLag[4] += 1
$g_aiAndroidTimeLag[5] = __TimerInit()
SetLog($g_aiAndroidTimeLag[4] & ". Time lag detected of " & $lagPerMin & " sec/min for " & $g_sAndroidEmulator, $COLOR_ERROR)
InitAndroidTimeLag(False)
EndIf
Local $bReboot = False
If $bRebootAndroid And $g_aiAndroidTimeLag[4] >= $g_iAndroidTimeLagRebootThreshold Then
SetLog("Rebooting " & $g_sAndroidEmulator & " due to " & $g_aiAndroidTimeLag[4] & " time lag problems", $COLOR_ERROR)
$bReboot = True
EndIf
Return SetError(0, $lagPerMin, $bReboot)
EndFunc
Global $g_aiAndroidPageError[2] = [0, 0]
Func InitAndroidPageError()
$g_aiAndroidPageError[0] = 0
$g_aiAndroidPageError[1] = 0
EndFunc
Func CheckAndroidPageError($bRebootAndroid = True)
If $g_aiAndroidPageError[1] = 0 Then Return False
Local $bResetTimer = __TimerDiff($g_aiAndroidPageError[1]) > $g_iAndroidRebootPageErrorPerMinutes * 60 * 1000
If $g_aiAndroidPageError[0] >= $g_iAndroidRebootPageErrorCount And $bResetTimer = False Then
Local $sMin = Round(__TimerDiff($g_aiAndroidPageError[1]) /(60 * 1000), 1) & " Minutes"
If $bRebootAndroid = True Then
SetLog("Reboot " & $g_sAndroidEmulator & " due to " & $g_aiAndroidPageError[0] & " page errors in " & $sMin, $COLOR_ERROR)
Else
SetLog($g_sAndroidEmulator & " had " & $g_aiAndroidPageError[0] & " page errors in " & $sMin, $COLOR_ERROR)
EndIf
InitAndroidPageError()
If $bRebootAndroid = True Then
Return True
EndIf
Return False
EndIf
If $bResetTimer = True Then
If $g_aiAndroidPageError[0] > 0 Then
SetDebugLog("Cleared " & $g_aiAndroidPageError[0] & " " & $g_sAndroidEmulator & " page errors")
EndIf
InitAndroidPageError()
EndIf
Return False
EndFunc
Func AndroidPageError($sSource)
$g_aiAndroidPageError[0] += 1
SetDebugLog("Page error count increased to " & $g_aiAndroidPageError[0] & ", source: " & $sSource)
If $g_aiAndroidPageError[1] = 0 Then $g_aiAndroidPageError[1] = __TimerInit()
Return $g_aiAndroidPageError[0]
EndFunc
Func InitAndroidRebootCondition($bLaunched = True)
If $bLaunched = False Then
$g_hAndroidLaunchTime = 0
Return False
EndIf
$g_hAndroidLaunchTime = __TimerInit()
Return True
EndFunc
Func CheckAndroidRebootCondition($bRebootAndroid = True, $bLogOnly = False)
If $g_hAndroidLaunchTime = 0 Then InitAndroidRebootCondition(True)
If $g_bGfxError Then
$g_bGfxError = False
SetLog("Reboot " & $g_sAndroidEmulator & " (" & $g_sAndroidInstance & ") due to detected Gfx Errors")
Return True
EndIF
If $g_iAndroidRebootHours <= 0 Then Return False
Local $iLaunched = __TimerDiff($g_hAndroidLaunchTime)
If $bLogOnly = True Then
Local $day = 0, $hour = 0, $min = 0, $sec = 0, $sTime
_TicksToDay($g_iAndroidRebootHours * 60 * 60 * 1000 - $iLaunched, $day, $hour, $min, $sec)
$sTime = StringFormat("%id %ih %im", $day, $hour, $min)
SetLog($g_sAndroidEmulator & " (" & $g_sAndroidInstance & ") will be automatically rebooted in " & $sTime)
Return True
EndIf
If $g_bIdleState = False Then Return False
Local $iRunTimeHrs = $iLaunched /(60 * 60 * 1000)
If $iRunTimeHrs >= $g_iAndroidRebootHours Then
SetLog("Reboot " & $g_sAndroidEmulator & " (" & $g_sAndroidInstance & ") due to configured run-time of " & $g_iAndroidRebootHours & "h")
Return True
EndIf
Return False
EndFunc
Func OpenBS($bRestart = False)
Return OpenAndroid($bRestart)
EndFunc
Func OpenBlueStacks($bRestart = False)
Local $hTimer, $iCount = 0, $cmdPar
Local $PID, $ErrorResult, $connected_to, $process_killed
SetLog("Starting BlueStacks and Clash Of Clans", $COLOR_SUCCESS)
LaunchConsole($g_sAndroidAdbPath, "start-server", $process_killed)
$cmdPar = GetAndroidProgramParameter()
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath)
$ErrorResult = ControlGetHandle("BlueStacks Error", "", "")
If $g_bDebugAndroid Then SetDebugLog("$PID= " & $PID & ", $ErrorResult = " & $ErrorResult, $COLOR_DEBUG)
If $PID = 0 Or $ErrorResult <> 0 Then
SetError(1, 1, -1)
Return False
EndIf
WinGetAndroidHandle()
$hTimer = __TimerInit()
While $g_hAndroidControl = 0
If _Sleep(3000) Then ExitLoop
_StatusUpdateTime($hTimer, $g_sAndroidEmulator & " Starting")
If __TimerDiff($hTimer) > $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog("BlueStacks refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnstop()
SetError(1, 1, -1)
Return False
EndIf
WinGetAndroidHandle()
WEnd
If $g_hAndroidControl Then
$connected_to = ConnectAndroidAdb(False, 3000)
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return
If Not $g_bRunState Then Return False
SetLog("BlueStacks Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func OpenBlueStacks2($bRestart = False)
Local $hTimer, $iCount = 0, $cmdOutput, $process_killed, $i, $connected_to, $PID, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
If Not InitAndroid() Then Return False
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
CloseUnsupportedBlueStacks2()
LaunchConsole($g_sAndroidAdbPath, "start-server", $process_killed)
$hTimer = __TimerInit()
WinGetAndroidHandle()
Local $bStopIfLaunchFails = False
While $g_hAndroidControl = 0
If Not $g_bRunState Then Return False
$cmdPar = GetAndroidProgramParameter()
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath, Default, $bStopIfLaunchFails)
If $PID > 0 Then $PID = ProcessExists2($g_sAndroidProgramPath, $g_sAndroidInstance)
If $PID <= 0 Then
CloseAndroid("OpenBlueStacks2")
$bStopIfLaunchFails = True
If _Sleep(1000) Then Return False
EndIf
_StatusUpdateTime($hTimer)
If __TimerDiff($hTimer) > $g_iAndroidLaunchWaitSec * 1000 Or($PID = 0 And $bStopIfLaunchFails = True) Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
If _Sleep(3000) Then Return False
_StatusUpdateTime($hTimer, $g_sAndroidEmulator & " Starting")
WinGetAndroidHandle()
WEnd
WinGetAndroidHandle()
Local $aWin = WinGetPos($g_hAndroidWindow)
Local $lCurStyle = _WinAPI_GetWindowLong($g_hAndroidWindow, $GWL_STYLE)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_STYLE, BitOR($lCurStyle, $WS_CAPTION, $WS_SYSMENU))
Local $iCaptionHeight = _WinAPI_GetSystemMetrics($SM_CYCAPTION)
If BitAND($lCurStyle, BitOR($WS_CAPTION, $WS_SYSMENU)) <> BitOR($WS_CAPTION, $WS_SYSMENU) And UBound($aWin) > 3 Then
WinMove2($g_hAndroidWindow, "", $aWin[0], $aWin[1], $aWin[2], $aWin[3] + $iCaptionHeight)
EndIf
If $g_hAndroidControl Then
$connected_to = ConnectAndroidAdb(False, 3000)
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return
If Not $g_bRunState Then Return False
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
AndroidAdbLaunchShellInstance()
If Not $g_bRunState Then Return False
ConfigBlueStacks2WindowManager()
Return True
EndIf
Return False
EndFunc
Func GetBlueStacksXAdbPath()
Local $adbPath = $__BlueStacks_Path & "HD-Adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func GetBlueStacksAdbPath()
Return GetBlueStacksXAdbPath()
EndFunc
Func GetBlueStacks2AdbPath()
Return GetBlueStacksXAdbPath()
EndFunc
Func InitBlueStacksX($bCheckOnly = False, $bAdjustResolution = False, $bLegacyMode = False)
Local $plusMode = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\", "Engine") = "plus" And $bLegacyMode = False
Local $frontend_exe = ["HD-Frontend.exe", "HD-Player.exe"]
If $plusMode = True Then
Local $frontend_exe = "HD-Plus-Frontend.exe"
EndIf
Local $i, $aFiles = [$frontend_exe, "HD-Adb.exe", "HD-Quit.exe"]
Local $Values[4][3] = [ ["Screen Width", $g_iAndroidClientWidth, $g_iAndroidClientWidth], ["Screen Height", $g_iAndroidClientHeight, $g_iAndroidClientHeight], ["Window Width", $g_iAndroidWindowWidth, $g_iAndroidWindowWidth], ["Window Height", $g_iAndroidWindowHeight, $g_iAndroidWindowHeight] ]
Local $bChanged = False
$__BlueStacks_Version = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\", "Version")
$__BlueStacks_Path = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\", "InstallDir")
If @error <> 0 Then
$__BlueStacks_Path = @ProgramFilesDir & "\BlueStacks\"
SetError(0, 0, 0)
EndIf
$__BlueStacks_Path = StringReplace($__BlueStacks_Path, "\\", "\")
Local $sPreferredADB = FindPreferredAdbPath()
If $sPreferredADB Then _ArrayDelete($aFiles, 1)
For $i = 0 To UBound($aFiles) - 1
Local $File
Local $bFileFound = False
Local $aFiles2 = $aFiles[$i]
If Not IsArray($aFiles2) Then Local $aFiles2 = [$aFiles[$i]]
For $j = 0 To UBound($aFiles2) - 1
$File = $__BlueStacks_Path & $aFiles2[$j]
$bFileFound = FileExists($File)
If $bFileFound Then
If $i = 0 And IsArray($frontend_exe) Then $frontend_exe = $aFiles2[$j]
ExitLoop
EndIf
Next
If Not $bFileFound Then
If $plusMode And Not $bLegacyMode And $i = 0 Then
SetDebugLog("Cannot find " & $g_sAndroidEmulator & " file:" & $File, $COLOR_ACTION)
SetDebugLog("Try legacy mode", $COLOR_ACTION)
Return InitBlueStacksX($bCheckOnly, $bAdjustResolution, True)
EndIf
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($File, $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
Next
If Not $bCheckOnly Then
$g_iAndroidAdbSuCommand = "/system/xbin/bstk/su"
Local $BootParameter = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\", "BootParameters")
Local $OEMFeatures
Local $aRegExResult = StringRegExp($BootParameter, "OEMFEATURES=(\d+)", $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$OEMFeatures = $aRegExResult[UBound($aRegExResult) - 1]
$g_bAndroidHasSystemBar = BitAND($OEMFeatures, 0x000001) = 0
EndIf
$g_sAndroidPath = $__BlueStacks_Path
$g_sAndroidProgramPath = $__BlueStacks_Path & $frontend_exe
$g_sAndroidAdbPath = $sPreferredADB
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = $__BlueStacks_Path & "HD-Adb.exe"
$g_sAndroidVersion = $__BlueStacks_Version
For $i = 0 To 5
If RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\SharedFolder\" & $i & "\", "Name") = "BstSharedFolder" Then
$g_sAndroidPicturesPath = "/storage/sdcard/windows/BstSharedFolder/"
$g_sAndroidPicturesHostPath = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\SharedFolder\" & $i & "\", "Path")
ExitLoop
EndIf
Next
SetDebugLog($g_sAndroidEmulator & " Engine 'Plus'-Mode: " & $plusMode)
SetDebugLog($g_sAndroidEmulator & " OEM Features: " & $OEMFeatures)
SetDebugLog($g_sAndroidEmulator & " System Bar is " &($g_bAndroidHasSystemBar ? "" : "not ") & "available")
For $i = 0 To UBound($Values) - 1
If $Values[$i][1] <> $Values[$i][2] Then
$bChanged = True
SetDebugLog($g_sAndroidEmulator & " " & $Values[$i][0] & " updated from " & $Values[$i][1] & " to " & $Values[$i][2])
EndIf
Next
WinGetAndroidHandle()
EndIf
Return True
EndFunc
Func InitBlueStacks($bCheckOnly = False)
Local $bInstalled = InitBlueStacksX($bCheckOnly)
If $bInstalled And(GetVersionNormalized($__BlueStacks_Version) < GetVersionNormalized("0.8") Or GetVersionNormalized($__BlueStacks_Version) > GetVersionNormalized("1.x") > 0) Then
If Not $bCheckOnly Then
SetLog("BlueStacks version is " & $__BlueStacks_Version & " but support version 0.8.x - 1.x not found", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
$g_bAndroidHasSystemBar = True
EndIf
Return $bInstalled
EndFunc
Func InitBlueStacks2($bCheckOnly = False)
Local $bInstalled = InitBlueStacksX($bCheckOnly, True)
If $bInstalled And StringInStr($__BlueStacks_Version, "2.") <> 1 And StringInStr($__BlueStacks_Version, "3.") <> 1 And StringInStr($__BlueStacks_Version, "4.") <> 1 Then
If Not $bCheckOnly Then
SetLog("BlueStacks supported version 2.x, 3.x or 4.x not found", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If $bInstalled And Not $bCheckOnly Then
$__VBoxManage_Path = $__BlueStacks_Path & "BstkVMMgr.exe"
Local $bs3 = GetVersionNormalized("2.50.0.0")
Local $bs3WithFrame = GetVersionNormalized("2.56.75")
local $bsNow = GetVersionNormalized($__BlueStacks_Version)
If StringInStr($__BlueStacks_Version, "4.") = 1 Or(StringInStr($__BlueStacks_Version, "2.") = 1 And $bsNow >= $bs3 And $bsNow < $bs3WithFrame) Then
Local $aOff = [0, 13]
If $g_aiMouseOffsetWindowOnly[0] <> $aOff[0] Or $g_aiMouseOffsetWindowOnly[1] <> $aOff[1] Then
$g_aiMouseOffsetWindowOnly = $aOff
SetDebugLog("BlueStacks " & $__BlueStacks_Version & ": Adjust mouse clicks when running undocked by: " & $aOff[0] & ", " & $aOff[1])
EndIf
EndIf
Local $BstAdbPort = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\Config\", "BstAdbPort")
If $BstAdbPort Then
$g_sAndroidAdbDevice = "127.0.0.1:" & $BstAdbPort
Else
$g_sAndroidAdbDevice = $g_avAndroidAppConfig[$__BS2_Idx][10]
EndIf
EndIf
Return $bInstalled
EndFunc
Func GetBlueStacksBackgroundMode()
Return $g_iAndroidBackgroundModeDirectX
EndFunc
Func GetBlueStacks2BackgroundMode()
Local $GlRenderMode = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\Config\", "GlRenderMode")
Switch $GlRenderMode
Case 4
Return $g_iAndroidBackgroundModeDirectX
Case 1
Return $g_iAndroidBackgroundModeOpenGL
Case Else
SetLog($g_sAndroidEmulator & " unsupported render mode " & $GlRenderMode, $COLOR_WARNING)
Return 0
EndSwitch
EndFunc
Func RestartBlueStacksXCoC()
If Not $g_bRunState Then Return False
Local $cmdOutput
If Not InitAndroid() Then Return False
If WinGetAndroidHandle() = 0 Then Return False
$cmdOutput = AndroidAdbSendShellCommand("am start -W -n " & $g_sAndroidGamePackage & "/" & $g_sAndroidGameClass, 60000)
SetLog("Please wait for CoC restart......", $COLOR_INFO)
Return True
EndFunc
Func RestartBlueStacksCoC()
Return RestartBlueStacksXCoC()
EndFunc
Func RestartBlueStacks2CoC()
Return RestartBlueStacksXCoC()
EndFunc
Func CheckScreenBlueStacksX($bSetLog = True)
Local $REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\FrameBuffer\0"
Local $aValues[5][2] = [ ["FullScreen", 0], ["GuestHeight", $g_iAndroidClientHeight], ["GuestWidth", $g_iAndroidClientWidth], ["WindowHeight", $g_iAndroidClientHeight], ["WindowWidth", $g_iAndroidClientWidth] ]
Local $i, $Value, $iErrCnt = 0
For $i = 0 To UBound($aValues) - 1
$Value = RegRead($REGISTRY_KEY_DIRECTORY, $aValues[$i][0])
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
SetDebugLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
EndIf
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
$iErrCnt += 1
EndIf
Next
Local $DPI = 0
Local $BootParameter = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\", "BootParameters")
Local $aRegExResult = StringRegExp($BootParameter, "DPI=(\d+)", $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$DPI = $aRegExResult[UBound($aRegExResult) - 1]
If $DPI <> 160 Then
SetDebugLog("DPI is " & $DPI & " and will be changed to 160", $COLOR_ERROR)
$iErrCnt += 1
EndIf
Else
SetDebugLog("DPI is missing and will be set to 160", $COLOR_ERROR)
$iErrCnt += 1
EndIf
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func CheckScreenBlueStacks($bSetLog = True)
Return CheckScreenBlueStacksX($bSetLog)
EndFunc
Func CheckScreenBlueStacks2($bSetLog = True)
Return CheckScreenBlueStacksX($bSetLog)
EndFunc
Func SetScreenBlueStacks()
Local $REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\FrameBuffer\0"
RegWrite($REGISTRY_KEY_DIRECTORY, "FullScreen", "REG_DWORD", "0")
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestHeight", "REG_DWORD", $g_iAndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestWidth", "REG_DWORD", $g_iAndroidClientWidth)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowHeight", "REG_DWORD", $g_iAndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowWidth", "REG_DWORD", $g_iAndroidClientWidth)
$REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance
Local $BootParameter = RegRead($REGISTRY_KEY_DIRECTORY, "BootParameters")
$BootParameter = StringRegExpReplace($BootParameter, "DPI=\d+", "DPI=160")
If @error = 0 And @extended > 0 Then
RegWrite($REGISTRY_KEY_DIRECTORY, "BootParameters", "REG_SZ", $BootParameter)
Else
RegWrite($REGISTRY_KEY_DIRECTORY, "BootParameters", "REG_SZ", $BootParameter & " DPI=160")
EndIf
EndFunc
Func SetScreenBlueStacks2()
Local $REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\FrameBuffer\0"
RegWrite($REGISTRY_KEY_DIRECTORY, "FullScreen", "REG_DWORD", "0")
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestHeight", "REG_DWORD", $g_iAndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestWidth", "REG_DWORD", $g_iAndroidClientWidth)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowHeight", "REG_DWORD", $g_iAndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowWidth", "REG_DWORD", $g_iAndroidClientWidth)
$REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\Config"
RegWrite($REGISTRY_KEY_DIRECTORY, "FEControlBar", "REG_DWORD", "0")
$REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance
Local $BootParameter = RegRead($REGISTRY_KEY_DIRECTORY, "BootParameters")
$BootParameter = StringRegExpReplace($BootParameter, "DPI=\d+", "DPI=160")
If @error = 0 And @extended > 0 Then
RegWrite($REGISTRY_KEY_DIRECTORY, "BootParameters", "REG_SZ", $BootParameter)
Else
RegWrite($REGISTRY_KEY_DIRECTORY, "BootParameters", "REG_SZ", $BootParameter & " DPI=160")
EndIf
EndFunc
Func RebootBlueStacksSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func ConfigBlueStacks2WindowManager()
If Not $g_bRunState Then Return
Local $cmdOutput
$cmdOutput = AndroidAdbSendShellCommand("wm size reset", Default, Default, False)
$cmdOutput = AndroidAdbSendShellCommand("wm density 160", Default, Default, False)
AndroidSetFontSizeNormal()
EndFunc
Func RebootBlueStacks2SetScreen($bOpenAndroid = True)
If Not InitAndroid() Then Return False
ConfigBlueStacks2WindowManager()
CloseAndroid("RebootBlueStacks2SetScreen")
If _Sleep(1000) Then Return False
SetScreenAndroid()
If Not $g_bRunState Then Return False
If $bOpenAndroid Then
OpenAndroid(True)
EndIf
Return True
EndFunc
Func GetBlueStacksRunningInstance($bStrictCheck = True)
WinGetAndroidHandle()
Local $a[2] = [$g_hAndroidWindow, ""]
Return $a
EndFunc
Func GetBlueStacks2RunningInstance($bStrictCheck = True)
WinGetAndroidHandle()
Local $a[2] = [$g_hAndroidWindow, ""]
If $g_hAndroidWindow <> 0 Then Return $a
If $bStrictCheck Then Return False
Local $WinTitleMatchMode = Opt("WinTitleMatchMode", -3)
Local $h = WinGetHandle("Bluestacks App Player", "")
If @error = 0 Then
$a[0] = $h
EndIf
Opt("WinTitleMatchMode", $WinTitleMatchMode)
Return $a
EndFunc
Func GetBlueStacksProgramParameter($bAlternative = False)
Return $g_sAndroidInstance
EndFunc
Func GetBlueStacks2ProgramParameter($bAlternative = False)
Return $g_sAndroidInstance
EndFunc
Func BlueStacksBotStartEvent()
If $g_bAndroidEmbedded = False Then
SetDebugLog("Disable " & $g_sAndroidEmulator & " minimize/maximize Window Buttons")
DisableBS($g_hAndroidWindow, $SC_MINIMIZE)
DisableBS($g_hAndroidWindow, $SC_MAXIMIZE)
EndIf
Return AndroidCloseSystemBar()
EndFunc
Func BlueStacksBotStopEvent()
If $g_bAndroidEmbedded = False Then
SetDebugLog("Enable " & $g_sAndroidEmulator & " minimize/maximize Window Buttons")
EnableBS($g_hAndroidWindow, $SC_MINIMIZE)
EnableBS($g_hAndroidWindow, $SC_MAXIMIZE)
EndIf
Return AndroidOpenSystemBar()
EndFunc
Func BlueStacks2BotStartEvent()
If $g_bAndroidEmbedded = False Then
SetDebugLog("Disable " & $g_sAndroidEmulator & " minimize/maximize Window Buttons")
DisableBS($g_hAndroidWindow, $SC_MINIMIZE)
DisableBS($g_hAndroidWindow, $SC_MAXIMIZE)
EndIf
If $g_bAndroidHasSystemBar Then Return AndroidCloseSystemBar()
Return False
EndFunc
Func BlueStacks2BotStopEvent()
If $g_bAndroidEmbedded = False Then
SetDebugLog("Enable " & $g_sAndroidEmulator & " minimize/maximize Window Buttons")
EnableBS($g_hAndroidWindow, $SC_MINIMIZE)
EnableBS($g_hAndroidWindow, $SC_MAXIMIZE)
EndIf
If $g_bAndroidHasSystemBar Then Return AndroidOpenSystemBar()
Return False
EndFunc
Func BlueStacksAdjustClickCoordinates(ByRef $x, ByRef $y)
$x = Round(32767.0 / $g_iAndroidClientWidth * $x)
$y = Round(32767.0 / $g_iAndroidClientHeight * $y)
EndFunc
Func BlueStacks2AdjustClickCoordinates(ByRef $x, ByRef $y)
$x = Round(32767.0 / $g_iAndroidClientWidth * $x)
$y = Round(32767.0 / $g_iAndroidClientHeight * $y)
EndFunc
Func DisableBS($HWnD, $iButton)
Local $hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, 0)
_GUICtrlMenu_RemoveMenu($hSysMenu, $iButton, False)
_GUICtrlMenu_DrawMenuBar($HWnD)
EndFunc
Func EnableBS($HWnD, $iButton)
Local $hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, 1)
_GUICtrlMenu_RemoveMenu($hSysMenu, $iButton, False)
_GUICtrlMenu_DrawMenuBar($HWnD)
EndFunc
Func GetBlueStacksSvcPid()
Local $PID = ProcessExists2("HD-Service.exe")
Return $PID
EndFunc
Func CloseBlueStacks()
Local $iIndex, $bOops = False
Local $aServiceList[4] = ["BstHdAndroidSv", "BstHdLogRotatorSvc", "BstHdUpdaterSvc", "bthserv"]
If Not InitAndroid() Then Return
SetDebugLog("Closing BlueStacks: " & $__BlueStacks_Path & "HD-Quit.exe")
RunWait($__BlueStacks_Path & "HD-Quit.exe")
If @error <> 0 Then
SetLog($g_sAndroidEmulator & " failed to quit", $COLOR_ERROR)
EndIf
If _Sleep(2000) Then Return
$bOops = ProcessExists("HD-Frontend.exe") <> 0
If $bOops Then
$bOops = False
SetDebugLog("Failed to terminate HD-Frontend.exe with HD-Quit.exe, fallback to taskkill", $COLOR_ERROR)
KillBSProcess()
If _Sleep(1000) Then Return
SetLog("Please wait for full BS shutdown....", $COLOR_SUCCESS)
For $iIndex = 0 To UBound($aServiceList) - 1
ServiceStop($aServiceList[$iIndex])
If @error Then
$bOops = True
If $g_bDebugAndroid Then SetDebugLog($aServiceList[$iIndex] & "errored trying to stop", $COLOR_WARNING)
EndIf
Next
If $bOops Then
If $g_bDebugAndroid Then SetDebugLog("Service Stop issues, Stopping BS 2nd time", $COLOR_WARNING)
KillBSProcess()
If _SleepStatus(5000) Then Return
EndIf
EndIf
If $g_bDebugAndroid And $bOops Then
SetLog("BS Kill Failed to stop service", $COLOR_ERROR)
EndIf
If $bOops Then
SetError(1, @extended, -1)
EndIf
EndFunc
Func CloseBlueStacks2()
Local $bOops = False
If Not InitAndroid() Then Return
If Not CloseUnsupportedBlueStacksX(False) And GetVersionNormalized($g_sAndroidVersion) > GetVersionNormalized("2.10") Then
Local $aFiles = ["HD-Frontend.exe", "HD-Plus-Service.exe", "HD-Service.exe"]
For $sFile In $aFiles
Local $PID
$PID = ProcessExists2($sFile, $g_sAndroidInstance)
If $PID Then
ShellExecute(@WindowsDir & "\System32\taskkill.exe", " -f -t -pid " & $PID, "", Default, @SW_HIDE)
If _Sleep(1000) Then Return
EndIf
Next
If _Sleep(1000) Then Return
For $sFile In $aFiles
Local $PID
$PID = ProcessExists2($sFile, $g_sAndroidInstance)
If $PID Then
SetLog($g_sAndroidEmulator & " failed to kill " & $sFile, $COLOR_ERROR)
EndIf
Next
Else
SetDebugLog("Closing BlueStacks: " & $__BlueStacks_Path & "HD-Quit.exe")
RunWait($__BlueStacks_Path & "HD-Quit.exe")
If @error <> 0 Then
SetLog($g_sAndroidEmulator & " failed to quit", $COLOR_ERROR)
EndIf
EndIf
If _Sleep(2000) Then Return
If $bOops Then
SetError(1, @extended, -1)
EndIf
EndFunc
Func KillBSProcess()
Local $aBS_FileNames[8][2] = [['HD-Agent.exe', 0], ['HD-BlockDevice.exe', 0], ['HD-Frontend.exe', 0], ['HD-Network.exe', 0], ['HD-Service.exe', 0], ['HD-SharedFolder.exe', 0], ['HD-UpdaterService.exe', 0], ['HD-Adb.exe', 0]]
For $iIndex = 0 To UBound($aBS_FileNames) - 1
$aBS_FileNames[$iIndex][1] = ProcessExists($aBS_FileNames[$iIndex][0])
If $g_bDebugAndroid Then SetDebugLog($aBS_FileNames[$iIndex][0] & " PID = " & $aBS_FileNames[$iIndex][1], $COLOR_DEBUG)
If $aBS_FileNames[$iIndex][1] > 0 Then
ShellExecute(@WindowsDir & "\System32\taskkill.exe", " -t -pid " & $aBS_FileNames[$iIndex][1], "", Default, @SW_HIDE)
If _Sleep(1000) Then Return
EndIf
If ProcessExists($aBS_FileNames[$iIndex][1]) Then
If $g_bDebugAndroid Then SetDebugLog($aBS_FileNames[$iIndex][0] & " 1st Kill failed, trying again", $COLOR_DEBUG)
ShellExecute(@WindowsDir & "\System32\taskkill.exe", "-f -t -pid " & $aBS_FileNames[$iIndex][1], "", Default, @SW_HIDE)
If _Sleep(500) Then Return
EndIf
Next
EndFunc
Func ServiceStop($sServiceName)
Local $ServiceRunning, $svcWaitIterations, $data, $PID, $hTimer, $bFailed, $Result
$hTimer = __TimerInit()
$Result = RunWait(@ComSpec & " /c " & 'net stop ' & $sServiceName, "", @SW_HIDE)
If @error Then
SetLog("net stop service failed on " & $sServiceName & ", Result= " & $Result, $COLOR_ERROR)
SetError(1, @extended, -1)
Return
EndIf
$ServiceRunning = True
$svcWaitIterations = 0
While $ServiceRunning
_StatusUpdateTime($hTimer, "BS Service Stop")
$data = ""
$PID = Run(@WindowsDir & '\System32\sc.exe query ' & $sServiceName, '', @SW_HIDE, 2)
Do
$data &= StdoutRead($PID)
Until @error
StdioClose($PID)
$Result = StringInStr($data, "stopped")
$bFailed = StringInStr($data, "failed")
If $Result Then
$ServiceRunning = False
EndIf
$svcWaitIterations = $svcWaitIterations + 1
If $svcWaitIterations > 15 Or $bFailed Then
SetError(1, @extended, -1)
$ServiceRunning = False
EndIf
If _Sleep(1000) Then Return
WEnd
If $g_bDebugAndroid And $svcWaitIterations > 15 Then
SetLog("Failed to stop service " & $sServiceName, $COLOR_ERROR)
Else
If $g_bDebugAndroid Then SetDebugLog($sServiceName & "Service stopped successfully", $COLOR_SUCCESS)
EndIf
EndFunc
Func CloseUnsupportedBlueStacks2()
Return CloseUnsupportedBlueStacksX()
EndFunc
Func CloseUnsupportedBlueStacksX($bClose = True)
Local $WinTitleMatchMode = Opt("WinTitleMatchMode", -3)
Local $sPartnerExePath = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Config\", "PartnerExePath")
If IsArray(ControlGetPos("Bluestacks App Player", "", "")) Or($sPartnerExePath And ProcessExists2($sPartnerExePath)) Then
Opt("WinTitleMatchMode", $WinTitleMatchMode)
If $bClose = True Then
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " App Player", $COLOR_ERROR)
SetLog("Please let MyBot start " & $g_sAndroidEmulator & " automatically", $COLOR_INFO)
RebootBlueStacks2SetScreen(False)
EndIf
Return True
EndIf
Opt("WinTitleMatchMode", $WinTitleMatchMode)
Return False
EndFunc
Func OpenDroid4X($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $launchAndroid, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
$launchAndroid = WinGetAndroidHandle() = 0
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath)
If $PID = 0 Then
SetError(1, 1, -1)
Return False
EndIf
EndIf
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return False
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
$hTimer = __TimerInit()
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If Not $g_bRunState Then Return False
If __TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func GetDroid4XProgramParameter($bAlternative = False)
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Return "-o " &($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
EndIf
Return ""
EndFunc
Func GetDroid4XPath()
Local $droid4xPath = RegRead($g_sHKLM & "\SOFTWARE\Droid4X\", "InstallDir")
If @error <> 0 Then
Local $DisplayIcon = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\Droid4X\", "DisplayIcon")
If @error = 0 Then
Local $iLastBS = StringInStr($DisplayIcon, "\", 0, -1)
$droid4xPath = StringLeft($DisplayIcon, $iLastBS)
EndIf
EndIf
If @error <> 0 Then
$droid4xPath = @ProgramFilesDir & "\Droid4X\"
SetError(0, 0, 0)
EndIf
Return StringReplace($droid4xPath, "\\", "\")
EndFunc
Func GetDroid4XAdbPath()
Local $adbPath = GetDroid4XPath() & "adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func GetDroid4XBackgroundMode()
Return $g_iAndroidBackgroundModeOpenGL
EndFunc
Func InitDroid4X($bCheckOnly = False)
Local $process_killed, $aRegExResult, $VirtualBox_Path, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
$__Droid4X_Version = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\Droid4X\", "DisplayVersion")
$__Droid4X_Path = GetDroid4XPath()
$VirtualBox_Path = RegRead($g_sHKLM & "\SOFTWARE\Oracle\VirtualBox\", "InstallDir")
If @error <> 0 Then
$VirtualBox_Path = @ProgramFilesDir & "\Oracle\VirtualBox\"
SetError(0, 0, 0)
EndIf
$VirtualBox_Path = StringReplace($VirtualBox_Path, "\\", "\")
If FileExists($__Droid4X_Path & "Droid4X.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($__Droid4X_Path & "Droid4X.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
Local $sPreferredADB = FindPreferredAdbPath()
If $sPreferredADB = "" And FileExists($__Droid4X_Path & "adb.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($__Droid4X_Path & "adb.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($VirtualBox_Path & "VBoxManage.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find VirtualBox:", $COLOR_ERROR)
SetLog($VirtualBox_Path & "VBoxManage.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
$__VBoxManage_Path = $VirtualBox_Path & "VBoxManage.exe"
If Not GetAndroidVMinfo($__VBoxVMinfo, $__VBoxManage_Path) Then Return False
$aRegExResult = StringRegExp($__VBoxVMinfo, "ADB_PORT.*host ip = ([^,]+),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDeviceHost = " & $g_sAndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Host", $COLOR_ERROR)
EndIf
$aRegExResult = StringRegExp($__VBoxVMinfo, "ADB_PORT.*host port = (\d{3,5}),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIf
If $oops = 0 Then
$g_sAndroidAdbDevice = $g_sAndroidAdbDeviceHost & ":" & $g_sAndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_ERROR)
EndIf
$g_sAndroidProgramPath = $__Droid4X_Path & "Droid4X.exe"
$g_sAndroidPath = $__Droid4X_Path
$g_sAndroidAdbPath = $sPreferredADB
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = $__Droid4X_Path & "adb.exe"
$g_sAndroidVersion = $__Droid4X_Version
If $g_sAndroidInstance = "" Or StringCompare($g_sAndroidInstance, $g_avAndroidAppConfig[$g_iAndroidConfig][1]) = 0 Then
Else
If $g_sAndroidTitle = $g_avAndroidAppConfig[$g_iAndroidConfig][2] Then
$g_sAndroidTitle = StringReplace($g_avAndroidAppConfig[$g_iAndroidConfig][2], "Droid4X", $g_sAndroidInstance)
EndIf
EndIf
$g_sAndroidPicturesPath = "/mnt/shared/picture/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'picture', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidPicturesHostPath = $aRegExResult[0] & "\"
$g_bAndroidSharedFolderAvailable = True
Else
SetLog($g_sAndroidEmulator & " Background Mode is not available", $COLOR_ERROR)
$g_sAndroidPicturesHostPath = ""
$g_bAndroidAdbScreencap = False
$g_bAndroidSharedFolderAvailable = False
EndIf
WinGetAndroidHandle()
UpdateDroid4XConfig()
EndIf
Return True
EndFunc
Func SetScreenDroid4X()
If Not $g_bRunState Then Return False
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_graph_mode " & $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_dpi 160", $process_killed)
AndroidPicturePathAutoConfig()
If $g_bAndroidSharedFolderAvailable = False And $g_bAndroidPicturesPathAutoConfig = True And FileExists($g_sAndroidPicturesHostPath) = 1 Then
Local $path = $g_sAndroidPicturesHostPath
If StringRight($path, 1) = "\" Then $path = StringLeft($path, StringLen($path) - 1)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "sharedfolder add " & $g_sAndroidInstance & " --name picture --hostpath """ & $path & """  --automount", $process_killed)
EndIf
Return True
EndFunc
Func RebootDroid4XSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CheckScreenDroid4X($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[2][2] = [ ["vbox_dpi", "160"], ["vbox_graph_mode", $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16"] ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult, $properties
For $i = 0 To UBound($aValues) - 1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
Else
SetDebugLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
EndIf
$iErrCnt += 1
EndIf
Next
If $iErrCnt > 0 Then Return False
If AndroidPicturePathAutoConfig(Default, Default, $bSetLog) Then $iErrCnt += 1
Return True
EndFunc
Func UpdateDroid4XConfig()
Return UpdateDroid4XWindowState()
EndFunc
Func UpdateDroid4XWindowState()
WinGetAndroidHandle()
ControlGetPos($g_hAndroidWindow, $g_sAppPaneName, $g_sAppClassInstance)
If @error = 1 Then
SetError(0, 0, 0)
Return False
EndIf
Local $acw = $g_avAndroidAppConfig[$g_iAndroidConfig][5]
Local $ach = $g_avAndroidAppConfig[$g_iAndroidConfig][6]
Local $aww = $g_avAndroidAppConfig[$g_iAndroidConfig][7]
Local $awh = $g_avAndroidAppConfig[$g_iAndroidConfig][8]
Local $v = GetVersionNormalized($g_sAndroidVersion)
For $i = 0 To UBound($__Droid4X_Window) - 1
Local $v2 = GetVersionNormalized($__Droid4X_Window[$i][0])
If $v >= $v2 Then
SetDebugLog("Using Window sizes of " & $g_sAndroidEmulator & " " & $__Droid4X_Window[$i][0])
$aww = $__Droid4X_Window[$i][1]
$awh = $__Droid4X_Window[$i][2]
ExitLoop
EndIf
Next
Local $i
Local $Values[4][3] = [ ["Screen Width", $g_iAndroidClientWidth, $g_iAndroidClientWidth], ["Screen Height", $g_iAndroidClientHeight, $g_iAndroidClientHeight], ["Window Width", $g_iAndroidWindowWidth, $g_iAndroidWindowWidth], ["Window Height", $g_iAndroidWindowHeight, $g_iAndroidWindowHeight] ]
Local $bChanged = False, $ok = False
$Values[0][2] = $acw
$Values[1][2] = $ach
$Values[2][2] = $aww
$Values[3][2] = $awh
$g_iAndroidClientWidth = $Values[0][2]
$g_iAndroidClientHeight = $Values[1][2]
$g_iAndroidWindowWidth = $Values[2][2]
$g_iAndroidWindowHeight = $Values[3][2]
For $i = 0 To UBound($Values) - 1
If $Values[$i][1] <> $Values[$i][2] Then
$bChanged = True
SetDebugLog($g_sAndroidEmulator & " " & $Values[$i][0] & " updated from " & $Values[$i][1] & " to " & $Values[$i][2])
EndIf
Next
Return $bChanged
EndFunc
Func CloseDroid4X()
Return CloseVboxAndroidSvc()
EndFunc
Func OpenMEmu($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
Local $launchAndroid =(WinGetAndroidHandle() = 0 ? True : False)
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath)
If $PID = 0 Then
SetError(1, 1, -1)
Return False
EndIf
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
$hTimer = __TimerInit()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return False
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If __TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func GetMEmuProgramParameter($bAlternative = False)
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Return($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
EndIf
Return ""
EndFunc
Func GetMEmuPath()
Local $MEmu_Path = EnvGet("MEmu_Path") & "\MEmu\"
If FileExists($MEmu_Path & "MEmu.exe") = 0 Then
Local $InstallLocation = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\MEmu\", "InstallLocation")
If @error = 0 And FileExists($InstallLocation & "\MEmu\MEmu.exe") = 1 Then
$MEmu_Path = $InstallLocation & "\MEmu\"
Else
Local $DisplayIcon = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\MEmu\", "DisplayIcon")
If @error = 0 Then
Local $iLastBS = StringInStr($DisplayIcon, "\", 0, -1)
$MEmu_Path = StringLeft($DisplayIcon, $iLastBS)
If StringLeft($MEmu_Path, 1) = """" Then $MEmu_Path = StringMid($MEmu_Path, 2)
Else
$MEmu_Path = @ProgramFilesDir & "\Microvirt\MEmu\"
SetError(0, 0, 0)
EndIf
EndIf
EndIf
$MEmu_Path = StringReplace($MEmu_Path, "\\", "\")
Return $MEmu_Path
EndFunc
Func GetMEmuAdbPath()
Local $adbPath = GetMEmuPath() & "adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func GetMEmuBackgroundMode()
Local $iDirectX = $g_iAndroidBackgroundModeDirectX
Local $iOpenGL = $g_iAndroidBackgroundModeOpenGL
If @OSBuild >= 16299 Then
SetDebugLog("DirectX/OpenGL Fix applied for Windows Build 16299")
$iDirectX = $g_iAndroidBackgroundModeOpenGL
$iOpenGL = $g_iAndroidBackgroundModeDirectX
EndIf
Local $aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: graphics_render_mode, value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then
Local $graphics_render_mode = $aRegExResult[0]
SetDebugLog($g_sAndroidEmulator & " instance " & $g_sAndroidInstance & " rendering mode is " & $graphics_render_mode)
Switch $graphics_render_mode
Case "1"
Return $iDirectX
Case "2"
Return $iDirectX
Case Else
Return $iOpenGL
EndSwitch
EndIf
Return $iOpenGL
EndFunc
Func InitMEmu($bCheckOnly = False)
Local $process_killed, $aRegExResult, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
Local $MEmuVersion = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\MEmu\", "DisplayVersion")
SetError(0, 0, 0)
Local $MEmu_Path = GetMEmuPath()
Local $MEmu_Manage_Path = EnvGet("MEmuHyperv_Path") & "\MEmuManage.exe"
If FileExists($MEmu_Manage_Path) = 0 Then
$MEmu_Manage_Path = $MEmu_Path & "..\MEmuHyperv\MEmuManage.exe"
EndIf
If FileExists($MEmu_Path & "MEmu.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($MEmu_Path & "MEmu.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
Local $sPreferredADB = FindPreferredAdbPath()
If $sPreferredADB = "" And FileExists($MEmu_Path & "adb.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($MEmu_Path & "adb.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($MEmu_Manage_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find MEmu-Hyperv:", $COLOR_ERROR)
SetLog($MEmu_Manage_Path, $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
If Not GetAndroidVMinfo($__VBoxVMinfo, $MEmu_Manage_Path) Then Return False
$g_sAndroidProgramPath = $MEmu_Path & "MEmu.exe"
$g_sAndroidAdbPath = $sPreferredADB
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = $MEmu_Path & "adb.exe"
$g_sAndroidVersion = $MEmuVersion
$__MEmu_Path = $MEmu_Path
$g_sAndroidPath = $__MEmu_Path
$__VBoxManage_Path = $MEmu_Manage_Path
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = ADB.*host ip = ([^,]+),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDeviceHost = " & $g_sAndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Host", $COLOR_ERROR)
EndIf
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = ADB.*host port = (\d{3,5}),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIf
If $oops = 0 Then
$g_sAndroidAdbDevice = $g_sAndroidAdbDeviceHost & ":" & $g_sAndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_ERROR)
EndIf
$g_sAndroidPicturesPath = "/mnt/shell/emulated/0/Pictures/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'picture', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidPicturesHostPath = $aRegExResult[0] & "\"
Else
$oops = 1
$g_bAndroidAdbScreencap = False
$g_sAndroidPicturesHostPath = ""
SetLog($g_sAndroidEmulator & " Background Mode is not available", $COLOR_ERROR)
EndIf
$__VBoxGuestProperties = LaunchConsole($__VBoxManage_Path, "guestproperty enumerate " & $g_sAndroidInstance, $process_killed)
UpdateMEmuConfig()
EndIf
Return SetError($oops, 0, True)
EndFunc
Func SetScreenMEmu()
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " resolution_width " & $g_iAndroidClientWidth, $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " resolution_height " & $g_iAndroidClientHeight, $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " is_full_screen 0", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " is_customed_resolution 1", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_dpi 160", $process_killed)
Return True
EndFunc
Func RebootMEmuSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseMEmu()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenMEmu($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[4][2] = [ ["is_full_screen", "0"], ["vbox_dpi", "160"], ["resolution_height", $g_iAndroidClientHeight], ["resolution_width", $g_iAndroidClientWidth] ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult
For $i = 0 To UBound($aValues) - 1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
Else
SetDebugLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
EndIf
$iErrCnt += 1
EndIf
Next
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func UpdateMEmuConfig()
Local $aRegExResult
Local $iSizeConfig = FindMEmuWindowConfig()
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: phone_layout, value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then
$__MEmu_PhoneLayout = $aRegExResult[0]
If $iSizeConfig > -1 And $__MEmu_Window[$iSizeConfig][4] = "-1" Then
SetDebugLog($g_sAndroidEmulator & " phone_layout is " & $__MEmu_PhoneLayout & ", but set to -1 to disable screen compensation")
$__MEmu_PhoneLayout = $__MEmu_Window[$iSizeConfig][4]
Else
SetDebugLog($g_sAndroidEmulator & " phone_layout is " & $__MEmu_PhoneLayout)
EndIf
Else
SetDebugLog("Cannot read " & $g_sAndroidEmulator & " guestproperty phone_layout!", $COLOR_ERROR)
If $iSizeConfig > -1 Then
$__MEmu_PhoneLayout = $__MEmu_Window[$iSizeConfig][4]
SetDebugLog("Using phone_layout " & $__MEmu_PhoneLayout)
EndIf
EndIf
SetError(0, 0, 0)
Return UpdateMEmuWindowState()
EndFunc
Func FindMEmuWindowConfig()
Local $v = GetVersionNormalized($g_sAndroidVersion)
For $i = 0 To UBound($__MEmu_Window) - 1
Local $v2 = GetVersionNormalized($__MEmu_Window[$i][0])
If $v >= $v2 Then
SetDebugLog("Using Window sizes of " & $g_sAndroidEmulator & " " & $__MEmu_Window[$i][0])
Return $i
EndIf
Next
SetDebugLog("Cannot find Window sizes of " & $g_sAndroidEmulator & " " & $g_sAndroidVersion)
Return -1
EndFunc
Func UpdateMEmuWindowState()
WinGetAndroidHandle()
ControlGetPos($g_hAndroidWindow, $g_sAppPaneName, $g_sAppClassInstance)
If @error = 1 Then
SetError(0, 0, 0)
EndIf
Local $acw = $g_avAndroidAppConfig[$g_iAndroidConfig][5]
Local $ach = $g_avAndroidAppConfig[$g_iAndroidConfig][6]
Local $aww = $g_avAndroidAppConfig[$g_iAndroidConfig][7]
Local $awh = $g_avAndroidAppConfig[$g_iAndroidConfig][8]
Local $tbw = $__MEmu_ToolBar_Width
Local $iSizeConfig = FindMEmuWindowConfig()
If $iSizeConfig > -1 Then
$aww = $__MEmu_Window[$iSizeConfig][1]
$awh = $__MEmu_Window[$iSizeConfig][2]
$tbw = $__MEmu_Window[$iSizeConfig][3]
EndIf
Local $bToolBarVisible = True
Local $i
Local $Values[4][3] = [ ["Screen Width", $g_iAndroidClientWidth, $g_iAndroidClientWidth], ["Screen Height", $g_iAndroidClientHeight, $g_iAndroidClientHeight], ["Window Width", $g_iAndroidWindowWidth, $g_iAndroidWindowWidth], ["Window Height", $g_iAndroidWindowHeight, $g_iAndroidWindowHeight] ]
Local $bChanged = False, $ok = False
Local $toolBarPos = ControlGetPos($g_hAndroidWindow, "", "Qt5QWindowIcon3")
If UBound($toolBarPos) = 4 Then
Local $tbw_using = $tbw
If $toolBarPos[2] > 20 And $toolBarPos[2] < 60 Then $tbw_using = $toolBarPos[2]
SetDebugLog($g_sAndroidEmulator & " Tool Bar found, width = " & $toolBarPos[2] & ", height = " & $toolBarPos[3] & ", expected width = " & $tbw & ", using width = " & $tbw_using)
$tbw = $tbw_using
$bToolBarVisible = ControlCommand($g_hAndroidWindow, "", "Qt5QWindowIcon3", "IsVisible", "") = 1
SetDebugLog($g_sAndroidEmulator & " Tool Bar is " &($bToolBarVisible ? "visible" : "hidden"))
$ok = True
EndIf
If Not $ok Then
SetDebugLog($g_sAndroidEmulator & " Tool Bar state is undetermined as treated as " &($bToolBarVisible ? "visible" : "hidden"), $COLOR_ERROR)
EndIf
Local $w =($bToolBarVisible ? 0 : $tbw)
Switch $__MEmu_PhoneLayout
Case "0"
$Values[0][2] = $acw
$Values[1][2] = $ach + $__MEmu_SystemBar
$Values[2][2] = $aww - $w
$Values[3][2] = $awh + $__MEmu_SystemBar
Case "1"
$Values[0][2] = $acw + $__MEmu_SystemBar
$Values[1][2] = $ach
$Values[2][2] = $aww + $__MEmu_SystemBar - $w
$Values[3][2] = $awh
Case "2", "-1"
$Values[0][2] = $acw
$Values[1][2] = $ach
$Values[2][2] = $aww - $w
$Values[3][2] = $awh
Case Else
SetDebugLog("Unsupported " & $g_sAndroidEmulator & " guestproperty phone_layout = " & $__MEmu_PhoneLayout, $COLOR_ERROR)
EndSwitch
$g_iAndroidClientWidth = $Values[0][2]
$g_iAndroidClientHeight = $Values[1][2]
$g_iAndroidWindowWidth = $Values[2][2]
$g_iAndroidWindowHeight = $Values[3][2]
For $i = 0 To UBound($Values) - 1
If $Values[$i][1] <> $Values[$i][2] Then
$bChanged = True
SetDebugLog($g_sAndroidEmulator & " " & $Values[$i][0] & " updated from " & $Values[$i][1] & " to " & $Values[$i][2])
EndIf
Next
Return $bChanged
EndFunc
Func OpenLeapDroid($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
Local $launchAndroid =(WinGetAndroidHandle() = 0 ? True : False)
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath)
If $PID = 0 Then
SetError(1, 1, -1)
Return False
EndIf
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
$hTimer = __TimerInit()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return False
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If __TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func IsLeapDroidCommandLine($CommandLine)
SetDebugLog("Check LeapDroid command line instance: " & $CommandLine)
Local $sInstance =($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
$CommandLine = StringReplace($CommandLine, GetLeapDroidPath(), "")
If StringRegExp($CommandLine, "-s " & $sInstance & "\b") = 1 Then Return True
Return False
EndFunc
Func GetLeapDroidProgramParameter($bAlternative = False)
Local $sInstance =($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Return "-vfiber -novtcheck -w " & $g_iAndroidClientWidth & " -h " & $g_iAndroidClientHeight & " -s " & $sInstance
EndIf
Return "-s " & $sInstance
EndFunc
Func GetLeapDroidPath()
Local $LeapDroid_Path = RegRead($g_sHKLM & "\SOFTWARE\Leapdroid\Leapdroid VM\", "InstallDir")
If $LeapDroid_Path <> "" And FileExists($LeapDroid_Path & "\LeapdroidVM.exe") = 0 Then
$LeapDroid_Path = ""
EndIf
Local $InstallLocation = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\LeapdroidVM\", "InstallLocation")
If $LeapDroid_Path = "" And FileExists($InstallLocation & "\leapdroidvm.ini") = 1 Then
$LeapDroid_Path = IniRead($InstallLocation & "\leapdroidvm.ini", "main", "install_path", "")
If FileExists($LeapDroid_Path & "\LeapdroidVM.exe") = 0 Then
$LeapDroid_Path = ""
EndIf
EndIf
If $LeapDroid_Path = "" And FileExists($InstallLocation & "\LeapdroidVM.exe") = 1 Then
$LeapDroid_Path = $InstallLocation
EndIf
If $LeapDroid_Path = "" And FileExists(@ProgramFilesDir & "\Leapdroid\VM\LeapdroidVM.exe") = 1 Then
$LeapDroid_Path = @ProgramFilesDir & "\Leapdroid\VM"
EndIf
SetError(0, 0, 0)
If $LeapDroid_Path <> "" And StringRight($LeapDroid_Path, 1) <> "\" Then $LeapDroid_Path &= "\"
Return StringReplace($LeapDroid_Path, "\\", "\")
EndFunc
Func GetLeapDroidAdbPath()
Local $adbPath = GetLeapDroidPath() & "adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitLeapDroid($bCheckOnly = False)
Local $process_killed, $aRegExResult, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
Local $LeapDroidVersion = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\LeapDroid\", "DisplayVersion")
SetError(0, 0, 0)
Local $LeapDroid_Path = GetLeapDroidPath()
Local $LeapDroid_Manage_Path = GetLeapDroidPath() & "VBoxManage.exe"
If FileExists($LeapDroid_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator, $COLOR_ERROR)
SetLog("installation directory", $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find installation directory")
EndIf
Return False
EndIf
If FileExists($LeapDroid_Path & "LeapdroidVM.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($LeapDroid_Path & "LeapdroidVM.exe", $COLOR_ERROR)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $LeapDroid_Path & "LeapdroidVM.exe")
SetError(1, @extended, False)
EndIf
Return False
EndIf
Local $sPreferredADB = FindPreferredAdbPath()
If $sPreferredADB = "" And FileExists($LeapDroid_Path & "adb.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($LeapDroid_Path & "adb.exe", $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $LeapDroid_Path & "adb.exe")
EndIf
Return False
EndIf
If FileExists($LeapDroid_Manage_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($LeapDroid_Manage_Path, $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $LeapDroid_Manage_Path)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
If Not GetAndroidVMinfo($__VBoxVMinfo, $LeapDroid_Manage_Path) Then Return False
$__VBoxGuestProperties = LaunchConsole($LeapDroid_Manage_Path, "guestproperty enumerate " & $g_sAndroidInstance, $process_killed)
$g_sAndroidProgramPath = $LeapDroid_Path & "LeapdroidVM.exe"
$g_sAndroidAdbPath = $sPreferredADB
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = $LeapDroid_Path & "adb.exe"
$g_sAndroidVersion = $LeapDroidVersion
$__LeapDroid_Path = $LeapDroid_Path
$g_sAndroidPath = $__LeapDroid_Path
$__VBoxManage_Path = $LeapDroid_Manage_Path
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: adb_port, value: (\d{3,5}),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = "127.0.0.1"
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("InitLeapDroid: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIf
If $oops = 0 Then
$g_sAndroidAdbDevice = "emulator-" &($g_sAndroidAdbDevicePort - 1)
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_ERROR)
EndIf
$g_sAndroidPicturesPath = "/mnt/shared/yw_shared/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'yw_shared', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidPicturesHostPath = $aRegExResult[0] & "\"
Else
$g_sAndroidPicturesPath = "/mnt/shared/LeapDroidShared/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'LeapDroidShared', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidPicturesHostPath = $aRegExResult[0] & "\"
Else
$oops = 1
$g_bAndroidAdbScreencap = False
$g_sAndroidPicturesHostPath = ""
SetLog($g_sAndroidEmulator & " Background Mode is not available", $COLOR_ERROR)
EndIf
EndIf
$g_bUpdateAndroidWindowTitle = True
EndIf
Return SetError($oops, 0, True)
EndFunc
Func UpdateLeapdroidSettings(ByRef $fileContent, $param, $value)
$fileContent = StringRegExpReplace($fileContent, "^(" & $param & "=.*)", $param & "=" & $value)
Return @extended
EndFunc
Func SetScreenLeapDroid()
If Not InitAndroid() Then Return False
Local $files[2] = [@MyDocumentsDir & "\Leapdroid\Leapdroid Emulator\leapdroid.settings", GetLeapDroidPath() & "Leapdroid Emulator\leapdroid.settings"]
Local $f, $p, $h
For $f In $files
$p = StringMid($f, 1, StringInStr($f, "\", 0, -1))
If FileExists($p) Then
If FileExists($f) = 0 Then
$h = FileOpen($f, $FO_OVERWRITE)
If $h = -1 Then
SetLog("Cannot write " & $g_sAndroidEmulator & " config file:" & @CRLF & $f, $COLOR_ERROR)
ContinueLoop
EndIf
FileWrite($h, "RESOLUTION=" & $g_iGAME_WIDTH & "x" & $g_iGAME_HEIGHT & @CRLF & "DPI=160")
FileClose($h)
Else
Local $i
$h = FileOpen($f, $FO_READ)
If $h = -1 Then
SetLog("Cannot read " & $g_sAndroidEmulator & " config file:" & @CRLF & $f, $COLOR_ERROR)
ContinueLoop
EndIf
Local $s = FileRead($h)
FileClose($h)
$i = UpdateLeapdroidSettings($s, "RESOLUTION", $g_iGAME_WIDTH & "x" & $g_iGAME_HEIGHT)
If $i < 1 Then SetDebugLog("Cannot update " & $g_sAndroidEmulator & " screen resolution in file:" & @CRLF & $f, $COLOR_ERROR)
$i = UpdateLeapdroidSettings($s, "DPI", "160")
If $i < 1 Then SetDebugLog("Cannot update " & $g_sAndroidEmulator & " screen DPI in file:" & @CRLF & $f, $COLOR_ERROR)
$h = FileOpen($f, $FO_OVERWRITE)
If $h = -1 Then
SetLog("Cannot write " & $g_sAndroidEmulator & " config file:" & @CRLF & $f, $COLOR_ERROR)
ContinueLoop
EndIf
FileWrite($h, $s)
FileClose($h)
EndIf
EndIf
Next
Return True
EndFunc
Func RebootLeapDroidSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseLeapDroid()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenLeapDroid($bSetLog = True)
If Not InitAndroid() Then Return False
Return True
EndFunc
Func EmbedLeapDroid($bEmbed = Default, $hHWndAfter = Default)
If $bEmbed = Default Then $bEmbed = $g_bAndroidEmbedded
If $hHWndAfter = Default Then $hHWndAfter = $HWND_TOPMOST
Local $aWin = _WinAPI_EnumProcessWindows(GetAndroidPid(), False)
Local $i
Local $hToolbar = 0
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
If $c = "QTool" Then
$hToolbar = $h
ExitLoop
EndIf
Next
If $hToolbar = 0 Then
SetDebugLog("EmbedLeapDroid(" & $bEmbed & "): QTool Window not found, list of windows:" & $c, Default, True)
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
SetDebugLog("EmbedLeapDroid(" & $bEmbed & "): Handle = " & $h & ", Class = " & $c, Default, True)
Next
Else
SetDebugLog("EmbedLeapDroid(" & $bEmbed & "): $hToolbar=" & $hToolbar, Default, True)
If $bEmbed Then WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
_WinAPI_ShowWindow($hToolbar,($bEmbed ? @SW_HIDE : @SW_SHOWNOACTIVATE))
If Not $bEmbed Then
WinMove2($hToolbar, "", -1, -1, -1, -1, $hHWndAfter, 0, False)
If $hHWndAfter = $HWND_TOPMOST Then WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
EndIf
EndIf
EndFunc
Func LeapDroidBotStartEvent()
Return AndroidCloseSystemBar()
EndFunc
Func LeapDroidBotStopEvent()
EndFunc
Func OpenNox($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
Local $launchAndroid =(WinGetAndroidHandle() = 0 ? True : False)
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath)
If $PID = 0 Then
SetError(1, 1, -1)
Return False
EndIf
EndIf
$hTimer = __TimerInit()
If WaitForRunningVMS($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return False
$g_bInitAndroid = True
InitAndroid()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return False
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If __TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func IsNoxCommandLine($CommandLine)
Local $aRegexResult = StringRegExp($CommandLine, "-clone:(\b.+\b)", $STR_REGEXPARRAYMATCH)
If Not @error Then
Local $sInstance = $aRegexResult[0]
If $sInstance = $g_sAndroidInstance Or($g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1] And $sInstance = 'Nox_0') Then
SetDebugLog("IsNoxCommandLine, instance " & $g_sAndroidInstance & ", returns True for: " & $CommandLine)
Return True
EndIf
Else
If $g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
SetDebugLog("IsNoxCommandLine, instance " & $g_sAndroidInstance & ", returns True for: " & $CommandLine)
Return True
EndIf
EndIf
SetDebugLog("IsNoxCommandLine, instance " & $g_sAndroidInstance & ", returns False for: " & $CommandLine)
Return False
EndFunc
Func GetNoxProgramParameter($bAlternative = False)
Local $customScreen = "-resolution:" & $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & " -dpi:160"
Local $clone = """-clone:" &($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance) & """"
If $bAlternative = False Then
Return $customScreen & " " & $clone
EndIf
If $g_sAndroidInstance = "" Or $g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then Return ""
Return $clone
EndFunc
Func GetNoxRtPath()
Local $path = RegRead($g_sHKLM & "\SOFTWARE\BigNox\VirtualBox\", "InstallDir")
If @error = 0 Then
If StringRight($path, 1) <> "\" Then $path &= "\"
EndIf
If FileExists($path) = 0 Then
$path = @ProgramFilesDir & "\Bignox\BigNoxVM\RT\"
EndIf
If FileExists($path) = 0 Then
$path = EnvGet("ProgramFiles(x86)") & "\Bignox\BigNoxVM\RT\"
EndIf
If FileExists($path) = 0 Then
$path = EnvGet("ProgramFiles") & "\Bignox\BigNoxVM\RT\"
EndIf
SetError(0, 0, 0)
Return StringReplace($path, "\\", "\")
EndFunc
Func GetNoxPath()
Local $path = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\DuoDianOnline\SetupInfo\", "InstallPath")
If @error = 0 Then
If StringRight($path, 1) <> "\" Then $path &= "\"
$path &= "bin\"
Else
$path = ""
SetError(0, 0, 0)
EndIf
Return StringReplace($path, "\\", "\")
EndFunc
Func GetNoxAdbPath()
Local $adbPath = GetNoxPath() & "nox_adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func GetNoxBackgroundMode()
Local $iDirectX = $g_iAndroidBackgroundModeDirectX
Local $iOpenGL = $g_iAndroidBackgroundModeOpenGL
If @OSBuild >= 16299 Then
SetDebugLog("DirectX/OpenGL Fix applied for Windows Build 16299")
$iDirectX = $g_iAndroidBackgroundModeOpenGL
$iOpenGL = $g_iAndroidBackgroundModeDirectX
EndIf
Local $sConfig = GetNoxConfigFile()
If $sConfig Then
Local $graphic_engine_type = IniRead($sConfig, "setting", "graphic_engine_type", "")
Switch $graphic_engine_type
Case "0"
Return $iOpenGL
Case "1"
Return $iDirectX
Case Else
SetLog($g_sAndroidEmulator & " unsupported Graphics Engine Type " & $graphic_engine_type, $COLOR_WARNING)
EndSwitch
EndIf
Return 0
EndFunc
Func InitNox($bCheckOnly = False)
Local $process_killed, $aRegexResult, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
Local $Version = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\Nox\", "DisplayVersion")
SetError(0, 0, 0)
Local $path = GetNoxPath()
Local $RtPath = GetNoxRtPath()
Local $NoxFile = $path & "Nox.exe"
Local $AdbFile = $path & "nox_adb.exe"
Local $VBoxFile = $RtPath & "BigNoxVMMgr.exe"
Local $Files = [$NoxFile, $AdbFile, $VBoxFile]
Local $sPreferredADB = FindPreferredAdbPath()
If $sPreferredADB Then _ArrayDelete($Files, 1)
For $File In $Files
If FileExists($File) = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & " file:", $COLOR_ERROR)
SetLog($File, $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
Next
If Not $bCheckOnly Then
InitAndroidConfig(True)
If Not GetAndroidVMinfo($__VBoxVMinfo, $VBoxFile) Then Return False
$g_sAndroidProgramPath = $NoxFile
$g_sAndroidAdbPath = $sPreferredADB
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = GetNoxAdbPath()
$g_sAndroidVersion = $Version
$__Nox_Path = $path
$g_sAndroidPath = $__Nox_Path
$__VBoxManage_Path = $VBoxFile
$aRegexResult = StringRegExp($__VBoxVMinfo, ".*host ip = ([^,]+), .* guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = $aRegexResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDeviceHost = " & $g_sAndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Host", $COLOR_ERROR)
EndIf
$aRegexResult = StringRegExp($__VBoxVMinfo, "name = .*host port = (\d{3,5}), .* guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDevicePort = $aRegexResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIf
If $oops = 0 Then
$g_sAndroidAdbDevice = $g_sAndroidAdbDeviceHost & ":" & $g_sAndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_ERROR)
EndIf
$g_sAndroidPicturesPath = "(/mnt/shared/Other|/mnt/shell/emulated/0/Download/other)"
$aRegexResult = StringRegExp($__VBoxVMinfo, "Name: 'Other', Host path: '(.*)'.*", $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$g_bAndroidSharedFolderAvailable = True
$g_sAndroidPicturesHostPath = $aRegexResult[UBound($aRegexResult) - 1] & "\"
Else
If FileExists(@MyDocumentsDir & "\Nox_share\") Then
$g_bAndroidSharedFolderAvailable = True
$g_sAndroidPicturesHostPath = @MyDocumentsDir & "\Nox_share\Other\"
If Not FileExists($g_sAndroidPicturesHostPath) Then
DirCreate($g_sAndroidPicturesHostPath)
EndIf
ElseIf FileExists(@HomeDrive & @HomePath & "\Nox_share\") Then
$g_bAndroidSharedFolderAvailable = True
$g_sAndroidPicturesHostPath = @HomeDrive & @HomePath & "\Nox_share\"
If Not FileExists($g_sAndroidPicturesHostPath) Then
DirCreate($g_sAndroidPicturesHostPath)
EndIf
Else
$g_bAndroidSharedFolderAvailable = False
$g_bAndroidAdbScreencap = False
$g_sAndroidPicturesHostPath = ""
SetLog($g_sAndroidEmulator & " Background Mode is not available", $COLOR_ERROR)
EndIf
EndIf
Local $v = GetVersionNormalized($g_sAndroidVersion)
For $i = 0 To UBound($__Nox_Config) - 1
Local $v2 = GetVersionNormalized($__Nox_Config[$i][0])
If $v >= $v2 Then
SetDebugLog("Using Android Config of " & $g_sAndroidEmulator & " " & $__Nox_Config[$i][0])
$g_sAppClassInstance = $__Nox_Config[$i][1]
$g_avAndroidAppConfig[$g_iAndroidConfig][3] = $g_sAppClassInstance
ExitLoop
EndIf
Next
UpdateHWnD($g_hAndroidWindow, False)
EndIf
Return True
EndFunc
Func GetNoxConfigFile()
Local $sLocalAppData = EnvGet("LOCALAPPDATA")
Local $sPre = ""
If $g_sAndroidInstance <> "nox" Then $sPre = "clone_" & $g_sAndroidInstance & "_"
Local $sConfig = $sLocalAppData & "\Nox\" & $sPre & "conf.ini"
If FileExists($sConfig) Then Return $sConfig
Return ""
EndFunc
Func SetScreenNox()
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
AndroidPicturePathAutoConfig(@MyDocumentsDir, "\Nox_share\Other")
If $g_bAndroidSharedFolderAvailable = False And $g_bAndroidPicturesPathAutoConfig = True And FileExists($g_sAndroidPicturesHostPath) = 1 Then
Local $path = $g_sAndroidPicturesHostPath
If StringRight($path, 1) = "\" Then $path = StringLeft($path, StringLen($path) - 1)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "sharedfolder remove " & $g_sAndroidInstance & " --name Other", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "sharedfolder add " & $g_sAndroidInstance & " --name Other --hostpath """ & $path & """  --automount", $process_killed)
EndIf
Local $sConfig = GetNoxConfigFile()
If $sConfig Then
SetDebugLog("Configure Nox screen config: " & $sConfig)
IniWrite($sConfig, "setting", "h_resolution", $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight)
IniWrite($sConfig, "setting", "h_dpi", "160")
IniWrite($sConfig, "setting", "fixsize", "true")
IniWrite($sConfig, "setting", "is_save_pos_and_size", "false")
IniWrite($sConfig, "setting", "last_player_width", "864")
IniWrite($sConfig, "setting", "last_player_height", "770")
Else
SetDebugLog("Cannot find Nox config to cnfigure screen: " & $sConfig, $COLOR_ERROR)
EndIf
Return True
EndFunc
Func RebootNoxSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseNox()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenNox($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[2][2] = [ ["vbox_dpi", "160"], ["vbox_graph_mode", $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16"] ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegexResult
For $i = 0 To UBound($aValues) - 1
$aRegexResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegexResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
Else
SetDebugLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
EndIf
$iErrCnt += 1
EndIf
Next
If AndroidPicturePathAutoConfig(@MyDocumentsDir, "\Nox_share\Other", $bSetLog) Then $iErrCnt += 1
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func GetNoxRunningInstance($bStrictCheck = True)
Local $a[2] = [0, ""]
SetDebugLog("GetAndroidRunningInstance: Try to find """ & $g_sAndroidProgramPath & """")
For $PID In ProcessesExist($g_sAndroidProgramPath, "", 1)
Local $currentInstance = $g_sAndroidInstance
Local $CommandLine = ProcessGetCommandLine($PID)
SetDebugLog("GetNoxRunningInstance: Found """ & $CommandLine & """ by PID=" & $PID)
Local $aRegexResult = StringRegExp($CommandLine, ".*""-clone:([^""]+)"".*|.*-clone:([\S]+).*", $STR_REGEXPARRAYMATCH)
If @error = 0 Then
$g_sAndroidInstance = $aRegexResult[0]
If $g_sAndroidInstance = "" Then $g_sAndroidInstance = $aRegexResult[1]
SetDebugLog("Running " & $g_sAndroidEmulator & " instance is """ & $g_sAndroidInstance & """")
EndIf
If WinGetAndroidHandle() <> 0 Then
$a[0] = $g_hAndroidWindow
$a[1] = $g_sAndroidInstance
Return $a
Else
$g_sAndroidInstance = $currentInstance
EndIf
Next
Return $a
EndFunc
Func RedrawNoxWindow()
Return SetError(1)
Local $aPos = WinGetPos($g_hAndroidWindow)
Local $aMousePos = MouseGetPos()
MouseClickDrag("left", $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 3, $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 53, 0)
MouseClickDrag("left", $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 53, $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 3, 0)
MouseMove($aMousePos[0], $aMousePos[1], 0)
$aPos = WinGetPos($g_hAndroidWindow)
ControlClick($g_hAndroidWindow, "", "", "left", 1, $aPos[2] - 46, 18)
If _Sleep(500) Then Return False
$aPos = WinGetPos($g_hAndroidWindow)
ControlClick($g_hAndroidWindow, "", "", "left", 1, $aPos[2] - 46, 18)
EndFunc
Func HideNoxWindow($bHide = True, $hHWndAfter = Default)
Return EmbedNox($bHide, $hHWndAfter)
EndFunc
Func EmbedNox($bEmbed = Default, $hHWndAfter = Default)
If $bEmbed = Default Then $bEmbed = $g_bAndroidEmbedded
If $hHWndAfter = Default Then $hHWndAfter = $HWND_TOPMOST
Local $aWin = _WinAPI_EnumProcessWindows(GetAndroidPid(), False)
Local $i
Local $hToolbar = 0
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
If $c = "Qt5QWindowToolSaveBits" Then
Local $aPos = WinGetPos($h)
If UBound($aPos) > 3 Then
If $hToolbar = 0 And(($aPos[2] >= $g_iAndroidClientWidth And $aPos[3] > 7) Or($aPos[2] > 7 And $aPos[3] >= $g_iAndroidClientHeight)) Then
$hToolbar = $h
ElseIf $aPos[2] = 7 Or $aPos[3] = 7 Then
WinMove2($h, "", -1, -1, -1, -1, $HWND_NOTOPMOST, $SWP_HIDEWINDOW, False)
EndIf
EndIf
EndIf
Next
If $hToolbar = 0 Then
SetDebugLog("EmbedNox(" & $bEmbed & "): toolbar Window not found, list of windows:" & $c, Default, True)
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
SetDebugLog("EmbedNox(" & $bEmbed & "): Handle = " & $h & ", Class = " & $c, Default, True)
Next
Else
SetDebugLog("EmbedNox(" & $bEmbed & "): $hToolbar=" & $hToolbar, Default, True)
If $bEmbed Then
WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, $SWP_HIDEWINDOW, False, False)
Else
WinMove2($hToolbar, "", -1, -1, -1, -1, $hHWndAfter, $SWP_SHOWWINDOW, False, False)
If $hHWndAfter = $HWND_TOPMOST Then WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, $SWP_SHOWWINDOW, False, False)
EndIf
EndIf
EndFunc
Func OpenKOPLAYER($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_GREEN)
If Not InitAndroid() Then Return
Local $launchAndroid =(WinGetAndroidHandle() = 0 ? True : False)
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter() & " -t " & $g_sAndroidInstance
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath)
If $PID = 0 Then
SetError(1, 1, -1)
Return False
EndIf
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_GREEN)
$hTimer = __TimerInit()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return
If __TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_RED)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_RED)
SetError(1, @extended, False)
Return
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_GREEN)
EndFunc
Func GetKOPLAYERProgramParameter($bAlternative = False)
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Return "-n " &($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
EndIf
Return "-n default"
EndFunc
Func IsKOPLAYERCommandLine($CommandLine)
SetDebugLog($CommandLine)
Local $param1 = GetKOPLAYERProgramParameter()
Local $param2 = GetKOPLAYERProgramParameter(True)
If StringInStr($CommandLine, $param1 & " ") > 0 Or StringRight($CommandLine, StringLen($param1)) = $param1 Then Return True
If StringInStr($CommandLine, $param2 & " ") > 0 Or StringRight($CommandLine, StringLen($param2)) = $param2 Then Return True
Return False
EndFunc
Func GetKOPLAYERPath()
Local $KOPLAYER_Path = RegRead($g_sHKLM & "\SOFTWARE\KOPLAYER\SETUP\", "InstallPath")
If $KOPLAYER_Path = "" Then
$KOPLAYER_Path = @ProgramFilesDir & "\KOPLAYER\"
Else
If StringRight($KOPLAYER_Path, 1) <> "\" Then $KOPLAYER_Path &= "\"
EndIf
Return StringReplace($KOPLAYER_Path, "\\", "\")
EndFunc
Func GetKOPLAYERAdbPath()
Local $adbPath = GetKOPLAYERPath() & "Tools\adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitKOPLAYER($bCheckOnly = False)
Local $process_killed, $aRegExResult, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
Local $KOPLAYERVersion = RegRead($g_sHKLM & "\SOFTWARE\KOPLAYER\SETUP\", "Version")
SetError(0, 0, 0)
Local $KOPLAYER_Path = GetKOPLAYERPath()
Local $KOPLAYER_Manage_Path = $KOPLAYER_Path & "vbox\VBoxManage.exe"
If FileExists($KOPLAYER_Path & "KOPLAYER.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_RED)
SetLog($KOPLAYER_Path & "KOPLAYER.exe", $COLOR_RED)
SetError(1, @extended, False)
EndIf
Return False
EndIf
Local $sPreferredADB = FindPreferredAdbPath()
If $sPreferredADB = "" And FileExists(GetKOPLAYERAdbPath()) = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_RED)
SetLog($KOPLAYER_Path & "adb.exe", $COLOR_RED)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($KOPLAYER_Manage_Path) = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find KOPLAYER-VBoxManage:", $COLOR_RED)
SetLog($KOPLAYER_Manage_Path, $COLOR_RED)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
If Not GetAndroidVMinfo($__VBoxVMinfo, $KOPLAYER_Manage_Path) Then Return False
$g_sAndroidProgramPath = $KOPLAYER_Path & "KOPLAYER.exe"
$g_sAndroidAdbPath = $sPreferredADB
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = GetKOPLAYERAdbPath()
$g_sAndroidVersion = $KOPLAYERVersion
$__KOPLAYER_Path = $KOPLAYER_Path
$g_sAndroidPath = $__KOPLAYER_Path
$__VBoxManage_Path = $KOPLAYER_Manage_Path
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = .*host ip = ([^,]*),.*guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = $aRegExResult[0]
If $g_sAndroidAdbDeviceHost = "" Then $g_sAndroidAdbDeviceHost = "127.0.0.1"
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDeviceHost = " & $g_sAndroidAdbDeviceHost, $COLOR_PURPLE)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Host", $COLOR_RED)
EndIf
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = .*host port = (\d{3,5}),.*guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_PURPLE)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_RED)
EndIf
If $oops = 0 Then
$g_sAndroidAdbDevice = $g_sAndroidAdbDeviceHost & ":" & $g_sAndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_RED)
EndIf
$g_sAndroidPicturesPath = "/mnt/shared/UserData/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'UserData', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidPicturesHostPath = StringReplace($aRegExResult[0], "/", "\") & "\"
Else
$g_bAndroidAdbScreencap = False
$g_sAndroidPicturesHostPath = ""
SetLog($g_sAndroidEmulator & " Background Mode is not available", $COLOR_RED)
EndIf
EndIf
Return True
EndFunc
Func GetKOPLAYERBackgroundMode()
Local $aRegExResult = StringRegExp($__VBoxExtraData, "Key: GUI/RenderMode, Value: (.*)", $STR_REGEXPARRAYMATCH)
Local $sRenderMode = "Unknown"
If Not @error Then
$sRenderMode = $aRegExResult[0]
Switch $sRenderMode
Case "DirectX"
Return $g_iAndroidBackgroundModeDirectX
Case "Opengl"
Return $g_iAndroidBackgroundModeOpenGL
Case Else
SetLog($g_sAndroidEmulator & " unsupported Render Mode " & $sRenderMode, $COLOR_WARNING)
EndSwitch
EndIf
Return 0
EndFunc
Func SetScreenKOPLAYER()
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_graph_mode " & $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_dpi 160", $process_killed)
Return True
EndFunc
Func RebootKOPLAYERSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseKOPLAYER()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenKOPLAYER($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[2][2] = [ ["vbox_dpi", "160"], ["vbox_graph_mode", $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16"] ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult
For $i = 0 To UBound($aValues) - 1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_RED)
Else
SetDebugLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_RED)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_RED)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_RED)
EndIf
$iErrCnt += 1
EndIf
Next
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func EmbedKOPLAYER($bEmbed = Default, $hHWndAfter = Default)
If $bEmbed = Default Then $bEmbed = $g_bAndroidEmbedded
If $hHWndAfter = Default Then $hHWndAfter = $HWND_TOPMOST
Local $aWin = _WinAPI_EnumProcessWindows(GetAndroidPid(), False)
Local $i
Local $hToolbar = 0
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
If $c = "Qt5QWindowToolSaveBits" Then
$hToolbar = $h
ExitLoop
EndIf
Next
If $hToolbar = 0 Then
SetDebugLog("EmbedKOPLAYER(" & $bEmbed & "): Qt5QWindowToolSaveBits Window not found, list of windows:" & $c, Default, True)
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
SetDebugLog("EmbedKOPLAYER(" & $bEmbed & "): Handle = " & $h & ", Class = " & $c, Default, True)
Next
Else
SetDebugLog("EmbedKOPLAYER(" & $bEmbed & "): $hToolbar=" & $hToolbar, Default, True)
If $bEmbed Then WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
_WinAPI_ShowWindow($hToolbar,($bEmbed ? @SW_HIDE : @SW_SHOWNOACTIVATE))
If Not $bEmbed Then
WinMove2($hToolbar, "", -1, -1, -1, -1, $hHWndAfter, 0, False)
If $hHWndAfter = $HWND_TOPMOST Then WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
EndIf
EndIf
EndFunc
Func OpeniTools($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
Local $launchAndroid =(WinGetAndroidHandle() = 0 ? True : False)
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath)
If $PID = 0 Then
SetError(1, 1, -1)
Return False
EndIf
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
$hTimer = __TimerInit()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return False
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If __TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func IsiToolsCommandLine($CommandLine)
SetDebugLog("Check iTools command line instance: " & $CommandLine)
Local $sInstance =($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
$CommandLine = StringReplace($CommandLine, GetiToolsPath(), "")
If StringRegExp($CommandLine, "/start " & $sInstance & "\b") = 1 Then Return True
If StringRegExp($CommandLine, "/restart .*\b" & $sInstance & "\b") = 1 Then Return True
Return False
EndFunc
Func GetiToolsProgramParameter($bAlternative = False)
Local $sInstance =($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Return "/start " & $sInstance
EndIf
Return ""
EndFunc
Func GetiToolsPath()
Local $iTools_Path = ""
If $iTools_Path <> "" And FileExists($iTools_Path & "\iToolsAVM.exe") = 0 Then
$iTools_Path = ""
EndIf
Local $InstallLocation = ""
Local $DisplayIcon = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\iToolsAVM\", "DisplayIcon")
If @error = 0 Then
Local $iLastBS = StringInStr($DisplayIcon, "\", 0, -1) - 1
$InstallLocation = StringLeft($DisplayIcon, $iLastBS)
EndIf
If $iTools_Path = "" And FileExists($InstallLocation & "\iToolsAVM.exe") = 1 Then
$iTools_Path = $InstallLocation
EndIf
If $iTools_Path = "" And FileExists(@ProgramFilesDir & "\iToolsAVM\iToolsAVM.exe") = 1 Then
$iTools_Path = @ProgramFilesDir & "\iToolsAVM"
EndIf
SetError(0, 0, 0)
If $iTools_Path <> "" And StringRight($iTools_Path, 1) <> "\" Then $iTools_Path &= "\"
Return StringReplace($iTools_Path, "\\", "\")
EndFunc
Func GetiToolsAdbPath()
Local $adbPath = GetiToolsPath() & "tools\adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitiTools($bCheckOnly = False)
Local $process_killed, $aRegExResult, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
SetError(0, 0, 0)
Local $VirtualBox_Path = RegRead($g_sHKLM & "\SOFTWARE\Oracle\VirtualBox\", "InstallDir")
If @error <> 0 And FileExists(@ProgramFilesDir & "\Oracle\VirtualBox\") Then
$VirtualBox_Path = @ProgramFilesDir & "\Oracle\VirtualBox\"
SetError(0, 0, 0)
EndIf
$VirtualBox_Path = StringReplace($VirtualBox_Path, "\\", "\")
Local $iTools_Path = GetiToolsPath()
Local $iTools_Manage_Path = $VirtualBox_Path & "VBoxManage.exe"
If FileExists($iTools_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator, $COLOR_ERROR)
SetLog("installation directory", $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find installation directory")
EndIf
Return False
EndIf
If FileExists($iTools_Path & "iToolsAVM.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($iTools_Path & "iToolsAVM.exe", $COLOR_ERROR)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $iTools_Path & "iToolsAVM.exe")
SetError(1, @extended, False)
EndIf
Return False
EndIf
Local $sPreferredADB = FindPreferredAdbPath()
If $sPreferredADB = "" And FileExists($iTools_Path & "tools\adb.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($iTools_Path & "tools\adb.exe", $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $iTools_Path & "tools\adb.exe")
EndIf
Return False
EndIf
If FileExists($iTools_Manage_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($iTools_Manage_Path, $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $iTools_Manage_Path)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
If Not GetAndroidVMinfo($__VBoxVMinfo, $iTools_Manage_Path) Then Return False
$g_sAndroidProgramPath = $iTools_Path & "iToolsAVM.exe"
$g_sAndroidAdbPath = $sPreferredADB
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = $iTools_Path & "tools\adb.exe"
$g_sAndroidVersion = ""
$__iTools_Path = $iTools_Path
$g_sAndroidPath = $__iTools_Path
$__VBoxManage_Path = $iTools_Manage_Path
$aRegExResult = StringRegExp($__VBoxVMinfo, "ADB_PORT.*host ip = ([^,]+),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDeviceHost = " & $g_sAndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Host", $COLOR_ERROR)
EndIf
$aRegExResult = StringRegExp($__VBoxVMinfo, "ADB_PORT.*host port = (\d{3,5}),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIf
If $oops = 0 Then
$g_sAndroidAdbDevice = $g_sAndroidAdbDeviceHost & ":" & $g_sAndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_ERROR)
EndIf
$g_sAndroidPicturesPath = "/mnt/shared/picture/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'picture', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_bAndroidSharedFolderAvailable = True
$g_sAndroidPicturesHostPath = $aRegExResult[0] & "\"
Else
$oops = 1
$g_bAndroidAdbScreencap = False
$g_bAndroidSharedFolderAvailable = False
$g_sAndroidPicturesHostPath = ""
SetLog($g_sAndroidEmulator & " shared folder is not available", $COLOR_ERROR)
EndIf
$g_bUpdateAndroidWindowTitle = True
EndIf
Return SetError($oops, 0, True)
EndFunc
Func SetScreeniTools()
If Not $g_bRunState Then Return False
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_graph_mode " & $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_dpi 160", $process_killed)
AndroidPicturePathAutoConfig()
If $g_bAndroidSharedFolderAvailable = False And $g_bAndroidPicturesPathAutoConfig = True And FileExists($g_sAndroidPicturesHostPath) = 1 Then
Local $path = $g_sAndroidPicturesHostPath
If StringRight($path, 1) = "\" Then $path = StringLeft($path, StringLen($path) - 1)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "sharedfolder add " & $g_sAndroidInstance & " --name picture --hostpath """ & $path & """  --automount", $process_killed)
EndIf
Return True
EndFunc
Func RebootiToolsSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseiTools()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreeniTools($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[2][2] = [ ["vbox_dpi", "160"], ["vbox_graph_mode", $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16"] ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult, $properties
For $i = 0 To UBound($aValues) - 1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
SetGuiLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR, $bSetLog)
EndIf
SetGuiLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR, $bSetLog)
$iErrCnt += 1
EndIf
Next
If $iErrCnt > 0 Then Return False
If AndroidPicturePathAutoConfig(Default, Default, $bSetLog) Then $iErrCnt += 1
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func HideiToolsWindow($bHide = True, $hHWndAfter = Default)
Return EmbediTools($bHide, $hHWndAfter)
EndFunc
Func EmbediTools($bEmbed = Default, $hHWndAfter = Default)
If $bEmbed = Default Then $bEmbed = $g_bAndroidEmbedded
If $hHWndAfter = Default Then $hHWndAfter = $HWND_TOPMOST
Local $aWin = _WinAPI_EnumProcessWindows(GetAndroidPid(), False)
Local $i
Local $hToolbar = 0
Local $hAddition = []
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
If $c = "CHWindow" Then
Local $aPos = WinGetPos($h)
If UBound($aPos) > 2 Then
If($aPos[2] = 38 Or $aPos[2] = 21) Then
$hToolbar = $h
EndIf
If $aPos[2] = 10 Or $aPos[3] = 10 Then
ReDim $hAddition[UBound($hAddition) + 1]
$hAddition[UBound($hAddition) - 1] = $h
EndIf
EndIf
EndIf
Next
If $hToolbar = 0 Then
SetDebugLog("EmbediTools(" & $bEmbed & "): toolbar Window not found, list of windows:" & $c, Default, True)
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
SetDebugLog("EmbediTools(" & $bEmbed & "): Handle = " & $h & ", Class = " & $c, Default, True)
Next
Else
SetDebugLog("EmbediTools(" & $bEmbed & "): $hToolbar=" & $hToolbar, Default, True)
If $bEmbed Then WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
_WinAPI_ShowWindow($hToolbar,($bEmbed ? @SW_HIDE : @SW_SHOWNOACTIVATE))
If Not $bEmbed Then
WinMove2($hToolbar, "", -1, -1, -1, -1, $hHWndAfter, 0, False)
If $hHWndAfter = $HWND_TOPMOST Then WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
EndIf
For $i = 0 To UBound($hAddition) - 1
If $bEmbed Then WinMove2($hAddition[$i], "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
_WinAPI_ShowWindow($hAddition[$i],($bEmbed ? @SW_HIDE : @SW_SHOWNOACTIVATE))
If Not $bEmbed Then
WinMove2($hAddition[$i], "", -1, -1, -1, -1, $hHWndAfter, 0, False)
If $hHWndAfter = $HWND_TOPMOST Then WinMove2($hAddition[$i], "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
EndIf
Next
EndIf
EndFunc
Func getBSPos()
Local $SuspendMode = ResumeAndroid()
Local $Changed = False, $aOldValues[4]
Local $hWin = $g_hAndroidWindow
WinGetAndroidHandle()
If $g_bAndroidBackgroundLaunched = False Then
getAndroidPos(True)
Else
SetError($g_hAndroidWindow = 0 ? 1 : 0)
EndIf
If @error = 1 Then
If Not $g_bRunState Then Return
SetError(0, 0, 0)
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
If $g_bAndroidBackgroundLaunched = False Then
getAndroidPos(True)
Else
SetError($g_hAndroidWindow = 0 ? 1 : 0)
EndIf
If Not $g_bRunState Then Return
If @error = 1 Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslatedFileIni("MBR Popups", "sText_01", "MyBot has experienced a serious error") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "sText_02", "Unable to find or start up ") & $g_sAndroidEmulator & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "sText_03", "Reboot PC and try again,") & GetTranslatedFileIni("MBR Popups", "sText_04", "and search www.mybot.run forums for more help") & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "sText_05", "Close MyBot!"), GetTranslatedFileIni("MBR Popups", "sText_06", "Okay - Must Exit Program"), $stext, 15, $g_hFrmBot)
If $MsgBox = 1 Then
BotClose()
EndIf
EndIf
EndIf
If @error = 1 Then
If Not $g_bRunState Then Return
SetError(0, 0, 0)
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
Return
EndIf
If $g_bAndroidBackgroundLaunched = True Then
SuspendAndroid($SuspendMode, False)
Return
EndIf
$aOldValues[0] = $g_aiBSpos[0]
$aOldValues[1] = $g_aiBSpos[1]
$aOldValues[2] = $g_aiBSrpos[0]
$aOldValues[3] = $g_aiBSrpos[1]
Local $aPos = getAndroidPos()
If Not IsArray($aPos) Then
If Not $g_bRunState Then Return
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
$aPos = getAndroidPos(True)
If Not $g_bRunState Then Return
If @error = 1 Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
$stext = @CRLF & GetTranslatedFileIni("MBR Popups", "sText_01", "MyBot has experienced a serious error") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "sText_02", "Unable to find or start up") & " " & $g_sAndroidEmulator & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "sText_03", "Reboot PC and try again,") & GetTranslatedFileIni("MBR Popups", "sText_04", "and search www.mybot.run forums for more help") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "sText_05", "Close MyBot!"), GetTranslatedFileIni("MBR Popups", "sText_06", "Okay - Must Exit Program"), $stext, 15, $g_hFrmBot)
If $MsgBox = 1 Then
BotClose()
Return
EndIf
EndIf
EndIf
If IsArray($aPos) Then
Local $tPoint = DllStructCreate("int X;int Y")
DllStructSetData($tPoint, "X", $aPos[0])
If @error <> 0 Then
$tPoint = 0
Return SetError(0, 0, 0)
EndIf
DllStructSetData($tPoint, "Y", $aPos[1])
If @error <> 0 Then
$tPoint = 0
Return SetError(0, 0, 0)
EndIf
_WinAPI_ClientToScreen(GetCurrentAndroidHWnD(), $tPoint)
If @error <> 0 Then
$tPoint = 0
Return SetError(0, 0, 0)
EndIf
$g_aiBSpos[0] = DllStructGetData($tPoint, "X")
If @error <> 0 Then
$tPoint = 0
Return SetError(0, 0, 0)
EndIf
$g_aiBSpos[1] = DllStructGetData($tPoint, "Y")
If @error <> 0 Then
$tPoint = 0
Return SetError(0, 0, 0)
EndIf
$g_aiBSrpos[0] = $aPos[0]
$g_aiBSrpos[1] = $aPos[1]
$tPoint = 0
$Changed = Not($aOldValues[0] = $g_aiBSpos[0] And $aOldValues[1] = $g_aiBSpos[1] And $aOldValues[2] = $g_aiBSrpos[0] And $aOldValues[3] = $g_aiBSrpos[1])
If $g_bDebugClick Or $g_bDebugSetlog And $Changed Then SetLog("$g_aiBSpos X,Y = " & $g_aiBSpos[0] & "," & $g_aiBSpos[1] & "; $g_aiBSrpos X,Y = " & $g_aiBSrpos[0] & "," & $g_aiBSrpos[1], $COLOR_ERROR, "Verdana", "7.5", 0)
EndIf
SuspendAndroid($SuspendMode, False)
EndFunc
Func getAndroidPos($FastCheck = False, $RetryCount1 = 0, $RetryCount2 = 0, $bWidthFirst = Default)
Static $asControlSize[6][4]
Local $aControlSize = ControlGetPos(GetCurrentAndroidHWnD(), $g_sAppPaneName, GetAndroidControlClass(True))
If $FastCheck Then Return $aControlSize
If AndroidMakeDpiAware() Then AndroidDpiAwareness()
Local $sPre = "(" & $RetryCount1 & "/" & $RetryCount2 & ") "
Local $bResizedOk = False
If IsArray($aControlSize) Then
If($aControlSize[2] <> $g_iAndroidClientWidth Or $aControlSize[3] <> $g_iAndroidClientHeight) And $RetryCount1 = 0 And $RetryCount2 = 0 Then
UpdateAndroidWindowState()
If $RetryCount1 = 0 Then
For $i = 0 To 5
For $j = 0 To 3
$asControlSize[$i][$j] = 0
Next
Next
EndIf
EndIf
If $aControlSize[2] <> $g_iAndroidClientWidth Or $aControlSize[3] <> $g_iAndroidClientHeight Then
If $RetryCount1 < 6 Then
For $i = 0 To 3
$asControlSize[$RetryCount1][$i] = $aControlSize[$i]
Next
EndIf
SetDebugLog($sPre & "Unsupported " & $g_sAndroidEmulator & " screen size of " & $aControlSize[2] & " x " & $aControlSize[3] & " at " & $aControlSize[0] & ", " & $aControlSize[1] & " (expect " & $g_iAndroidClientWidth & " x " & $g_iAndroidClientHeight & ")", $COLOR_ACTION)
Local $aAdj0 = [0, 0]
If $RetryCount1 = 0 And $RetryCount2 = 0 Then
Local $aWin = WinGetPos($g_hAndroidWindow)
If UBound($aWin) > 2 Then
Local $hCtrl = ControlGetHandle($g_hAndroidWindow, $g_sAppPaneName, $g_sAppClassInstance)
Local $fZoom =($g_iAndroidClientWidth / $aControlSize[2] + $g_iAndroidClientHeight / $aControlSize[3]) / 2
$aAdj0[0] = Int($aWin[2] * $fZoom) - $aWin[2]
$aAdj0[1] = Int($aWin[3] * $fZoom) - $aWin[3]
WinMove2($g_hAndroidWindow, "", $aWin[0], $aWin[1], $aWin[2] + $aAdj0[0], $aWin[3] + $aAdj0[1])
RedrawAndroidWindow()
$aControlSize = getAndroidPosWait($aControlSize)
EndIf
EndIf
Local $bExpectControlResize = True
Local $AndroidWinPos = WinGetPos($g_hAndroidWindow)
If UBound($AndroidWinPos) < 4 Then
Return
EndIf
Local $WinWidth = $AndroidWinPos[2]
Local $WinHeight = $AndroidWinPos[3]
Local $aAndroidWindow[2] = [$WinWidth, $WinHeight]
Local $aAdj = [$g_iAndroidClientWidth - $aControlSize[2], $g_iAndroidClientHeight - $aControlSize[3]]
Switch $RetryCount1
Case 0
Local $tRECT = _WinAPI_GetClientRect($g_hAndroidWindow)
If @error = 0 Then
$aAndroidWindow[0] = $g_iAndroidWindowWidth
$aAndroidWindow[1] = $g_iAndroidWindowHeight
$aAdj[0] = $WinWidth -(DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left"))
$aAdj[1] = $WinHeight -(DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top"))
Else
SetDebugLog($sPre & "WARNING: Cannot determine " & $g_sAndroidEmulator & " Window Client Area!", $COLOR_ERROR)
EndIf
Case 1
Case 2
$bExpectControlResize = False
If Abs($aControlSize[3] - $g_iAndroidClientHeight) = 0 Or Abs($aControlSize[2] - $g_iAndroidClientWidth) > 0 Then
$aAdj[1] = 0
$bWidthFirst = False
Else
$aAdj[0] = 0
$bWidthFirst = True
EndIf
Case 3
If $bWidthFirst = True Then
$aAdj[1] = 0
ElseIf $bWidthFirst = False Then
$aAdj[0] = 0
EndIf
Case 4
If CheckDpiAwareness(True) = False Then
CheckDpiAwareness(False, True)
AndroidDpiAwareness()
EndIf
Case 5
EndSwitch
$aAndroidWindow[0] += $aAdj[0]
$aAndroidWindow[1] += $aAdj[1]
SetDebugLog($sPre & $g_sAndroidTitle & " Adjusted Window Size: " & $aAndroidWindow[0] & " x " & $aAndroidWindow[1] & " (by " & $aAdj[0] + $aAdj0[0] & ", " & $aAdj[1] + $aAdj0[1] & ")", $COLOR_INFO)
If $bExpectControlResize And $RetryCount1 < 6 Then
WinMove($g_hAndroidWindow, "", $AndroidWinPos[0], $AndroidWinPos[1], $aAndroidWindow[0] - 2, $aAndroidWindow[1] - 2)
$AndroidWinPos = WinGetPos($g_hAndroidWindow)
If UBound($AndroidWinPos) > 3 Then
$WinWidth = $AndroidWinPos[2]
$WinHeight = $AndroidWinPos[3]
EndIf
EndIf
If UBound($AndroidWinPos) > 3 Then
WinMove2($g_hAndroidWindow, "", $AndroidWinPos[0], $AndroidWinPos[1], $aAndroidWindow[0], $aAndroidWindow[1])
Local $aNewControlSize = getAndroidPos(True)
If UBound($aNewControlSize) > 2 Then
SetDebugLog($sPre & $g_sAndroidEmulator & " window resized to " & $aAndroidWindow[0] & " x " & $aAndroidWindow[1], $COLOR_SUCCESS)
RedrawAndroidWindow()
If $bExpectControlResize Then
$aNewControlSize = getAndroidPosWait($aControlSize, $aNewControlSize)
EndIf
If UBound($aNewControlSize) > 2 Then
$aControlSize = $aNewControlSize
If $aControlSize[2] <> $g_iAndroidClientWidth Or $aControlSize[3] <> $g_iAndroidClientHeight Then
If $bExpectControlResize = True Then
If $g_bDebugSetlog Then
SetDebugLog($sPre & $g_sAndroidEmulator & " window resize didn't work, screen is " & $aControlSize[2] & " x " & $aControlSize[3], $COLOR_ERROR)
Else
SetLog($g_sAndroidEmulator & " window resize didn't work, screen is " & $aControlSize[2] & " x " & $aControlSize[3], $COLOR_ERROR)
EndIf
If $RetryCount1 > 0 And $RetryCount1 < 6 And $RetryCount2 = 0 Then
Local $bXinc = $aControlSize[0] > $asControlSize[$RetryCount1][0] And $asControlSize[$RetryCount1][0] > $asControlSize[$RetryCount1 - 1][0]
Local $bYinc = $aControlSize[1] > $asControlSize[$RetryCount1][1] And $asControlSize[$RetryCount1][1] > $asControlSize[$RetryCount1 - 1][1]
If($bXinc And Not $bYinc) Or(Not $bXinc And $bYinc) Or($aControlSize[2] < $g_iAndroidClientWidth / 2 Or $aControlSize[2] > $g_iAndroidClientWidth * 1.5 Or $aControlSize[3] < $g_iAndroidClientHeight / 2 Or $aControlSize[3] > $g_iAndroidClientHeight * 1.5) Then
SetLog($g_sAndroidEmulator & " window cannot be resized, abort", $COLOR_ERROR)
Return $aControlSize
EndIf
EndIf
EndIf
If $RetryCount1 < 6 Then
Sleep(250)
Return getAndroidPos($FastCheck, $RetryCount1 + 1, $RetryCount2, $bWidthFirst)
EndIf
Else
$bResizedOk = True
EndIf
Else
If $RetryCount2 < 5 Then
Sleep(250)
Return getAndroidPos($FastCheck, $RetryCount1, $RetryCount2 + 1, $bWidthFirst)
EndIf
EndIf
Else
SetDebugLog($sPre & "WARNING: Cannot resize " & $g_sAndroidEmulator & " window to " & $aAndroidWindow[0] & " x " & $aAndroidWindow[1], $COLOR_ERROR)
EndIf
Else
If $RetryCount2 < 5 Then
Sleep(250)
Return getAndroidPos($FastCheck, $RetryCount1, $RetryCount2 + 1, $bWidthFirst)
EndIf
EndIf
ElseIf $RetryCount1 > 0 Or $RetryCount2 > 0 Then
$bResizedOk = True
EndIf
Else
SetDebugLog($sPre & "WARNING: Cannot resize " & $g_sAndroidEmulator & " window, control '" & $g_sAppClassInstance & "' not available", $COLOR_ERROR)
EndIf
If $bResizedOK Then
If $g_bDebugSetlog Then
SetDebugLog($sPre & $g_sAndroidEmulator & " window resized to work with MyBot", $COLOR_SUCCESS)
Else
SetLog($g_sAndroidEmulator & " window resized to work with MyBot", $COLOR_SUCCESS)
EndIf
EndIf
Return $aControlSize
EndFunc
Func getAndroidPosWait(ByRef $aControlSize, $aNewControlSize = 0)
If UBound($aNewControlSize) < 4 Then $aNewControlSize = getAndroidPos(True)
Local $hTimer = __TimerInit()
While __TimerDiff($hTimer) < 3000 And UBound($aNewControlSize) > 2 And($aControlSize[2] = $aNewControlSize[2] Or $aControlSize[3] = $aNewControlSize[3]) And $aNewControlSize[2] <> $g_iAndroidClientWidth And $aNewControlSize[3] <> $g_iAndroidClientHeight
Sleep($DELAYSLEEP)
$aNewControlSize = getAndroidPos(True)
WEnd
Return $aNewControlSize
EndFunc
Func UniversalCloseWaitOpenCoC($iWaitTime = 0, $sSource = "Unknown", $StopEmulator = False, $bFullRestart = False, $bSuspendComputer = False)
If $g_bDebugSetlog Then SetDebugLog("Begin UniversalCloseWaitOpenCoC:", $COLOR_DEBUG1)
Local $sWaitTime = ""
Local $iMin, $iSec, $iHour, $iWaitSec, $StopAndroidFlag
If $iWaitTime > 0 Then
$iWaitSec = Round($iWaitTime / 1000)
$iHour = Floor(Floor($iWaitSec / 60) / 60)
$iMin = Floor(Mod(Floor($iWaitSec / 60), 60))
$iSec = Floor(Mod($iWaitSec, 60))
If $iHour > 0 Then $sWaitTime &= $iHour & " hours "
If $iMin > 0 Then $sWaitTime &= $iMin & " minutes "
If $iSec > 0 Then $sWaitTime &= $iSec & " seconds "
EndIf
Local $msg = ""
Select
Case StringInStr($StopEmulator, "rand", $STR_NOCASESENSEBASIC)
$StopAndroidFlag = Random(0, 2, 1)
Switch $StopAndroidFlag
Case 0
$msg = " =Time out"
Case 1
$msg = " =Close CoC"
Case 2
$msg = " =Close Android"
Case Else
$msg = "One Bad Monkey Error!"
EndSwitch
SetLog("Random close option= " & $StopAndroidFlag & $msg, $COLOR_SUCCESS)
Case StringInStr($StopEmulator, "idle", $STR_NOCASESENSEBASIC)
$StopAndroidFlag = 0
Case $StopEmulator = False
$StopAndroidFlag = 1
Case $StopEmulator = True
$StopAndroidFlag = 2
Case Else
$StopAndroidFlag = 1
SetLog("Code Monkey provided bad stop emulator flag value", $COLOR_ERROR)
EndSelect
If $g_bDebugSetlog Then SetDebugLog("Stop Android flag : Input flag " & $StopAndroidFlag & " : " & $StopEmulator, $COLOR_DEBUG)
If _Sleep($DELAYRESPOND) Then Return False
Switch $StopAndroidFlag
Case 0
If $iWaitTime > 0 Then
SetLog("Going idle for " & $sWaitTime & "before starting CoC", $COLOR_SUCCESS)
Local $hTimer = __TimerInit()
LockBotSlot(False)
If $bSuspendComputer Then SuspendComputer($iWaitTime)
If _SleepStatus($iWaitTime, True, True, True, $hTimer) Then Return False
LockBotSlot(True)
Else
If _SleepStatus($DELAYWAITNOPENCOC10000) Then Return False
EndIf
If _Sleep($DELAYRESPOND) Then Return False
OpenCoC()
Case 1
Local $bSendHome = True
If $bSendHome Then
AndroidHomeButton()
Else
PoliteCloseCoC($sSource)
EndIf
If _Sleep(3000) Then Return False
If $iWaitTime > 0 Then
If $iWaitTime > 30000 Then
AndroidShieldForceDown(True)
EnableGuiControls()
SetLog("Enabled bot controls due to long wait time", $COLOR_SUCCESS)
EndIf
LockBotSlot(False)
WaitnOpenCoC($iWaitTime, $bFullRestart, $bSuspendComputer, True)
AndroidShieldForceDown(False)
If $g_bRunState = False Then Return False
Else
WaitnOpenCoC($DELAYWAITNOPENCOC10000, $bFullRestart)
EndIf
If _Sleep($DELAYRESPOND) Then Return False
If $iWaitTime > 30000 Then
SaveConfig()
readConfig()
applyConfig()
DisableGuiControls()
EndIf
Case 2
PoliteCloseCoC($sSource)
If _Sleep(3000) Then Return False
CloseAndroid("UniversalCloseWaitOpenCoC")
ReduceBotMemory()
If $iWaitTime > 0 Then
SetLog("Waiting " & $sWaitTime & "before starting CoC", $COLOR_SUCCESS)
If $iWaitTime > 30000 Then
EnableGuiControls()
SetLog("Enabled bot controls due to long wait time", $COLOR_SUCCESS)
EndIf
Local $hTimer = __TimerInit()
LockBotSlot(False)
If $bSuspendComputer Then SuspendComputer($iWaitTime)
If _SleepStatus($iWaitTime, True, True, True, $hTimer) Then Return False
LockBotSlot(True)
If $iWaitTime > 30000 Then
SaveConfig()
readConfig()
applyConfig()
DisableGuiControls()
EndIf
Else
If _SleepStatus($DELAYWAITNOPENCOC10000) Then Return False
EndIf
StartAndroidCoC()
Case Else
SetLog("Code Monkey is drinking banana liqueur again!", $COLOR_ERROR)
EndSwitch
EndFunc
Func SuspendComputer($iMilliseconds)
SetDebugLog("Trying to suspend computer")
If $g_BotInstanceCount > 1 Then
SetLog($g_BotInstanceCount & " bot instances detected, will not suspend computer", $COLOR_ERROR)
Return False
EndIf
If SetWakeUpSeconds(Round($iMilliseconds / 1000, 0)) Then
AndroidAdbTerminateShellInstance()
KillAdbDaemon()
InitAndroidTimeLag()
SetLog("Suspend computer now", $COLOR_INFO)
CheckPostponedLog(True)
If SetSuspend() Then
Return True
EndIf
SetLog("Cannot suspend computer, error: " & @error & ", extended: " & @extended, $COLOR_ERROR)
Return False
EndIf
SetLog("Cannot set computer wakeup time, error: " & @error & ", extended: " & @extended, $COLOR_ERROR)
Return False
EndFunc
Global $g_aiAndroidEmbeddedGraphics[0][2]
Func GetCurrentAndroidHWnD()
Local $h =(($g_bAndroidEmbedded = False Or $g_iAndroidEmbedMode = 1) ? $g_hAndroidWindow : $g_hFrmBot)
Return $h
EndFunc
Func GetAndroidDisplayHWnD()
Local $h =(($g_bAndroidEmbedded = False) ? $g_hAndroidWindow : $g_hFrmBot)
Return $h
EndFunc
Func AndroidEmbed($Embed = True, $CallWinGetAndroidHandle = True, $bForceEmbed = False, $bNoAndroidScreenSizeCheck = False)
If $g_iGuiMode <> 1 Then Return False
If $g_bAndroidEmbed = False Then Return False
Return _AndroidEmbed($Embed, $CallWinGetAndroidHandle, $bForceEmbed, $bNoAndroidScreenSizeCheck)
EndFunc
Func _AndroidEmbed($Embed = True, $CallWinGetAndroidHandle = True, $bForceEmbed = False, $bNoAndroidScreenSizeCheck = False)
If($CallWinGetAndroidHandle = False And $g_hAndroidWindow = 0) Or($CallWinGetAndroidHandle = True And WinGetAndroidHandle() = 0) Then
SetDebugLog("Android Emulator not launched", $COLOR_ERROR)
If $g_bAndroidEmbedded = False Then
updateBtnEmbed()
Return False
Else
If $Embed = True Then
SetDebugLog("Docked Android Window not available, force undock", $COLOR_ERROR)
$Embed = False
EndIf
EndIf
EndIf
If $g_bAndroidBackgroundLaunched = True Then
If $g_bAndroidEmbedded = False Then
SetDebugLog("Android Emulator launched in background mode", $COLOR_ERROR)
updateBtnEmbed()
Return False
Else
If $Embed = True Then
SetDebugLog("Android Emulator launched in background mode, force undock", $COLOR_ERROR)
$Embed = False
EndIf
EndIf
EndIf
Local $aPos = WinGetPos($g_hAndroidWindow)
If IsArray($aPos) = 0 Or @error <> 0 Then
If $g_bAndroidEmbedded = False Then
SetDebugLog("Android Window not available", $COLOR_ERROR)
updateBtnEmbed()
Return False
Else
If $Embed = True Then
SetDebugLog("Android Window not accessible, force undock", $COLOR_ERROR)
$Embed = False
EndIf
EndIf
EndIf
Local $hTimer = __TimerInit()
Do
Local $hCtrl = ControlGetHandle(GetCurrentAndroidHWnD(), $g_sAppPaneName, GetAndroidControlClass())
Local $hCtrlTarget = _WinAPI_GetParent($hCtrl)
If $hCtrlTarget = 0 Then Sleep(10)
Until $hCtrlTarget <> 0 Or __TimerDiff($hTimer) > 3000
If $hCtrlTarget = 0 Then
If $g_bAndroidEmbedded = False Then
SetDebugLog("Android Control not available", $COLOR_ERROR)
updateBtnEmbed()
Return False
Else
If $Embed = True Then
SetDebugLog("Android Control not available, force undock", $COLOR_ERROR)
$Embed = False
EndIf
EndIf
EndIf
Local $aPosFrmBotEx, $aPosLog
Local $hCtrlTarget = $g_aiAndroidEmbeddedCtrlTarget[0]
Local $hCtrlTargetParent = $g_aiAndroidEmbeddedCtrlTarget[1]
Local $HWnDParent = $g_aiAndroidEmbeddedCtrlTarget[2]
Local $HWnD2 = $g_aiAndroidEmbeddedCtrlTarget[3]
Local $lCurStyle = $g_aiAndroidEmbeddedCtrlTarget[4]
Local $lCurExStyle = $g_aiAndroidEmbeddedCtrlTarget[5]
Local $aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
Local $lCurStyleTarget = $g_aiAndroidEmbeddedCtrlTarget[8]
Local $hThumbnail = $g_aiAndroidEmbeddedCtrlTarget[9]
Local $targetIsHWnD = $hCtrlTarget = $g_hAndroidWindow
Local $activeHWnD = WinGetHandle("")
Local $HWnD_available = WinGetHandle($g_hAndroidWindow) = $g_hAndroidWindow
If $Embed = False Then
If $g_bAndroidEmbedded = True Then
SetDebugLog("Undocking Android Control...")
If _WinAPI_IsIconic($g_hFrmBot) Then BotMinimize("_AndroidEmbed (1)", True)
If $g_bAndroidShieldEnabled = True Then
AndroidShield("AndroidEmbed undock", False, $CallWinGetAndroidHandle, 100)
If $g_hFrmBotEmbeddedShield Then
GUIDelete($g_hFrmBotEmbeddedShield)
$g_hFrmBotEmbeddedShield = 0
EndIf
If $g_hFrmBotEmbeddedMouse Then
GUIDelete($g_hFrmBotEmbeddedMouse)
$g_hFrmBotEmbeddedMouse = 0
EndIf
$g_avAndroidShieldStatus[0] = Default
EndIf
SetRedrawBotWindow(False, Default, Default, Default, "_AndroidEmbed")
If $hThumbnail <> 0 Then
_WinAPI_DwmUnregisterThumbnail($hThumbnail)
$g_aiAndroidEmbeddedCtrlTarget[9] = 0
EndIf
$aPos = $g_aiAndroidEmbeddedCtrlTarget[7]
$g_hProcShieldInput[3] = True
If $HWnD_available Then
Switch $g_iAndroidEmbedMode
Case 0
If $targetIsHWnD = False Then
_WinAPI_SetParent($hCtrlTarget, $hCtrlTargetParent)
_WinAPI_SetWindowLong($hCtrlTarget, $GWL_HWNDPARENT, $hCtrlTargetParent)
EndIf
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE, $lCurExStyle)
_WinAPI_SetParent($g_hAndroidWindow, $HWnDParent)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_HWNDPARENT, $HWnDParent)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_STYLE, $lCurStyle)
WinMove($g_hAndroidWindow, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3] - 1)
WinMove2($g_hAndroidWindow, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3])
Case 1
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE, $lCurExStyle)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_STYLE, $lCurStyle)
WinMove($g_hAndroidWindow, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3] - 1)
WinMove($g_hAndroidWindow, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3])
EndSwitch
EndIf
WinMove(($targetIsHWnD ? $hCtrl : $hCtrlTarget), "", $aPosCtl[0], $aPosCtl[1], $aPosCtl[2], $aPosCtl[3])
WinMove2(($targetIsHWnD ? $hCtrl : $hCtrlTarget), "", $aPosCtl[0], $aPosCtl[1], $aPosCtl[2], $aPosCtl[3], 0, 0, False)
If $g_bDebugAndroidEmbedded Then SetDebugLog("Placed Android Control at " & $aPosCtl[0] & "," & $aPosCtl[1])
ControlHide($g_hGUI_LOG, "", $g_hDivider)
$aPosFrmBotEx = ControlGetPos($g_hFrmBot, "", $g_hFrmBotEx)
If UBound($aPosFrmBotEx) < 4 Then
SetLog("Bot Window not available", $COLOR_ERROR)
$g_hProcShieldInput[3] = False
Return False
EndIf
ControlMove($g_hFrmBot, "", $g_hFrmBotEx, 0, 0, $aPosFrmBotEx[2], $aPosFrmBotEx[3] - $g_iFrmBotAddH)
ControlMove($g_hFrmBot, "", $g_hFrmBotBottom, 0, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP)
WinSetTrans($g_hFrmBotBottom, "", 255)
$aPosLog = ControlGetPos($g_hFrmBotEx, "", $g_hGUI_LOG)
ControlMove($g_hFrmBotEx, "", $g_hGUI_LOG, Default, Default, $aPosLog[2], $aPosLog[3] - $g_iFrmBotAddH)
$g_bAndroidEmbedded = False
WinMove2($g_hFrmBot, "", $g_iFrmBotPosX, $g_iFrmBotPosY, $g_aFrmBotPosInit[2], $g_aFrmBotPosInit[3] + $g_aFrmBotPosInit[7], $HWND_NOTOPMOST, 0, False)
updateBtnEmbed()
$g_iLogDividerY -= $g_iFrmBotAddH
$g_iFrmBotAddH = 0
cmbLog()
SetRedrawBotWindow(True, Default, Default, Default, "_AndroidEmbed")
If $HWnD_available Then
_SendMessage($g_hAndroidWindow, $WM_SETREDRAW, False, 0)
_WinAPI_ShowWindow($g_hAndroidWindow, @SW_HIDE)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE, BitOR($lCurExStyle, $WS_EX_APPWINDOW))
_WinAPI_ShowWindow($g_hAndroidWindow, @SW_SHOWNOACTIVATE)
_SendMessage($g_hAndroidWindow, $WM_SETREDRAW, True, 0)
_WinAPI_UpdateWindow($g_hAndroidWindow)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE, $lCurExStyle)
_WinAPI_EnableWindow($g_hAndroidWindow, True)
_WinAPI_EnableWindow($hCtrlTarget, True)
WinMove2(($targetIsHWnD ? $hCtrl : $hCtrlTarget), "", $aPosCtl[0], $aPosCtl[1], $aPosCtl[2], $aPosCtl[3], 0, 0, False)
WinMove($g_hAndroidWindow, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3])
If $g_iAndroidEmbedMode = 1 Then
WinMove2($g_hAndroidWindow, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3], $HWND_TOPMOST)
WinMove2($g_hAndroidWindow, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3], $HWND_NOTOPMOST, 0, False)
EndIf
If $bNoAndroidScreenSizeCheck = False Then
getBSPos()
EndIf
Execute("Embed" & $g_sAndroidEmulator & "(False)")
EndIf
SetDebugLog("Undocked Android Window")
$g_hProcShieldInput[3] = False
Return True
EndIf
updateBtnEmbed()
Return False
EndIf
If $g_bAndroidEmbedded = True And $bForceEmbed = False Then
If $g_hAndroidWindow = $HWnD2 Then
If $targetIsHWnD = False Then
WinMove2($g_hAndroidWindow, "", $aPosCtl[2] + 2, $g_aFrmBotPosInit[5], -1, -1, $HWND_BOTTOM)
EndIf
Return False
EndIf
SetDebugLog("Docked Android Window gone", $COLOR_ERROR)
Return _AndroidEmbed(False)
EndIf
Local $bAlreadyEmbedded = $g_bAndroidEmbedded = True
SetDebugLog("Docking Android Control...")
If _WinAPI_DwmEnableComposition(True) = 1 Then
SetDebugLog("Desktop Window Manager available", $COLOR_SUCCESS)
Else
SetDebugLog("Desktop Window Manager not available!", $COLOR_ERROR)
SetDebugLog("Android Shield will be invisible!", $COLOR_ERROR)
EndIf
If _WinAPI_IsIconic($g_hFrmBot) Then BotMinimize("_AndroidEmbed (2)", True)
If _WinAPI_IsIconic($g_hAndroidWindow) Then WinSetState($g_hAndroidWindow, "", @SW_RESTORE)
Switch $g_iAndroidEmbedMode
Case 0
Local $iBotDpiAware = GetProcessDpiAwareness(@AutoItPID)
If GetProcessDpiAwareness(GetAndroidPid()) And $iBotDpiAware = 0 And CheckDpiAwareness(True) = False Then
CheckDpiAwareness(False, True)
EndIf
If $iBotDpiAware Then
$g_hAndroidWindowDpiAware = $g_hAndroidWindow
EndIf
EndSwitch
If $bNoAndroidScreenSizeCheck = False Then getAndroidPos()
Local $hTimer = __TimerInit()
Do
$aPos = WinGetPos($g_hAndroidWindow)
If UBound($aPos) < 3 Then Sleep(10)
Until UBound($aPos) > 2 Or __TimerDiff($hTimer) > 3000
If UBound($aPos) < 3 Then
SetDebugLog("Android Window not accessible", $COLOR_ERROR)
updateBtnEmbed()
Return False
EndIf
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPos[] = " & $aPos[0] & ", " & $aPos[1] & ", " & $aPos[2] & ", " & $aPos[3], Default, True)
$lCurStyle = _WinAPI_GetWindowLong($g_hAndroidWindow, $GWL_STYLE)
$lCurExStyle = _WinAPI_GetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE)
$HWnDParent = __WinAPI_GetParent($g_hAndroidWindow)
$hCtrl = ControlGetHandle(GetCurrentAndroidHWnD(), $g_sAppPaneName, $g_sAppClassInstance)
$hCtrlTarget = __WinAPI_GetParent($hCtrl)
$targetIsHWnD = $hCtrlTarget = $g_hAndroidWindow
$lCurStyleTarget = _WinAPI_GetWindowLong($hCtrlTarget, $GWL_STYLE)
$hCtrlTargetParent = __WinAPI_GetParent($hCtrlTarget)
SetDebugLog("AndroidEmbed: $hCtrl=" & $hCtrl & ", $hCtrlTarget=" & $hCtrlTarget & ", $hCtrlTargetParent=" & $hCtrlTargetParent & ", $g_hAndroidWindow=" & $g_hAndroidWindow, Default, True)
Local $adjustPosCtrl = False
If $bAlreadyEmbedded = True Then
$g_hProcShieldInput[3] = True
Else
$aPosCtl = ControlGetPos($g_hAndroidWindow, "",($targetIsHWnD ? $hCtrl : $hCtrlTarget))
If UBound($aPosCtl) < 3 Then
SetDebugLog("Android Control Position not available", $COLOR_ERROR)
updateBtnEmbed()
Return False
EndIf
If $aPosCtl[2] <> $g_iAndroidClientWidth Then
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosCtl[2] = " & $aPosCtl[2] & " changed to " & $g_iAndroidClientWidth, Default, True)
$aPosCtl[2] = $g_iAndroidClientWidth
EndIf
If $aPosCtl[3] <> $g_iAndroidClientHeight Then
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosCtl[3] = " & $aPosCtl[3] & " changed to " & $g_iAndroidClientHeight, Default, True)
$aPosCtl[3] = $g_iAndroidClientHeight
EndIf
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosCtl[] = " & $aPosCtl[0] & ", " & $aPosCtl[1] & ", " & $aPosCtl[2] & ", " & $aPosCtl[3], Default, True)
If $targetIsHWnD Then
Local $aPosParentCtl = $aPosCtl
$hCtrlTargetParent = $hCtrlTarget
ElseIf $hCtrlTargetParent = $g_hAndroidWindow Then
Local $aPosParentCtl = $aPosCtl
Else
$adjustPosCtrl = True
Local $aPosParentCtl = ControlGetPos($g_hAndroidWindow, "", $hCtrlTargetParent)
If $hCtrlTargetParent = 0 Or IsArray($aPosParentCtl) = 0 Or @error <> 0 Then
SetDebugLog("Android Parent Control not available", $COLOR_ERROR)
updateBtnEmbed()
Return False
EndIf
EndIf
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosParentCtl[] = " & $aPosParentCtl[0] & ", " & $aPosParentCtl[1] & ", " & $aPosParentCtl[2] & ", " & $aPosParentCtl[3], Default, True)
Local $botClientHeight = $g_aFrmBotPosInit[5] - $g_aFrmBotPosInit[7]
$g_iFrmBotAddH = $aPosCtl[3] - $botClientHeight - $g_aFrmBotPosInit[7]
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $g_iFrmBotAddH = " & $g_iFrmBotAddH, Default, True)
If $g_iFrmBotAddH < 0 Then $g_iFrmBotAddH = 0
Local $g_hFrmBotWidth = $g_aFrmBotPosInit[2] + $aPosCtl[2] + 2
Local $g_hFrmBotHeight = $g_aFrmBotPosInit[3] + $g_iFrmBotAddH + $g_aFrmBotPosInit[7]
$g_hProcShieldInput[3] = True
$g_bAndroidEmbedded = True
If $g_iFrmBotDockedPosX = $g_WIN_POS_DEFAULT Or $g_iFrmBotDockedPosY = $g_WIN_POS_DEFAULT Then
If $g_iFrmBotPosX < $g_iAndroidPosX Then
$g_iFrmBotDockedPosX = $g_iFrmBotPosX
$g_iFrmBotDockedPosY = $g_iFrmBotPosY
Else
$g_iFrmBotDockedPosX = $g_iAndroidPosX
$g_iFrmBotDockedPosY = $g_iAndroidPosY
EndIf
EndIf
WinMove2($g_hFrmBot, "", $g_iFrmBotDockedPosX, $g_iFrmBotDockedPosY, -1, -1, 0, 0, False)
$aPosFrmBotEx = ControlGetPos($g_hFrmBot, "", $g_hFrmBotEx)
$aPosFrmBotEx[3] = $g_aFrmBotPosInit[6]
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosFrmBotEx[] = " & $aPosFrmBotEx[0] & ", " & $aPosFrmBotEx[1] & ", " & $aPosFrmBotEx[2] & ", " & $aPosFrmBotEx[3], Default, True)
WinMove($g_hFrmBotEx, "", $aPosCtl[2] + 2, 0, $aPosFrmBotEx[2], $aPosFrmBotEx[3] + $g_iFrmBotAddH)
WinMove($g_hFrmBotBottom, "", $aPosCtl[2] + 2, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP + $g_iFrmBotAddH)
If $g_iAndroidEmbedMode = 0 Then
WinMove2($hCtrlTarget, "", 0, 0, $aPosCtl[2], $aPosCtl[3], $HWND_BOTTOM)
EndIf
_SendMessage($g_hFrmBot, $WM_SETREDRAW, False, 0)
Local $a = ControlGetRelativePos($g_hFrmBotEx, "", $g_hTabMain)
If UBound($a) > 3 Then
Local $ctrlResult = WinMove(GUICtrlGetHandle($g_hTabMain), "", $a[0], $a[1], $a[2], $a[3] + $g_iFrmBotAddH)
If $g_bDebugAndroidEmbedded Then SetDebugLog("Move $g_hTabMain Pos: " & $a[0] & ", " & $a[1] & ", " & $a[2] & ", " & $a[3] + $g_iFrmBotAddH & ": " & $ctrlResult)
EndIf
$aPosLog = ControlGetPos($g_hFrmBotEx, "", $g_hGUI_LOG)
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosLog[] = " & $aPosLog[0] & ", " & $aPosLog[1] & ", " & $aPosLog[2] & ", " & $aPosLog[3], Default, True)
WinMove($g_hGUI_LOG, "", $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, $aPosLog[2], $aPosLog[3] + $g_iFrmBotAddH)
WinMove2($g_hFrmBot, "", $g_iFrmBotDockedPosX, $g_iFrmBotDockedPosY, $g_hFrmBotWidth, $g_hFrmBotHeight,($g_bChkBackgroundMode ? $HWND_NOTOPMOST : $HWND_TOPMOST), 0, False)
$g_aiAndroidEmbeddedCtrlTarget[0] = $hCtrlTarget
$g_aiAndroidEmbeddedCtrlTarget[1] = $hCtrlTargetParent
$g_aiAndroidEmbeddedCtrlTarget[2] = $HWnDParent
$g_aiAndroidEmbeddedCtrlTarget[3] = $g_hAndroidWindow
$g_aiAndroidEmbeddedCtrlTarget[4] = $lCurStyle
$g_aiAndroidEmbeddedCtrlTarget[5] = $lCurExStyle
If $adjustPosCtrl = True Then
$aPosCtl[0] = $aPosParentCtl[0] - $aPosCtl[0]
$aPosCtl[1] = $aPosParentCtl[1] - $aPosCtl[1]
EndIf
$g_aiAndroidEmbeddedCtrlTarget[6] = $aPosCtl
$g_aiAndroidEmbeddedCtrlTarget[7] = $aPos
$g_aiAndroidEmbeddedCtrlTarget[8] = $lCurStyleTarget
EndIf
Local $newStyle = AndroidEmbed_GWL_STYLE()
SetDebugLog("AndroidEmbed_GWL_STYLE=" & Get_GWL_STYLE_Text($newStyle))
Local $a = AndroidEmbed_HWnD_Position()
Switch $g_iAndroidEmbedMode
Case 0
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE, $WS_EX_MDICHILD)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_HWNDPARENT, $g_hFrmBot)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_STYLE, $newStyle)
_WinAPI_SetParent($g_hAndroidWindow, $g_hFrmBot)
If $targetIsHWnD = False Then
_WinAPI_SetWindowLong($hCtrlTarget, $GWL_HWNDPARENT, $g_hFrmBot)
_WinAPI_SetParent($hCtrlTarget, $g_hFrmBot)
EndIf
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_STYLE, $newStyle)
If $targetIsHWnD = False Then
WinMove2($g_hAndroidWindow, "", $a[0], $a[1], -1, -1, $HWND_BOTTOM, 0, False)
EndIf
Case 1
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_STYLE, $newStyle)
WinMove2($g_hAndroidWindow, "", -1, -1, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_ShowWindow($g_hAndroidWindow, @SW_HIDE)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE))
_WinAPI_ShowWindow($g_hAndroidWindow, @SW_SHOWNOACTIVATE)
_SendMessage($g_hAndroidWindow, $WM_SETREDRAW, True, 0)
_WinAPI_UpdateWindow($g_hAndroidWindow)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE))
WinMove($g_hAndroidWindow, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3] - 1)
WinMove($g_hAndroidWindow, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3])
If $targetIsHWnD = False Then
WinMove2($hCtrlTarget, "", 0, 0, $aPosCtl[2], $aPosCtl[3], 0, 0, False)
EndIf
If _WinAPI_DwmIsCompositionEnabled() And $hThumbnail = 0 Then
Local $iFix = 0
If $g_bCustomTitleBarActive = True Then $iFix = 1
$hThumbnail = _WinAPI_DwmRegisterThumbnail($g_hFrmBot, $g_hAndroidWindow)
Local $tSIZE = _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
Local $iWidth = DllStructGetData($tSIZE, 1)
Local $iHeight = DllStructGetData($tSIZE, 2)
Local $tDestRect = _WinAPI_CreateRectEx(0 + $iFix, 0 + $iFix, $aPosCtl[2] + $iFix, $aPosCtl[3] + $iFix)
Local $tSrcRect = _WinAPI_CreateRectEx(0, 0, $iWidth, $iHeight)
_WinAPI_DwmUpdateThumbnailProperties($hThumbnail, 1, 0, 255, $tDestRect, $tSrcRect)
$g_aiAndroidEmbeddedCtrlTarget[9] = $hThumbnail
EndIf
WinMove2($g_hAndroidWindow, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3], $HWND_BOTTOM, $SWP_SHOWWINDOW, False)
EndSwitch
Execute("Embed" & $g_sAndroidEmulator & "(True)")
updateBtnEmbed()
$g_iLogDividerY += $g_iFrmBotAddH
cmbLog()
_WinAPI_EnableWindow($hCtrlTarget, False)
_WinAPI_EnableWindow($g_hAndroidWindow, False)
Local $aCheck = WinGetPos($g_hAndroidWindow)
If IsArray($aCheck) Then
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: Android Window Pos: " & $aCheck[0] & ", " & $aCheck[1] & ", " & $aCheck[2] & ", " & $aCheck[3], Default, True)
Else
SetDebugLog("AndroidEmbed: Android Window not found", $COLOR_ERROR)
EndIf
Local $aCheck = ControlGetPos(GetCurrentAndroidHWnD(), $g_sAppPaneName, $g_sAppClassInstance)
If IsArray($aCheck) Then
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: Android Control Pos: " & $aCheck[0] & ", " & $aCheck[1] & ", " & $aCheck[2] & ", " & $aCheck[3], Default, True)
Else
SetDebugLog("AndroidEmbed: Android Control not found", $COLOR_ERROR)
EndIf
If $bNoAndroidScreenSizeCheck = False Then
getBSPos()
EndIf
_SendMessage($g_hFrmBot, $WM_SETREDRAW, True, 0)
_WinAPI_RedrawWindow($g_hFrmBot, 0, 0, $RDW_INVALIDATE + $RDW_ALLCHILDREN + $RDW_ERASE)
_WinAPI_RedrawWindow($g_hFrmBotBottom, 0, 0, $RDW_INVALIDATE + $RDW_ALLCHILDREN + $RDW_ERASE)
_WinAPI_UpdateWindow($g_hFrmBot)
_WinAPI_UpdateWindow($g_hFrmBotBottom)
If $g_iAndroidEmbedMode = 0 Then
WinMove2($hCtrlTarget, "", 0, 0, $aPosCtl[2] - 1, $aPosCtl[3] - 1, $HWND_BOTTOM, 0, False)
WinMove2($hCtrl, "", 0, 0, $aPosCtl[2] - 1, $aPosCtl[3] - 1, $HWND_BOTTOM)
WinMove2($hCtrlTarget, "", 0, 0, $aPosCtl[2], $aPosCtl[3], $HWND_BOTTOM, 0, False)
WinMove2($hCtrl, "", 0, 0, $aPosCtl[2], $aPosCtl[3], $HWND_BOTTOM)
EndIf
SetDebugLog("Android Window docked")
$g_hProcShieldInput[3] = False
$g_hProcShieldInput[4] = 0
AndroidShield("AndroidEmbed dock", Default, $CallWinGetAndroidHandle, 100)
Return True
EndFunc
Func Get_GWL_STYLE_Text($iGWL_STYLE)
Local $s = ""
Local $a[20][2] = [[$WS_MAXIMIZEBOX, "$WS_MAXIMIZEBOX"] , [$WS_MINIMIZEBOX, "$WS_MINIMIZEBOX"] , [$WS_TABSTOP, "$WS_TABSTOP"] , [$WS_GROUP, "$WS_GROUP"] , [$WS_SIZEBOX, "$WS_SIZEBOX"] , [$WS_SYSMENU, "$WS_SYSMENU"] , [$WS_HSCROLL, "$WS_HSCROLL"] , [$WS_VSCROLL, "$WS_VSCROLL"] , [$WS_DLGFRAME, "$WS_DLGFRAME"] , [$WS_BORDER, "$WS_BORDER"] , [$WS_CAPTION, "$WS_CAPTION"] , [$WS_MAXIMIZE, "$WS_MAXIMIZE"] , [$WS_CLIPCHILDREN, "$WS_CLIPCHILDREN"] , [$WS_CLIPSIBLINGS, "$WS_CLIPSIBLINGS"] , [$WS_DISABLED, "$WS_DISABLED"] , [$WS_VISIBLE, "$WS_VISIBLE"] , [$WS_MINIMIZE, "$WS_MINIMIZE"] , [$WS_CHILD, "$WS_CHILD"] , [$WS_POPUP, "$WS_POPUP"] , [$WS_POPUPWINDOW, "$WS_POPUPWINDOW"] ]
Local $i
For $i = 0 To UBound($a) - 1
If BitAND($iGWL_STYLE, $a[$i][0]) > 0 Then
If $s <> "" Then $s &= ", "
$s &= $a[$i][1]
$iGWL_STYLE -= $a[$i][0]
EndIf
Next
If $iGWL_STYLE > 0 Then
If $s <> "" Then $s &= ","
$s &= Hex($iGWL_STYLE, 8)
EndIf
Return $s
EndFunc
Func AndroidEmbed_GWL_STYLE()
If $g_bAndroidEmbedded = True Then
Local $lCurStyle = $g_aiAndroidEmbeddedCtrlTarget[4]
Local $newStyle = BitOR($WS_CHILD, BitAND($lCurStyle, BitNOT(BitOR($WS_POPUP, $WS_CAPTION, $WS_SYSMENU, $WS_MINIMIZEBOX, $WS_MAXIMIZEBOX, $WS_SIZEBOX, $WS_BORDER, $WS_THICKFRAME))))
If $g_iAndroidEmbedMode = 1 Then
$newStyle = BitOR($WS_POPUP, BitAND($newStyle, BitNOT($WS_CHILD)))
EndIf
Return $newStyle
EndIf
Return ""
EndFunc
Func AndroidEmbed_HWnD_Position($bForShield = False, $bDetachedShield = Default, $hCtrlTarget = Default, $aPosCtl = Default)
Local $aPos[2]
If $bDetachedShield = Default Then
$bDetachedShield = $g_avAndroidShieldStatus[4]
EndIf
If $g_iAndroidEmbedMode = 1 Or($bForShield = True And $bDetachedShield = True) Then
Local $tPoint = DllStructCreate("int X;int Y")
DllStructSetData($tPoint, "X", 0)
DllStructSetData($tPoint, "Y", 0)
_WinAPI_ClientToScreen($g_hFrmBot, $tPoint)
$aPos[0] = DllStructGetData($tPoint, "X")
$aPos[1] = DllStructGetData($tPoint, "Y")
$tPoint = 0
ElseIf $g_iAndroidEmbedMode = 0 And $bForShield = False Then
If $hCtrlTarget = Default Then
$hCtrlTarget = $g_aiAndroidEmbeddedCtrlTarget[0]
EndIf
If $aPosCtl = Default Then
$aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
EndIf
Local $targetIsHWnD = $hCtrlTarget = $g_hAndroidWindow
If $targetIsHWnD = False Then
$aPos[0] = 0
$aPos[1] = $aPosCtl[3]
Else
$aPos[0] = 0
$aPos[1] = 0
EndIf
ElseIf $bForShield = True And($bDetachedShield = False Or $bDetachedShield = Default) Then
$aPos[0] = 0
$aPos[1] = 0
Else
SetDebugLog("AndroidEmbed_HWnD_Position: Wrong window state:" & @CRLF & "$bForShield=" & $bForShield & @CRLF & "$g_iAndroidEmbedMode=" & $g_iAndroidEmbedMode & @CRLF & "$bDetachedShield=" & $bDetachedShield)
EndIf
Return $aPos
EndFunc
Func AndroidEmbedCheck($bTestIfRequired = Default, $bHasFocus = Default, $iAction = 6)
If $g_bFrmBotMinimized Then $bHasFocus = False
If $bHasFocus = Default Then $bHasFocus = WinActive($g_hFrmBot) <> 0
If $bTestIfRequired = Default Then
$iAction = AndroidEmbedCheck(True, $bHasFocus)
If $iAction = 0 Then
Return 0
EndIf
$bTestIfRequired = False
EndIf
If $g_bAndroidEmbedded = True And AndroidEmbedArrangeActive() = False Then
Local $aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
Local $aPos = AndroidEmbed_HWnD_Position()
Local $aPosShield = AndroidEmbed_HWnD_Position(True)
Local $newStyle = AndroidEmbed_GWL_STYLE()
Local $bDetachedShield = $g_avAndroidShieldStatus[4]
If $bTestIfRequired = False Then
SetDebugLog("AndroidEmbedCheck: $iAction=" & $iAction, Default, True)
If BitAND($iAction, 2) > 0 Then
AndroidEmbedArrangeActive(True)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_STYLE, $newStyle)
AndroidEmbed(True, False, True)
EndIf
If BitAND($iAction, 1) Or BitAND($iAction, 4) > 0 Then
WinMove2($g_hAndroidWindow, "", $aPos[0], $aPos[1], -1, -1, $HWND_BOTTOM, 0, True)
EndIf
If $g_bAndroidShieldEnabled = True And $bDetachedShield = True Then
If BitAND($iAction, 1) > 0 Or BitAND($iAction, 4) > 0 Then
If BitAND($iAction, 4) > 0 Then
WinMove2($g_hFrmBotEmbeddedShield, "", $aPosShield[0], $aPosShield[1], $aPosCtl[2], $aPosCtl[3], 0, 0, False)
If $g_hFrmBotEmbeddedGraphics Then
WinMove2($g_hFrmBotEmbeddedGraphics, "", $aPosShield[0], $aPosShield[1], $aPosCtl[2], $aPosCtl[3], 0, 0, False)
EndIf
EndIf
CheckBotZOrder()
EndIf
EndIf
Return True
EndIf
Local $iZorder = 0
If $g_bAndroidShieldEnabled = True And $bDetachedShield = True And $bHasFocus = False Then
If CheckBotZOrder(True) Then
$iZorder = 1
EndIf
EndIf
Local $style = _WinAPI_GetWindowLong($g_hAndroidWindow, $GWL_STYLE)
If BitAND($style, $WS_DISABLED) > 0 Then $newStyle = BitOR($newStyle, $WS_DISABLED)
If BitAND($style, $WS_MAXIMIZEBOX) > 0 Then $newStyle = BitOR($newStyle, $WS_MAXIMIZEBOX)
Local $iStyle =(($style <> $newStyle) ? 2 : 0)
If $iStyle > 0 Then
SetDebugLog("AndroidEmbedCheck: Android Window GWL_STYLE changed: " & Get_GWL_STYLE_Text($newStyle) & " to " & Get_GWL_STYLE_Text($style), Default, True)
EndIf
Local $a1[2] = [$aPos[0], $aPos[1]]
Local $a2 = $aPos
Switch $g_iAndroidEmbedMode
Case 0
Local $a1 = ControlGetPos($g_hFrmBot, "", $g_hAndroidWindow)
Case 1
Local $a1 = WinGetPos($g_hAndroidWindow)
EndSwitch
Local $iPos =((IsArray($a1) And($a1[0] <> $a2[0] Or $a1[1] <> $a2[1])) ? 4 : 0)
If $iPos > 0 Then
SetDebugLog("AndroidEmbedCheck: Android Window Position changed: X: " & $a1[0] & " <> " & $a2[0] & ", Y: " & $a1[1] & " <> " & $a2[1], Default, True)
EndIf
If $iPos = 0 And $bDetachedShield = True Then
$a1 = WinGetPos($g_hFrmBotEmbeddedShield)
$a2 = $aPosShield
$iPos =((IsArray($a1) And($a1[0] <> $a2[0] Or $a1[1] <> $a2[1])) ? 4 : 0)
If $iPos > 0 Then
SetDebugLog("AndroidEmbedCheck: Android Shield Position changed: X: " & $a1[0] & " <> " & $a2[0] & ", Y: " & $a1[1] & " <> " & $a2[1], Default, True)
EndIf
EndIf
Return BitOR($iZorder, $iStyle, $iPos)
EndIf
Return 0
EndFunc
Func AndroidEmbedded()
Return $g_bAndroidEmbedded
EndFunc
Func AndroidEmbedArrangeActive($bActive = Default)
If $bActive = Default Then Return $g_hProcShieldInput[3]
Local $bWasActive = $g_hProcShieldInput[3]
$g_hProcShieldInput[3] = $bActive
Return $bWasActive
EndFunc
Func AndroidShieldStartup()
_OnAutoItErrorRegister()
EndFunc
Func AndroidShieldDestroy()
_OnAutoItErrorUnRegister()
EndFunc
Func AndroidShieldForceDown($bForceDown = True, $AndroidHasFocus = False)
Local $wasDown = $g_bAndroidShieldForceDown
$g_bAndroidShieldForceDown = $bForceDown
AndroidShield("AndroidShieldForceDown", Default, True, 0, $AndroidHasFocus)
Return $wasDown
EndFunc
Func AndroidShieldForcedDown()
Return $g_bAndroidShieldForceDown
EndFunc
Func AndroidShieldHasFocus()
Return $g_hProcShieldInput[2] = True
EndFunc
Func AndroidShielded()
Return $g_avAndroidShieldStatus[0] = True
EndFunc
Func AndroidShieldActiveDelay($bIsStillWaiting = False)
Return $g_avAndroidShieldDelay[0] <> 0 And $g_avAndroidShieldDelay[1] > 0 And($bIsStillWaiting = False Or __TimerDiff($g_avAndroidShieldDelay[0]) < $g_avAndroidShieldDelay[1])
EndFunc
Func AndroidShieldCheck()
If AndroidShieldActiveDelay(True) = True Then Return False
Return AndroidShield("AndroidShieldCheck")
EndFunc
Func AndroidShieldLock($Lock = Default)
If $Lock = Default Then Return $g_hProcShieldInput[3]
Local $wasLock = $g_hProcShieldInput[3]
$g_hProcShieldInput[3] = $Lock
Return $wasLock
EndFunc
Func AndroidShield($sCaller, $Enable = Default, $CallWinGetAndroidHandle = True, $iDelay = 0, $AndroidHasFocus = Default, $AndroidUpdateFocus = True)
If $g_bAndroidShieldEnabled = False Or $g_hProcShieldInput[3] = True Then Return False
If $iDelay > 0 Then
Return _AndroidShield($sCaller, $Enable, $CallWinGetAndroidHandle, $iDelay, $AndroidHasFocus, $AndroidUpdateFocus)
EndIf
Return _AndroidShield($sCaller, $Enable, $CallWinGetAndroidHandle, $iDelay, $AndroidHasFocus, $AndroidUpdateFocus)
EndFunc
Func _AndroidShield($sCaller, $Enable = Default, $CallWinGetAndroidHandle = True, $iDelay = 0, $AndroidHasFocus = Default, $AndroidUpdateFocus = True)
Local $bForceUpdate = False
If AndroidShieldActiveDelay() Then
If AndroidShieldActiveDelay(True) = False Then
If $Enable = Default Then $Enable = $g_avAndroidShieldDelay[2]
If $AndroidHasFocus = Default Then $AndroidHasFocus = $g_avAndroidShieldDelay[3]
Else
If $iDelay = 0 Then
If $Enable <> Default Then $g_avAndroidShieldDelay[2] = $Enable
If $AndroidHasFocus <> Default Then $g_avAndroidShieldDelay[3] = $AndroidHasFocus
Return False
EndIf
EndIf
EndIf
If $iDelay > 0 Then
$g_avAndroidShieldDelay[0] = __TimerInit()
$g_avAndroidShieldDelay[1] = $iDelay
$g_avAndroidShieldDelay[2] = $Enable
$g_avAndroidShieldDelay[3] = $AndroidHasFocus
Return False
EndIf
$g_avAndroidShieldDelay[0] = 0
$g_avAndroidShieldDelay[1] = 0
$g_avAndroidShieldDelay[2] = Default
$g_avAndroidShieldDelay[3] = Default
If $Enable = Default Then
$Enable = $g_bRunState And $g_bBotPaused = False
If $g_bAndroidShieldForceDown Then $Enable = False
EndIf
If $AndroidHasFocus = Default Then
$AndroidHasFocus = AndroidShieldHasFocus()
Else
If $AndroidUpdateFocus Then $g_hProcShieldInput[2] = $AndroidHasFocus
EndIf
Local $shieldState = "active"
Local $color = $g_iAndroidShieldColor
Local $trans = $g_iAndroidShieldTransparency
If $Enable = False Or $g_bBotPaused = True Then
If _WinAPI_GetActiveWindow() = $g_hFrmBot And $AndroidHasFocus Then
$shieldState = "disabled-focus"
$color = $g_iAndroidActiveColor
$trans = $g_iAndroidActiveTransparency
SetAccelerators(True)
Else
$shieldState = "disabled-nofocus"
$color = $g_iAndroidInactiveColor
$trans = $g_iAndroidInactiveTransparency
SetAccelerators(False)
EndIf
Else
SetAccelerators(False)
EndIf
Local $bNoVisibleShield = $g_bChkBackgroundMode = False
Local $bDetachedShield = $bNoVisibleShield = False And($g_bAndroidShieldPreWin8 = True Or $g_iAndroidEmbedMode = 1)
Local $bCreateShield = Not($bNoVisibleShield And($g_bAndroidShieldPreWin8 = True Or $g_iAndroidEmbedMode = 1))
If $g_bAndroidEmbedded = False Then
Return False
EndIf
If $g_bAndroidBackgroundLaunched = True Then
Return False
EndIf
If $bForceUpdate = False And $g_avAndroidShieldStatus[0] = $Enable And $g_avAndroidShieldStatus[1] = $color And $g_avAndroidShieldStatus[2] = $trans And $g_avAndroidShieldStatus[3] = $bNoVisibleShield And $g_avAndroidShieldStatus[4] = $bDetachedShield Then
Return False
EndIf
If($CallWinGetAndroidHandle = False And $g_hAndroidWindow = 0) Or($CallWinGetAndroidHandle = True And WinGetAndroidHandle() = 0) Then
Return False
EndIf
Local $aPos = WinGetPos($g_hAndroidWindow)
If IsArray($aPos) = 0 Or @error <> 0 Then
Return False
EndIf
Local $hCtrlTarget = $g_aiAndroidEmbeddedCtrlTarget[0]
Local $aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
If $g_hFrmBotEmbeddedShield <> 0 And($g_avAndroidShieldStatus[3] <> $bNoVisibleShield Or $g_avAndroidShieldStatus[4] <> $bDetachedShield) Then
GUIDelete($g_hFrmBotEmbeddedShield)
$g_hFrmBotEmbeddedShield = 0
EndIf
$g_hProcShieldInput[3] = True
Local $show_shield = @SW_SHOWNOACTIVATE
If $bCreateShield And($Enable <> $g_avAndroidShieldStatus[0] Or $g_hFrmBotEmbeddedShield = 0) Then
If $bDetachedShield = False Then
If $g_hFrmBotEmbeddedShield = 0 Then
$g_hFrmBotEmbeddedShield = GUICreate("", $aPosCtl[2], $aPosCtl[3], 0, 0, BitOR($WS_CHILD, $WS_TABSTOP),($bNoVisibleShield ? $WS_EX_TRANSPARENT : 0), $g_hFrmBot)
Else
WinMove($g_hFrmBotEmbeddedShield, "", 0, 0, $aPosCtl[2], $aPosCtl[3])
EndIf
WinMove2($hCtrlTarget, "", -1, -1, -1, -1, $HWND_BOTTOM)
Else
Local $bHasFocus = WinActive($g_hFrmBot) <> 0
Local $a = AndroidEmbed_HWnD_Position(True, $bDetachedShield)
If $g_hFrmBotEmbeddedShield = 0 Then
$g_hFrmBotEmbeddedShield = GUICreate("", $aPosCtl[2], $aPosCtl[3], $a[0], $a[1], BitOR($WS_POPUP, $WS_TABSTOP), BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE, $WS_EX_TRANSPARENT), $g_hFrmBot)
_WinAPI_EnableWindow($g_hFrmBotEmbeddedShield, False)
GUISetOnEvent($GUI_EVENT_PRIMARYDOWN, "BotMoveRequest")
$g_hFrmBotEmbeddedMouse = GUICreate("", $aPosCtl[2], $aPosCtl[3], 0, 0, BitOR($WS_CHILD, $WS_TABSTOP), $WS_EX_TRANSPARENT, $g_hFrmBot)
EndIf
If $g_bBotDockedShrinked And Not $bHasFocus Then WinMove2($g_hFrmBotButtons, "", -1, -1, -1, -1, $HWND_BOTTOM, 0, False)
WinMove2($g_hFrmBotEmbeddedShield, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3],($bHasFocus ? -1 : $HWND_BOTTOM), 0, False)
WinMove2($g_hFrmBotEmbeddedMouse, "", 0, 0, $aPosCtl[2], $aPosCtl[3],($bHasFocus ? -1 : $HWND_BOTTOM), 0, False)
WinMove2($hCtrlTarget, "", -1, -1, -1, -1, $HWND_BOTTOM)
SetDebugLog("$g_hFrmBotEmbeddedShield Position: " & $a[0] & ", " & $a[1] & ", " & $aPosCtl[2] & ", " & $aPosCtl[3], Default, True)
EndIf
EndIf
If $bNoVisibleShield = False Then
WinSetTrans($g_hFrmBotEmbeddedShield, "", $trans)
GUISetBkColor($color, $g_hFrmBotEmbeddedShield)
EndIf
GUISetState($show_shield, $g_hFrmBotEmbeddedShield)
GUISetState($show_shield, $g_hFrmBotEmbeddedMouse)
If $g_bBotDockedShrinked Then GUISetState($show_shield, $g_hFrmBotButtons)
$g_hProcShieldInput[3] = False
$g_avAndroidShieldStatus[0] = $Enable
$g_avAndroidShieldStatus[1] = $color
$g_avAndroidShieldStatus[2] = $trans
$g_avAndroidShieldStatus[3] = $bNoVisibleShield
$g_avAndroidShieldStatus[4] = $bDetachedShield
AndroidShieldStartup()
HandleWndProc($shieldState = "disabled-focus")
CheckBotZOrder()
SetDebugLog("AndroidShield updated to " & $shieldState & "(handle=" & $g_hFrmBotEmbeddedShield & ", color=" & Hex($color, 6) & "), caller: " & $sCaller, Default, True)
Return True
EndFunc
Func AndroidGraphicsGdiBegin()
If $g_bAndroidEmbedded = False Then Return 0
AndroidGraphicsGdiEnd()
Local $wasDown = AndroidShieldForcedDown()
AndroidShieldForceDown(False)
AndroidShield("AndroidGraphicsGdiBegin", True, True, 0, False)
Local $iL = 0
Local $iT = 0
Local $iW = $g_iAndroidClientWidth
Local $iH = $g_iAndroidClientHeight
Local $iOpacity = 255
Local $aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
If IsArray($aPosCtl) = 1 Then
$iW = $aPosCtl[2]
$iH = $aPosCtl[3]
EndIf
Local $a = [0, 0]
If $g_hFrmBotEmbeddedGraphics = 0 Then
Local $bDetachedShield = $g_avAndroidShieldStatus[4]
If $bDetachedShield = True Then
Local $a = AndroidEmbed_HWnD_Position(True, $bDetachedShield)
$iL = $a[0]
$iT = $a[1]
EndIf
$g_hFrmBotEmbeddedGraphics = GUICreate("", $iW, $iH, $iL, $iT, $WS_CHILD, BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE, $WS_EX_LAYERED, $WS_EX_TOPMOST), $g_hFrmBot)
EndIf
WinMove2($g_hFrmBotEmbeddedGraphics, "", $iW, $iH, $iL, $iT, $HWND_NOTOPMOST, 0, False)
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotEmbeddedGraphics)
Local $hDC = _WinAPI_GetDC($g_hFrmBotEmbeddedGraphics)
Local $hMDC = AndroidGraphicsGdiAddObject("hMDC", _WinAPI_CreateCompatibleDC($hDC))
Local $hBitmap = AndroidGraphicsGdiAddObject("hBitmap", _WinAPI_CreateCompatibleBitmap($hDC, $iW, $iH))
_WinAPI_SelectObject($hMDC, $hBitmap)
AndroidGraphicsGdiAddObject("hDC", $hDC)
Local $hGraphics = AndroidGraphicsGdiAddObject("Graphics", _GDIPlus_GraphicsCreateFromHDC($hMDC))
_GDIPlus_GraphicsSetSmoothingMode($hGraphics, $GDIP_SMOOTHINGMODE_HIGHQUALITY)
_GDIPlus_GraphicsClear($hGraphics)
Local $tSIZE = DllStructCreate($tagSIZE)
AndroidGraphicsGdiAddObject("DllStruct", $tSIZE)
Local $pSize = DllStructGetPtr($tSIZE)
DllStructSetData($tSIZE, "X", $iW)
DllStructSetData($tSIZE, "Y", $iH)
Local $tSource = DllStructCreate($tagPOINT)
AndroidGraphicsGdiAddObject("DllStruct", $tSource)
Local $pSource = DllStructGetPtr($tSource)
Local $tBlend = DllStructCreate($tagBLENDFUNCTION)
AndroidGraphicsGdiAddObject("DllStruct", $tBlend)
Local $pBlend = DllStructGetPtr($tBlend)
DllStructSetData($tBlend, "Alpha", $iOpacity)
DllStructSetData($tBlend, "Format", 1)
Local $tPoint = DllStructCreate($tagPOINT)
AndroidGraphicsGdiAddObject("DllStruct", $tPoint)
Local $pPoint = DllStructGetPtr($tPoint)
DllStructSetData($tPoint, "X", $a[0])
DllStructSetData($tPoint, "Y", $a[1])
AndroidGraphicsGdiUpdate()
SetDebugLog("AndroidGraphicsGdiBegin: Graphics " & $hGraphics)
AndroidShieldForceDown($wasDown)
Return $hGraphics
EndFunc
Func AndroidGraphicsGdiUpdate()
If $g_bAndroidEmbedded = False Then Return 0
Local $hMDC = $g_aiAndroidEmbeddedGraphics[0][1]
Local $hDC = $g_aiAndroidEmbeddedGraphics[2][1]
Local $pSize = DllStructGetPtr($g_aiAndroidEmbeddedGraphics[4][1])
Local $pSource = DllStructGetPtr($g_aiAndroidEmbeddedGraphics[5][1])
Local $pBlend = DllStructGetPtr($g_aiAndroidEmbeddedGraphics[6][1])
Local $pPoint = DllStructGetPtr($g_aiAndroidEmbeddedGraphics[7][1])
Local $tPoint = DllStructCreate($tagPOINT, $pPoint)
Local $bDetachedShield = $g_avAndroidShieldStatus[4]
Local $a = AndroidEmbed_HWnD_Position(True, $bDetachedShield)
DllStructSetData($tPoint, "X", $a[0])
DllStructSetData($tPoint, "Y", $a[1])
_WinAPI_UpdateLayeredWindow($g_hFrmBotEmbeddedGraphics, $hDC, $pPoint, $pSize, $hMDC, $pSource, 0, $pBlend, $ULW_ALPHA)
EndFunc
Func AndroidGraphicsGdiAddObject($sType, $hHandle)
If $g_bAndroidEmbedded = False Then Return 0
Local $i = UBound($g_aiAndroidEmbeddedGraphics)
ReDim $g_aiAndroidEmbeddedGraphics[$i + 1][2]
$g_aiAndroidEmbeddedGraphics[$i][0] = $sType
$g_aiAndroidEmbeddedGraphics[$i][1] = $hHandle
SetDebugLog("AndroidGraphicsGdiAddObject: " & $sType & " " & $hHandle)
Return $hHandle
EndFunc
Func AndroidGraphicsGdiEnd($Result = Default, $bClear = True)
If UBound($g_aiAndroidEmbeddedGraphics) > 0 Then
Local $i
For $i = UBound($g_aiAndroidEmbeddedGraphics) - 1 To 0 Step -1
Local $sType = $g_aiAndroidEmbeddedGraphics[$i][0]
Local $hHandle = $g_aiAndroidEmbeddedGraphics[$i][1]
If $hHandle <> 0 Then
SetDebugLog("AndroidGraphicsGdiEnd: Dispose/release/delete " & $sType & " " & $hHandle)
Switch $sType
Case "Pen"
_GDIPlus_PenDispose($hHandle)
Case "DllStruct"
Case "Graphics"
_GDIPlus_GraphicsClear($hHandle)
AndroidGraphicsGdiUpdate()
_GDIPlus_GraphicsDispose($hHandle)
Case "hDC"
_WinAPI_ReleaseDC($g_hFrmBotEmbeddedGraphics, $hHandle)
Case "hBitmap"
_WinAPI_DeleteObject($hHandle)
Case "hMDC"
_WinAPI_DeleteDC($hHandle)
Case Else
SetDebugLog("Unknown GDI Type: " & $sType)
EndSwitch
EndIf
Next
ReDim $g_aiAndroidEmbeddedGraphics[0][2]
If $g_hFrmBotEmbeddedGraphics <> 0 Then
GUIDelete($g_hFrmBotEmbeddedGraphics)
$g_hFrmBotEmbeddedGraphics = 0
EndIf
EndIf
Return $Result
EndFunc
Func AndroidDpiAwareness($bCheckAwareness = Default)
If $bCheckAwareness = Default Then $bCheckAwareness = False
If $g_hAndroidWindowDpiAware = $g_hAndroidWindow Or GetProcessDpiAwareness(GetAndroidPid()) Then
$g_hAndroidWindowDpiAware = $g_hAndroidWindow
If $bCheckAwareness = True Then Return True
Return False
EndIf
If CheckDpiAwareness(True) = True Then
If $g_hAndroidWindowDpiAware <> $g_hAndroidWindow Then
Local $bWasEmbedded = AndroidEmbedded()
AndroidEmbed(True, False, False, True)
AndroidEmbed(False, False, False, True)
Return True
EndIf
EndIf
Return False
EndFunc
Func WerFaultClose($programFile, $tryCountMax = 10, $tryCount = 0)
Local $WinTitleMatchMode = Opt("WinTitleMatchMode", -3)
Local $sTitle = $programFile
Local $iLastBS = StringInStr($sTitle, "\", 0, -1)
If $iLastBS > 0 Then $sTitle = StringMid($sTitle, $iLastBS + 1)
Local $aList = WinList($sTitle)
Opt("WinTitleMatchMode", $WinTitleMatchMode)
Local $closed = 0
Local $i
SetDebugLog("Found " & $aList[0][0] & " WerFault Windows with title '" & $sTitle & "'")
If $aList[0][0] > 0 Then
For $i = 1 To $aList[0][0]
Local $HWnD = $aList[$i][1]
Local $pid = WinGetProcess($HWnD)
Local $process = ProcessGetWmiProcess($pid)
If IsArray($process) Then
Local $werfault = $process[1]
$iLastBS = StringInStr($werfault, "\", 0, -1)
$werfault = StringMid($werfault, $iLastBS + 1)
If $werfault = "WerFault.exe" Then
SetDebugLog("Found WerFault Process " & $pid)
If WinClose($HWnD) Then
SetDebugLog("Closed " & $werfault & " Window " & $HWnD)
$closed += 1
Else
If WinKill($HWnD) Then
SetDebugLog("Killed " & $werfault & " Window " & $HWnD)
$closed += 1
Else
SetDebugLog("Cannot close " & $werfault & " Window " & $HWnD, $COLOR_ERROR)
EndIf
EndIf
Else
SetDebugLog("Process " & $pid & " is not WerFault, " & $process[2], $COLOR_ERROR)
EndIf
ELse
SetDebugLog("Wmi Object for process " & $pid & " not found")
EndIF
Next
ElseIf FileExists($programFile) = 1 Then
Local $pFileVersionInfo
If _WinAPI_GetFileVersionInfo($programFile, $pFileVersionInfo) Then
Local $aFileDescription = _WinAPI_VerQueryValue($pFileVersionInfo, $FV_FILEDESCRIPTION)
If UBound($aFileDescription) > 1 And UBound($aFileDescription, 2) > 1 Then
Local $sFileDescription = $aFileDescription[1][1]
If $sFileDescription Then Return WerFaultClose($sFileDescription, $tryCountMax, $tryCount)
EndIf
EndIf
EndIf
If $closed > 0 And $tryCount < $tryCountMax Then
If _Sleep(1000) = False Then
$closed += WerFaultClose($programFile, $tryCountMax, $tryCount + 1)
EndIF
EndIf
Return $closed
EndFunc
Func _NumberFormat($Number, $NullToZero = False)
If $Number = "" Then
If $NullToZero = False Then
Return ""
Else
Return "0"
EndIf
EndIf
If StringLeft($Number, 1) = "-" Then
Return "- " & StringRegExpReplace(StringTrimLeft($Number, 1), "(\A\d{1,3}(?=(\d{3})+\z)|\d{3}(?=\d))", "\1 ")
Else
Return StringRegExpReplace($Number, "(\A\d{1,3}(?=(\d{3})+\z)|\d{3}(?=\d))", "\1 ")
EndIf
EndFunc
Func _PadStringCenter($String = "", $Width = 50, $PadChar = "=")
If $String = "" Then Return ""
Local $Odd = Mod(($Width - StringLen($String)), 2)
Local $Count =($Width - StringLen($String)) / 2
Local $Pad = ""
For $i = 0 To $Count - 1
$Pad &= $PadChar
Next
Local $Out = ""
If $Odd Then
$Out = $Pad & $String & $Pad & $PadChar
Else
$Out = $Pad & $String & $Pad
EndIf
Return $Out
EndFunc
Func _ProcessSuspendResume($iPIDorName, $iSuspend = True)
If IsString($iPIDorName) Then $iPIDorName = ProcessExists($iPIDorName)
If Not $iPIDorName Then Return SetError(2, 0, 0)
Local $ai_Handle = _WinAPI_OpenProcess($PROCESS_ALL_ACCESS, False, $iPIDorName)
Local $i_sucess = DllCall("ntdll.dll", "int", "Nt" &($iSuspend ? "Suspend" : "Resume") & "Process", "int", $ai_Handle)
_WinAPI_CloseHandle($ai_Handle)
If IsArray($i_sucess) Then Return 1
Return SetError(1, 0, 0)
EndFunc
Func _ProcessSuspendResume2($iPIDorName, $iSuspend = True)
If IsString($iPIDorName) Then $iPIDorName = ProcessExists($iPIDorName)
If Not $iPIDorName Then Return SetError(2, 0, 0)
If $iSuspend Then
DllCall('kernel32.dll', 'ptr', 'DebugActiveProcess', 'int', $iPIDorName)
DllCall('kernel32.dll', 'ptr', 'DebugSetProcessKillOnExit', 'int', False)
Else
DllCall('kernel32.dll', 'ptr', 'DebugActiveProcessStop', 'int', $iPIDorName)
EndIf
EndFunc
Func _Sleep($iDelay, $iSleep = True, $CheckRunState = True, $SleepWhenPaused = True)
Static $hTimer_SetTime = 0
Static $hTimer_PBRemoteControlInterval = 0
Static $hTimer_PBDeleteOldPushesInterval = 0
Static $hTimer_EmptyWorkingSetAndroid = 0
Static $hTimer_EmptyWorkingSetBot = 0
Static $b_Sleep_Active = False
Local $iBegin = __TimerInit()
If $b_Sleep_Active = True Then
EndIf
$b_Sleep_Active = True
debugGdiHandle("_Sleep")
CheckBotRequests()
If SetCriticalMessageProcessing() = False Then
If $g_bMoveDivider Then
MoveDivider()
$g_bMoveDivider = False
EndIf
If $iDelay > 0 And __TimerDiff($g_hTxtLogTimer) >= $g_iTxtLogTimerTimeout Then
If $g_bNotifyDeleteAllPushesNow = True Then PushMsg("DeleteAllPBMessages")
If __TimerDiff($hTimer_PBRemoteControlInterval) >= $g_iPBRemoteControlInterval Or($hTimer_PBRemoteControlInterval = 0 And $g_bNotifyRemoteEnable) Then
NotifyRemoteControl()
$hTimer_PBRemoteControlInterval = __TimerInit()
EndIf
If __TimerDiff($hTimer_PBDeleteOldPushesInterval) >= $g_iPBDeleteOldPushesInterval Or($hTimer_PBDeleteOldPushesInterval = 0 And $g_bNotifyDeletePushesOlderThan) Then
PushBulletDeleteOldPushes()
$hTimer_PBDeleteOldPushesInterval = __TimerInit()
EndIf
If(($g_iEmptyWorkingSetAndroid > 0 And __TimerDiff($hTimer_EmptyWorkingSetAndroid) >= $g_iEmptyWorkingSetAndroid * 1000) Or $hTimer_EmptyWorkingSetAndroid = 0) And $g_bRunState And TestCapture() = False Then
If IsArray(getAndroidPos(True)) = 1 Then _WinAPI_EmptyWorkingSet(GetAndroidPid())
$hTimer_EmptyWorkingSetAndroid = __TimerInit()
EndIf
If($g_iEmptyWorkingSetBot > 0 And __TimerDiff($hTimer_EmptyWorkingSetBot) >= $g_iEmptyWorkingSetBot * 1000) Or $hTimer_EmptyWorkingSetBot = 0 Then
ReduceBotMemory(False)
$hTimer_EmptyWorkingSetBot = __TimerInit()
EndIf
CheckPostponedLog()
If BotCloseRequestProcessed() Then
BotClose()
$b_Sleep_Active = False
Return True
EndIf
EndIf
EndIf
If $CheckRunState And Not $g_bRunState Then
ResumeAndroid()
$b_Sleep_Active = False
Return True
EndIf
Local $iRemaining = $iDelay - __TimerDiff($iBegin)
While $iRemaining > 0
DllCall($g_hLibNTDLL, "dword", "ZwYieldExecution")
If $CheckRunState = True And $g_bRunState = False Then
ResumeAndroid()
$b_Sleep_Active = False
Return True
EndIf
If SetCriticalMessageProcessing() = False Then
If $g_bBotPaused And $SleepWhenPaused And $g_bTogglePauseAllowed Then TogglePauseSleep()
If $g_bTogglePauseUpdateState Then TogglePauseUpdateState("_Sleep")
If $g_bMakeScreenshotNow = True Then
If $g_bScreenshotPNGFormat = False Then
MakeScreenshot($g_sProfileTempPath, "jpg")
Else
MakeScreenshot($g_sProfileTempPath, "png")
EndIf
EndIf
If __TimerDiff($g_hTxtLogTimer) >= $g_iTxtLogTimerTimeout Then
If $g_bRunState And Not $g_bSearchMode And Not $g_bBotPaused And($hTimer_SetTime = 0 Or __TimerDiff($hTimer_SetTime) >= 750) Then
SetTime()
$hTimer_SetTime = __TimerInit()
EndIf
AndroidEmbedCheck()
AndroidShieldCheck()
CheckPostponedLog()
EndIf
EndIf
$iRemaining = $iDelay - __TimerDiff($iBegin)
If $iRemaining >= $DELAYSLEEP Then
_SleepMilli($DELAYSLEEP)
Else
_SleepMilli($iRemaining)
EndIf
CheckBotRequests()
WEnd
$b_Sleep_Active = False
Return False
EndFunc
Func _SleepMicro($iMicroSec)
DllStructSetData($g_hStruct_SleepMicro, "time", $iMicroSec * -10)
DllCall($g_hLibNTDLL, "dword", "ZwDelayExecution", "int", 0, "ptr", $g_pStruct_SleepMicro)
EndFunc
Func _SleepMilli($iMilliSec)
_SleepMicro(Int($iMilliSec * 1000))
EndFunc
Func _SleepStatus($iDelay, $iSleep = True, $bDirection = True, $CheckRunState = True, $iBeginTimer = __TimerInit())
Local $iDay = 0, $iHour = 0, $iMin = 0, $iSec = 0
Local $iCurTime, $iTime
Local $bUpdate = True, $hLastUpdate
Local $iDayCalc = 0, $iHourCalc = 0, $iMinCalc = 0, $iSecCalc = 0
Local $sTimeWait, $sTimeLeftLapse = ",  Time Lapse = "
_TicksToDay($iDelay, $iDay, $iHour, $iMin, $iSec)
While __TimerDiff($iBeginTimer) < $iDelay
If $g_bRunState = False And $CheckRunState = True Then Return True
If $bUpdate Then
$iCurTime = __TimerDiff($iBeginTimer)
$iTime = $iCurTime
If $bDirection = True Then
$iTime = $iDelay - $iCurTime
$sTimeLeftLapse = ",  Time Left = "
EndIf
_TicksToDay($iTime, $iDayCalc, $iHourCalc, $iMinCalc, $iSecCalc)
$sTimeWait = "Waiting Time = "
Select
Case $iDay > 0
$sTimeWait &= StringFormat("%2u Day(s) ", $iDay)
$sTimeLeftLapse &= StringFormat("%2u Day(s) ", $iDayCalc)
ContinueCase
Case $iHour > 0
$sTimeWait &= StringFormat("%02u:", $iHour)
$sTimeLeftLapse &= StringFormat("%02u:", $iHourCalc)
ContinueCase
Case Else
$sTimeWait &= StringFormat("%02u:%02u", $iMin, $iSec)
$sTimeLeftLapse &= StringFormat("%02u:%02u", $iMinCalc, $iSecCalc)
EndSelect
$hLastUpdate = __TimerInit()
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, " Status: " & $sTimeWait & $sTimeLeftLapse)
EndIf
_Sleep($DELAYSLEEP)
$bUpdate = __TimerDiff($hLastUpdate) > 750
WEnd
If $g_bRunState = False And $CheckRunState = True Then Return True
Return False
EndFunc
Func _StatusUpdateTime($hTimer, $sWhyWait = "")
Local $iCurTime = __TimerDiff($hTimer)
Local $iMinCalc = Int($iCurTime /(60 * 1000))
Local $iSecCalc = Int(($iCurTime -($iMinCalc * 60 * 1000)) / 1000)
Local $sString = $sWhyWait & " Wait Time = " & StringFormat("%02u" & ":" & "%02u", $iMinCalc, $iSecCalc)
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, " Status: " & $sString)
EndFunc
Func _TicksToDay($iTicks, ByRef $iDays, ByRef $iHours, ByRef $iMins, ByRef $iSecs)
_TicksToTime($iTicks, $iHours, $iMins, $iSecs)
If @error Then Return SetError(1, 0, 0)
$iDays = Int($iHours / 24)
$iHours = Mod($iHours, 24)
Return 1
EndFunc
Func Click($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $g_bDebugClick Or TestCapture() Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("Click " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ACTION, "Verdana", "7.5", 0)
EndIf
If TestCapture() Then Return
If $g_bAndroidAdbClick = True Then
AndroidClick($x, $y, $times, $speed)
EndIf
If $g_bAndroidAdbClick = True Then
Return
EndIf
Local $SuspendMode = ResumeAndroid()
If $times <> 1 Then
For $i = 0 To($times - 1)
If isProblemAffectBeforeClick($i) Then
If $g_bDebugClick Then SetLog("VOIDED Click " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
If isProblemAffectBeforeClick() Then
If $g_bDebugClick Then SetLog("VOIDED Click " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func _ControlClick($x, $y)
Local $useHWnD = $g_iAndroidControlClickWindow = 1 And $g_bAndroidEmbedded = False
Local $hWin =(($useHWnD) ?($g_hAndroidWindow) :($g_hAndroidControl))
$x = Int($x) + $g_aiMouseOffset[0]
$y = Int($y) + $g_aiMouseOffset[1]
If $g_bAndroidEmbedded = False Then
$x += $g_aiMouseOffsetWindowOnly[0]
$y += $g_aiMouseOffsetWindowOnly[1]
EndIf
If $hWin = $g_hAndroidWindow Then
$x += $g_aiBSrpos[0]
$y += $g_aiBSrpos[1]
EndIf
If $g_iAndroidControlClickMode = 0 Then
Opt("MouseClickDelay", $g_iAndroidControlClickDelay)
Opt("MouseClickDownDelay", $g_iAndroidControlClickDownDelay)
Return ControlClick($hWin, "", "", "left", "1", $x, $y)
EndIf
Local $WM_LBUTTONDOWN = 0x0201, $WM_LBUTTONUP = 0x0202
Local $lParam = BitOR(Int($y) * 0x10000, BitAND(Int($x), 0xFFFF))
_SendMessage($hWin, $WM_LBUTTONDOWN, 0x0001, $lParam)
_SleepMicro($g_iAndroidControlClickDownDelay * 1000)
_SendMessage($hWin, $WM_LBUTTONUP, 0x0000, $lParam)
_SleepMicro($g_iAndroidControlClickDelay * 1000)
Return 1
EndFunc
Func isProblemAffectBeforeClick($iCount = 0)
If NeedCaptureRegion($iCount) = True Then Return isProblemAffect(True)
Return False
EndFunc
Func ClickP($point, $howMuch = 1, $speed = 0, $debugtxt = "")
Click($point[0], $point[1], $howMuch, $speed, $debugtxt)
EndFunc
Func BuildingClick($x, $y, $debugtxt = "")
Local $point[2] = [$x, $y]
ConvertToVillagePos($x, $y)
If $g_bDebugClick Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("BuildingClick " & $point[0] & "," & $point[1] & " converted to " & $x & "," & $y & " " & $debugtxt & $txt, $COLOR_ACTION)
EndIf
Return Click($x, $y, 1, 0, $debugtxt)
EndFunc
Func BuildingClickP($point, $debugtxt = "")
Local $x = $point[0]
Local $y = $point[1]
Return BuildingClick($x, $y, $debugtxt)
EndFunc
Func PureClick($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $g_bDebugClick Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("PureClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ACTION, "Verdana", "7.5", 0)
EndIf
If TestCapture() Then Return
If $g_bAndroidAdbClick = True Then
AndroidClick($x, $y, $times, $speed, False)
EndIf
If $g_bAndroidAdbClick = True Then
Return
EndIf
Local $SuspendMode = ResumeAndroid()
If $times <> 1 Then
For $i = 0 To($times - 1)
MoveMouseOutBS()
_ControlClick($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
MoveMouseOutBS()
_ControlClick($x, $y)
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func PureClickP($point, $howMuch = 1, $speed = 0, $debugtxt = "")
PureClick($point[0], $point[1], $howMuch, $speed, $debugtxt)
EndFunc
Func GemClick($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $g_bDebugClick Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("GemClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ACTION, "Verdana", "7.5", 0)
EndIf
If TestCapture() Then Return
If $g_bAndroidAdbClick = True Then
If isGemOpen(True) Then
Return False
EndIf
AndroidClick($x, $y, $times, $speed)
EndIf
If $g_bAndroidAdbClick = True Then
Return
EndIf
Local $SuspendMode = ResumeAndroid()
Local $i
If $times <> 1 Then
For $i = 0 To($times - 1)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If isProblemAffectBeforeClick($i) Then
If $g_bDebugClick Then SetLog("VOIDED GemClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If _Sleep($speed, False) Then ExitLoop
Next
Else
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If isProblemAffectBeforeClick() Then
If $g_bDebugClick Then SetLog("VOIDED GemClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func GemClickP($point, $howMuch = 1, $speed = 0, $debugtxt = "")
Return GemClick($point[0], $point[1], $howMuch, $speed, $debugtxt = "")
EndFunc
Func AttackClick($x, $y, $times = 1, $speed = 0, $afterDelay = 0, $debugtxt = "")
Local $timer = __TimerInit()
If $y > 555 + $g_iBottomOffsetY Then $y = 555 + $g_iBottomOffsetY
AttackRemainingTime(False)
Local $result = PureClick($x, $y, $times, $speed, $debugtxt)
Local $delay = $times * $speed + $afterDelay - __TimerDiff($timer)
If IsKeepClicksActive() = False And $delay > 0 Then _Sleep($delay, False)
Return $result
EndFunc
Func _DecodeDebug($message)
Local $separator = " | "
Switch $message
Case "#0112", "#0115", "#0140", "#0141", "#0142", "#0143", "#0199", "#0328", "#0201", "#0204", "#0205", "#0206", "#0327", "#0207", "#0208", "#0209", "#0210", "#0211"
Return $separator & "Away"
Case "#0214", "#0215", "#0216", "#0217", "#0218", "#0219", "#0220", "#0221", "#0235", "#0242", "#0268", "#0291", "#0292", "#0295", "#0298", "#0300", "#0301", "#0302"
Return $separator & "Away"
Case "#0303", "#0306", "#0308", "#0309", "#0310", "#0311", "#0312", "#0319", "#0333", "#0257", "#0139", "#0125", "#0251", "#0335", "#0313", "#0314", "#0332", "#0329"
Return $separator & "Away"
Case "#0121", "#0124", "#0133", "#0157", "#0161", "#0165", "#0166", "#0167", "#0170", "#0171", "#0176", "#0224", "#0234", "#0265", "#0346", "#0348", "#0350", "#0351"
Return $separator & "Away"
Case "#0352", "#0353", "#0354", "#0355", "#0356", "#0357", "#0358", "#0359", "#0360", "#0361", "#0362", "#0363", "#0364", "#0365", "#0366", "#0367", "#0368", "#0369"
Return $separator & "Away"
Case "#0370", "#0371", "#0373", "#0374", "#0375", "#0376", "#0377", "#0378", "#0379", "#0380", "#0381", "#0382", "#0383", "#0384", "#0385", "#0386", "#0387", "#0388"
Return $separator & "Away"
Case "#0389", "#0390", "#0391", "#0392", "#0393", "#0394", "#0395", "#0501", "#0502", "#0503", "#0504", "#0467", "#0505", "#0931", "#0932", "#0933"
Return $separator & "Away"
Case "#0001"
Return $separator & "AtkTH - Select Barbarian"
Case "#0002", "#0006"
Return $separator & "AtkTH - Barbarian Bottom Left"
Case "#0003", "#0007"
Return $separator & "AtkTH - Barbarian Bottom Right"
Case "#0004", "#0008"
Return $separator & "AtkTH - Barbarian Top Right"
Case "#0005", "#0009"
Return $separator & "AtkTH - Barbarian Top Left"
Case "#0010"
Return $separator & "AtkTH - Select Archer"
Case "#0011", "#0015"
Return $separator & "AtkTH - Arcer Bottom Left"
Case "#0012", "#0016"
Return $separator & "AtkTH - Arcer Bottom Right"
Case "#0013", "#0017"
Return $separator & "AtkTH - Arcer Top Right"
Case "#0014", "#0018"
Return $separator & "AtkTH - Arcer Top Left"
Case "#0155"
Return $separator & "Attack - Next Button"
Case "#0331"
Return $separator & "Collect resources"
Case "#0330"
Return $separator & "Collect resources*"
Case "#0432"
Return $separator & "Clean tombs*"
Case "#0431"
Return $separator & "Clean yard"
Case "#0430"
Return $separator & "Clean yard*"
Case "#0266"
Return $separator & "Train - TrainIT Selected Troop"
Case "#0269"
Return $separator & "Train - Open Barrack"
Case "#0270"
Return $separator & "Train - Train Troops button"
Case "#0271"
Return $separator & "Train - Next Button "
Case "#0272", "#0286", "#0289", "#0325"
Return $separator & "Train - Prev Button "
Case "#0273", "#0284", "#0285", "#0287", "#0288"
Return $separator & "Train - Remove Troops"
Case "#0274"
Return $separator & "Train - Train Barbarian"
Case "#0275"
Return $separator & "Train - Train Archer"
Case "#0276"
Return $separator & "Train - Train Giant"
Case "#0277"
Return $separator & "Train - Train Goblin"
Case "#0278"
Return $separator & "Train - Train Wall Breaker"
Case "#0279"
Return $separator & "Train - Train Balloon"
Case "#0280"
Return $separator & "Train - Train Wizard"
Case "#0281"
Return $separator & "Train - Train Healer"
Case "#0282"
Return $separator & "Train - Train Dragon"
Case "#0283"
Return $separator & "Train - Train P.E.K.K.A."
Case "#0290"
Return $separator & "Train - GemClick Spell"
Case "#0293"
Return $separator & "Train - Click Army Camp"
Case "#0294"
Return $separator & "Train - Open Info Army Camp"
Case "#0336"
Return $separator & "Train - Go to first barrack"
Case "#0337"
Return $separator & "Train - Click Prev Button*"
Case "#0338"
Return $separator & "Train - Click Next Button*"
Case "#0339"
Return $separator & "Train - Select Prev Barrack/SP"
Case "#0340"
Return $separator & "Train - Click Next Barrack/SP"
Case "#0341"
Return $separator & "Train - Train Bowler"
Case "#0342"
Return $separator & "Train - Train Baby Dragon"
Case "#0343"
Return $separator & "Train - Train Miner"
Case "#0168"
Return $separator & "Donate - Open Chat"
Case "#0169"
Return $separator & "Donate - Select Clan Tab"
Case "#0172"
Return $separator & "Donate - Scroll"
Case "#0173"
Return $separator & "Donate - Click Chat"
Case "#0174"
Return $separator & "Donate - Click Donate Button"
Case "#0175"
Return $separator & "Donate - Donate Selected Troop first row"
Case "#0600"
Return $separator & "Donate - Donate Selected Troop second row"
Case "#0601"
Return $separator & "Donate - Donate Selected Troop spell"
Case "#0144"
Return $separator & "ChkLang - Config Button"
Case "#0145", "#0146", "#0147", "#0148"
Return $separator & "ChkLang - Close Page"
Case "#0222"
Return $separator & "Profile - Profile Button"
Case "#0223"
Return $separator & "Profile - Close Page"
Case "#0225"
Return $separator & "Rearm - Click Town Hall"
Case "#0326", "#0228"
Return $separator & "Rearm - Click Rearm Button"
Case "#0226", "#0229"
Return $separator & "Rearm - Click Rearm"
Case "#0227", "#0230", "#0233"
Return $separator & "Rearm - Close Gem Spend Window"
Case "#0231"
Return $separator & "Rearm - Click Inferno Button"
Case "#0232"
Return $separator & "Rearm - Inferno Button"
Case "#0250"
Return $separator & "Request - Click Castle Clan"
Case "#0253"
Return $separator & "Request - Click Request Button"
Case "#0254", "#0255"
Return $separator & "Request - Click Select Text For Request"
Case "#0256"
Return $separator & "Request - Click Send Request"
Case "#0334"
Return $separator & "Request - Click Train Button"
Case "#0099"
Return $separator & "Return Home - End Battle"
Case "#0100"
Return $separator & "Return Home - Surrender, Confirm"
Case "#0101"
Return $separator & "Return Home - Return Home Button"
Case "#0396"
Return $separator & "Reach Limit - Return home, Press End Battle "
Case "#0468"
Return $separator & "Clan Level - Open Chat"
Case "#0469"
Return $separator & "Clan Level - Open Chat Clan Tab "
Case "#0470"
Return $separator & "Clan Level - Click Info Clan Button"
Case "#071", "#0472"
Return $separator & "Clan Level - Close Chat"
Case "#0473"
Return $separator & "Clan Level - Close Clan Info Page"
Case "#0149"
Return $separator & "Prepare Search - Press Attack Button"
Case "#0150"
Return $separator & "Prepare Search - Press Find a Match Button"
Case "#0030"
Return $separator & "Attack - press surrender"
Case "#0031"
Return $separator & "Attack - press confirm surrender"
Case "#0510"
Return $separator & "Attack Search - Open chat tab"
Case "#0511"
Return $separator & "Attack Search - close chat tab"
Case "#0512"
Return $separator & "Attack Search - Press retry search button"
Case "#0513"
Return $separator & "Attack Search - Return Home button"
Case "#0000"
Return $separator & " "
Case Else
Return ""
EndSwitch
EndFunc
Func SendText($sText)
Local $result = 1
Local $error = 0
If $g_bAndroidAdbInput = True Then
AndroidSendText($sText)
$error = @error
EndIf
If $g_bAndroidAdbInput = False Or $error <> 0 Then
Local $SuspendMode = ResumeAndroid()
Local $ascText = ""
Local $r, $i, $vk, $shiftBits, $char
Local $c = 0
For $i = 1 To StringLen($sText)
$char = StringMid($sText, $i, 1)
$vk = _VkKeyScan($char)
$shiftBits = @extended
If $vk = -1 And $shiftBits = -1 Then
SetDebugLog("SendText cannot send character: " & $char)
$c += 1
Else
If BitAND($shiftBits, 1) > 0 Then $ascText &= "{LSHIFT down}"
If BitAND($shiftBits, 2) > 0 Then $ascText &= "{LCTRL down}"
If BitAND($shiftBits, 4) > 0 Then $ascText &= "{LALT down}"
$ascText &= "{ASC " & _WinAPI_MapVirtualKey($vk, $MAPVK_VK_TO_CHAR) & "}"
If BitAND($shiftBits, 4) > 0 Then $ascText &= "{LALT up}"
If BitAND($shiftBits, 2) > 0 Then $ascText &= "{LCTRL up}"
If BitAND($shiftBits, 1) > 0 Then $ascText &= "{LSHIFT up}"
$r = ControlSend($g_hAndroidWindow, "", "", $ascText, 0)
$ascText = ""
If $r = 1 Then
$c += 1
EndIf
EndIf
Next
$result = 0
If $c = StringLen($sText) Then $result = 1
SuspendAndroid($SuspendMode)
EndIf
Return $result
EndFunc
Func _VkKeyScan($s_Char)
Local $a_Ret = DllCall("user32.dll", "short", "VkKeyScanW", "ushort", AscW($s_Char))
If @error Then Return SetError(@error, @extended, -1)
Return SetExtended(BitShift($a_Ret[0], 8), BitAND($a_Ret[0], 0xFF))
EndFunc
Func ClickOkay($FeatureName = "Okay", $bCheckOneTime = False)
Local $i = 0
If _Sleep($DELAYSPECIALCLICK1) Then Return False
While 1
Local $offColors[3][3] = [[0x000000, 144, 0], [0xFFFFFF, 54, 17], [0xCBE870, 54, 10]]
Local $ButtonPixel = _MultiPixelSearch(438, 372 + $g_iMidOffsetY, 590, 404 + $g_iMidOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $g_bDebugSetlog Then SetDebugLog($FeatureName & " btn chk-#1: " & _GetPixelColor(441, 374 + $g_iMidOffsetY, True) & ", #2: " & _GetPixelColor(441 + 144, 374 + $g_iMidOffsetY, True) & ", #3: " & _GetPixelColor(441 + 54, 374 + 17 + $g_iMidOffsetY, True) & ", #4: " & _GetPixelColor(441 + 54, 374 + 10 + $g_iMidOffsetY, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Then
SetDebugLog("ButtonPixelLocation = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetDebugLog("Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 144, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 17, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 10, True), $COLOR_DEBUG)
EndIf
PureClick($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 2, 50, "#0117")
ExitLoop
EndIf
If $bCheckOneTime Then Return False
If $i > 5 Then
SetLog("Can not find button for " & $FeatureName & ", giving up", $COLOR_ERROR)
If $g_bDebugImageSave Then DebugImageSave($FeatureName & "_ButtonCheck_")
SetError(1, @extended, False)
Return
EndIf
$i += 1
If _Sleep($DELAYSPECIALCLICK2) Then Return False
WEnd
Return True
EndFunc
Func ClickRemove($FeatureName = "Remove")
If _CheckPixel($aIsShieldInfo, $g_bCapturePixel) Then
Local $i = 0
While 1
Local $offColors[3][3] = [[0x1A1A1A, 108, 0], [0xFFFFFF, 64, 12], [0xE51115, 55, 20]]
Local $ButtonPixel = _MultiPixelSearch(474, 252, 587, 276, 1, 1, Hex(0x0D0D0D, 6), $offColors, 20)
If $g_bDebugSetlog Then SetDebugLog($FeatureName & " btn chk-#1: " & _GetPixelColor(476, 253, True) & ", #2: " & _GetPixelColor(476 + 108, 253, True) & ", #3: " & _GetPixelColor(476 + 64, 253 + 12, True) & ", #4: " & _GetPixelColor(476 + 55, 253 + 20, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Then
SetDebugLog("ButtonPixelLocation = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetDebugLog("Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 108, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 64, $ButtonPixel[1] + 12, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 55, $ButtonPixel[1] + 20, True), $COLOR_DEBUG)
EndIf
PureClick($ButtonPixel[0] + 55, $ButtonPixel[1] + 10, 1, 0)
ExitLoop
EndIf
If $i > 15 Then
SetLog("Can not find button for " & $FeatureName & ", giving up", $COLOR_ERROR)
If $g_bDebugImageSave Then DebugImageSave($FeatureName & "_ButtonCheck_")
SetError(1, @extended, False)
Return
EndIf
$i += 1
If _Sleep($DELAYSPECIALCLICK1) Then Return False
WEnd
Return True
Else
If $g_bDebugSetlog Then SetDebugLog($FeatureName & " remove button found", $COLOR_INFO)
Return False
EndIf
EndFunc
Func CreateLogFile()
If $g_hLogFile <> 0 Then
FileClose($g_hLogFile)
$g_hLogFile = 0
EndIf
Local $aOldLogs = _FileListToArray($g_sProfileLogsPath, @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & ".*.log", $FLTA_FILES)
If UBound($aOldLogs) < 2 Then
Local $aDate, $aTime, $YEAR, $MON, $MDAY, $HOUR
_DateTimeSplit(_DateAdd("h", -1, _NowCalc()), $aDate, $aTime)
$YEAR = StringFormat("%04d", $aDate[1])
$MON = StringFormat("%02d", $aDate[2])
$MDAY = StringFormat("%02d", $aDate[3])
$HOUR = StringFormat("%02d", $aTime[1])
$aOldLogs = _FileListToArray($g_sProfileLogsPath, $YEAR & "-" & $MON & "-" & $MDAY & "_" & $HOUR & ".*.log", $FLTA_FILES)
EndIf
Local $sLogPath
If UBound($aOldLogs) > 1 Then
_ArraySort($aOldLogs, 1, 1, 0)
$g_sLogFileName = $aOldLogs[1]
$sLogPath = $g_sProfileLogsPath & $g_sLogFileName
$g_hLogFile = FileOpen($sLogPath, $FO_APPEND)
SetDebugLog("Append to log file: " & $sLogPath)
Else
$g_sLogFileName = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "." & @MIN & "." & @SEC & ".log"
$sLogPath = $g_sProfileLogsPath & $g_sLogFileName
$g_hLogFile = FileOpen($sLogPath, $FO_APPEND)
SetDebugLog("Created log file: " & $sLogPath)
EndIf
If IsBotLaunched() Then
SetDebugLog("Android: " & $g_sAndroidEmulator)
SetDebugLog("Android Instance: " & $g_sAndroidInstance)
SetDebugLog("Android Version: " & $g_sAndroidVersion)
SetDebugLog("Android Version API: " & $g_iAndroidVersionAPI)
SetDebugLog("Android ADB Device: " & $g_sAndroidAdbDevice)
SetDebugLog("Android Program Path: " & $g_sAndroidProgramPath)
SetDebugLog("Android Program FileVersionInfo: " &((IsArray($g_avAndroidProgramFileVersionInfo) ? _ArrayToString($g_avAndroidProgramFileVersionInfo, ",", 1) : "not available")))
SetDebugLog("Android ADB Path: " & $g_sAndroidAdbPath)
SetDebugLog("Android VBoxManage Path: " & $__VBoxManage_Path)
SetDebugLog("Android ADB Shared Folder: " & $g_sAndroidPicturesPath)
EndIf
SetDebugLog("Full Command Line: " & _ArrayToString($CmdLine, " "))
SetDebugLog("@AutoItExe: " & @AutoItExe)
SetDebugLog("@ScriptFullPath: " & @ScriptFullPath)
SetDebugLog("@WorkingDir: " & @WorkingDir)
SetDebugLog("@AutoItPID: " & @AutoItPID)
SetDebugLog("@OSArch: " & @OSArch)
SetDebugLog("@OSVersion: " & @OSVersion)
SetDebugLog("@OSBuild: " & @OSBuild)
SetDebugLog("@OSServicePack: " & @OSServicePack)
SetDebugLog("Primary Display: " & @DesktopWidth & " x " & @DesktopHeight & " - " & @DesktopDepth & "bit")
FlushGuiLog($g_hTxtLog, $g_oTxtLogInitText)
EndFunc
Func CreateAttackLogFile()
If $g_hAttackLogFile <> 0 Then
FileClose($g_hAttackLogFile)
$g_hAttackLogFile = 0
EndIf
Local $sAttackLogFName = "AttackLog" & "-" & @YEAR & "-" & @MON & ".log"
Local $sAttackLogPath = $g_sProfileLogsPath & $sAttackLogFName
$g_hAttackLogFile = FileOpen($sAttackLogPath, $FO_APPEND)
SetDebugLog("Created attack log file: " & $sAttackLogPath)
EndFunc
Func CreateSwitchLogFile()
If $g_hSwitchLogFile <> 0 Then
FileClose($g_hSwitchLogFile)
$g_hSwitchLogFile = 0
EndIf
Local $sSwitchLogFName = "SwitchAccLog" & "-" & @YEAR & "-" & @MON & ".log"
Local $sSwitchLogPath = $g_sProfilePath & "\" & $sSwitchLogFName
$g_hSwitchLogFile = FileOpen($sSwitchLogPath, $FO_APPEND)
SetDebugLog("Created attack log file: " & $sSwitchLogPath)
EndFunc
Func DebugImageSave($TxtName = "Unknown", $capturenew = Default, $extensionpng = Default, $makesubfolder = Default, $sTag = "")
If $capturenew = Default Then $capturenew = True
If $extensionpng = Default Then $extensionpng = "png"
If $makesubfolder = Default Then $makesubfolder = True
Local $Date = @MDAY & "." & @MON & "." & @YEAR
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $savefolder = $g_sProfileTempDebugPath
If $makesubfolder = True Then
$savefolder = $g_sProfileTempDebugPath & $TxtName & "\"
DirCreate($savefolder)
EndIf
Local $extension
If $extensionpng = "png" then
$extension = "png"
Else
$extension = "jpg"
EndIf
Local $exist = true
local $i = 1
Local $first = True
Local $filename = ""
While $exist
If $first Then
$first = False
$filename = $savefolder & $TxtName & $sTag & $Date & " at " & $Time & "." & $extension
If FileExists($filename) = 1 Then
$exist = True
Else
$exist = False
EndIf
Else
$filename = $savefolder & $TxtName & $sTag & $Date & " at " & $Time & " (" & $i & ")." & $extension
If FileExists($filename) = 1 Then
$i +=1
Else
$exist = False
EndIf
EndIf
WEnd
If IsBool($capturenew) And $capturenew Then
_CaptureRegion2()
EndIf
If IsPtr($capturenew) Then
_GDIPlus_ImageSaveToFile($capturenew, $filename)
If $g_bDebugSetlog Then SetDebugLog("DebugImageSave(" & $capturenew & ") " & $filename, $COLOR_DEBUG)
Else
Local $EditedImage = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
_GDIPlus_ImageSaveToFile($EditedImage, $filename)
_GDIPlus_BitmapDispose($EditedImage)
If $g_bDebugSetlog Then SetDebugLog("DebugImageSave " & $filename, $COLOR_DEBUG)
EndIf
If _Sleep($DELAYDEBUGIMAGESAVE1) Then Return
EndFunc
Func _logErrorDLLCall($sDllName, $ErrorCode)
Local $sEmsg
If $ErrorCode > 0 Then
Switch $ErrorCode
Case 1
$sEmsg = "unable to use DLL file"
Case 2
$sEmsg = "unknown return type"
Case 3
$sEmsg = "function not found in the DLL file"
Case 4
$sEmsg = "bad number of parameters"
Case 5
$sEmsg = "bad parameter"
Case Else
$sEmsg = "Unknown Error Code?"
EndSwitch
SetLog($sDllName & " DLLCall Error, @error code: " & $sEmsg, $COLOR_ERROR)
EndIf
EndFunc
Func _logErrorDateDiff($ErrorCode)
Local $sEmsg
Switch $ErrorCode
Case 1
$sEmsg = "1| Invalid $sType"
Case 2
$sEmsg = "2| Invalid $iNumber"
Case 3
$sEmsg = "3| Invalid $sEndDate"
EndSwitch
SetLog("_DateDiff error code = " & $sEmsg, $COLOR_ERROR)
EndFunc
Func _logErrorDateAdd($ErrorCode)
Local $sEmsg
Switch $ErrorCode
Case 1
$sEmsg = "1| Invalid $sType"
Case 2
$sEmsg = "2| Invalid $sStartDate"
Case 3
$sEmsg = "3| Invalid $sEndDate"
EndSwitch
SetLog("_DateAdd error code = " & $sEmsg, $COLOR_ERROR)
EndFunc
Func _logErrorGetBuilding($ErrorCode)
Local $sEmsg
Switch $ErrorCode
Case 1
$sEmsg = "1| Path missing in $g_oBldgImages dictionary"
Case 2
$sEmsg = "2| DLL found no buildings"
Case Else
$sEmsg = "Slap Code Monkey!"
EndSwitch
SetLog("# GetLocationBuilding error code: " & $sEmsg, $COLOR_ERROR)
EndFunc
Func FindPos()
getBSPos()
AndroidToFront(Default, "FindPos")
Local $wasDown = AndroidShieldForceDown(True, True)
While 1
If _IsPressed("01") Or _IsPressed("02") Then
Local $Pos = MouseGetPos()
$Pos[0] -= $g_aiBSpos[0]
$Pos[1] -= $g_aiBSpos[1]
ConvertFromVillagePos($Pos[0], $Pos[1])
While _IsPressed("01") Or _IsPressed("02")
Sleep(10)
WEnd
AndroidShieldForceDown($wasDown, True)
Return $Pos
EndIf
Sleep(10)
WEnd
EndFunc
Func Tab($a, $b)
Local $Tab = ""
For $i = StringLen($a) To $b Step 1
$Tab &= " "
Next
Return $Tab
EndFunc
Func Time()
Return "[" & _NowTime(3) & "] "
EndFunc
Func TimeDebug()
Return "[" & @YEAR & "-" & @MON & "-" & @MDAY & " " & _NowTime(5) & "." & @MSEC & "] "
EndFunc
Func __TimerInit()
Local $iCurrentTimeMSec = _Date_Time_GetTickCount()
Return $iCurrentTimeMSec
EndFunc
Func __TimerDiff($iTimeMsec)
If $iTimeMsec <= 0 Then
SetError(1, 0, 0)
Return
EndIf
Local $iCurrentTimeMSec = _Date_Time_GetTickCount()
If $iCurrentTimeMSec < $iTimeMsec Then
$iTimeMsec = $iTimeMsec - 4294967296
EndIf
Return $iCurrentTimeMSec - $iTimeMsec
EndFunc
Global $g_iHPTimerFreq = 0
Func _HPTimerInit()
Local $iTimerCount = _WinAPI_QueryPerformanceCounter()
If $iTimerCount = 0 Then
Local $err = _WinAPI_GetLastError()
SetLog("QueryPerformanceCounter error code: " & $err, $COLOR_ERROR)
SetError(1, $err, 0)
Return
EndIf
If $g_iHPTimerFreq = 0 Then
$g_iHPTimerFreq = _WinAPI_QueryPerformanceFrequency()
If $g_iHPTimerFreq = 0 Then
Local $err = _WinAPI_GetLastError()
SetLog("QueryPerformanceFrequency error code: " & $err, $COLOR_ERROR)
Else
SetDebugLog("QueryPerformanceFrequency is: " & $g_iHPTimerFreq)
EndIf
EndIf
Return $iTimerCount
EndFunc
Func _HPTimerDiff($iOldTimerCount)
If $iOldTimerCount = 0 Then
SetLog("Bad parameter data passed to _HPTimerDiff", $COLOR_ERROR)
SetError(1, 0, 0)
Return
EndIf
Local $iNewTimerCount = _WinAPI_QueryPerformanceCounter()
If $iNewTimerCount = 0 Then
Local $err = _WinAPI_GetLastError()
SetLog("QueryPerformanceCounter error code: " & $err, $COLOR_ERROR)
SetError(1, $err, 0)
Return
EndIf
If $g_iHPTimerFreq = 0 Then
SetLog("QueryPerformanceFrequency error code: " & $err & " ,Abort timer check", $COLOR_ERROR)
Return 0
EndIf
Return(($iNewTimerCount - $iOldTimerCount) / $g_iHPTimerFreq) * 1000
EndFunc
Func TogglePause()
TogglePauseImpl("Button")
EndFunc
Func TogglePauseImpl($Source, $bDelayed = False)
If Not $g_bRunState Then Return
ResumeAndroid()
$g_bBotPaused = Not $g_bBotPaused
If $g_bTogglePauseAllowed = False Then
$g_bTogglePauseUpdateState = True
Return
EndIf
TogglePauseUpdateState($Source)
If $bDelayed = False Then TogglePauseSleep()
EndFunc
Func TogglePauseUpdateState($Source)
$g_iActualTrainSkip = 0
$g_bTogglePauseUpdateState = False
If $g_bBotPaused Then
AndroidShield("TogglePauseImpl paused", False)
TrayTip($g_sBotTitle, "", 1)
If Not $g_bDisableNotifications Then TrayTip($g_sBotTitle, "was Paused!", 1, $TIP_ICONEXCLAMATION)
SetLog("Bot was Paused!", $COLOR_ERROR)
If Not $g_bSearchMode Then
$g_iTimePassed += Int(__TimerDiff($g_hTimerSinceStarted))
EndIf
PushMsg("Pause", $Source)
GUICtrlSetState($g_hBtnPause, $GUI_HIDE)
GUICtrlSetState($g_hBtnResume, $GUI_SHOW)
TrayItemSetText($g_hTiPause, GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Resume", "Resume bot"))
Else
AndroidShield("TogglePauseImpl resumed")
TrayTip($g_sBotTitle, "", 1)
If Not $g_bDisableNotifications Then TrayTip($g_sBotTitle, "was Resumed.", 1, $TIP_ICONASTERISK)
SetLog("Bot was Resumed.", $COLOR_SUCCESS)
If Not $g_bSearchMode Then
$g_hTimerSinceStarted = __TimerInit()
EndIf
PushMsg("Resume", $Source)
GUICtrlSetState($g_hBtnPause, $GUI_SHOW)
GUICtrlSetState($g_hBtnResume, $GUI_HIDE)
TrayItemSetText($g_hTiPause, GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Pause", "Pause bot"))
EndIf
SetRedrawBotWindow(True, Default, Default, Default, "TogglePauseUpdateState")
EndFunc
Func TogglePauseSleep()
Local $counter = 0
Local $hTimerAutoResume = __TimerInit()
While $g_bBotPaused
If _Sleep($DELAYTOGGLEPAUSE1, True, True, False) Then ExitLoop
If $g_bAutoResumeEnable And __TimerDiff($hTimerAutoResume) >=($g_iAutoResumeTime * 60000) Then
SetLog("Auto resume bot after " & $g_iAutoResumeTime & " minutes of waiting", $COLOR_INFO)
TogglePause()
EndIf
$counter = $counter + 1
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyRemoteEnable = True And $counter = 200 Then
NotifyRemoteControl()
$counter = 0
EndIf
WEnd
$g_bSkipFirstZoomout = False
If _Sleep($DELAYTOGGLEPAUSE2, True, True, False) Then Return
EndFunc
Func CheckPrerequisites($bSilent = False)
Local $isAllOK = True
Local $isNetFramework4dot5Installed = isNetFramework4dot5Installed()
Local $isVC2010Installed = isVC2010Installed()
If($isNetFramework4dot5Installed = False Or $isVC2010Installed = False) Then
If($isNetFramework4dot5Installed = False And Not $bSilent) Then
SetLog("The .Net Framework 4.5 is not installed", $COLOR_ERROR)
SetLog("Please download here : https://www.microsoft.com/en-US/download/details.aspx?id=30653", $COLOR_ERROR)
EndIf
If($isVC2010Installed = False And Not $bSilent) Then
SetLog("The VC 2010 x86 is not installed", $COLOR_ERROR)
SetLog("Please download here : https://www.microsoft.com/en-US/download/details.aspx?id=5555", $COLOR_ERROR)
EndIf
$isAllOK = False
EndIf
If isEveryFileInstalled($bSilent) = False Then $isAllOK = False
If Not checkAutoitVersion($bSilent) Then $isAllOK = False
checkIsAdmin($bSilent)
If @DesktopHeight <= 768 Then
Opt('WinTitleMatchMode', 4)
Local $pos = ControlGetPos("classname=Shell_TrayWnd", "", "")
If Not @error Then
If $pos[2] > $pos[3] Then
SetLog("Please set your taskbar location to Right!", $COLOR_ERROR)
SetLog("TASKBAR SIZE: " & $pos[2] & "," & $pos[3], $COLOR_ERROR)
$isAllOK = False
EndIf
EndIf
Opt('WinTitleMatchMode', 3)
EndIf
If $isAllOK = False And Not $bSilent Then
GUICtrlSetState($g_hBtnStart, $GUI_DISABLE)
$g_bRestarted = False
EndIf
Return $isAllOK
EndFunc
Func isNetFramework4Installed()
Local $z = 0, $sKeyName, $success = False
Do
$z += 1
$sKeyName = RegEnumKey("HKLM\SOFTWARE\Microsoft\NET Framework Setup\NDP", $z)
If StringRegExp($sKeyName, "v4|v4.\d+") Then
$success = True
EndIf
Until $sKeyName = '' Or $success
Return $success
EndFunc
Func isNetFramework4dot5Installed()
Local $z = 0, $sKeyValue, $success = False
$sKeyValue = RegRead("HKLM\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full\", "Release")
If Number($sKeyValue) >= 378389 Then $success = True
Return $success
EndFunc
Func isVC2010Installed()
Local $hDll = DllOpen("msvcp100.dll")
Local $success = $hDll <> -1
If $success = False Then Return $success
DllClose($hDll)
_WinAPI_FreeLibrary($hDll)
Return $success
EndFunc
Func isEveryFileInstalled($bSilent = False)
Local $bResult = False, $iCount = 0
Local $aCheckFiles = [@ScriptDir & "\COCBot", $g_sLibPath, @ScriptDir & "\Images", $g_sLibMyBotPath, $g_sLibImageSearchPath, $g_sLibIconPath, $g_sLibPath & "\opencv_core220.dll", $g_sLibPath & "\opencv_imgproc220.dll"]
For $vElement In $aCheckFiles
$iCount += FileExists($vElement)
Next
If $iCount = UBound($aCheckFiles) Then
$bResult = True
ElseIf Not $bSilent Then
GUICtrlSetState($g_hBtnStart, $GUI_DISABLE)
Local $sText1 = "", $sText2 = "", $sText3 = "", $MsgBox = 0
$sText1 = GetTranslatedFileIni("MBR Popups", "CheckPrerequisites_Item_01", "Hey Chief, we are missing some files!")
$sText2 = GetTranslatedFileIni("MBR Popups", "CheckPrerequisites_Item_02", "Please extract all files and folders and start this program again!")
$sText3 = GetTranslatedFileIni("MBR Popups", "CheckPrerequisites_Item_03", "Sorry, Start button disabled until fixed!")
SetLog($sText1, $COLOR_ERROR)
SetLog($sText2, $COLOR_ERROR)
SetLog($sText3, $COLOR_ERROR)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), $sText1, $sText2, 0)
GUICtrlSetState($g_hBtnStart, $GUI_DISABLE)
EndIf
If @Compiled Then
If Not StringInStr(@ScriptFullPath, "MyBot.run.exe", 1) Then
If Not $bSilent Then
Local $sText1, $sText2, $MsgBox
$sText1 = GetTranslatedFileIni("MBR Popups", "CheckPrerequisites_Item_04", "Hey Chief, file name incorrect!")
$sText2 = GetTranslatedFileIni("MBR Popups", "CheckPrerequisites_Item_05", 'You have renamed the file "MyBot.run.exe"! Please change it back to MyBot.run.exe and restart the bot!')
$sText3 = GetTranslatedFileIni("MBR Popups", "CheckPrerequisites_Item_03", "Sorry, Start button disabled until fixed!")
SetLog($sText1, $COLOR_ERROR)
SetLog($sText2, $COLOR_ERROR)
SetLog($sText3, $COLOR_ERROR)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), $sText1, $sText2, 0)
GUICtrlSetState($g_hBtnStart, $GUI_DISABLE)
EndIf
$bResult = False
EndIf
EndIf
Return $bResult
EndFunc
Func checkAutoitVersion($bSilent = False)
If @Compiled = True Then Return 1
Local $requiredAutoit = "3.3.14.2"
Local $result = _VersionCompare(@AutoItVersion, $requiredAutoit)
If $result = 0 Or $result = 1 Then Return 1
If Not $bSilent Then
Local $sText1 = "Hey Chief, your AutoIt version is out of date!"
Local $sText3 = "Click OK to download the latest version of AutoIt."
Local $sText2 = "The bot requires AutoIt version " & $requiredAutoit & " or above. Your version of AutoIt is " & @AutoItVersion & "." & @CRLF & $sText3 & @CRLF & "After installing the new version, open the bot again."
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
Local $MsgBox = _ExtMsgBox(48, "OK|Cancel", $sText1, $sText2, 0)
If $MsgBox = 1 Then ShellExecute("https://www.autoitscript.com/site/autoit/downloads/")
EndIf
Return 0
EndFunc
Func checkIsAdmin($bSilent = False)
If IsAdmin() Then Return True
If Not $bSilent Then SetLog("My Bot running without admin privileges", $COLOR_ERROR)
Return False
EndFunc
Func WindowsArrange($position, $offsetX = 0, $offsetY = 0)
WinGetAndroidHandle()
Local $AndroidPos = WinGetPos($g_hAndroidWindow)
Local $BotPos = WinGetPos($g_hFrmBot)
If IsArray($AndroidPos) And IsArray($BotPos) Then
Local $hTimer = __TimerInit()
WinSetState($g_hAndroidWindow, "", @SW_RESTORE)
While IsArray($AndroidPos) And __TimerDiff($hTimer) < 3000 And $AndroidPos[0] < -30000 And $AndroidPos[1] < -30000
$AndroidPos = WinGetPos($g_hAndroidWindow)
If _Sleep($DELAYSLEEP) Then Return False
WEnd
Local $x = $offsetX
Local $y = $offsetY
Local $AndroidX = $AndroidPos[0]
Local $AndroidY = $AndroidPos[1]
Local $AndroidW = $AndroidPos[2]
Local $AndroidH = $AndroidPos[3]
Local $BotX = $BotPos[0]
Local $BotY = $BotPos[1]
Local $BotW = $BotPos[2]
Local $BotH = $BotPos[3]
If Number($AndroidX) > -30000 And Number($AndroidY) > -30000 Then
Local $bAdjusted = False
If $position = "EMBED" Then
AndroidEmbed(True)
If Not($offsetX == "" Or $offsetY == "") Then
$bAdjusted = $BotX <> $offsetX Or $BotY <> $offsetY
If $bAdjusted = True Then WinMove($g_hFrmBot, "", $offsetX, $offsetY)
EndIf
Else
If $g_bAndroidEmbedded = True Then
Return
EndIf
Switch $position
Case "BS-BOT"
If $offsetX == "" Then
$x = $AndroidX
$offsetX = 0
EndIf
If $offsetY == "" Then
$y = $AndroidY
$offsetY = 0
EndIf
$bAdjusted = $AndroidX <> $x Or $AndroidY <> $y
If $bAdjusted Then
WinMove($g_hAndroidWindow, "", $x, $y)
_Sleep($DELAYWINDOWSARRANGE1, True, False)
EndIf
$bAdjusted = $bAdjusted = True Or $BotX <> $AndroidW + $offsetX * 2 Or $BotY <> $y
If $bAdjusted Then WinMove($g_hFrmBot, "", $x + $AndroidW + $offsetX, $y)
Case "BOT-BS"
If $offsetX == "" Then
$x = $BotX
$offsetX = 0
EndIf
If $offsetY == "" Then
$y = $BotY
$offsetY = 0
EndIf
$bAdjusted = $BotX <> $x Or $BotY <> $y
If $bAdjusted Then
WinMove($g_hFrmBot, "", $x, $y)
_Sleep($DELAYWINDOWSARRANGE1, True, False)
EndIf
$bAdjusted = $bAdjusted Or $AndroidX <> $x + $BotW + $offsetX Or $AndroidY <> $y
If $bAdjusted Then WinMove($g_hAndroidWindow, "", $x + $BotW + $offsetX, $y)
Case "SNAP-TR"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $BotX <> $AndroidX + $AndroidW + $offsetX Or $BotY <> $AndroidY + $offsetY
If $bAdjusted Then WinMove($g_hFrmBot, "", $AndroidX + $AndroidW + $offsetX, $AndroidY + $offsetY)
Case "SNAP-BR"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $AndroidX <> $AndroidX + $AndroidW + $offsetX Or $AndroidY <> $AndroidY +($AndroidH - $BotH) + $offsetY
If $bAdjusted Then WinMove($g_hFrmBot, "", $AndroidX + $AndroidW + $offsetX, $AndroidY +($AndroidH - $BotH) + $offsetY)
Case "SNAP-TL"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $BotX <> $AndroidX - $BotW - $offsetX Or $BotY <> $AndroidY + $offsetY
If $bAdjusted Then WinMove($g_hFrmBot, "", $AndroidX - $BotW - $offsetX, $AndroidY + $offsetY)
Case "SNAP-BL"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $BotX <> $AndroidX - $BotW - $offsetX Or $BotY <> $AndroidY +($AndroidH - $BotH) + $offsetY
If $bAdjusted Then WinMove($g_hFrmBot, "", $AndroidX - $BotW - $offsetX, $AndroidY +($AndroidH - $BotH) + $offsetY)
EndSwitch
EndIf
If $bAdjusted = True Then
SetDebugLog("WindowsArrange: " & $position & ", offsetX=" & $offsetX & ", offsetY=" & $offsetY & ", X=" & $x & ", Y=" & $y)
_Sleep($DELAYWINDOWSARRANGE1, True, False)
EndIf
EndIf
EndIf
EndFunc
Func DisposeWindows()
updateBtnEmbed()
Local $aPos = WinGetPos($g_hFrmBot)
If IsArray($aPos) Then
If _CheckWindowVisibility($g_hFrmBot, $aPos) Then
SetDebugLog("Bot Window '" & $g_sAndroidTitle & "' not visible, moving to position: " & $aPos[0] & ", " & $aPos[1])
WinMove($g_hFrmBot, "", $aPos[0], $aPos[1])
EndIf
EndIf
CheckDpiAwareness()
If $g_bAutoAlignEnable Then
Switch $g_iAutoAlignPosition
Case 0
WindowsArrange("BS-BOT", $g_iAutoAlignOffsetX, $g_iAutoAlignOffsetY)
Case 1
WindowsArrange("BOT-BS", $g_iAutoAlignOffsetX, $g_iAutoAlignOffsetY)
Case 2
WindowsArrange("SNAP-TR", $g_iAutoAlignOffsetX, $g_iAutoAlignOffsetY)
Case 3
WindowsArrange("SNAP-TL", $g_iAutoAlignOffsetX, $g_iAutoAlignOffsetY)
Case 4
WindowsArrange("SNAP-BR", $g_iAutoAlignOffsetX, $g_iAutoAlignOffsetY)
Case 5
WindowsArrange("SNAP-BL", $g_iAutoAlignOffsetX, $g_iAutoAlignOffsetY)
Case 6
WindowsArrange("EMBED", $g_iAutoAlignOffsetX, $g_iAutoAlignOffsetY)
EndSwitch
EndIf
EndFunc
Func WinMove2($WinTitle, $WinText, $x = -1, $y = -1, $w = -1, $h = -1, $hAfter = 0, $iFlags = 0, $bCheckAfterPos = True, $bIconCheck = True)
If $WinTitle = $g_hFrmBot And $g_iGuiMode = 0 Then Return $WinTitle
Local $hWin = WinGetHandle($WinTitle, $WinText)
If @error Then Return 0
If $bIconCheck And _WinAPI_IsIconic($hWin) Then
SetDebugLog("Window " & $WinTitle &(($WinTitle <> $hWin) ? "(" & $hWin & ")" : "") & " restored", $COLOR_ACTION)
WinSetState($hWin, "", @SW_RESTORE)
EndIf
Local $NoMove = $x = -1 And $y = -1
Local $NoResize = $w = -1 And $h = -1
Local $NOZORDER =($hAfter = 0 ? BitOR($SWP_NOZORDER, $SWP_NOOWNERZORDER) : 0)
$bCheckAfterPos = $bCheckAfterPos And(Not $NoMove Or Not $NoResize)
If Not $NoMove Or Not $NoResize Then
Local $aPos = WinGetPos($hWin)
If @error <> 0 Or Not IsArray($aPos) Then
SetError(1, @extended, -1)
Return 0
EndIf
Local $aPPos = WinGetClientPos(__WinAPI_GetParent($hWin))
If IsArray($aPPos) Then
$aPos[0] -= $aPPos[0]
$aPos[1] -= $aPPos[1]
EndIf
If $x = -1 Or $y = -1 Or $w = -1 Or $h = -1 Then
If $x = -1 Then $x = $aPos[0]
If $y = -1 Then $y = $aPos[1]
If $w = -1 Then $w = $aPos[2]
If $h = -1 Then $h = $aPos[3]
EndIf
$NoMove = $NoMove Or($x = $aPos[0] And $y = $aPos[1])
$NoResize = $NoResize Or($w = $aPos[2] And $h = $aPos[3])
EndIf
If $g_bWinMove2_Compatible And $NoResize = False Then
WinMove($WinTitle, $WinText, $x, $y, $w, $h)
_WinAPI_SetWindowPos($hWin, $hAfter, 0, 0, 0, 0, BitOR($SWP_NOSIZE, $SWP_NOMOVE, $SWP_NOREPOSITION, $SWP_NOACTIVATE, $SWP_NOSENDCHANGING, $NOZORDER, $iFlags))
Else
_WinAPI_SetWindowPos($hWin, $hAfter, $x, $y, $w, $h, BitOR(($NoMove ? BitOR($SWP_NOMOVE, $SWP_NOREPOSITION) : 0),($NoResize ? $SWP_NOSIZE : 0), $SWP_NOACTIVATE, $SWP_NOSENDCHANGING, $NOZORDER, $iFlags))
EndIf
If $bCheckAfterPos Then
$aPos = WinGetPos($hWin)
If @error <> 0 Or Not IsArray($aPos) Then
SetError(1, @extended, -1)
Return 0
EndIf
Local $aPPos = WinGetClientPos(__WinAPI_GetParent($hWin))
If IsArray($aPPos) Then
$aPos[0] -= $aPPos[0]
$aPos[1] -= $aPPos[1]
EndIf
If $x <> $aPos[0] Or $y <> $aPos[1] Or $w <> $aPos[2] Or $h <> $aPos[3] Then
SetDebugLog("Window " & $WinTitle &(($WinTitle <> $hWin) ? "(" & $hWin & ")" : "") & " got resized/moved again to " & $aPos[0] & "/" & $aPos[1] & " " & $aPos[2] & "x" & $aPos[3] & ", restore now " & $x & "/" & $y & " " & $w & "x" & $h, $COLOR_ACTION)
WinMove($hWin, "", $x, $y, $w, $h - 1)
If $g_bWinMove2_Compatible Then
WinMove($hWin, "", $x, $y, $w, $h)
_WinAPI_SetWindowPos($hWin, $hAfter, 0, 0, 0, 0, BitOR($SWP_NOSIZE, $SWP_NOMOVE, $SWP_NOREPOSITION, $SWP_NOACTIVATE, $SWP_NOSENDCHANGING, $NOZORDER, $iFlags))
Else
_WinAPI_SetWindowPos($hWin, $hAfter, $x, $y, $w, $h, BitOR($SWP_NOMOVE, $SWP_NOREPOSITION, $SWP_NOACTIVATE, $SWP_NOSENDCHANGING, $NOZORDER, $iFlags))
EndIf
EndIf
EndIf
Return $hWin
EndFunc
Func ControlGetHandle2($title, $text, $controlID, $iMinWidth = Default, $iMinHeight = Default)
For $sClass In StringSplit($controlID, "|", $STR_NOCOUNT)
Local $hCtrl = ControlGetHandle($title, $text, $sClass)
If $hCtrl Then
If $iMinWidth <> Default Or $iMinHeight <> Default Then
Local $aPos = WinGetPos($hCtrl)
If UBound($aPos) > 3 Then
If($iMinWidth = Default Or $aPos[2] >= $iMinWidth) And($iMinHeight = Default Or $aPos[2] >= $iMinHeight) Then
$g_sControlGetHandle2_Classname = $sClass
Return $hCtrl
EndIf
Else
SetDebugLog("ControlGetHandle2 cannot validate window dimension")
$g_sControlGetHandle2_Classname = $sClass
Return $hCtrl
EndIf
Else
$g_sControlGetHandle2_Classname = $sClass
Return $hCtrl
EndIf
EndIf
Next
$g_sControlGetHandle2_Classname = ""
Return SetError(1, 0, 0)
EndFunc
Func WinGetClientPos($hWin, $x = 0, $y = 0)
Local $tPoint = DllStructCreate("int x;int y")
DllStructSetData($tPoint, "x", $x)
DllStructSetData($tPoint, "y", $y)
_WinAPI_ClientToScreen($hWin, $tPoint)
If @error Then Return SetError(1, 0, 0)
Local $a[2] = [DllStructGetData($tPoint, "x"), DllStructGetData($tPoint, "y")]
$tPoint = 0
Return $a
EndFunc
Func WinGetPos2($title, $text = "")
Local $aPos = 0
If $title = $g_hFrmBot And $g_iGuiMode = 0 Then Return $aPos
If IsHWnd($title) = 0 Then $title = WinGetHandle($title, $text)
While IsHWnd($title) And(IsArray($aPos) = 0 Or $aPos[2] < 200)
If _WinAPI_IsIconic($title) Then WinSetState($title, "", @SW_RESTORE)
If _WinAPI_IsIconic($title) = False Then $aPos = WinGetPos($title)
WEnd
Return $aPos
EndFunc
Func ControlGetPos2($title, $text, $controlID)
Local $aPos = 0
If $title = $g_hFrmBot And $g_iGuiMode = 0 Then Return $aPos
If IsHWnd($title) = 0 Then $title = WinGetHandle($title, $text)
While IsHWnd($title) And(IsArray($aPos) = 0 Or $aPos[2] < 200)
If _WinAPI_IsIconic($title) Then WinSetState($title, "", @SW_RESTORE)
If _WinAPI_IsIconic($title) = False Then $aPos = ControlGetPos($title, $text, $controlID)
WEnd
Return $aPos
EndFunc
Func ControlGetRelativePos($title, $text, $controlID)
Local $a = ControlGetPos($title, $text, $controlID)
If UBound($a) < 4 Then Return SetError(1)
Local $hCtrl =((IsHWnd($controlID)) ?($controlID) :(GUICtrlGetHandle($controlID)))
Local $hWinParent = __WinAPI_GetParent($hCtrl)
Local $aParent = ControlGetPos($title, "", $hWinParent)
If IsArray($aParent) = 1 Then
$a[0] -= $aParent[0]
$a[1] -= $aParent[1]
EndIf
Return $a
EndFunc
Func __WinAPI_GetParent($hWin, $iMillis = 3000)
If $hWin = 0 Then Return 0
Local $hTimer = __TimerInit()
Local $bPostSomething = True
Local $hWinParent = 0
Do
$hWinParent = _WinAPI_GetParent($hWin)
If IsPtr($hWinParent) = 0 Then
If $bPostSomething And __TimerDiff($hTimer) > $iMillis / 2 Then
$bPostSomething = False
EndIf
Sleep(10)
EndIf
Until IsPtr($hWinParent) = 1 Or __TimerDiff($hTimer) > $iMillis
Return $hWinParent
EndFunc
Func _CheckWindowVisibility(Const $hWnd, ByRef $p)
If $p[0] < -30000 And $p[1] < -30000 Then Return False
Local $monitorHandle = _MonitorFromWindow($hWnd, 0)
If $monitorHandle <> 0 Then
Return False
EndIf
$monitorHandle = _MonitorFromWindow($hWnd, 2)
Local $monitorInfo = _MonitorGetInfo($monitorHandle)
If UBound($monitorInfo) > 1 Then
$p[0] = $monitorInfo[0]
$p[1] = $monitorInfo[1]
EndIf
Return True
EndFunc
Func _GraphicsCreateDC($sDriver="DISPLAY",$sDevice=0,$pInitData=0)
If Not IsString($sDriver) Then Return SetError(1,0,False)
Local $aRet,$sDeviceType
If $sDevice="" Or Not IsString($sDevice) Then
$sDeviceType="ptr"
$sDevice=0
Else
$sDeviceType="wstr"
EndIf
$aRet=DllCall('gdi32.dll',"handle","CreateDCW","wstr",$sDriver,$sDeviceType,$sDevice,"ptr",0,"ptr",$pInitData)
If @error Then Return SetError(2,@error,0)
If $aRet[0]=0 Then Return SetError(3,0,0)
Return $aRet[0]
EndFunc
Func _MonitorGetInfo($hMonitor,$hMonitorDC=0)
If Not IsPtr($hMonitor) Or $hMonitor=0 Then Return SetError(1,0,'')
Local $aRet, $stMonInfoEx=DllStructCreate('dword;long[8];dword;wchar[32]'), $bMonDCCreated=0
DllStructSetData($stMonInfoEx,1,DllStructGetSize($stMonInfoEx))
$aRet=DllCall('user32.dll','bool','GetMonitorInfoW','handle',$hMonitor,'ptr',DllStructGetPtr($stMonInfoEx))
If @error Then
$stMonInfoEx = 0
Return SetError(2,0,'')
EndIf
If Not $aRet[0] Then
$stMonInfoEx = 0
Return SetError(3,0,'')
EndIf
Dim $aRet[12]
For $i=0 To 7
$aRet[$i]=DllStructGetData($stMonInfoEx,2,$i+1)
Next
$aRet[8]=DllStructGetData($stMonInfoEx,3)
$aRet[9]=DllStructGetData($stMonInfoEx,4)
If $hMonitorDC=0 Then
$hMonitorDC=_GraphicsCreateDC($aRet[9],$aRet[9])
$bMonDCCreated=1
EndIf
$aRet[10]=_WinAPI_GetDeviceCaps($hMonitorDC,12)
$aRet[11]=_WinAPI_GetDeviceCaps($hMonitorDC,116)
If $bMonDCCreated Then _WinAPI_DeleteDC($hMonitorDC)
$stMonInfoEx = 0
Return $aRet
EndFunc
Func _MonitorFromWindow($hWnd, $iFlags=2)
If Not IsHWnd($hWnd) Or $iFlags<0 Or $iFlags>2 Then Return SetError(1,0,0)
Local $aRet=DllCall('user32.dll', 'handle', 'MonitorFromWindow', 'hwnd', $hWnd, 'dword', $iFlags)
If @error Then Return SetError(2,@error,0)
If $aRet[0]=0 Then Return SetError(3,0,0)
Return $aRet[0]
EndFunc
Func MakeScreenshot($TargetDir, $type = "jpg")
If WinGetAndroidHandle() <> 0 Then
Local $iLeft = 0, $iTop = 0, $iRight = $g_iAndroidClientWidth, $iBottom = $g_iAndroidClientHeight
Local $iW = Number($iRight) - Number($iLeft)
Local $iH = Number($iBottom) - Number($iTop)
Local $hHBitmapScreenshot = _CaptureRegion($iLeft, $iTop, $iRight, $iBottom, True)
Local $hBitmapScreenshot = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmapScreenshot)
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($hBitmapScreenshot)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFF000029)
If $g_bScreenshotHideName Then
If $g_aiClanCastlePos[0] = -1 Or $g_aiClanCastlePos[1] = -1 Then
SetLog("Screenshot warning: Locate the Clan Castle to hide the clanname!", $COLOR_ERROR)
EndIf
_GDIPlus_GraphicsFillRect($hGraphic, 0, 0, 250, 63, $hBrush)
If $g_aiClanCastlePos[0] <> -1 Then
Local $xCC = $g_aiClanCastlePos[0]
Local $yCC = $g_aiClanCastlePos[1]
ConvertToVillagePos($xCC, $yCC)
_GDIPlus_GraphicsFillRect($hGraphic, $xCC - 31, $yCC - 3, 66, 20, $hBrush)
EndIf
EndIf
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = $Date & "_" & $Time & "." & $type
_GDIPlus_ImageSaveToFile($hBitmapScreenshot, $TargetDir & $filename)
If FileExists($TargetDir & $filename) = 1 Then
If $g_sProfileTempPath = $TargetDir Then
SetLog("Screenshot saved: .\Profiles\" & $g_sProfileCurrentName & "\Temp\" & $filename)
Else
SetLog("Screenshot saved: " & $TargetDir & $filename)
EndIf
Else
SetLog("Screenshot file not created: " & $TargetDir & $filename, $COLOR_ERROR)
EndIf
$g_bMakeScreenshotNow = False
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($hBitmapScreenshot)
_WinAPI_DeleteObject($hHBitmapScreenshot)
Else
SetLog("Not in game", $COLOR_ERROR)
EndIf
EndFunc
Func _PostMessage_ClickDrag($X1, $Y1, $X2, $Y2, $Button = "left", $Delay = 50)
Local $hWin = $g_hAndroidControl
$X1 = Int($X1) + $g_aiMouseOffset[0]
$Y1 = Int($Y1) + $g_aiMouseOffset[1]
$X2 = Int($X2) + $g_aiMouseOffset[0]
$Y2 = Int($Y2) + $g_aiMouseOffset[1]
If $hWin = $g_hAndroidWindow Then
$X1 += $g_aiBSrpos[0]
$Y1 += $g_aiBSrpos[1]
$X2 += $g_aiBSrpos[0]
$Y2 += $g_aiBSrpos[1]
EndIf
If $g_bAndroidEmbedded = False Then
$X1 += $g_aiMouseOffsetWindowOnly[0]
$Y1 += $g_aiMouseOffsetWindowOnly[1]
$X2 += $g_aiMouseOffsetWindowOnly[0]
$Y2 += $g_aiMouseOffsetWindowOnly[1]
EndIf
WinGetAndroidHandle()
If Not IsHWnd($g_hAndroidWindow) Then
Return SetError(1, "", False)
EndIf
Local $Pressed = 0
If StringLower($Button) == "left" Then
$Button = $WM_LBUTTONDOWN
$Pressed = 1
ElseIf StringLower($Button) == "right" Then
$Button = $WM_RBUTTONDOWN
$Pressed = 2
ElseIf StringLower($Button) == "middle" Then
$Button = $WM_MBUTTONDOWN
$Pressed = 10
If $Delay == 10 Then $Delay = 100
EndIf
Local $User32 = DllOpen("User32.dll")
If @error Then Return SetError(4, "", False)
MoveMouseOutBS()
DllCall($User32, "bool", "PostMessage", "hwnd", $g_hAndroidWindow, "int", $Button, "int", "0", "long", _MakeLong($X1, $Y1))
If @error Then
DllClose($User32)
Return SetError(5, "", False)
EndIf
If _Sleep($Delay / 2) Then Return SetError(-1, "", False)
DllCall($User32, "bool", "PostMessage", "hwnd", $g_hAndroidWindow, "int", $WM_MOUSEMOVE, "int", $Pressed, "long", _MakeLong($X2, $Y2))
If @error Then
DllClose($User32)
Return SetError(6, "", False)
EndIf
If _Sleep($Delay / 2) Then Return SetError(-1, "", False)
DllCall($User32, "bool", "PostMessage", "hwnd", $g_hAndroidWindow, "int", $Button + 1, "int", "0", "long", _MakeLong($X2, $Y2))
If @error Then
DllClose($User32)
Return SetError(7, "", False)
EndIf
DllClose($User32)
Return SetError(0, 0, True)
EndFunc
Func _MakeLong($LowWORD, $HiWORD)
Return BitOR($HiWORD * 0x10000, BitAND($LowWORD, 0xFFFF))
EndFunc
Func ClickDrag($X1, $Y1, $X2, $Y2, $Delay = 50)
If TestCapture() Then Return
Local $error = 0
If $g_bAndroidAdbClickDrag = True Then
If $g_bAndroidAdbClickDragScript = True Then
AndroidClickDrag($X1, $Y1, $X2, $Y2, $g_bRunState)
$error = @error
Else
AndroidInputSwipe($X1, $Y1, $X2, $Y2, $g_bRunState)
$error = @error
EndIf
If _Sleep($Delay / 5) Then Return SetError(-1, "", False)
EndIf
If $g_bAndroidAdbClickDrag = False Or $error <> 0 Then
Return _PostMessage_ClickDrag($X1, $Y1, $X2, $Y2, "left", $Delay)
EndIf
Return SetError(0, 0,($error = 0 ? True : False))
EndFunc
Func TestLanguage()
If Not $g_bRunState Then Return
If getOcrLanguage($aDetectLang[0], $aDetectLang[1]) = "english" Then
SetLog("Language setting is English: Correct.", $COLOR_INFO)
Return True
ElseIf Not ChangeLanguage() Then
SetLog("Language setting is Wrong: Change CoC language to English!", $COLOR_ERROR)
btnStop()
EndIf
EndFunc
Func ChangeLanguage()
SetLog("Change Language To English", $COLOR_INFO)
If IsMainPage() Then Click($aButtonSetting[0], $aButtonSetting[1], 1, 0, "Click Setting")
If _Sleep(500) Then Return False
For $i = 0 To 20
If _ColorCheck(_GetPixelColor($aButtonLanguage[0], $aButtonLanguage[1], True), Hex($aButtonLanguage[2], 6), $aButtonLanguage[3]) Then
Click($aButtonLanguage[0], $aButtonLanguage[1], 1, 1000)
SetLog("   1. Click Language Button")
If _Sleep(200) Then Return False
ExitLoop
EndIf
If $i = 20 Then Return False
If _Sleep(900) Then Return False
Next
For $i = 0 To 20
If _ColorCheck(_GetPixelColor($aListLanguage[0], $aListLanguage[1], True), Hex($aListLanguage[2], 6), $aListLanguage[3]) Then
ClickDrag(Random(370, 375, 1), Random(170, 175, 1), Random(370, 375, 1), Random(590, 595, 1), 200)
If _Sleep(200) Then Return False
ClickDrag(Random(370, 375, 1), Random(170, 175, 1), Random(370, 375, 1), Random(380, 385, 1), 200)
If _Sleep(900) Then Return False
If _ColorCheck(_GetPixelColor($aEnglishLanguage[0], $aEnglishLanguage[1], True), Hex($aEnglishLanguage[2], 6), $aEnglishLanguage[3]) Then
Click($aEnglishLanguage[0], $aEnglishLanguage[1], 1, 1000)
SetLog("   2. Click English Language")
If _Sleep(300) Then Return False
ExitLoop
EndIf
EndIf
If $i = 20 Then Return False
If _Sleep(900) Then Return False
Next
For $i = 0 To 10
If _ColorCheck(_GetPixelColor($aLanguageOkay[0], $aLanguageOkay[1], True), Hex($aLanguageOkay[2], 6), $aLanguageOkay[3]) Then
If _Sleep(250) Then Return False
Click($aLanguageOkay[0], $aLanguageOkay[1], 1, 0, "Click OKAY")
SetLog("   3. Click OKAY")
SetLog("Please wait for loading CoC...!")
waitMainScreen()
Return True
EndIf
If $i = 10 Then Return False
If _Sleep(900) Then Return False
Next
Return False
EndFunc
Func Deletefiles($Folder, $Filter, $daydiff = 120, $type = 0, $Recursion = $FLTAR_NORECUR)
Local $x
Local $FileListName = _FileListToArrayRec($Folder, $Filter, $FLTAR_FILESFOLDERS, $Recursion)
If Not((Not IsArray($FileListName)) Or(@error = 1)) Then
For $x = $FileListName[0] To 1 Step -1
Local $FileDate = FileGetTime($Folder & $FileListName[$x])
If IsArray($FileDate) Then
Local $Date = $FileDate[0] & '/' & $FileDate[1] & '/' & $FileDate[2] & ' ' & $FileDate[3] & ':' & $FileDate[4] & ':' & $FileDate[5]
If _DateDiff('D', $Date, _NowCalc()) < $daydiff Then ContinueLoop
If $type = 0 Then
FileDelete($Folder & $FileListName[$x])
Else
FileRecycle($Folder & $FileListName[$x])
EndIf
Else
ContinueLoop
EndIf
Next
Else
Return False
EndIf
If $Folder = $g_sProfileTempDebugPath Then
$FileListName = _FileListToArray($Folder, "*", $FLTA_FOLDERS)
If IsArray($FileListName) Then
For $x = $FileListName[0] To 1 Step -1
If DirGetSize($Folder & $FileListName[$x]) = 0 Then DirRemove($Folder & $FileListName[$x])
Next
EndIf
EndIf
Return True
EndFunc
Global $ResetStats = 0
Func UpdateStats($bForceUpdate = False)
Static $s_iOldSmartZapGain = 0, $s_iOldNumLSpellsUsed = 0, $s_iOldNumEQSpellsUsed = 0
Static $topgoldloot = 0, $topelixirloot = 0, $topdarkloot = 0, $topTrophyloot = 0
Static $bDonateTroopsStatsChanged = False, $bDonateSpellsStatsChanged = False
Static $iOldFreeBuilderCount, $iOldTotalBuilderCount, $iOldGemAmount
Static $iOldCurrentLoot[$eLootCount]
Static $iOldTotalLoot[$eLootCount]
Static $iOldLastLoot[$eLootCount]
Static $iOldLastBonus[$eLootCount]
Static $iOldSkippedVillageCount, $iOldDroppedTrophyCount
Static $iOldCostGoldWall, $iOldCostElixirWall, $iOldCostGoldBuilding, $iOldCostElixirBuilding, $iOldCostDElixirHero
Static $iOldNbrOfWallsUppedGold, $iOldNbrOfWallsUppedElixir, $iOldNbrOfBuildingsUppedGold, $iOldNbrOfBuildingsUppedElixir, $iOldNbrOfHeroesUpped
Static $iOldSearchCost, $iOldTrainCostElixir, $iOldTrainCostDElixir
Static $iOldNbrOfOoS
Static $iOldNbrOfTHSnipeFails, $iOldNbrOfTHSnipeSuccess
Static $iOldGoldFromMines, $iOldElixirFromCollectors, $iOldDElixirFromDrills
Static $iOldAttackedCount, $iOldAttackedVillageCount[$g_iModeCount + 1]
Static $iOldTotalGoldGain[$g_iModeCount + 1], $iOldTotalElixirGain[$g_iModeCount + 1], $iOldTotalDarkGain[$g_iModeCount + 1], $iOldTotalTrophyGain[$g_iModeCount + 1]
Static $iOldNbrOfDetectedMines[$g_iModeCount + 1], $iOldNbrOfDetectedCollectors[$g_iModeCount + 1], $iOldNbrOfDetectedDrills[$g_iModeCount + 1]
Static $iOldCurrentLootBB[$eLootCountBB]
If $bForceUpdate Then
$s_iOldSmartZapGain = 0
$s_iOldNumLSpellsUsed = 0
$s_iOldNumEQSpellsUsed = 0
$topgoldloot = 0
$topelixirloot = 0
$topdarkloot = 0
$topTrophyloot = 0
$bDonateTroopsStatsChanged = True
$bDonateSpellsStatsChanged = True
$iOldFreeBuilderCount = 0
$iOldTotalBuilderCount = 0
$iOldGemAmount = 0
UpdateStats_ClearArray($iOldCurrentLoot)
UpdateStats_ClearArray($iOldTotalLoot)
UpdateStats_ClearArray($iOldLastLoot)
UpdateStats_ClearArray($iOldLastBonus)
$iOldSkippedVillageCount = 0
$iOldDroppedTrophyCount = 0
$iOldCostGoldWall = 0
$iOldCostElixirWall = 0
$iOldCostGoldBuilding = 0
$iOldCostElixirBuilding = 0
$iOldCostDElixirHero = 0
$iOldNbrOfWallsUppedGold = 0
$iOldNbrOfWallsUppedElixir = 0
$iOldNbrOfBuildingsUppedGold = 0
$iOldNbrOfBuildingsUppedElixir = 0
$iOldNbrOfHeroesUpped = 0
$iOldSearchCost = 0
$iOldTrainCostElixir = 0
$iOldTrainCostDElixir = 0
$iOldNbrOfOoS = 0
$iOldNbrOfTHSnipeFails = 0
$iOldNbrOfTHSnipeSuccess = 0
$iOldGoldFromMines = 0
$iOldElixirFromCollectors = 0
$iOldDElixirFromDrills = 0
$iOldAttackedCount = 0
UpdateStats_ClearArray($iOldAttackedVillageCount)
UpdateStats_ClearArray($iOldTotalGoldGain)
UpdateStats_ClearArray($iOldTotalElixirGain)
UpdateStats_ClearArray($iOldTotalDarkGain)
UpdateStats_ClearArray($iOldTotalTrophyGain)
UpdateStats_ClearArray($iOldNbrOfDetectedMines)
UpdateStats_ClearArray($iOldNbrOfDetectedCollectors)
UpdateStats_ClearArray($iOldNbrOfDetectedDrills)
UpdateStats_ClearArray($iOldCurrentLootBB)
EndIf
If $g_iFirstRun = 1 Then
GUICtrlSetState($g_hLblVillageReportTemp, $GUI_HIDE)
GUICtrlSetState($g_hPicResultGoldTemp, $GUI_HIDE)
GUICtrlSetState($g_hPicResultElixirTemp, $GUI_HIDE)
GUICtrlSetState($g_hPicResultDETemp, $GUI_HIDE)
GUICtrlSetState($g_hLblResultGoldNow, $GUI_SHOW + $GUI_DISABLE)
GUICtrlSetState($g_hPicResultGoldNow, $GUI_SHOW)
GUICtrlSetState($g_hLblResultElixirNow, $GUI_SHOW)
GUICtrlSetState($g_hPicResultElixirNow, $GUI_SHOW)
If $g_aiCurrentLoot[$eLootDarkElixir] <> "" Then
GUICtrlSetState($g_hLblResultDeNow, $GUI_SHOW)
GUICtrlSetState($g_hPicResultDeNow, $GUI_SHOW)
Else
GUICtrlSetState($g_hPicResultDEStart, $GUI_HIDE)
GUICtrlSetState($g_hPicDarkLoot, $GUI_HIDE)
GUICtrlSetState($g_hPicDarkLastAttack, $GUI_HIDE)
GUICtrlSetState($g_hPicHourlyStatsDark, $GUI_HIDE)
EndIf
GUICtrlSetState($g_hLblResultTrophyNow, $GUI_SHOW)
GUICtrlSetState($g_hLblResultBuilderNow, $GUI_SHOW)
GUICtrlSetState($g_hLblResultGemNow, $GUI_SHOW)
btnVillageStat("UpdateStats")
$g_iStatsStartedWith[$eLootGold] = $g_aiCurrentLoot[$eLootGold]
$g_iStatsStartedWith[$eLootElixir] = $g_aiCurrentLoot[$eLootElixir]
$g_iStatsStartedWith[$eLootDarkElixir] = $g_aiCurrentLoot[$eLootDarkElixir]
$g_iStatsStartedWith[$eLootTrophy] = $g_aiCurrentLoot[$eLootTrophy]
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootGold], _NumberFormat($g_aiCurrentLoot[$eLootGold], True))
GUICtrlSetData($g_hLblResultGoldNow, _NumberFormat($g_aiCurrentLoot[$eLootGold], True))
$iOldCurrentLoot[$eLootGold] = $g_aiCurrentLoot[$eLootGold]
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootElixir], _NumberFormat($g_aiCurrentLoot[$eLootElixir], True))
GUICtrlSetData($g_hLblResultElixirNow, _NumberFormat($g_aiCurrentLoot[$eLootElixir], True))
$iOldCurrentLoot[$eLootElixir] = $g_aiCurrentLoot[$eLootElixir]
If $g_iStatsStartedWith[$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootDarkElixir], _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir], True))
GUICtrlSetData($g_hLblResultDeNow, _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir], True))
$iOldCurrentLoot[$eLootDarkElixir] = $g_aiCurrentLoot[$eLootDarkElixir]
EndIf
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootTrophy], _NumberFormat($g_aiCurrentLoot[$eLootTrophy], True))
GUICtrlSetData($g_hLblResultTrophyNow, _NumberFormat($g_aiCurrentLoot[$eLootTrophy], True))
$iOldCurrentLoot[$eLootTrophy] = $g_aiCurrentLoot[$eLootTrophy]
GUICtrlSetData($g_hLblResultGemNow, _NumberFormat($g_iGemAmount, True))
$iOldGemAmount = $g_iGemAmount
GUICtrlSetData($g_hLblResultBuilderNow, $g_iFreeBuilderCount & "/" & $g_iTotalBuilderCount)
$iOldFreeBuilderCount = $g_iFreeBuilderCount
$iOldTotalBuilderCount = $g_iTotalBuilderCount
$g_iFirstRun = 0
GUICtrlSetState($btnResetStats, $GUI_ENABLE)
If $g_iGuiMode = 0 Then
UpdateStatsManagedMyBotHost()
EndIf
Return
EndIf
Local $bStatsUpdated = False
If $g_iFirstAttack = 1 Then
$g_iFirstAttack = 2
EndIf
If Number($g_iStatsLastAttack[$eLootGold]) > Number($topgoldloot) Then
$bStatsUpdated = True
$topgoldloot = $g_iStatsLastAttack[$eLootGold]
GUICtrlSetData($g_ahLblStatsTop[$eLootGold], _NumberFormat($topgoldloot))
EndIf
If Number($g_iStatsLastAttack[$eLootElixir]) > Number($topelixirloot) Then
$bStatsUpdated = True
$topelixirloot = $g_iStatsLastAttack[$eLootElixir]
GUICtrlSetData($g_ahLblStatsTop[$eLootElixir], _NumberFormat($topelixirloot))
EndIf
If Number($g_iStatsLastAttack[$eLootDarkElixir]) > Number($topdarkloot) Then
$bStatsUpdated = True
$topdarkloot = $g_iStatsLastAttack[$eLootDarkElixir]
GUICtrlSetData($g_ahLblStatsTop[$eLootDarkElixir], _NumberFormat($topdarkloot))
EndIf
If Number($g_iStatsLastAttack[$eLootTrophy]) > Number($topTrophyloot) Then
$bStatsUpdated = True
$topTrophyloot = $g_iStatsLastAttack[$eLootTrophy]
GUICtrlSetData($g_ahLblStatsTop[$eLootTrophy], _NumberFormat($topTrophyloot))
EndIf
If $ResetStats = 1 Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootGold], _NumberFormat($g_aiCurrentLoot[$eLootGold], True))
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootElixir], _NumberFormat($g_aiCurrentLoot[$eLootElixir], True))
If $g_iStatsStartedWith[$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootDarkElixir], _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir], True))
EndIf
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootTrophy], _NumberFormat($g_aiCurrentLoot[$eLootTrophy], True))
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootGold], "")
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootElixir], "")
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootDarkElixir], "")
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootTrophy], "")
GUICtrlSetData($g_hLblResultGoldHourNow, "")
GUICtrlSetData($g_hLblResultElixirHourNow, "")
GUICtrlSetData($g_hLblResultDEHourNow, "")
EndIf
If $iOldFreeBuilderCount <> $g_iFreeBuilderCount Or $iOldTotalBuilderCount <> $g_iTotalBuilderCount Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultBuilderNow, $g_iFreeBuilderCount & "/" & $g_iTotalBuilderCount)
$iOldFreeBuilderCount = $g_iFreeBuilderCount
$iOldTotalBuilderCount = $g_iTotalBuilderCount
EndIf
If $iOldGemAmount <> $g_iGemAmount Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultGemNow, _NumberFormat($g_iGemAmount, True))
$iOldGemAmount = $g_iGemAmount
EndIf
If $iOldCurrentLoot[$eLootGold] <> $g_aiCurrentLoot[$eLootGold] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultGoldNow, _NumberFormat($g_aiCurrentLoot[$eLootGold], True))
$iOldCurrentLoot[$eLootGold] = $g_aiCurrentLoot[$eLootGold]
EndIf
If $iOldCurrentLoot[$eLootElixir] <> $g_aiCurrentLoot[$eLootElixir] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultElixirNow, _NumberFormat($g_aiCurrentLoot[$eLootElixir], True))
$iOldCurrentLoot[$eLootElixir] = $g_aiCurrentLoot[$eLootElixir]
EndIf
If $iOldCurrentLoot[$eLootDarkElixir] <> $g_aiCurrentLoot[$eLootDarkElixir] And $g_iStatsStartedWith[$eLootDarkElixir] <> "" Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultDeNow, _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir], False))
$iOldCurrentLoot[$eLootDarkElixir] = $g_aiCurrentLoot[$eLootDarkElixir]
EndIf
If $iOldCurrentLoot[$eLootTrophy] <> $g_aiCurrentLoot[$eLootTrophy] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultTrophyNow, _NumberFormat($g_aiCurrentLoot[$eLootTrophy], True))
$iOldCurrentLoot[$eLootTrophy] = $g_aiCurrentLoot[$eLootTrophy]
EndIf
If $iOldTotalLoot[$eLootGold] <> $g_iStatsTotalGain[$eLootGold] And($g_iFirstAttack = 2 Or $ResetStats = 1) Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsTotalGain[$eLootGold], _NumberFormat($g_iStatsTotalGain[$eLootGold]))
$iOldTotalLoot[$eLootGold] = $g_iStatsTotalGain[$eLootGold]
EndIf
If $iOldTotalLoot[$eLootElixir] <> $g_iStatsTotalGain[$eLootElixir] And($g_iFirstAttack = 2 Or $ResetStats = 1) Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsTotalGain[$eLootElixir], _NumberFormat($g_iStatsTotalGain[$eLootElixir]))
$iOldTotalLoot[$eLootElixir] = $g_iStatsTotalGain[$eLootElixir]
EndIf
If $iOldTotalLoot[$eLootDarkElixir] <> $g_iStatsTotalGain[$eLootDarkElixir] And(($g_iFirstAttack = 2 And $g_iStatsStartedWith[$eLootDarkElixir] <> "") Or $ResetStats = 1) Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsTotalGain[$eLootDarkElixir], _NumberFormat($g_iStatsTotalGain[$eLootDarkElixir]))
$iOldTotalLoot[$eLootDarkElixir] = $g_iStatsTotalGain[$eLootDarkElixir]
EndIf
If $iOldTotalLoot[$eLootTrophy] <> $g_iStatsTotalGain[$eLootTrophy] And($g_iFirstAttack = 2 Or $ResetStats = 1) Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsTotalGain[$eLootTrophy], _NumberFormat($g_iStatsTotalGain[$eLootTrophy]))
$iOldTotalLoot[$eLootTrophy] = $g_iStatsTotalGain[$eLootTrophy]
EndIf
If $iOldLastLoot[$eLootGold] <> $g_iStatsLastAttack[$eLootGold] Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsLastAttack[$eLootGold], _NumberFormat($g_iStatsLastAttack[$eLootGold]))
$iOldLastLoot[$eLootGold] = $g_iStatsLastAttack[$eLootGold]
EndIf
If $iOldLastLoot[$eLootElixir] <> $g_iStatsLastAttack[$eLootElixir] Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsLastAttack[$eLootElixir], _NumberFormat($g_iStatsLastAttack[$eLootElixir]))
$iOldLastLoot[$eLootElixir] = $g_iStatsLastAttack[$eLootElixir]
EndIf
If $iOldLastLoot[$eLootDarkElixir] <> $g_iStatsLastAttack[$eLootDarkElixir] Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsLastAttack[$eLootDarkElixir], _NumberFormat($g_iStatsLastAttack[$eLootDarkElixir]))
$iOldLastLoot[$eLootDarkElixir] = $g_iStatsLastAttack[$eLootDarkElixir]
EndIf
If $iOldLastLoot[$eLootTrophy] <> $g_iStatsLastAttack[$eLootTrophy] Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsLastAttack[$eLootTrophy], _NumberFormat($g_iStatsLastAttack[$eLootTrophy]))
$iOldLastLoot[$eLootTrophy] = $g_iStatsLastAttack[$eLootTrophy]
EndIf
If $iOldLastBonus[$eLootGold] <> $g_iStatsBonusLast[$eLootGold] Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsBonusLast[$eLootGold], _NumberFormat($g_iStatsBonusLast[$eLootGold]))
$iOldLastBonus[$eLootGold] = $g_iStatsBonusLast[$eLootGold]
EndIf
If $iOldLastBonus[$eLootElixir] <> $g_iStatsBonusLast[$eLootElixir] Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsBonusLast[$eLootElixir], _NumberFormat($g_iStatsBonusLast[$eLootElixir]))
$iOldLastBonus[$eLootElixir] = $g_iStatsBonusLast[$eLootElixir]
EndIf
If $iOldLastBonus[$eLootDarkElixir] <> $g_iStatsBonusLast[$eLootDarkElixir] Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsBonusLast[$eLootDarkElixir], _NumberFormat($g_iStatsBonusLast[$eLootDarkElixir]))
$iOldLastBonus[$eLootDarkElixir] = $g_iStatsBonusLast[$eLootDarkElixir]
EndIf
If $iOldCostGoldWall <> $g_iCostGoldWall Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblWallUpgCostGold, _NumberFormat($g_iCostGoldWall, True))
$iOldCostGoldWall = $g_iCostGoldWall
EndIf
If $iOldCostElixirWall <> $g_iCostElixirWall Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblWallUpgCostElixir, _NumberFormat($g_iCostElixirWall, True))
$iOldCostElixirWall = $g_iCostElixirWall
EndIf
If $iOldCostGoldBuilding <> $g_iCostGoldBuilding Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblBuildingUpgCostGold, _NumberFormat($g_iCostGoldBuilding, True))
$iOldCostGoldBuilding = $g_iCostGoldBuilding
EndIf
If $iOldCostElixirBuilding <> $g_iCostElixirBuilding Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblBuildingUpgCostElixir, _NumberFormat($g_iCostElixirBuilding, True))
$iOldCostElixirBuilding = $g_iCostElixirBuilding
EndIf
If $iOldCostDElixirHero <> $g_iCostDElixirHero Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblHeroUpgCost, _NumberFormat($g_iCostDElixirHero, True))
$iOldCostDElixirHero = $g_iCostDElixirHero
EndIf
If $iOldSkippedVillageCount <> $g_iSkippedVillageCount Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultVillagesSkipped, _NumberFormat($g_iSkippedVillageCount, True))
If Not ProfileSwitchAccountEnabled() Then GUICtrlSetData($g_hLblResultSkippedHourNow, _NumberFormat($g_iSkippedVillageCount, True))
$iOldSkippedVillageCount = $g_iSkippedVillageCount
EndIf
If $iOldDroppedTrophyCount <> $g_iDroppedTrophyCount Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultTrophiesDropped, _NumberFormat($g_iDroppedTrophyCount, True))
$iOldDroppedTrophyCount = $g_iDroppedTrophyCount
EndIf
If $iOldNbrOfWallsUppedGold <> $g_iNbrOfWallsUppedGold Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblWallGoldMake, $g_iNbrOfWallsUppedGold)
$iOldNbrOfWallsUppedGold = $g_iNbrOfWallsUppedGold
WallsStatsMAJ()
EndIf
If $iOldNbrOfWallsUppedElixir <> $g_iNbrOfWallsUppedElixir Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblWallElixirMake, $g_iNbrOfWallsUppedElixir)
$iOldNbrOfWallsUppedElixir = $g_iNbrOfWallsUppedElixir
WallsStatsMAJ()
EndIf
If $iOldNbrOfBuildingsUppedGold <> $g_iNbrOfBuildingsUppedGold Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfBuildingUpgGold, $g_iNbrOfBuildingsUppedGold)
$iOldNbrOfBuildingsUppedGold = $g_iNbrOfBuildingsUppedGold
EndIf
If $iOldNbrOfBuildingsUppedElixir <> $g_iNbrOfBuildingsUppedElixir Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfBuildingUpgElixir, $g_iNbrOfBuildingsUppedElixir)
$iOldNbrOfBuildingsUppedElixir = $g_iNbrOfBuildingsUppedElixir
EndIf
If $iOldNbrOfHeroesUpped <> $g_iNbrOfHeroesUpped Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfHeroUpg, $g_iNbrOfHeroesUpped)
$iOldNbrOfHeroesUpped = $g_iNbrOfHeroesUpped
EndIf
If $iOldSearchCost <> $g_iSearchCost Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblSearchCost, _NumberFormat($g_iSearchCost, True))
$iOldSearchCost = $g_iSearchCost
EndIf
If $iOldTrainCostElixir <> $g_iTrainCostElixir Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTrainCostElixir, _NumberFormat($g_iTrainCostElixir, True))
$iOldTrainCostElixir = $g_iTrainCostElixir
EndIf
If $iOldTrainCostDElixir <> $g_iTrainCostDElixir Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTrainCostDElixir, _NumberFormat($g_iTrainCostDElixir, True))
$iOldTrainCostDElixir = $g_iTrainCostDElixir
EndIf
If $iOldNbrOfOoS <> $g_iNbrOfOoS Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfOoS, $g_iNbrOfOoS)
$iOldNbrOfOoS = $g_iNbrOfOoS
EndIf
If $iOldNbrOfTHSnipeFails <> $g_iNbrOfTHSnipeFails Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfTSFailed, $g_iNbrOfTHSnipeFails)
$iOldNbrOfTHSnipeFails = $g_iNbrOfTHSnipeFails
EndIf
If $iOldNbrOfTHSnipeSuccess <> $g_iNbrOfTHSnipeSuccess Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfTSSuccess, $g_iNbrOfTHSnipeSuccess)
$iOldNbrOfTHSnipeSuccess = $g_iNbrOfTHSnipeSuccess
EndIf
If $iOldGoldFromMines <> $g_iGoldFromMines Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblGoldFromMines, _NumberFormat($g_iGoldFromMines, True))
$iOldGoldFromMines = $g_iGoldFromMines
EndIf
If $iOldElixirFromCollectors <> $g_iElixirFromCollectors Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblElixirFromCollectors, _NumberFormat($g_iElixirFromCollectors, True))
$iOldElixirFromCollectors = $g_iElixirFromCollectors
EndIf
If $iOldDElixirFromDrills <> $g_iDElixirFromDrills Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblDElixirFromDrills, _NumberFormat($g_iDElixirFromDrills, True))
$iOldDElixirFromDrills = $g_iDElixirFromDrills
EndIf
For $i = 0 To $eTroopCount - 1
If $g_aiDonateStatsTroops[$i][0] <> $g_aiDonateStatsTroops[$i][1] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblDonTroop[$i], _NumberFormat($g_aiDonateStatsTroops[$i][0], True))
If $g_aiDonateStatsTroops[$i][0] > $g_aiDonateStatsTroops[$i][1] Then
$g_iTotalDonateStatsTroops +=($g_aiDonateStatsTroops[$i][0] - $g_aiDonateStatsTroops[$i][1])
$g_iTotalDonateStatsTroopsXP +=(($g_aiDonateStatsTroops[$i][0] - $g_aiDonateStatsTroops[$i][1]) * $g_aiTroopDonateXP[$i])
EndIf
$g_aiDonateStatsTroops[$i][1] = $g_aiDonateStatsTroops[$i][0]
$bDonateTroopsStatsChanged = True
EndIf
Next
If $bDonateTroopsStatsChanged Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTotalTroopsQ, _NumberFormat($g_iTotalDonateStatsTroops, True))
GUICtrlSetData($g_hLblTotalTroopsXP, _NumberFormat($g_iTotalDonateStatsTroopsXP, True))
$bDonateTroopsStatsChanged = False
EndIf
For $i = 0 To $eSpellCount - 1
If $g_aiDonateStatsSpells[$i][0] <> $g_aiDonateStatsSpells[$i][1] And $i <> $eSpellClone Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblDonSpell[$i], _NumberFormat($g_aiDonateStatsSpells[$i][0], True))
If $g_aiDonateStatsSpells[$i][0] > $g_aiDonateStatsSpells[$i][1] Then
$g_iTotalDonateStatsSpells +=($g_aiDonateStatsSpells[$i][0] - $g_aiDonateStatsSpells[$i][1])
$g_iTotalDonateStatsSpellsXP +=(($g_aiDonateStatsSpells[$i][0] - $g_aiDonateStatsSpells[$i][1]) * $g_aiSpellDonateXP[$i])
EndIf
$g_aiDonateStatsSpells[$i][1] = $g_aiDonateStatsSpells[$i][0]
$bDonateSpellsStatsChanged = True
EndIf
Next
If $bDonateSpellsStatsChanged Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTotalSpellsQ, _NumberFormat($g_iTotalDonateStatsSpells, True))
GUICtrlSetData($g_hLblTotalSpellsXP, _NumberFormat($g_iTotalDonateStatsSpellsXP, True))
$bDonateSpellsStatsChanged = False
EndIf
If $s_iOldSmartZapGain <> $g_iSmartZapGain Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblSmartZap, _NumberFormat($g_iSmartZapGain, True))
$s_iOldSmartZapGain = $g_iSmartZapGain
EndIf
If $s_iOldNumLSpellsUsed <> $g_iNumLSpellsUsed Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblSmartLightningUsed, _NumberFormat($g_iNumLSpellsUsed, True))
$s_iOldNumLSpellsUsed = $g_iNumLSpellsUsed
EndIf
If $s_iOldNumEQSpellsUsed <> $g_iNumEQSpellsUsed Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblSmartEarthQuakeUsed, _NumberFormat($g_iNumEQSpellsUsed, True))
$s_iOldNumEQSpellsUsed = $g_iNumEQSpellsUsed
EndIf
$g_aiAttackedCount = 0
For $i = 0 To $g_iModeCount
If $iOldAttackedVillageCount[$i] <> $g_aiAttackedVillageCount[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblAttacked[$i], _NumberFormat($g_aiAttackedVillageCount[$i], True))
$iOldAttackedVillageCount[$i] = $g_aiAttackedVillageCount[$i]
EndIf
$g_aiAttackedCount += $g_aiAttackedVillageCount[$i]
If $iOldTotalGoldGain[$i] <> $g_aiTotalGoldGain[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTotalGoldGain[$i], _NumberFormat($g_aiTotalGoldGain[$i], True))
$iOldTotalGoldGain[$i] = $g_aiTotalGoldGain[$i]
EndIf
If $iOldTotalElixirGain[$i] <> $g_aiTotalElixirGain[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTotalElixirGain[$i], _NumberFormat($g_aiTotalElixirGain[$i], True))
$iOldTotalElixirGain[$i] = $g_aiTotalElixirGain[$i]
EndIf
If $iOldTotalDarkGain[$i] <> $g_aiTotalDarkGain[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTotalDElixirGain[$i], _NumberFormat($g_aiTotalDarkGain[$i], True))
$iOldTotalDarkGain[$i] = $g_aiTotalDarkGain[$i]
EndIf
If $iOldTotalTrophyGain[$i] <> $g_aiTotalTrophyGain[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTotalTrophyGain[$i], _NumberFormat($g_aiTotalTrophyGain[$i], True))
$iOldTotalTrophyGain[$i] = $g_aiTotalTrophyGain[$i]
EndIf
Next
If $iOldAttackedCount <> $g_aiAttackedCount Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultVillagesAttacked, _NumberFormat($g_aiAttackedCount, True))
If Not ProfileSwitchAccountEnabled() Then GUICtrlSetData($g_hLblResultAttackedHourNow, _NumberFormat($g_aiAttackedCount, True))
$iOldAttackedCount = $g_aiAttackedCount
EndIf
For $i = 0 To $g_iModeCount
If $i = $TS Then ContinueLoop
If $iOldNbrOfDetectedMines[$i] <> $g_aiNbrOfDetectedMines[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfDetectedMines[$i], $g_aiNbrOfDetectedMines[$i])
$iOldNbrOfDetectedMines[$i] = $g_aiNbrOfDetectedMines[$i]
EndIf
If $iOldNbrOfDetectedCollectors[$i] <> $g_aiNbrOfDetectedCollectors[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfDetectedCollectors[$i], $g_aiNbrOfDetectedCollectors[$i])
$iOldNbrOfDetectedCollectors[$i] = $g_aiNbrOfDetectedCollectors[$i]
EndIf
If $iOldNbrOfDetectedDrills[$i] <> $g_aiNbrOfDetectedDrills[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfDetectedDrills[$i], $g_aiNbrOfDetectedDrills[$i])
$iOldNbrOfDetectedDrills[$i] = $g_aiNbrOfDetectedDrills[$i]
EndIf
Next
If $g_iFirstAttack = 2 Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootGold], _NumberFormat(Round($g_iStatsTotalGain[$eLootGold] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootElixir], _NumberFormat(Round($g_iStatsTotalGain[$eLootElixir] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
If $g_iStatsStartedWith[$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootDarkElixir], _NumberFormat(Round($g_iStatsTotalGain[$eLootDarkElixir] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h")
EndIf
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootTrophy], _NumberFormat(Round($g_iStatsTotalGain[$eLootTrophy] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h")
If Not ProfileSwitchAccountEnabled() Then
GUICtrlSetData($g_hLblResultGoldHourNow, _NumberFormat(Round($g_iStatsTotalGain[$eLootGold] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
GUICtrlSetData($g_hLblResultElixirHourNow, _NumberFormat(Round($g_iStatsTotalGain[$eLootElixir] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
If $g_iStatsStartedWith[$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_hLblResultDEHourNow, _NumberFormat(Round($g_iStatsTotalGain[$eLootDarkElixir] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h")
EndIf
EndIf
EndIf
If Number($g_iStatsLastAttack[$eLootGold]) > Number($topgoldloot) Then
$bStatsUpdated = True
$topgoldloot = $g_iStatsLastAttack[$eLootGold]
GUICtrlSetData($g_ahLblStatsTop[$eLootGold], _NumberFormat($topgoldloot))
EndIf
If Number($g_iStatsLastAttack[$eLootElixir]) > Number($topelixirloot) Then
$bStatsUpdated = True
$topelixirloot = $g_iStatsLastAttack[$eLootElixir]
GUICtrlSetData($g_ahLblStatsTop[$eLootElixir], _NumberFormat($topelixirloot))
EndIf
If Number($g_iStatsLastAttack[$eLootDarkElixir]) > Number($topdarkloot) Then
$bStatsUpdated = True
$topdarkloot = $g_iStatsLastAttack[$eLootDarkElixir]
GUICtrlSetData($g_ahLblStatsTop[$eLootDarkElixir], _NumberFormat($topdarkloot))
EndIf
If Number($g_iStatsLastAttack[$eLootTrophy]) > Number($topTrophyloot) Then
$bStatsUpdated = True
$topTrophyloot = $g_iStatsLastAttack[$eLootTrophy]
GUICtrlSetData($g_ahLblStatsTop[$eLootTrophy], _NumberFormat($topTrophyloot))
EndIf
For $i = 0 To UBound($g_aiCurrentLootBB) - 1
If $iOldCurrentLootBB[$i] <> $g_aiCurrentLootBB[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_alblBldBaseStats[$i], _NumberFormat($g_aiCurrentLootBB[$i], True))
$iOldCurrentLootBB[$i] = $g_aiCurrentLootBB[$i]
EndIf
Next
If ProfileSwitchAccountEnabled() Then
For $i = 0 To 7
GUICtrlSetData($g_ahLblResultGoldNowAcc[$i], _NumberFormat($g_aiGoldCurrentAcc[$i], True))
GUICtrlSetData($g_ahLblResultElixirNowAcc[$i], _NumberFormat($g_aiElixirCurrentAcc[$i], True))
GUICtrlSetData($g_ahLblResultDENowAcc[$i], _NumberFormat($g_aiDarkCurrentAcc[$i], False))
GUICtrlSetData($g_ahLblResultTrophyNowAcc[$i], _NumberFormat($g_aiTrophyCurrentAcc[$i], True))
If $g_aiGemAmountAcc[$i] < 10000 Then
GUICtrlSetData($g_ahLblResultGemNowAcc[$i], _NumberFormat($g_aiGemAmountAcc[$i], True))
Else
GUICtrlSetData($g_ahLblResultGemNowAcc[$i], Round($g_aiGemAmountAcc[$i]/1000,1) & " k")
EndIf
GUICtrlSetData($g_ahLblResultBuilderNowAcc[$i], $g_aiFreeBuilderCountAcc[$i] & "/" & $g_aiTotalBuilderCountAcc[$i])
GUICtrlSetData($g_ahLblPersonalBreak[$i], $g_aiPersonalBreak[$i])
GUICtrlSetData($g_ahLblHourlyStatsGoldAcc[$i], _NumberFormat(Round($g_aiGoldTotalAcc[$i] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
GUICtrlSetData($g_ahLblHourlyStatsElixirAcc[$i], _NumberFormat(Round($g_aiElixirTotalAcc[$i] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
GUICtrlSetData($g_ahLblHourlyStatsDarkAcc[$i], _NumberFormat(Round($g_aiDarkTotalAcc[$i] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h")
GUICtrlSetData($g_ahLblHourlyStatsTrophyAcc[$i], _NumberFormat(Round($g_aiTrophyLootAcc[$i] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h")
If $g_aiAttackedCountAcc[$i] < 10000 Then
GUICtrlSetData($g_ahLblResultAttacked[$i], $g_aiAttackedCountAcc[$i])
Else
GUICtrlSetData($g_ahLblResultAttacked[$i], Round($g_aiAttackedCountAcc[$i]/1000,1) & " k")
EndIf
Next
GUICtrlSetData($g_hLblResultSkippedHourNow, $g_aiSkippedVillageCountAcc[$g_iCurAccount])
GUICtrlSetData($g_hLblResultAttackedHourNow, $g_aiAttackedCountAcc[$g_iCurAccount])
If $g_iFirstAttack = 2 Then
GUICtrlSetData($g_hLblResultGoldHourNow, _NumberFormat(Round($g_aiGoldTotalAcc[$g_iCurAccount] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
GUICtrlSetData($g_hLblResultElixirHourNow, _NumberFormat(Round($g_aiElixirTotalAcc[$g_iCurAccount] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
GUICtrlSetData($g_hLblResultDEHourNow, _NumberFormat(Round($g_aiDarkTotalAcc[$g_iCurAccount] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h")
EndIf
EndIf
If $ResetStats = 1 Then
$ResetStats = 0
EndIf
If $bStatsUpdated And $g_iGuiMode = 0 Then
UpdateStatsManagedMyBotHost()
EndIf
EndFunc
Func ResetStats()
$ResetStats = 1
$g_iFirstAttack = 0
$g_iTimePassed = 0
$g_hTimerSinceStarted = __TimerInit()
GUICtrlSetData($g_hLblResultRuntime, "00:00:00")
GUICtrlSetData($g_hLblResultRuntimeNow, "00:00:00")
$g_iStatsStartedWith[$eLootGold] = $g_aiCurrentLoot[$eLootGold]
$g_iStatsStartedWith[$eLootElixir] = $g_aiCurrentLoot[$eLootElixir]
$g_iStatsStartedWith[$eLootDarkElixir] = $g_aiCurrentLoot[$eLootDarkElixir]
$g_iStatsStartedWith[$eLootTrophy] = $g_aiCurrentLoot[$eLootTrophy]
$g_iStatsTotalGain[$eLootGold] = 0
$g_iStatsTotalGain[$eLootElixir] = 0
$g_iStatsTotalGain[$eLootDarkElixir] = 0
$g_iStatsTotalGain[$eLootTrophy] = 0
$g_iStatsLastAttack[$eLootGold] = 0
$g_iStatsLastAttack[$eLootElixir] = 0
$g_iStatsLastAttack[$eLootDarkElixir] = 0
$g_iStatsLastAttack[$eLootTrophy] = 0
$g_iStatsBonusLast[$eLootGold] = 0
$g_iStatsBonusLast[$eLootElixir] = 0
$g_iStatsBonusLast[$eLootDarkElixir] = 0
$g_iSkippedVillageCount = 0
$g_iDroppedTrophyCount = 0
$g_iCostGoldWall = 0
$g_iCostElixirWall = 0
$g_iCostGoldBuilding = 0
$g_iCostElixirBuilding = 0
$g_iCostDElixirHero = 0
$g_iNbrOfWallsUppedGold = 0
$g_iNbrOfWallsUppedElixir = 0
$g_iNbrOfBuildingsUppedGold = 0
$g_iNbrOfBuildingsUppedElixir = 0
$g_iNbrOfHeroesUpped = 0
$g_iSearchCost = 0
$g_iTrainCostElixir = 0
$g_iTrainCostDElixir = 0
$g_iNbrOfOoS = 0
$g_iNbrOfTHSnipeFails = 0
$g_iNbrOfTHSnipeSuccess = 0
$g_iGoldFromMines = 0
$g_iElixirFromCollectors = 0
$g_iDElixirFromDrills = 0
$g_iSmartZapGain = 0
$g_iNumLSpellsUsed = 0
$g_iNumEQSpellsUsed = 0
For $i = 0 To $g_iModeCount
$g_aiAttackedVillageCount[$i] = 0
$g_aiTotalGoldGain[$i] = 0
$g_aiTotalElixirGain[$i] = 0
$g_aiTotalDarkGain[$i] = 0
$g_aiTotalTrophyGain[$i] = 0
$g_aiNbrOfDetectedMines[$i] = 0
$g_aiNbrOfDetectedCollectors[$i] = 0
$g_aiNbrOfDetectedDrills[$i] = 0
Next
For $i = 0 To $eTroopCount - 1
$g_aiDonateStatsTroops[$i][0] = 0
Next
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
$g_aiDonateStatsSpells[$i][0] = 0
EndIf
Next
$g_iTotalDonateStatsTroops = 0
$g_iTotalDonateStatsTroopsXP = 0
$g_iTotalDonateStatsSpells = 0
$g_iTotalDonateStatsSpellsXP = 0
If ProfileSwitchAccountEnabled() Then
For $i = 0 To $g_iTotalAcc
$g_aiGoldTotalAcc[$i] = 0
$g_aiElixirTotalAcc[$i] = 0
$g_aiDarkTotalAcc[$i] = 0
$g_aiTrophyLootAcc[$i] = 0
$g_aiAttackedCountAcc[$i] = 0
$g_aiSkippedVillageCountAcc[$i] = 0
Next
EndIf
UpdateStats()
EndFunc
Func WallsStatsMAJ()
$g_aiWallsCurrentCount[$g_iCmbUpgradeWallsLevel + 4] -= Number($g_iNbrOfWallsUpped)
$g_aiWallsCurrentCount[$g_iCmbUpgradeWallsLevel + 5] += Number($g_iNbrOfWallsUpped)
$g_iNbrOfWallsUpped = 0
For $i = 4 To 13
GUICtrlSetData($g_ahWallsCurrentCount[$i], $g_aiWallsCurrentCount[$i])
Next
SaveConfig()
EndFunc
Func UpdateStats_ClearArray(ByRef $a)
For $i = 0 To UBound($a) - 1
$a[$i] = 0
Next
EndFunc
Global $g_sLastVersion = ""
Global $g_sLastMessage = ""
Global $g_sOldVersionMessage = ""
Func CheckVersion()
If $g_bCheckVersion Then
CheckVersionHTML()
If $g_sLastVersion = "" Then
SetLog("WE CANNOT OBTAIN PRODUCT VERSION AT THIS TIME", $COLOR_ACTION)
ElseIf VersionNumFromVersionTXT($g_sBotVersion) < VersionNumFromVersionTXT($g_sLastVersion) Then
SetLog("WARNING, YOUR BOT VERSION (" & $g_sBotVersion & ") IS OUT OF DATE.", $COLOR_ERROR)
SetLog("PLEASE DOWNLOAD THE LATEST(" & $g_sLastVersion & ") FROM https://MyBot.run               ", $COLOR_ERROR)
SetLog(" ")
_PrintLogVersion($g_sOldVersionMessage)
PushMsg("Update")
ElseIf VersionNumFromVersionTXT($g_sBotVersion) > VersionNumFromVersionTXT($g_sLastVersion) Then
SetLog("YOU ARE USING A FUTURE VERSION OF MYBOT CHIEF!", $COLOR_SUCCESS)
SetLog("YOUR VERSION: " & $g_sBotVersion, $COLOR_SUCCESS)
SetLog("OFFICIAL VERSION: " & $g_sLastVersion, $COLOR_SUCCESS)
SetLog(" ")
Else
SetLog("WELCOME CHIEF, YOU HAVE THE LATEST VERSION OF THE BOT", $COLOR_SUCCESS)
SetLog(" ")
_PrintLogVersion($g_sLastMessage)
EndIf
EndIf
EndFunc
Func CheckVersionHTML()
Local $versionfile = @ScriptDir & "\LastVersion.txt"
If FileExists(@ScriptDir & "\TestVersion.txt") Then
FileCopy(@ScriptDir & "\TestVersion.txt", $versionfile, 1)
Else
Local $hDownload = InetGet("https://raw.githubusercontent.com/MyBotRun/MyBot/master/LastVersion.txt", $versionfile, 0, 1)
Local $i = 0
Do
Sleep($DELAYCHECKVERSIONHTML1)
$i += 1
Until InetGetInfo($hDownload, $INET_DOWNLOADCOMPLETE) Or $i > 25
InetClose($hDownload)
EndIf
Local $line, $line2, $Casesense = 0, $chkvers = False, $chkmsg = False, $chkmsg2 = False, $i = 0
$g_sLastVersion = ""
If FileExists($versionfile) Then
$g_sLastVersion = IniRead($versionfile, "general", "version", "")
Local $versionfilelocalized = @ScriptDir & "\LastVersion_" & $g_sLanguage & ".txt"
If FileExists(@ScriptDir & "\TestVersion_" & $g_sLanguage & ".txt") Then
FileCopy(@ScriptDir & "\TestVersion_" & $g_sLanguage & ".txt", $versionfilelocalized, 1)
Else
$hDownload = InetGet("https://raw.githubusercontent.com/MyBotRun/MyBot/master/LastVersion_" & $g_sLanguage & ".txt", $versionfilelocalized, 0, 1)
Local $i = 0
Do
Sleep($DELAYCHECKVERSIONHTML1)
$i += 1
Until InetGetInfo($hDownload, $INET_DOWNLOADCOMPLETE) Or $i > 25
InetClose($hDownload)
EndIf
If FileExists($versionfilelocalized) Then
$g_sLastMessage = IniRead($versionfilelocalized, "general", "messagenew", "")
$g_sOldVersionMessage = IniRead($versionfilelocalized, "general", "messageold", "")
FileDelete($versionfilelocalized)
Else
$g_sLastMessage = IniRead($versionfile, "general", "messagenew", "")
$g_sOldVersionMessage = IniRead($versionfile, "general", "messageold", "")
EndIf
FileDelete($versionfile)
EndIf
EndFunc
Func VersionNumFromVersionTXT($versionTXT)
Local $versionTXT_clean
If StringInStr($versionTXT, " ") Then
$versionTXT_clean = StringLeft($versionTXT, StringInStr($versionTXT, " ") - 1)
Else
$versionTXT_clean = $versionTXT
EndIf
Local $resultnumber = 0
If StringLeft($versionTXT_clean, 1) = "v" Then
Local $versionTXT_Vector = StringSplit(StringMid($versionTXT_clean, 2, -1), ".")
Local $multiplier = 1000000
If UBound($versionTXT_Vector) > 0 Then
For $i = 1 To UBound($versionTXT_Vector) - 1
$resultnumber = $resultnumber + Number($versionTXT_Vector[$i]) * $multiplier
$multiplier = $multiplier / 1000
Next
Else
$resultnumber = Number($versionTXT_Vector) * $multiplier
EndIf
EndIf
Return $resultnumber
EndFunc
Func _PrintLogVersion($message)
Local $messagevet = StringSplit($message, "\n", 1)
If Not(IsArray($messagevet)) Then
SetLog($message)
Else
For $i = 1 To $messagevet[0]
If StringLen($messagevet[$i]) <= 53 Then
SetLog($messagevet[$i], $COLOR_BLACK, "Lucida Console", 8.5)
Else
While StringLen($messagevet[$i]) > 53
Local $sp = StringInStr(StringLeft($messagevet[$i], 53), " ", 0, -1)
If $sp = 0 Then
Local $sp = StringInStr($messagevet[$i], " ", 0)
If $sp = 0 Then
SetLog($messagevet[$i], $COLOR_BLACK, "Lucida Console", 8.5)
Else
SetLog(StringLeft($messagevet[$i], $sp), $COLOR_BLACK, "Lucida Console", 8.5)
$messagevet[$i] = StringMid($messagevet[$i], $sp + 1, -1)
EndIf
Else
SetLog(StringLeft($messagevet[$i], $sp), $COLOR_BLACK, "Lucida Console", 8.5)
$messagevet[$i] = StringMid($messagevet[$i], $sp + 1, -1)
EndIf
WEnd
If StringLen($messagevet[$i]) > 0 Then SetLog($messagevet[$i], $COLOR_BLACK, "Lucida Console", 8.5)
EndIf
Next
EndIf
EndFunc
Func GetVersionNormalized($VersionString, $Chars = 5)
If StringLeft($VersionString, 1) = "v" Then $VersionString = StringMid($VersionString, 2)
Local $a = StringSplit($VersionString, ".", 2)
Local $i
For $i = 0 To UBound($a) - 1
If StringLen($a[$i]) < $Chars Then $a[$i] = _StringRepeat("0", $Chars - StringLen($a[$i])) & $a[$i]
Next
Return _ArrayToString($a, ".")
EndFunc
Func CloseRunningBot($sBotWindowTitle = $g_sBotTitle, $bCheckOnly = False, $bGuiInitialized = IsHWnd($g_hFrmBot))
Local $param = ""
For $i = 1 To $g_asCmdLine[0]
If $param <> "" Then $param &= " "
$param &= $g_asCmdLine[$i]
Next
Local $pid = 0
Local $otherPID = 0
Local $otherHWnD = 0
Local $otherPIDs = 0
If $param <> "" Then
$otherPIDs = ProcessesExist(@AutoItExe, $param, 1, 1, Default, True)
EndIf
Local $otherHWnDs = WinList($sBotWindowTitle)
Local $iExpectedWindows =(($bGuiInitialized) ?(1) :(0))
If $otherHWnDs[0][0] > $iExpectedWindows Or UBound($otherPIDs) > $iExpectedWindows Then
For $i = 1 To $otherHWnDs[0][0]
$pid = WinGetProcess($otherHWnDs[$i][1])
If $pid <> @AutoItPID Then
$otherPID = $pid
$otherHWnD = $otherHWnDs[$i][1]
ExitLoop
EndIf
Next
If $otherPID = 0 And UBound($otherPIDs) > $iExpectedWindows Then
For $aProcess In $otherPIDs
$pid = $aProcess[0]
Local $sCommandLine = $aProcess[2]
If $pid <> @AutoItPID And StringInStr($sCommandLine, "AutoIt3Wrapper.au3") = 0 Then
$otherPID = $pid
ExitLoop
EndIf
Next
EndIf
If $otherPID > 0 And $otherPID <> @AutoItPID Then
If $bCheckOnly = True Then
Return True
EndIf
SetDebugLog("Found existing " & $sBotWindowTitle & " instance to close, PID " & $otherPID & ", HWnD " & $otherHWnD)
WerFaultClose("AutoIt v3 Script")
WerFaultClose(@AutoItExe)
SetDebugLog("Send close message...")
_WinAPI_PostMessage($otherHWnD, $WM_CLOSE, 0, 0)
If ProcessWaitClose($otherPID, 30) = 0 Then
SetDebugLog("Existing bot window still there...")
WinKill($otherHWnD)
SetDebugLog("Existing bot window killed")
EndIf
If ProcessExists($otherPID) = $otherPID Then
SetDebugLog("Existing bot process still there...")
If KillProcess($otherPID, "CloseRunningBot") = True Then
SetDebugLog("Existing bot process now closed")
Return True
EndIf
Return False
EndIf
Return True
EndIf
EndIf
Return False
EndFunc
Func RestartBot($bCloseAndroid = True, $bAutostart = True)
SetDebugLog("Restart " & $g_sBotTitle)
Local $sCmdLine = ProcessGetCommandLine(@AutoItPID)
If @error <> 0 Then
SetLog("Cannot prepare to restart " & $g_sBotTitle & ", error code " & @error, $COLOR_RED)
Return SetError(1, 0, False)
EndIf
If $bAutostart = True Then
IniWrite($g_sProfileConfigPath, "general", "Restarted", 1)
EndIf
If StringInStr($sCmdLine, " /restart") = 0 Then
$sCmdLine &= " /restart"
EndIf
If $bCloseAndroid = True Then
CloseAndroid("RestartBot")
_Sleep(1000)
EndIf
Local $pid = Run("cmd.exe /c start """" " & $sCmdLine, $g_sWorkingDir, @SW_HIDE)
If @error = 0 Then
SetLog("Restarting " & $g_sBotTitle)
_SleepStatus(60 * 1000)
Return True
Else
SetLog("Cannot restart " & $g_sBotTitle, $COLOR_RED)
EndIf
Return SetError(2, 0, False)
EndFunc
Func WindowSystemMenu($HWnD, $iButton, $Action = Default, $DebugInfo = "")
Local $hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, False)
If $Action = Default Then
Return _GUICtrlMenu_GetItemID($hSysMenu, $iButton, False) <> 0
EndIf
Local $enabled = WindowSystemMenu($HWnD, $iButton)
If $Action <> $enabled Then
Local $i, $c = _GUICtrlMenu_GetItemCount($hSysMenu)
Local $aVisible[$c]
For $i = 0 To $c - 1
$aVisible[$i] = _GUICtrlMenu_GetItemID($hSysMenu, $i)
Next
_GUICtrlMenu_GetSystemMenu($HWnD, True)
$hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, False)
_GUICtrlMenu_DrawMenuBar($HWnD)
$c = _GUICtrlMenu_GetItemCount($hSysMenu)
If $DebugInfo = "" Then $DebugInfo = $iButton
For $i = 0 To $c - 1
Local $id = _GUICtrlMenu_GetItemID($hSysMenu, $i)
If $id = $iButton Then
If $Action = False Then
SetDebugLog("Hide SystemMenu Item: " & $DebugInfo)
_GUICtrlMenu_RemoveMenu($hSysMenu, $i)
Else
SetDebugLog("Show SystemMenu Item: " & $DebugInfo)
EndIf
ElseIf  _ArraySearch($aVisible, $id) = -1 Then
_GUICtrlMenu_RemoveMenu($hSysMenu, $i)
EndIf
Next
EndIf
EndFunc
Global $g_hWaitableTimerWakeUp = 0
Func SetWakeUpSeconds($iInSecs)
SetDebugLog("SetWakeUpTime: " & $iInSecs & " Seconds")
If $g_hWaitableTimerWakeUp Then _WinAPI_CloseHandle($g_hWaitableTimerWakeUp)
Local $result = DllCall("kernel32.dll", "long", "CreateWaitableTimer", "long", 0, "boolean", True, "str", "")
If $result[0] = 0 Then
Local $lastError = DllCall("kernel32.dll", "int", "GetLastError")
SetExtended($lastError[0])
SetError(1)
Return 0
EndIf
$g_hWaitableTimerWakeUp = $result[0]
DllCall("kernel32.dll", "none", "CancelWaitableTimer", "long", $g_hWaitableTimerWakeUp)
Local $iNanoSecs = -$iInSecs * 1000 * 1000 * 10
$result = DllCall("kernel32.dll", "boolean", "SetWaitableTimer", "handle", $g_hWaitableTimerWakeUp, "INT64*", $iNanoSecs, "long", 0, "ptr", 0, "ptr", 0, "boolean", True)
If $result[0] = 0 Then
Local $lastError = DllCall("kernel32.dll", "int", "GetLastError")
SetExtended($lastError[0])
SetError(2)
Return 0
EndIf
Return 1
EndFunc
Func SetSuspend($bSuspend = True, $bForce = True)
Local $bDisableWakeEvent = False
Local $result = DllCall("PowrProf.dll", "boolean", "SetSuspendState", "boolean", Not $bSuspend, "boolean", $bForce, "boolean", $bDisableWakeEvent)
If @error Or UBound($result) = 0 Then
Local $lastError = DllCall("kernel32.dll", "int", "GetLastError")
SetExtended($lastError[0])
SetError(1)
Return 0
EndIf
Return $result[0]
EndFunc
Func _ObjErrMsg($sFunctionName, $iErrorCode)
SetDebugLog("Dictionary Error: " & $sFunctionName & " code: " & $iErrorCode, $COLOR_ERROR, True)
EndFunc
Func _ObjAdd(ByRef $oDICT, $KEY, $VALUE)
If Not IsObj($oDICT) Then
SetError(1)
Return -1
ElseIf $KEY = '' Then
SetError(2)
Return -1
ElseIf $VALUE = '' Then
SetError(3)
Return -1
ElseIf $oDICT.Exists($KEY) Then
SetError(4)
Return -1
EndIf
$oDICT.Add($KEY, $VALUE)
Return 0
EndFunc
Func _ObjPutValue(ByRef $oDICT, $KEY, $VALUE)
If Not IsObj($oDICT) Then
SetError(1)
Return -1
ElseIf $KEY = '' Then
SetError(2)
Return -1
ElseIf $VALUE = '' Then
SetError(3)
Return -1
EndIf
If $oDICT.Exists($KEY) Then
$oDICT.Item($KEY) = $VALUE
Else
$oDICT.Add($KEY, $VALUE)
EndIf
Return 0
EndFunc
Func _ObjGetValue(ByRef $oDICT, $KEY)
If Not IsObj($oDICT) Then
SetError(1)
Return -1
ElseIf $KEY = '' Then
SetError(2)
Return -1
ElseIf Not $oDICT.Exists($KEY) Then
SetError(5)
Return -1
EndIf
Return $oDICT.Item($KEY)
EndFunc
Func _ObjSearch(ByRef $oDICT, $KEY)
If Not IsObj($oDICT) Then
SetError(1)
Return -1
ElseIf $KEY = '' Then
SetError(2)
Return -1
ElseIf Not $oDICT.Exists($KEY) Then
Return False
Else
Return True
EndIf
EndFunc
Func _ObjDeleteKey(ByRef $oDICT, $KEY = '')
If Not IsObj($oDICT) Then
SetError(1)
Return -1
EndIf
If $KEY = '' Then
$oDICT.RemoveAll
Return 0
ElseIf Not $oDICT.Exists($KEY) Then
SetError(5)
Return -1
EndIf
$oDICT.Remove($KEY)
Return 0
EndFunc
Func _LogObjList(ByRef $oDICT)
If Not IsObj($oDICT) Then
SetLog("_LogObjList parameter is not object dictionary!", $COLOR_ERROR)
SetError(1)
Return -1
EndIf
Local $count = $oDICT.Count
If $count > 0 Then
Local $strKey, $Text, $array, $TotalTime
Local $colKeys = $oDICT.Keys
For $strKey In $colKeys
$Text = ""
If IsArray($oDICT.Item($strKey)) Then
$array = $oDICT.Item($strKey)
$Text = "Array Contents: "
Select
Case UBound($array, 1) > 1 And IsArray($array[1])
$Text &= PixelArrayToString($array, ",")
Case UBound($array[0]) = 2
Local $aPixel = $array[0]
$Text &= PixelToString($aPixel, ";")
Case UBound($array) = 2 And IsArray($array[0]) = 0
$Text &= PixelToString($array, ":")
Case Else
$Text = "Monkey found bad banana!"
EndSelect
Else
$Text = $oDICT.Item($strKey)
If StringInStr($strKey, "FINDTIME", $STR_NOCASESENSEBASIC) Then $TotalTime += Number($Text)
EndIf
SetLog("Dictionary Key: " & StringFormat("[%18s]", $strKey) & " = " & $Text, $COLOR_DEBUG)
Next
SetLog("Key Summary: " & StringFormat("[%18s]", "TOTAL FINDTIME") & " = " & $TotalTime, $COLOR_DEBUG)
EndIf
EndFunc
Func IsPageLoop($aCheckPixel, $iLoop = 30, $bCapturePixel = $g_bCapturePixel)
$bCapturePixel = $bCapturePixel Or $iLoop > 1
Local $IsPage = False
Local $i = 0
While $i < $iLoop
ForceCaptureRegion()
If _CheckPixel($aCheckPixel, $bCapturePixel) Then
$IsPage = True
ExitLoop
EndIf
If _Sleep($DELAYISTRAINPAGE2) Then ExitLoop
$i += 1
WEnd
Return $IsPage
EndFunc
Func IsTrainPage($bSetLog = True, $iLoop = 30)
If IsPageLoop($aIsTrainPgChk1, $iLoop) Then
If($g_bDebugSetlog Or $g_bDebugClick) And $bSetLog Then SetLog("**Army Window OK**", $COLOR_ACTION)
Return True
EndIf
If $bSetLog Then SetLog("Cannot find Army Window...", $COLOR_ERROR)
If $g_bDebugImageSave Then DebugImageSave("IsTrainPage")
If $iLoop > 1 Then AndroidPageError("IsTrainPage")
Return False
EndFunc
Func IsAttackPage($bCapturePixel = $g_bCapturePixel)
If IsPageLoop($aIsAttackPage, 1, $bCapturePixel) Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Attack Window OK**", $COLOR_ACTION)
Return True
EndIf
If $g_bDebugSetlog Or $g_bDebugClick Then
Local $colorRead = _GetPixelColor($aIsAttackPage[0], $aIsAttackPage[1], $bCapturePixel)
SetLog("**Attack Window FAIL**", $COLOR_ACTION)
SetLog("expected in (" & $aIsAttackPage[0] & "," & $aIsAttackPage[1] & ")  = " & Hex($aIsAttackPage[2], 6) & " - Found " & $colorRead, $COLOR_ACTION)
EndIf
If $g_bDebugImageSave Then DebugImageSave("IsAttackPage")
Return False
EndFunc
Func IsAttackWhileShieldPage($bSaveDebugImage = True)
If IsPageLoop($aIsAttackShield, 1) Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Attack Shield Window Open**", $COLOR_ACTION)
Return True
EndIf
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Attack Shield Window not open**", $COLOR_ACTION)
If $g_bDebugImageSave And $bSaveDebugImage Then DebugImageSave("IsAttackWhileShieldPage_")
Return False
EndFunc
Func IsMainPage($iLoop = 30)
If IsPageLoop($aIsMain, $iLoop) Then
$g_bMainWindowOk = True
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Main Window OK**", $COLOR_ACTION)
Return True
EndIf
$g_bMainWindowOk = False
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Main Window FAIL**", $COLOR_ACTION)
If $g_bDebugImageSave Then DebugImageSave("IsMainPage")
If $iLoop > 1 Then AndroidPageError("IsMainPage")
Return False
EndFunc
Func IsMainPageBuilderBase($iLoop = 30)
If IsPageLoop($aIsOnBuilderBase, $iLoop) Then
$g_bMainWindowOk = True
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Main Window Builder Base OK**", $COLOR_ACTION)
Return True
EndIf
$g_bMainWindowOk = False
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Main Window Builder Base FAIL**", $COLOR_ACTION)
If $g_bDebugImageSave Then DebugImageSave("IsMainPageBuilderBase")
If $iLoop > 1 Then AndroidPageError("IsMainPageBase")
Return False
EndFunc
Func IsMainChatOpenPage()
If IsPageLoop($aChatTab, 1) Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Chat Open Window OK**", $COLOR_ACTION)
Return True
EndIf
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Chat Open Window FAIL** " & $aChatTab[0] & "," & $aChatTab[1] & " " & _GetPixelColor($aChatTab[0], $aChatTab[1], True), $COLOR_ACTION)
If $g_bDebugImageSave Then DebugImageSave("IsMainChatOpenPage")
Return False
EndFunc
Func IsClanInfoPage()
If IsPageLoop($aPerkBtn, 1) Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Clan Info Window OK**", $COLOR_ACTION)
Return True
EndIf
Local $result = _ColorCheck(_GetPixelColor(214, 106, True), Hex(0xFFFFFF, 6), 1) And _ColorCheck(_GetPixelColor(815, 58, True), Hex(0xD80402, 6), 5)
If $result Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Clan Info Window OK**", $COLOR_ACTION)
SetLog("Join a Clan to donate and receive troops!", $COLOR_ACTION)
Return True
Else
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Clan Info Window FAIL**", $COLOR_ACTION)
If $g_bDebugImageSave Then DebugImageSave("IsClanInfoPage")
Return False
EndIf
EndFunc
Func IsLaunchAttackPage()
Local $resultnoshield = IsPageLoop($aFindMatchButton, 1)
Local $resultwithshield = IsPageLoop($aFindMatchButton2, 1)
If $resultnoshield Or $resultwithshield Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Launch Attack Window OK**", $COLOR_ACTION)
Return True
EndIf
If $g_bDebugSetlog Or $g_bDebugClick Then
Local $colorReadnoshield = _GetPixelColor($aFindMatchButton[0], $aFindMatchButton[1], True)
Local $colorReadwithshield = _GetPixelColor($aFindMatchButton2[0], $aFindMatchButton2[1], True)
SetLog("**Launch Attack Window FAIL**", $COLOR_ACTION)
SetLog("expected in (" & $aFindMatchButton[0] & "," & $aFindMatchButton[1] & ")  = " & Hex($aFindMatchButton[2], 6) & " or " & Hex($aFindMatchButton2[2], 6) & " - Found " & $colorReadnoshield & " or " & $colorReadwithshield, $COLOR_ACTION)
EndIf
If $g_bDebugImageSave Then DebugImageSave("IsLaunchAttackPage")
Return False
EndFunc
Func IsEndBattlePage($bWriteLog = True)
If IsPageLoop($aConfirmSurrender, 1) Then
If($g_bDebugSetlog Or $g_bDebugClick) And $bWriteLog Then SetLog("**End Battle Window OK**", $COLOR_ACTION)
Return True
Else
If($g_bDebugSetlog Or $g_bDebugClick) And $bWriteLog Then
Local $colorRead = _GetPixelColor($aConfirmSurrender[0], $aConfirmSurrender[1], True)
SetLog("**End Battle Window FAIL**", $COLOR_ACTION)
SetLog("expected in (" & $aConfirmSurrender[0] & "," & $aConfirmSurrender[1] & ")  = " & Hex($aConfirmSurrender[2], 6) & " - Found " & $colorRead, $COLOR_ACTION)
EndIf
If $g_bDebugImageSave And $bWriteLog Then DebugImageSave("IsEndBattlePage")
Return False
EndIf
EndFunc
Func IsReturnHomeBattlePage($useReturnValue = False, $makeDebugImageScreenshot = True)
If IsPageLoop($aReturnHomeButton, 1) Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Return Home Battle Window OK**", $COLOR_ACTION)
Return True
EndIf
If($g_bDebugSetlog Or $g_bDebugClick) And($makeDebugImageScreenshot = True) Then SetLog("**Return Home Battle Window FAIL**", $COLOR_ACTION)
If $g_bDebugImageSave And $makeDebugImageScreenshot Then DebugImageSave("IsReturnHomeBattlePage")
If $useReturnValue Then
Return False
Else
Return True
EndIf
EndFunc
Func IsPostDefenseSummaryPage($bCapture = True)
Local $result
Local $GoldSpot = _GetPixelColor(330, 201 + $g_iMidOffsetY, $bCapture)
Local $ElixirSpot = _GetPixelColor(334, 233 + $g_iMidOffsetY, $bCapture)
$result = _ColorCheck($GoldSpot, Hex(0xF6E851, 6), 20) And _ColorCheck($ElixirSpot, Hex(0xE835E8, 6), 20)
If $result Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Post Defense Page visible**", $COLOR_ACTION)
Return True
Else
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Post Defense Page not visible**", $COLOR_ACTION)
If $g_bDebugImageSave Then DebugImageSave("IsPostDefenseSummaryPage")
Return False
EndIf
EndFunc
Func MoveMouseOutBS()
If $g_bMoveMouseOutBS = False Then Return
Local $hWindow, $txtTitleW, $hControl, $aMousePos
$aMousePos = MouseGetPos()
If IsArray($aMousePos) Then
$hControl = _WindowFromPoint($aMousePos[0], $aMousePos[1])
If $hControl <> 0 Then
$hWindow = _WinAPI_GetAncestor($hControl, 2)
$txtTitleW = WinGetTitle($hWindow)
If $hWindow = $g_hAndroidWindow And $txtTitleW == $g_sAndroidTitle Then
MouseMove(@DesktopWidth + 100, Round(@DesktopHeight / 2), 0)
SetLog("Keep Your Mouse Out of BlueStacks Window while bot is running", $COLOR_ERROR)
EndIf
EndIf
EndIf
EndFunc
Func _WindowFromPoint($iX, $iY)
Local $aRet, $stPoint = DllStructCreate("long;long")
DllStructSetData($stPoint, 1, $iX)
DllStructSetData($stPoint, 2, $iY)
Local $stInt64 = DllStructCreate("int64", DllStructGetPtr($stPoint))
$aRet = DllCall("user32.dll", "hwnd", "WindowFromPoint", "int64", DllStructGetData($stInt64, 1))
$stPoint = 0
$stInt64 = 0
If @error Then Return SetError(0, 0, 0)
If $aRet[0] = 0 Then Return SetError(0, 0, 0)
Return $aRet[0]
EndFunc
Func KillProcess($pid, $process_info = "", $attempts = 3)
Local $iCount = 0
If $process_info <> "" Then $process_info = ", " & $process_info
While ProcessExists($pid) And $iCount < $attempts
If ProcessClose($pid) = 1 Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " closed" & $process_info)
Else
Switch @error
Case 1
SetDebugLog("Process close error: OpenProcess failed")
Case 2
SetDebugLog("Process close error: AdjustTokenPrivileges Failed")
Case 3
SetDebugLog("Process close error: TerminateProcess Failed")
Case 4
SetDebugLog("Process close error: Cannot verify if process exists")
EndSwitch
EndIf
If ProcessExists($pid) Then
ShellExecute(@WindowsDir & "\System32\taskkill.exe", " -pid " & $pid, "", Default, @SW_HIDE)
If _Sleep(1000) Then Return False
If ProcessExists($pid) = 0 Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " killed (using taskkill)" & $process_info)
EndIf
EndIf
If ProcessExists($pid) Then
ShellExecute(@WindowsDir & "\System32\taskkill.exe", "-f -t -pid " & $pid, "", Default, @SW_HIDE)
If _Sleep(1000) Then Return False
If ProcessExists($pid) = 0 Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " killed (using taskkill -f -t)" & $process_info)
EndIf
EndIf
$iCount += 1
WEnd
If ProcessExists($pid) Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " failed to kill" & $process_info, $COLOR_ERROR)
Return False
EndIf
Return True
EndFunc
Func CreateMutex($sMutex)
Local $hMutex = _WinAPI_CreateMutex($sMutex, False)
If $hMutex Then
Switch _WinAPI_WaitForSingleObject($hMutex, 0)
Case 0x80, 0
Return $hMutex
EndSwitch
_WinAPI_CloseHandle($hMutex)
EndIf
Return 0
EndFunc
Func AcquireMutex($mutexName, $scope = Default, $timeout = Default, $sWaitMessage = "", $bUse_Sleep = False)
Local $timer = __TimerInit()
If $sWaitMessage = Default Then $sWaitMessage = "Waiting for mutex " & $mutexName & " to become available..."
Local $iDelay = $DELAYSLEEP
If $sWaitMessage Then $iDelay = 1000
Local $g_hMutex_MyBot = 0
If $scope = Default Then
$scope = @AutoItPID & "/"
ElseIf $scope <> "" Then
$scope &= "/"
EndIf
If $timeout = Default Then $timeout = 30000
Local $bLogged = False
While $g_hMutex_MyBot = 0 And($timeout < 1 Or __TimerDiff($timer) < $timeout)
$g_hMutex_MyBot = CreateMutex("MyBot.run/" & $scope & $mutexName)
If $g_hMutex_MyBot <> 0 Then ExitLoop
If $timeout = 0 Then ExitLoop
If $sWaitMessage Then
If $bLogged = False Then
$bLogged = True
SetLog($sWaitMessage)
EndIf
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, $sWaitMessage)
EndIf
If $bUse_Sleep Then
_Sleep($iDelay)
Else
Sleep($iDelay)
EndIf
WEnd
If $g_hMutex_MyBot Then
EndIf
Return $g_hMutex_MyBot
EndFunc
Func ReleaseMutex($hMutex, $ReturnValue = Default)
If $hMutex Then
_WinAPI_ReleaseMutex($hMutex)
_WinAPI_CloseHandle($hMutex)
EndIf
If $ReturnValue = Default Then Return
Return $ReturnValue
EndFunc
Func LockSemaphore($Semaphore, $sWaitMessage = Default)
Local $bAquired = False
If $sWaitMessage = Default Then $sWaitMessage = "Waiting for slot to become available..."
Local $iDelay = $DELAYSLEEP
If $sWaitMessage Then $iDelay = 1000
Local $hSemaphore = $Semaphore
If IsString($Semaphore) = 1 Then $hSemaphore = _WinAPI_CreateSemaphore($Semaphore, 1, 1)
Local $bLogged = False
While $bAquired = False And $g_bRunState = True
$bAquired = _WinAPI_WaitForSingleObject($hSemaphore, $DELAYSLEEP) <> $WAIT_TIMEOUT
If $bAquired = True Then
Return $hSemaphore
EndIf
If $sWaitMessage Then
If $bLogged = False Then
$bLogged = True
SetLog($sWaitMessage)
EndIf
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, $sWaitMessage)
EndIf
_Sleep($iDelay, True, False)
WEnd
If $Semaphore <> $hSemaphore Then _WinAPI_CloseHandle($hSemaphore)
Return 0
EndFunc
Func UnlockSemaphore(ByRef $hSemaphore, $bCloseHandle = False)
If $hSemaphore <> 0 And $hSemaphore <> -1 Then
Local $iPreviousCount = _WinAPI_ReleaseSemaphore($hSemaphore)
If $bCloseHandle = True Then
_WinAPI_CloseHandle($hSemaphore)
$hSemaphore = 0
EndIf
Return $iPreviousCount
EndIf
Return -1
EndFunc
Func AcquireMutexTicket($sMutexName, $iMinTicketNo, $sWaitMessage = Default, $bCheckRunState = True)
Local $hTicketMutex = 0
Local $sTicketMutex = 0
Local $iTicket = 256
For $i = 1 To 255
If $bCheckRunState = True And $g_bRunState = False Then Return 0
$sTicketMutex = $sMutexName & "." & $i
$hTicketMutex = AcquireMutex($sTicketMutex, "Global", 0)
If $hTicketMutex Then
$iTicket = $i
ExitLoop
EndIf
Next
If $hTicketMutex = 0 Then
SetLog("Could not aquire mutex ticker for: " & $sMutexName, $COLOR_RED)
Return 0
EndIf
If $iTicket <= $iMinTicketNo Then
SetDebugLog("Aquired mutex ticket: " & $sTicketMutex & ", " & $hTicketMutex)
Return $hTicketMutex
EndIf
SetDebugLog("Wait mutex ticket: " & $sTicketMutex)
If $sWaitMessage = Default Then $sWaitMessage = "Waiting for slot to become available..."
Local $iDelay = $DELAYSLEEP
If $sWaitMessage Then $iDelay = 1000
Local $bLogged = False
While $bCheckRunState = False Or $g_bRunState = True
If $iTicket = $iMinTicketNo + 1 Then
For $i = 1 To $iMinTicketNo
$sTicketMutex = $sMutexName & "." & $i
Local $hFinalTicketMutex = AcquireMutex($sTicketMutex, "Global", 0)
If $hFinalTicketMutex Then
SetDebugLog("Aquired mutex ticket: " & $sTicketMutex & ", " & $hFinalTicketMutex)
Return ReleaseMutex($hTicketMutex, $hFinalTicketMutex)
EndIf
Next
Else
$sTicketMutex = $sMutexName & "." &($iTicket - 1)
Local $hNextTicketMutex = AcquireMutex($sTicketMutex, "Global", 0)
If $hNextTicketMutex Then
SetDebugLog("New mutex ticket: " & $sTicketMutex)
$iTicket -= 1
$hTicketMutex = ReleaseMutex($hTicketMutex, $hNextTicketMutex)
EndIf
EndIf
If $sWaitMessage Then
If $bLogged = False Then
$bLogged = True
SetLog($sWaitMessage)
EndIf
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, $sWaitMessage)
EndIf
_Sleep($iDelay, True, False)
WEnd
Return ReleaseMutex($hTicketMutex, 0)
EndFunc
Func LockBotSlot($bLock = True)
If $g_bBotLaunchOption_NoBotSlot = True Then Return False
Static $bBotIsLocked = False
If $bLock = Default Then Return $bBotIsLocked
If $bLock = $bBotIsLocked Then Return $bBotIsLocked
Local $bWasLocked = $bBotIsLocked
If $bLock = True And $g_bRunState = True Then
If $g_hMutextOrSemaphoreGlobalActiveBots Then
SetDebugLog("LockBotSlot not released: " & $g_hMutextOrSemaphoreGlobalActiveBots)
ReleaseMutex($g_hMutextOrSemaphoreGlobalActiveBots)
$g_hMutextOrSemaphoreGlobalActiveBots = 0
EndIf
$g_hMutextOrSemaphoreGlobalActiveBots = AcquireMutexTicket("ActiveBot", $g_iGlobalActiveBotsAllowed, GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_09", "Waiting for bot slot..."))
If $g_hMutextOrSemaphoreGlobalActiveBots Then $bBotIsLocked = $bLock
ElseIf $bLock = False Then
ReleaseMutex($g_hMutextOrSemaphoreGlobalActiveBots)
SetDebugLog("Released Bot slot mutex: " & $g_hMutextOrSemaphoreGlobalActiveBots)
$g_hMutextOrSemaphoreGlobalActiveBots = 0
$bBotIsLocked = $bLock
EndIf
Return $bWasLocked
EndFunc
Global $g_oWMI = 0
Global $g_WmiAPI_External = False
Global Static $g_WmiFields = ["Handle", "ExecutablePath", "CommandLine"]
Func GetWmiSelectFields()
Return _ArrayToString($g_WmiFields, ",")
EndFunc
Func GetWmiObject()
If $g_oWMI = 0 Then $g_oWMI = ObjGet("winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2")
Return $g_oWMI
EndFunc
Func CloseWmiObject()
$g_oWMI = 0
EndFunc
Func WmiQuery($sQuery)
If $g_WmiAPI_External = True Then
Local $sAppFile = @ScriptDir & "\MyBot.run.Wmi." &((@Compiled) ?("exe") :("au3"))
If FileExists($sAppFile) Then
Local $process_killed
Local $cmd = """" & $sAppFile & """"
If @Compiled = 0 Then $cmd = """" & @AutoItExe & """ /AutoIt3ExecuteScript """ & $sAppFile & """"
Local $s = LaunchConsole($cmd, """" & $sQuery & """", $process_killed)
Return WmiOutputToArray($s)
EndIf
EndIf
Local $aProcesses[0]
SetDebugLog("WMI Query: " & $sQuery)
Local $oProcessColl = GetWmiObject().ExecQuery($sQuery, "WQL", 0x20 + 0x10)
For $Process In $oProcessColl
Local $aProcess[UBound($g_WmiFields)]
For $i = 0 To UBound($g_WmiFields) - 1
$aProcess[$i] = Execute("$Process." & $g_WmiFields[$i])
Next
ReDim $aProcesses[UBound($aProcesses) + 1]
$aProcesses[UBound($aProcesses) - 1] = $aProcess
Next
Return $aProcesses
EndFunc
Func WmiOutputToArray(ByRef $s)
Local $aProcesses[0]
Local $sProcesses = StringBetween($s, "<Processes>", "</Processes>")
If @error Then Return $aProcesses
Local $iPos = 1
While $iPos > 0
Local $sProcess = StringBetween($sProcesses, "<Process>", "</Process>", $iPos)
$iPos = @extended
If $iPos > 0 Then
Local $aProcess[UBound($g_WmiFields)]
Local $iPos2 = 1
For $i = 0 To UBound($g_WmiFields) - 1
$aProcess[$i] = StringBetween($sProcess, "<" & $g_WmiFields[$i] & ">", "</" & $g_WmiFields[$i] & ">", $iPos2)
$iPos2 = @extended
Next
ReDim $aProcesses[UBound($aProcesses) + 1]
$aProcesses[UBound($aProcesses) - 1] = $aProcess
EndIf
WEnd
Return $aProcesses
EndFunc
Func StringBetween(ByRef $s, $sStartTag, $sEndTag, $iStartPos = 1)
Local $iS = StringInStr($s, $sStartTag, 0, 1, $iStartPos)
If $iS > 0 Then
$iS += StringLen($sStartTag)
Local $iE = StringInStr($s, $sEndTag, 0, 1, $iS)
If $iE > 0 Then
Return SetError(0, $iE + StringLen($sEndTag), StringMid($s, $iS, $iE - $iS))
EndIf
EndIf
Return SetError(1, 0, "")
EndFunc
Func _NamedPipes_CreatePipe(ByRef $hReadPipe, ByRef $hWritePipe, $tSecurity = 0, $iSize = 0)
Local $aResult = DllCall("kernel32.dll", "bool", "CreatePipe", "handle*", 0, "handle*", 0, "struct*", $tSecurity, "dword", $iSize)
If @error Then Return SetError(@error, @extended, False)
$hReadPipe = $aResult[1]
$hWritePipe = $aResult[2]
Return $aResult[0]
EndFunc
Global $g_RunPipe_hProcess = 0
Global $g_RunPipe_hThread = 0
Func LaunchConsole($cmd, $param, ByRef $process_killed, $timeout = 10000, $bUseSemaphore = False)
Local $bDebug = $g_bDebugSetlog Or $g_bDebugAndroid
If $bUseSemaphore Then
Local $hSemaphore = LockSemaphore(StringReplace($cmd, "\", "/"), "Waiting to launch: " & $cmd)
EndIf
Local $data, $pid, $hStdIn[2], $hStdOut[2], $hTimer, $hProcess, $hThread
If StringLen($param) > 0 Then $cmd &= " " & $param
$hTimer = __TimerInit()
$process_killed = False
If $bDebug Then SetLog("Func LaunchConsole: " & $cmd, $COLOR_DEBUG)
$pid = RunPipe($cmd, "", @SW_HIDE, $STDERR_MERGED, $hStdIn, $hStdOut, $hProcess, $hThread)
If $bDebug Then SetLog("Func LaunchConsole: command launched", $COLOR_DEBUG)
If $pid = 0 Then
SetLog("Launch faild: " & $cmd, $COLOR_ERROR)
If $bUseSemaphore = True Then UnlockSemaphore($hSemaphore)
Return
EndIf
Local $timeout_sec = Round($timeout / 1000)
Local $iWaitResult
Do
$iWaitResult = _WinAPI_WaitForSingleObject($hProcess, $DELAYSLEEP)
$data &= ReadPipe($hStdOut[0])
Until($timeout > 0 And __TimerDiff($hTimer) > $timeout) Or $iWaitResult <> $WAIT_TIMEOUT
If ProcessExists($pid) Then
If ClosePipe($pid, $hStdIn, $hStdOut, $hProcess, $hThread) = 1 Then
If $bDebug Then SetLog("Process killed: " & $cmd, $COLOR_ERROR)
$process_killed = True
EndIf
Else
ClosePipe($pid, $hStdIn, $hStdOut, $hProcess, $hThread)
EndIf
$g_RunPipe_hProcess = 0
$g_RunPipe_hThread = 0
CleanLaunchOutput($data)
If $bDebug Then SetLog("Func LaunchConsole Output: " & $data, $COLOR_DEBUG)
If $bUseSemaphore Then UnlockSemaphore($hSemaphore)
Return $data
EndFunc
Func ProcessExists2($ProgramPath, $ProgramParameter = Default, $CompareMode = Default, $SearchMode = 0, $CompareCommandLineFunc = "")
If IsInt($ProgramPath) Then
Local $hProcess, $pid = Int($ProgramPath)
If _WinAPI_GetVersion() >= 6.0 Then
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_LIMITED_INFORMATION, 0, $pid)
Else
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_INFORMATION, 0, $pid)
EndIf
Local $iExitCode = 0
If $hProcess And @error = 0 Then
$iExitCode = _WinAPI_GetExitCodeProcess($hProcess)
_WinAPI_CloseHandle($hProcess)
EndIf
Return(($iExitCode = 259) ? $pid : 0)
EndIf
If $ProgramParameter = Default Then
$ProgramParameter = ""
If $CompareMode = Default Then $CompareMode = 1
EndIf
If $CompareMode = Default Then
$CompareMode = 0
EndIf
Local $exe = $ProgramPath
Local $iLastBS = StringInStr($exe, "\", 0, -1)
If $iLastBS > 0 Then $exe = StringMid($exe, $iLastBS + 1)
Local $commandLine =($ProgramPath <> "" ?('"' & $ProgramPath & '"' &($ProgramParameter = "" ? "" : " " & $ProgramParameter)) : $ProgramParameter)
Local $commandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($commandLine, ".exe", "", 1), " ", ""), '"', ""), "'", "")
Local $query = "Select " & GetWmiSelectFields() & " from Win32_Process"
If StringLen($commandLine) > 0 Then
$query &= " where "
If StringLen($ProgramPath) > 0 Then
$query &= "ExecutablePath like '%" & StringReplace($ProgramPath, "\", "\\") & "%'"
If $SearchMode = 1 And StringLen($ProgramParameter) > 0 Then $query &= " And "
EndIf
If $SearchMode = 1 And StringLen($ProgramParameter) > 0 Then $query &= "CommandLine like '%" & StringReplace($ProgramParameter, "\", "\\") & "%'"
EndIf
Local $pid = 0, $i = 0
For $Process In WmiQuery($query)
SetDebugLog($Process[0] & " = " & $Process[1] & " (" & $Process[2] & ")")
If $pid = 0 Then
Local $processCommandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($Process[2], ".exe", "", 1), " ", ""), '"', ""), "'", "")
If($CompareMode = 0 And $commandLineCompare = $processCommandLineCompare) Or($CompareMode = 0 And StringRight($commandLineCompare, StringLen($processCommandLineCompare)) = $processCommandLineCompare) Or($CompareMode = 0 And $CompareCommandLineFunc <> "" And Execute($CompareCommandLineFunc & "(""" & StringReplace($Process[2], """", "") & """)") = True) Or $CompareMode = 1 Then
$pid = Number($Process[0])
EndIf
EndIf
$i += 1
$Process = 0
Next
If $pid = 0 Then
SetDebugLog("Process by CommandLine not found: " & $ProgramPath &($ProgramParameter = "" ? "" :($ProgramPath <> "" ? " " : "") & $ProgramParameter))
Else
SetDebugLog("Found Process " & $pid & " by CommandLine: " & $ProgramPath &($ProgramParameter = "" ? "" :($ProgramPath <> "" ? " " : "") & $ProgramParameter))
EndIf
CloseWmiObject()
Return $pid
EndFunc
Func ProcessesExist($ProgramPath, $ProgramParameter = Default, $CompareMode = Default, $SearchMode = Default, $CompareCommandLineFunc = Default, $bReturnDetailedArray = Default, $strComputer = ".")
If $ProgramParameter = Default Then $ProgramParameter = ""
If $CompareMode = Default Then $CompareMode = 0
If $SearchMode = Default Then $SearchMode = 0
If $CompareCommandLineFunc = Default Then $CompareCommandLineFunc = ""
If $bReturnDetailedArray = Default Then $bReturnDetailedArray = False
If IsNumber($ProgramPath) Then
Local $a[1] = [ProcessExists($ProgramPath)]
Return $a
EndIf
Local $exe = $ProgramPath
Local $iLastBS = StringInStr($exe, "\", 0, -1)
If $iLastBS > 0 Then $exe = StringMid($exe, $iLastBS + 1)
Local $commandLine =($ProgramPath <> "" ?('"' & $ProgramPath & '"' &($ProgramParameter = "" ? "" : " " & $ProgramParameter)) : $ProgramParameter)
Local $commandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($commandLine, ".exe", "", 1), " ", ""), '"', ""), "'", "")
Local $query = "Select " & GetWmiSelectFields() & " from Win32_Process"
If StringLen($commandLine) > 0 Then
$query &= " where "
If StringLen($ProgramPath) > 0 Then
$query &= "ExecutablePath like '%" & StringReplace($ProgramPath, "\", "\\") & "%'"
If $SearchMode = 1 And StringLen($ProgramParameter) > 0 Then $query &= " And "
EndIf
If $SearchMode = 1 And StringLen($ProgramParameter) > 0 Then $query &= "CommandLine like '%" & StringReplace($ProgramParameter, "\", "\\") & "%'"
EndIf
Local $Process, $pid = 0, $i = 0
Local $PIDs[0]
For $Process In WmiQuery($query)
SetDebugLog($Process[0] & " = " & $Process[1])
Local $processCommandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($Process[2], ".exe", "", 1), " ", ""), '"', ""), "'", "")
If($CompareMode = 0 And $commandLineCompare = $processCommandLineCompare) Or($CompareMode = 0 And StringRight($commandLineCompare, StringLen($processCommandLineCompare)) = $processCommandLineCompare) Or($CompareMode = 0 And $CompareCommandLineFunc <> "" And Execute($CompareCommandLineFunc & "(""" & StringReplace($Process[2], """", "") & """)") = True) Or $CompareMode = 1 Then
$pid = Number($Process[0])
ReDim $PIDs[$i + 1]
Local $a = $pid
If $bReturnDetailedArray Then
Local $a = [$pid, $Process[1], $Process[2]]
EndIf
$PIDs[$i] = $a
$i += 1
$Process = 0
EndIf
Next
If $i = 0 Then
SetDebugLog("No process found by CommandLine: " & $ProgramPath &($ProgramParameter = "" ? "" : " " & $ProgramParameter))
Else
SetDebugLog("Found " & $i & " process(es) with " & $ProgramPath &($ProgramParameter = "" ? "" : " " & $ProgramParameter))
EndIf
CloseWmiObject()
Return $PIDs
EndFunc
Func ProcessGetCommandLine($pid, $strComputer = ".")
If Not IsNumber($pid) Then Return SetError(2, 0, -1)
Local $query = "Select " & GetWmiSelectFields() & " from Win32_Process where Handle = " & $pid
For $Process In WmiQuery($query)
SetDebugLog($Process[0] & " = " & $Process[2])
SetError(0, 0, 0)
Local $sProcessCommandLine = $Process[2]
$Process = 0
CloseWmiObject()
Return $sProcessCommandLine
Next
SetDebugLog("Process not found with PID " & $pid)
$Process = 0
CloseWmiObject()
Return SetError(1, 0, -1)
EndFunc
Func ProcessGetWmiProcess($pid, $strComputer = ".")
If Not IsNumber($pid) Then Return SetError(2, 0, -1)
Local $query = "Select " & GetWmiSelectFields() & " from Win32_Process where Handle = " & $pid
For $Process In WmiQuery($query)
SetDebugLog($Process[0] & " = " & $Process[2])
SetError(0, 0, 0)
CloseWmiObject()
Return $Process
Next
SetDebugLog("Process not found with PID " & $pid)
$Process = 0
CloseWmiObject()
Return SetError(1, 0, -1)
EndFunc
Func CleanLaunchOutput(ByRef $output)
$output = StringReplace($output, @CR & @CR, "")
$output = StringReplace($output, @CRLF & @CRLF, "")
If StringRight($output, 1) = @LF Then $output = StringLeft($output, StringLen($output) - 1)
If StringRight($output, 1) = @CR Then $output = StringLeft($output, StringLen($output) - 1)
EndFunc
Func RunPipe($program, $workdir, $show_flag, $opt_flag, ByRef $hStdIn, ByRef $hStdOut, ByRef $hProcess, ByRef $hThread)
If UBound($hStdIn) < 2 Then
Local $a = [0, 0]
$hStdIn = $a
EndIf
If UBound($hStdOut) < 2 Then
Local $a = [0, 0]
$hStdOut = $a
EndIf
Local $tSecurity = DllStructCreate($tagSECURITY_ATTRIBUTES)
DllStructSetData($tSecurity, "Length", DllStructGetSize($tSecurity))
DllStructSetData($tSecurity, "InheritHandle", True)
_NamedPipes_CreatePipe($hStdIn[0], $hStdIn[1], $tSecurity)
_WinAPI_SetHandleInformation($hStdIn[1], $HANDLE_FLAG_INHERIT, 0)
_NamedPipes_CreatePipe($hStdOut[0], $hStdOut[1], $tSecurity)
_WinAPI_SetHandleInformation($hStdOut[0], $HANDLE_FLAG_INHERIT, 0)
Local $StartupInfo = DllStructCreate($tagSTARTUPINFO)
DllStructSetData($StartupInfo, "Size", DllStructGetSize($StartupInfo))
DllStructSetData($StartupInfo, "Flags", $STARTF_USESTDHANDLES + $STARTF_USESHOWWINDOW)
DllStructSetData($StartupInfo, "StdInput", $hStdIn[0])
DllStructSetData($StartupInfo, "StdOutput", $hStdOut[1])
DllStructSetData($StartupInfo, "StdError", $hStdOut[1])
DllStructSetData($StartupInfo, "ShowWindow", $show_flag)
Local $lpStartupInfo = DllStructGetPtr($StartupInfo)
Local $ProcessInformation = DllStructCreate($tagPROCESS_INFORMATION)
Local $lpProcessInformation = DllStructGetPtr($ProcessInformation)
If __WinAPI_CreateProcess("", $program, 0, 0, True, 0, 0, $workdir, $lpStartupInfo, $lpProcessInformation) Then
Local $pid = DllStructGetData($ProcessInformation, "ProcessID")
$hProcess = DllStructGetData($ProcessInformation, "hProcess")
$hThread = DllStructGetData($ProcessInformation, "hThread")
Return $pid
EndIf
SetDebugLog("RunPipe: Failed creating new process: " & $program)
ClosePipe(0, $hStdIn, $hStdOut, 0, 0)
EndFunc
Func ClosePipe($pid, $hStdIn, $hStdOut, $hProcess, $hThread)
_WinAPI_CloseHandle($hStdIn[0])
_WinAPI_CloseHandle($hStdIn[1])
_WinAPI_CloseHandle($hStdOut[0])
_WinAPI_CloseHandle($hStdOut[1])
If $hProcess Then _WinAPI_CloseHandle($hProcess)
If $hThread Then _WinAPI_CloseHandle($hThread)
Return ProcessClose($pid)
EndFunc
Func ReadPipe(ByRef $hPipe)
If DataInPipe($hPipe) = 0 Then Return SetError(@error, @extended, "")
Local $tBuffer = DllStructCreate("char Text[4096]")
Local $iRead
If _WinAPI_ReadFile($hPipe, DllStructGetPtr($tBuffer), 4096, $iRead) Then
Return SetError(0, 0, DllStructGetData($tBuffer, "Text"))
EndIf
Return SetError(@error, @extended, "")
EndFunc
Func WritePipe(ByRef $hPipe, Const $s)
Local $tBuffer = DllStructCreate("char Text[4096]")
DllStructSetData($tBuffer, "Text", $s)
Local $iToWrite = StringLen($s)
Local $iWritten = 0
If _WinAPI_WriteFile($hPipe, DllStructGetPtr($tBuffer), $iToWrite, $iWritten) Then
Return SetError(0, 0, $iWritten)
EndIf
Return SetError(@error, @extended, 0)
EndFunc
Func DataInPipe(ByRef $hPipe)
Local $aResult = DllCall("kernel32.dll", "bool", "PeekNamedPipe", "handle", $hPipe, "ptr", 0, "int", 0, "dword*", 0, "dword*", 0, "dword*", 0)
If @error Then Return SetError(@error, @extended, 0)
Return SetError(0, 0, $aResult[5])
EndFunc
Func __WinAPI_CreateProcess($sAppName, $sCommand, $tSecurity, $tThread, $bInherit, $iFlags, $pEnviron, $sDir, $tStartupInfo, $tProcess)
Local $tCommand = 0
Local $sAppNameType = "wstr", $sDirType = "wstr"
If $sAppName = "" Then
$sAppNameType = "ptr"
$sAppName = 0
EndIf
If $sCommand <> "" Then
$tCommand = DllStructCreate("wchar Text[" & 4096 + 1 & "]")
DllStructSetData($tCommand, "Text", $sCommand)
EndIf
If $sDir = "" Then
$sDirType = "ptr"
$sDir = 0
EndIf
Local $aResult = DllCall("kernel32.dll", "bool", "CreateProcessW", $sAppNameType, $sAppName, "struct*", $tCommand, "struct*", $tSecurity, "struct*", $tThread, "bool", $bInherit, "dword", $iFlags, "struct*", $pEnviron, $sDirType, $sDir, "struct*", $tStartupInfo, "struct*", $tProcess)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_FreeConsole()
Local $aResult = DllCall("kernel32.dll", "bool", "FreeConsole")
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_AllocConsole()
Local $aResult = DllCall("kernel32.dll", "bool", "AllocConsole")
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetConsoleIcon($g_sLibIconPath, $nIconID, $hWnD = Default)
Local $hIcon = DllStructCreate("int")
Local $Result = DllCall("shell32.dll", "int", "ExtractIconEx", "str", $g_sLibIconPath, "int", $nIconID - 1, "hwnd", 0, "ptr", DllStructGetPtr($hIcon), "int", 1)
If UBound($Result) > 0 Then
$Result = $Result[0]
If $Result > 0 Then
Local $error = 0, $extended = 0
If $hWnD = Default Then
$Result = DllCall("kernel32.dll", "bool", "SetConsoleIcon", "ptr", DllStructGetData($hIcon, 1))
$Result = DllCall("kernel32.dll", "hwnd", "GetConsoleWindow")
$error = @error
$extended = @extended
If UBound($Result) > 0 Then $hWnD = $Result[0]
EndIf
If IsHWnd($hWnD) Then
_SendMessage($hWnD, $WM_SETICON, 0, DllStructGetData($hIcon, 1))
_SendMessage($hWnD, $WM_SETICON, 1, DllStructGetData($hIcon, 1))
Sleep(50)
EndIf
DllCall("user32.dll", "int", "DestroyIcon", "hwnd", DllStructGetData($hIcon, 1))
If $error Then Return SetError($error, $extended, False)
Return True
EndIf
EndIf
If @error Then Return SetError(@error, @extended, False)
EndFunc
Func _ConsoleWrite($Text)
Local $hFile, $pBuffer, $iToWrite, $iWritten, $tBuffer = DllStructCreate("char[" & StringLen($Text) & "]")
DllStructSetData($tBuffer, 1, $Text)
$hFile = _WinAPI_GetStdHandle(1)
_WinAPI_WriteFile($hFile, $tBuffer, StringLen($Text), $iWritten)
Return $iWritten
EndFunc
Func FindExitButton($sButtonName)
Local $aCoor
Local $sDirectory = "exitbutton-bundle"
Local $sReturnProps = "objectpoints"
Local $result = ""
Local $aPosXY = ""
$aCoor = StringSplit(GetButtonRectangle($sButtonName), ",", $STR_NOCOUNT)
_CaptureRegion2($aCoor[0], $aCoor[1], $aCoor[2], $aCoor[3])
$result = findMultiple($sDirectory ,"FV" ,"FV", 0, 0, 1 , $sReturnProps, False)
If IsArray($result) then
$aPosXY = StringSplit(($result[0])[0], ",", $STR_NOCOUNT)
$aPosXY[0] += $aCoor[0]
$aPosXY[1] += $aCoor[1]
If $g_bDebugSetlog Then SetDebugLog("FindExitButton: " & $sButtonName & " Button X|Y = " & $aPosXY[0] & "|" & $aPosXY[1], $COLOR_DEBUG)
Return $aPosXY
EndIf
If $g_bDebugSetlog Then SetDebugLog("FindExitButton: " & $sButtonName & " NOT Found" , $COLOR_DEBUG)
Return $aPosXY
EndFunc
Func FindAdsXButton()
Local $sCoor
Local $sDirectory = "adsxbutton-bundle"
Local $sReturnProps = "objectpoints"
Local $result = ""
Local $aPosXY = ""
$sCoor = GetDiamondFromRect(GetButtonRectangle("AdsX"))
$result = findMultiple($sDirectory, $sCoor, $sCoor, 0, 0, 1, $sReturnProps, False)
If IsArray($result) then
$aPosXY = StringSplit(($result[0])[0], ",", $STR_NOCOUNT)
If $g_bDebugSetlog Then SetDebugLog("FindAdsXButton: " & $g_sAndroidGameDistributor & " AdsX Button X|Y = " & $aPosXY[0] & "|" & $aPosXY[1], $COLOR_DEBUG)
Return $aPosXY
EndIf
If $g_bDebugSetlog Then SetDebugLog("FindAdsXButton: " & $g_sAndroidGameDistributor & " NOT Found", $COLOR_DEBUG)
Return $aPosXY
EndFunc
Func GetButtonRectangle($sButtonName)
Local $btnRectangle = "0,0," & $g_iDEFAULT_WIDTH & "," & $g_iDEFAULT_HEIGHT
Switch $sButtonName
Case "Kunlun", "Huawei", "Kaopu", "Microvirt", "Yeshen"
$btnRectangle = GetDummyRectangle("345,394", 10)
Case "Qihoo"
$btnRectangle = GetDummyRectangle("302,456", 10)
Case "Baidu"
$btnRectangle = GetDummyRectangle("464,426", 10)
Case "OPPO"
$btnRectangle = GetDummyRectangle("476,412", 10)
Case "Anzhi"
$btnRectangle = GetDummyRectangle("328,371", 10)
Case "Lenovo"
$btnRectangle = GetDummyRectangle("477,476", 10)
Case "Aiyouxi"
$btnRectangle = GetDummyRectangle("468,392", 10)
Case "9game"
$btnRectangle = "349,352,369,436"
Case "VIVO", "Xiaomi"
$btnRectangle = GetDummyRectangle("353,387", 10)
Case "Guopan"
$btnRectangle = GetDummyRectangle("409,440", 10)
Case "AdsX"
$btnRectangle =($g_iDEFAULT_WIDTH / 2) & ",0," & $g_iDEFAULT_WIDTH & "," &($g_iDEFAULT_HEIGHT / 2)
Case Else
$btnRectangle = "0,0," & $g_iDEFAULT_WIDTH & "," & $g_iDEFAULT_HEIGHT
EndSwitch
Return $btnRectangle
EndFunc
Func _CaptureRegion(Const $iLeft = 0, Const $iTop = 0, Const $iRight = $g_iGAME_WIDTH, Const $iBottom = $g_iGAME_HEIGHT, Const $ReturnLocal_hHBitmap = False)
If $ReturnLocal_hHBitmap Then
Local $_hHBitmap
_CaptureGameScreen($_hHBitmap, $iLeft, $iTop, $iRight, $iBottom)
Return $_hHBitmap
EndIf
If $g_hHBitmap <> 0 And $g_hHBitmap <> $g_hHBitmapTest And $g_hHBitmap2 <> $g_hHBitmap Then
GdiDeleteHBitmap($g_hHBitmap)
EndIf
_CaptureGameScreen($g_hHBitmap, $iLeft, $iTop, $iRight, $iBottom)
If $g_hBitmap <> 0 Then
GdiDeleteBitmap($g_hBitmap)
EndIf
$g_hBitmap = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap)
GdiAddBitmap($g_hBitmap)
Return $g_hHBitmap
EndFunc
Func _CaptureRegion2(Const $iLeft = 0, Const $iTop = 0, Const $iRight = $g_iGAME_WIDTH, Const $iBottom = $g_iGAME_HEIGHT)
If $g_hHBitmap2 <> 0 And $g_hHBitmap2 <> $g_hHBitmapTest And $g_hHBitmap2 <> $g_hHBitmap Then
GdiDeleteHBitmap($g_hHBitmap2)
EndIf
_CaptureGameScreen($g_hHBitmap2, $iLeft, $iTop, $iRight, $iBottom)
EndFunc
Func _CaptureGameScreen(ByRef $_hHBitmap, Const $iLeft = 0, Const $iTop = 0, Const $iRight = $g_iGAME_WIDTH, Const $iBottom = $g_iGAME_HEIGHT)
Local $SuspendMode
If $g_hHBitmapTest = 0 Then
If $g_bRunState Then CheckAndroidRunning()
Local $iL = $iLeft, $iT = $iTop, $iR = $iRight, $iB = $iBottom
Local $iW = Number($iR) - Number($iL), $iH = Number($iB) - Number($iT)
Local $bDebugAlwaysSaveFullScreenTimer = False
If Not $g_hDebugAlwaysSaveFullScreenTimer = 0 Then
If __TimerDiff($g_hDebugAlwaysSaveFullScreenTimer) < 300000 Then
$bDebugAlwaysSaveFullScreenTimer = True
$iL = 0
$iT = 0
$iR = $g_iGAME_WIDTH
$iB = $g_iGAME_HEIGHT
$iW = Number($iR) - Number($iL)
$iH = Number($iB) - Number($iT)
Else
SetLog("Disable $g_hDebugAlwaysSaveFullScreenTimer")
$g_hDebugAlwaysSaveFullScreenTimer = 0
EndIf
EndIf
If $g_bChkBackgroundMode = True Then
If $g_bAndroidAdbScreencap = True Then
$_hHBitmap = AndroidScreencap($iL, $iT, $iW, $iH)
Else
$SuspendMode = ResumeAndroid(False)
Local $hCtrl = ControlGetHandle(GetCurrentAndroidHWnD(), $g_sAppPaneName, $g_sAppClassInstance)
If $hCtrl = 0 Then SetLog("AndroidHandle not found, contact support", $COLOR_ERROR)
Local $hDC_Capture = _WinAPI_GetDC($hCtrl)
Local $hMemDC = _WinAPI_CreateCompatibleDC($hDC_Capture)
$_hHBitmap = _WinAPI_CreateCompatibleBitmap($hDC_Capture, $iW, $iH)
Local $hObjectOld = _WinAPI_SelectObject($hMemDC, $_hHBitmap)
Local $flags = 0
DllCall("user32.dll", "int", "PrintWindow", "hwnd", $hCtrl, "handle", $hMemDC, "int", $flags)
_WinAPI_SelectObject($hMemDC, $_hHBitmap)
_WinAPI_BitBlt($hMemDC, 0, 0, $iW, $iH, $hDC_Capture, $iL, $iT, $SRCCOPY)
_WinAPI_DeleteDC($hMemDC)
_WinAPI_SelectObject($hMemDC, $hObjectOld)
_WinAPI_ReleaseDC($hCtrl, $hDC_Capture)
SuspendAndroid($SuspendMode, False)
EndIf
Else
getBSPos()
$SuspendMode = ResumeAndroid(False)
$_hHBitmap = _ScreenCapture_Capture("", $iL + $g_aiBSpos[0], $iT + $g_aiBSpos[1], $iR + $g_aiBSpos[0] - 1, $iB + $g_aiBSpos[1] - 1, False)
SuspendAndroid($SuspendMode, False)
EndIf
If $bDebugAlwaysSaveFullScreenTimer = True Then
Local $sDateTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN & "-" & @SEC & "." & @MSEC
Local $hBitmap_full = _GDIPlus_BitmapCreateFromHBITMAP($_hHBitmap)
SetDebugLog("Save full screen: " & $g_sProfileTempDebugPath & "FullScreen_" & $sDateTime & ".png")
_GDIPlus_ImageSaveToFile($hBitmap_full, $g_sProfileTempDebugPath & "FullScreen_" & $sDateTime & ".png")
_GDIPlus_BitmapDispose($hBitmap_full)
If $iLeft > 0 Or $iTop > 0 Or $iRight < $g_iGAME_WIDTH Or $iBottom < $g_iGAME_HEIGHT Then
Local $hHBitmap_full = $_hHBitmap
$_hHBitmap = GetHHBitmapArea($_hHBitmap, $iLeft, $iTop, $iRight, $iBottom)
_WinAPI_DeleteObject($hHBitmap_full)
EndIf
EndIf
ElseIf $iLeft > 0 Or $iTop > 0 Or $iRight < $g_iGAME_WIDTH Or $iBottom < $g_iGAME_HEIGHT Then
$_hHBitmap = GetHHBitmapArea($g_hHBitmapTest, $iLeft, $iTop, $iRight, $iBottom)
Else
$_hHBitmap = $g_hHBitmapTest
EndIf
GdiAddHBitmap($_hHBitmap)
$g_bForceCapture = False
EndFunc
Func _CaptureDispose()
If $g_hBitmap <> 0 Then GdiDeleteBitmap($g_hBitmap)
If $g_hHBitmap <> 0 Then GdiDeleteHBitmap($g_hHBitmap)
If $g_hHBitmap2 <> 0 Then GdiDeleteHBitmap($g_hHBitmap2)
If $g_hHBitmapTest <> 0 Then GdiDeleteHBitmap($g_hHBitmapTest)
$g_hBitmap = 0
$g_hHBitmap = 0
$g_hHBitmap2 = 0
$g_hHBitmapTest = 0
EndFunc
Func _CaptureRegion2Sync()
If $g_hHBitmap2 <> 0 And $g_hHBitmap2 <> $g_hHBitmapTest And $g_hHBitmap2 <> $g_hHBitmap Then
GdiDeleteHBitmap($g_hHBitmap2)
EndIf
$g_hHBitmap2 = GetHHBitmapArea($g_hHBitmap)
EndFunc
Func _CaptureRegions()
_CaptureRegion()
_CaptureRegion2Sync()
Return True
EndFunc
Func GetHHBitmapArea(Const ByRef $_hHBitmap, Const $iLeft = 0, Const $iTop = 0, Const $iRight = $g_iGAME_WIDTH, Const $iBottom = $g_iGAME_HEIGHT)
Local $iW = Number($iRight) - Number($iLeft), $iH = Number($iBottom) - Number($iTop)
Local $hDC = _WinAPI_GetDC($g_hFrmBot)
Local $hMemDC_src = _WinAPI_CreateCompatibleDC($hDC)
Local $hMemDC_dst = _WinAPI_CreateCompatibleDC($hDC)
Local $_hHBitmapArea = _WinAPI_CreateCompatibleBitmap($hDC, $iW, $iH)
Local $hObjectOld_src = _WinAPI_SelectObject($hMemDC_src, $_hHBitmap)
Local $hObjectOld_dst = _WinAPI_SelectObject($hMemDC_dst, $_hHBitmapArea)
_WinAPI_BitBlt($hMemDC_dst, 0, 0, $iW, $iH, $hMemDC_src, $iLeft, $iTop, $SRCCOPY)
_WinAPI_SelectObject($hMemDC_src, $hObjectOld_src)
_WinAPI_SelectObject($hMemDC_dst, $hObjectOld_dst)
_WinAPI_ReleaseDC($g_hFrmBot, $hDC)
_WinAPI_DeleteDC($hMemDC_src)
_WinAPI_DeleteDC($hMemDC_dst)
GdiAddHBitmap($_hHBitmapArea)
Return $_hHBitmapArea
EndFunc
Func FastCaptureRegion()
Return $g_bChkBackgroundMode = True And $g_bAndroidAdbScreencap = False
EndFunc
Func NeedCaptureRegion(Const $iCount)
Local $bNeedCaptureRegion = FastCaptureRegion() Or Mod($iCount, 10) = 0
Return $bNeedCaptureRegion
EndFunc
Func ForceCaptureRegion(Const $bForceCapture = True)
$g_bForceCapture = $bForceCapture
EndFunc
Func TestCapture(Const $g_hHBitmap = Default)
If $g_hHBitmap = Default Then Return $g_hHBitmapTest <> 0
If $g_hHBitmapTest <> 0 Then _WinAPI_DeleteObject($g_hHBitmapTest)
$g_hHBitmapTest = $g_hHBitmap
Return $g_hHBitmap
EndFunc
Func debugGdiHandle(Const $sSource, Const $bLogAlways = False)
If $g_iDebugGDICount <> 0 Then
Local $iCount = _WinAPI_GetGuiResources()
If $iCount <> $g_iDebugGDICount Or $bLogAlways Then
Local $sMsg = "GDI Handle Count: " & $iCount & " / " &($iCount - $g_iDebugGDICount) & ", active: " & $g_oDebugGDIHandles.Count & " (" & $sSource & ")"
$g_iDebugGDICount = $iCount
If $g_iDebugGDICount > $g_iDebugGDICountMax Then
$g_iDebugGDICountMax = $g_iDebugGDICount
$sMsg &= " NEW MAX!"
EndIf
SetDebugLog($sMsg, Default, True)
EndIf
EndIf
EndFunc
Func GdiAddBitmap(Const ByRef $_hBitmap)
If $g_iDebugGDICount <> 0 Then
$g_oDebugGDIHandles("Bitmap:" & $_hBitmap) = Time()
SetDebugLog("GdiAddBitmap " & $_hBitmap, Default, True)
EndIf
EndFunc
Func GdiDeleteBitmap(ByRef $_hBitmap)
If $g_iDebugGDICount <> 0 Then SetDebugLog("_GDIPlus_BitmapDispose>: " & $_hBitmap & ", active: " & $g_oDebugGDIHandles.Count, Default, True)
Local $Result = _GDIPlus_BitmapDispose($_hBitmap)
If($Result <> True Or @error) And $g_iDebugGDICount = 0 Then SetDebugLog("GdiDeleteBitmap not deleted: " & $_hBitmap, Default, True)
If $g_iDebugGDICount <> 0 Then
SetDebugLog("_GDIPlus_BitmapDispose<: " & $_hBitmap & " " & $Result & ", active: " & $g_oDebugGDIHandles.Count, Default, True)
$g_oDebugGDIHandles.Remove("Bitmap:" & $_hBitmap)
SetDebugLog("GdiDeleteBitmap " & $_hBitmap & ", active: " & $g_oDebugGDIHandles.Count, Default, True)
EndIf
$_hBitmap = 0
EndFunc
Func GdiAddHBitmap(Const ByRef $_hHBitmap)
If $g_iDebugGDICount <> 0 Then
$g_oDebugGDIHandles("HBitmap:" & $_hHBitmap) = Time()
SetDebugLog("GdiAddHBitmap " & $_hHBitmap & ", active: " & $g_oDebugGDIHandles.Count, Default, True)
EndIf
EndFunc
Func GdiDeleteHBitmap(ByRef $_hHBitmap)
Local $Result = _WinAPI_DeleteObject($_hHBitmap)
If($Result <> True Or @error) And $g_iDebugGDICount = 0 Then SetDebugLog("GdiDeleteHBitmap not deleted: " & $_hHBitmap, Default, True)
If $g_iDebugGDICount <> 0 Then
$g_oDebugGDIHandles.Remove("HBitmap:" & $_hHBitmap)
SetDebugLog("GdiDeleteHBitmap " & $_hHBitmap & " " & $Result & ", active: " & $g_oDebugGDIHandles.Count, Default, True)
EndIf
$_hHBitmap = 0
EndFunc
Func __GDIPlus_Startup()
_GDIPlus_Startup()
$g_iDebugGDICountMax = _WinAPI_GetGuiResources()
debugGdiHandle("__GDIPlus_Startup", True)
EndFunc
Func __GDIPlus_Shutdown()
_CaptureDispose()
Local $hDll = $__g_hGDIPDll
_GDIPlus_Shutdown()
_WinAPI_FreeLibrary($hDll)
debugGdiHandle("__GDIPlus_Shutdown", True)
EndFunc
Func _ColorCheck($nColor1, $nColor2, $sVari = 5, $Ignore = Default)
Local $Red1, $Red2, $Blue1, $Blue2, $Green1, $Green2
$Red1 = Dec(StringMid(String($nColor1), 1, 2))
$Blue1 = Dec(StringMid(String($nColor1), 3, 2))
$Green1 = Dec(StringMid(String($nColor1), 5, 2))
$Red2 = Dec(StringMid(String($nColor2), 1, 2))
$Blue2 = Dec(StringMid(String($nColor2), 3, 2))
$Green2 = Dec(StringMid(String($nColor2), 5, 2))
Switch $Ignore
Case "Red"
If Abs($Blue1 - $Blue2) > $sVari Then Return False
If Abs($Green1 - $Green2) > $sVari Then Return False
Case "Heroes"
If Abs($Blue1 - $Blue2) > $sVari Then Return False
If Abs($Red1 - $Red2) > $sVari Then Return False
Case "Red+Blue"
If Abs($Green1 - $Green2) > $sVari Then Return False
Case Else
If Abs($Blue1 - $Blue2) > $sVari Then Return False
If Abs($Green1 - $Green2) > $sVari Then Return False
If Abs($Red1 - $Red2) > $sVari Then Return False
EndSwitch
Return True
EndFunc
Func _CheckPixel($aScreenCode, $bNeedCapture = Default, $Ignore = Default, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
If $bNeedCapture = Default Then $bNeedCapture = False
If $g_bDebugSetlog And $sLogText <> Default And IsString($sLogText) Then
$sLogText &= ", Expected: " & Hex($aScreenCode[2], 6) & ", Tolerance: " & $aScreenCode[3]
Else
$sLogText = Default
EndIf
If _ColorCheck(  _GetPixelColor($aScreenCode[0], $aScreenCode[1], $bNeedCapture, $sLogText, $LogTextColor, $bSilentSetLog), Hex($aScreenCode[2], 6), $aScreenCode[3], $Ignore) Then
Return True
EndIf
Return False
EndFunc
Func _CheckPixel2($aScreenCode, $sHexColor, $Ignore = Default)
If _ColorCheck( $sHexColor, Hex($aScreenCode[2], 6), $aScreenCode[3], $Ignore) Then
Return True
EndIf
Return False
EndFunc
Func _WaitForCheckPixel($aScreenCode, $bNeedCapture = Default, $Ignore = Default, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default, $iWaitLoop = Default)
If $iWaitLoop = Default Then $iWaitLoop = 250
Local $wCount = 0
While _CheckPixel($aScreenCode, $bNeedCapture, $Ignore, $sLogText, $LogTextColor, $bSilentSetLog) = False
If _Sleep($iWaitLoop ) Then Return
$wCount += 1
If $wCount > 20 Then
SetLog($sLogText & " not found!", $COLOR_ERROR)
Return False
EndIf
WEnd
Return True
EndFunc
Func GetListPixel($listPixel, $sDelim = "-", $sName = "")
If $sName <> "" Then debugAttackCSV("GetListPixel for " & $sName & ": " & $listPixel)
Local $listPixelSideStr = StringSplit($listPixel, "|")
If($listPixelSideStr[0] > 1) Then
Local $listPixelSide[UBound($listPixelSideStr) - 1]
For $i = 0 To UBound($listPixelSide) - 1
Local $pixel = GetPixel($listPixelSideStr[$i + 1], $sDelim)
If UBound($pixel) > 1 Then
$listPixelSide[$i] = $pixel
EndIf
Next
Return $listPixelSide
Else
If StringInStr($listPixel, $sDelim) > 0 Then
Local $pixel = GetPixel($listPixel, $sDelim)
Local $listPixelHere = [$pixel]
Return $listPixelHere
EndIf
Return -1
EndIf
EndFunc
Func GetPixel($sPixel, $sDelim = "-")
Local $pixel = StringSplit($sPixel, $sDelim, $STR_NOCOUNT)
If UBound($pixel) < 2 Then Return $pixel
$pixel[0] = Int($pixel[0])
$pixel[1] = Int($pixel[1])
Return $pixel
EndFunc
Func GetPixelDistance(Const ByRef $Pixel0, Const ByRef $Pixel1)
Local $a = $Pixel0[0] - $Pixel1[0]
Local $b = $Pixel0[1] - $Pixel1[1]
Local $d = Sqrt($a * $a + $b * $b)
Return $d
EndFunc
Func GetPixelListDistance(Const $PixelArray, Const $iMaxAllowedPixelDistance)
Local $dTotal = 0
Local $i
Local $iMax = UBound($PixelArray) - 1
If $iMax < 1 Then Return $dTotal
Local $prePixel = $PixelArray[0]
Local $curPixel
Local $d
For $i = 1 To $iMax
$curPixel = $PixelArray[$i]
If UBound($prePixel) > 1 And UBound($curPixel) > 1 Then
$d = GetPixelDistance($prePixel, $curPixel)
If $d <= $iMaxAllowedPixelDistance Then $dTotal += $d
EndIf
$prePixel = $curPixel
Next
Return $dTotal
EndFunc
Func GetLocationItem($functionName)
If $g_bDebugSetlog Or $g_bDebugBuildingPos Then
Local $hTimer = __TimerInit()
SetLog("GetLocationItem(" & $functionName & ")", $COLOR_DEBUG)
EndIf
Local $resultHere = DllCall($g_hLibMyBot, "str", $functionName, "ptr", $g_hHBitmap2)
If UBound($resultHere) > 0 Then
If $g_bDebugBuildingPos Then SetLog("#*# " & $functionName & ": " & $resultHere[0] & "calc in " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_DEBUG1)
Return GetListPixel($resultHere[0])
Else
If $g_bDebugBuildingPos Then SetLog("#*# " & $functionName & ": NONE calc in " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_DEBUG1)
EndIf
EndFunc
Func _GetPixelColor($iX, $iY, $bNeedCapture = False, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $aPixelColor = 0
If Not $bNeedCapture Or Not $g_bRunState Then
$aPixelColor = _GDIPlus_BitmapGetPixel($g_hBitmap, $iX, $iY)
Else
_CaptureRegion($iX - 1, $iY - 1, $iX + 1, $iY + 1)
$aPixelColor = _GDIPlus_BitmapGetPixel($g_hBitmap, 1, 1)
EndIf
If $sLogText <> Default And IsString($sLogText) Then
Local $String = $sLogText & " at X,Y: " & $iX & "," & $iY & " Found: " & Hex($aPixelColor, 6)
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
EndIf
Return Hex($aPixelColor, 6)
EndFunc
Func IsPixelColorGray($sPixelColorRgbHex)
If StringLen($sPixelColorRgbHex) <> 6 Then Return False
Local $sRed = StringLeft($sPixelColorRgbHex, 2)
Local $sBlue = StringRight($sPixelColorRgbHex, 2)
Return $sRed = $sBlue And $sRed = StringMid($sPixelColorRgbHex, 3, 2)
EndFunc
Func _PixelSearch($iLeft, $iTop, $iRight, $iBottom, $sColor, $iColorVariation, $bNeedCapture = True)
Local $x1, $x2, $y1, $y2
If $bNeedCapture = True Then
_CaptureRegion($iLeft, $iTop, $iRight, $iBottom)
$x1 = $iRight - $iLeft
$x2 = 0
$y1 = 0
$y2 = $iBottom - $iTop
Else
$x1 = $iRight
$x2 = $iLeft
$y1 = $iTop
$y2 = $iBottom
EndIf
For $x = $x1 To $x2 Step -1
For $y = $y1 To $y2
If _ColorCheck(_GetPixelColor($x, $y), $sColor, $iColorVariation) Then
Local $Pos[2] = [$iLeft + $x - $x2, $iTop + $y - $y1]
Return $Pos
EndIf
Next
Next
Return 0
EndFunc
Func _MultiPixelSearch($iLeft, $iTop, $iRight, $iBottom, $xSkip, $ySkip, $firstColor, $offColor, $iColorVariation)
_CaptureRegion($iLeft, $iTop, $iRight, $iBottom)
Local $offColorVariation = UBound($offColor, 2) > 3
Local $xRange = $iRight - $iLeft
Local $yRange = $iBottom - $iTop
If $xSkip < 0 Then
$xRange = Abs($xSkip)
$xSkip = 1
EndIf
If $ySkip < 0 Then
$yRange = Abs($ySkip)
$ySkip = 1
EndIf
For $x = 0 To $xRange Step $xSkip
For $y = 0 To $yRange Step $ySkip
If _ColorCheck(_GetPixelColor($x, $y), $firstColor, $iColorVariation) Then
Local $allchecked = True
Local $iCV = $iColorVariation
For $i = 0 To UBound($offColor) - 1
If $offColorVariation = True Then $iCV = $offColor[$i][3]
If _ColorCheck(_GetPixelColor($x + $offColor[$i][1], $y + $offColor[$i][2]), Hex($offColor[$i][0], 6), $iCV) = False Then
$allchecked = False
ExitLoop
EndIf
Next
If $allchecked Then
Local $Pos[2] = [$iLeft + $x, $iTop + $y]
Return $Pos
EndIf
EndIf
Next
Next
Return 0
EndFunc
Func _MultiPixelSearch2($iLeft, $iTop, $iRight, $iBottom, $xSkip, $ySkip, $firstColor, $offColor, $iColorVariation)
_CaptureRegion($iLeft, $iTop, $iRight, $iBottom)
Local $offColorVariation = UBound($offColor, 2) > 3
Local $xRange = $iRight - $iLeft
Local $yRange = $iBottom - $iTop
If $xSkip < 0 Then
$xRange = Abs($xSkip)
$xSkip = 1
EndIf
If $ySkip < 0 Then
$yRange = Abs($ySkip)
$ySkip = 1
EndIf
For $y = 0 To $yRange Step $ySkip
For $x = 0 To $xRange Step $xSkip
If _ColorCheck(_GetPixelColor($x, $y), $firstColor, $iColorVariation) Then
Local $allchecked = True
Local $iCV = $iColorVariation
For $i = 0 To UBound($offColor) - 1
If $offColorVariation = True Then $iCV = $offColor[$i][3]
If _ColorCheck(_GetPixelColor($x + $offColor[$i][1], $y + $offColor[$i][2]), Hex($offColor[$i][0], 6), $iCV) = False Then
$allchecked = False
ExitLoop
EndIf
Next
If $allchecked Then
Local $Pos[2] = [$iLeft + $x, $iTop + $y]
Return $Pos
EndIf
EndIf
Next
Next
Return 0
EndFunc
Func WaitforPixel($iLeft, $iTop, $iRight, $iBottom, $firstColor, $iColorVariation, $maxDelay = 10)
For $i = 1 To $maxDelay * 10
Local $result = _PixelSearch($iLeft, $iTop, $iRight, $iBottom, $firstColor, $iColorVariation)
If IsArray($result) Then Return True
If _Sleep(50) Then Return
Next
Return False
EndFunc
Func isInsideDiamondXY($Coordx, $Coordy)
Local $aCoords = [$Coordx, $Coordy]
Return isInsideDiamond($aCoords)
EndFunc
Func isInsideDiamond($aCoords)
Local $x = $aCoords[0], $y = $aCoords[1], $xD, $yD
Local $Left = 0, $Right = 855, $Top = 20, $Bottom = 675
Local $aDiamond[2][2] = [[$Left, $Top], [$Right, $Bottom]]
Local $aMiddle = [($aDiamond[0][0] + $aDiamond[1][0]) / 2,($aDiamond[0][1] + $aDiamond[1][1]) / 2]
$xD = $aMiddle[0]
$yD = $Top
ConvertToVillagePos($xD, $yD)
$Top = $yD
$xD = $aMiddle[0]
$yD = $Bottom
ConvertToVillagePos($xD, $yD)
$Bottom = $yD
$xD = $Left
$yD = $aMiddle[1]
ConvertToVillagePos($xD, $yD)
$Left = $xD
$xD = $Right
$yD = $aMiddle[1]
ConvertToVillagePos($xD, $yD)
$Right = $xD
Local $aDiamond[2][2] = [[$Left, $Top], [$Right, $Bottom]]
Local $aMiddle = [($aDiamond[0][0] + $aDiamond[1][0]) / 2,($aDiamond[0][1] + $aDiamond[1][1]) / 2]
Local $aSize = [$aMiddle[0] - $aDiamond[0][0], $aMiddle[1] - $aDiamond[0][1]]
Local $DX = Abs($x - $aMiddle[0])
Local $DY = Abs($y - $aMiddle[1])
If($DX / $aSize[0] + $DY / $aSize[1] <= 1) Then
If $x < 68 And $y > 316 Then
If $g_bDebugSetlog Then SetDebugLog("Coordinate Inside Village, but Exclude CHAT")
Return False
ElseIf $y < 63 Then
If $g_bDebugSetlog Then SetDebugLog("Coordinate Inside Village, but Exclude BUILDER")
Return False
ElseIf $x > 692 And $y > 156 And $y < 210 Then
If $g_bDebugSetlog Then SetDebugLog("Coordinate Inside Village, but Exclude GEMS")
Return False
EndIf
Return True
Else
If $g_bDebugSetlog Then SetDebugLog("Coordinate Outside Village")
Return False
EndIf
EndFunc
Func getBuilderCount($bSuppressLog = False, $bBuilderBase = False)
Local $sBuilderInfo, $aGetBuilders, $bIsMainPage = False
If Not $bBuilderBase Then
$bIsMainPage = IsMainPage()
Else
$bIsMainPage = IsMainPageBuilderBase()
EndIf
If $bIsMainPage Then
If Not $bBuilderBase Then
$sBuilderInfo = getBuilders($aBuildersDigits[0], $aBuildersDigits[1])
Else
$sBuilderInfo = getBuilders($aBuildersDigitsBuilderBase[0], $aBuildersDigitsBuilderBase[1])
EndIf
If StringInStr($sBuilderInfo, "#") > 0 Then
$aGetBuilders = StringSplit($sBuilderInfo, "#", $STR_NOCOUNT)
If Not $bBuilderBase Then
$g_iFreeBuilderCount = Int($aGetBuilders[0])
If $g_iTestFreeBuilderCount <> -1 Then $g_iFreeBuilderCount = $g_iTestFreeBuilderCount
$g_iTotalBuilderCount = Int($aGetBuilders[1])
If $g_bDebugSetlog And Not $bSuppressLog Then SetLog("No. of Free/Total Builders: " & $g_iFreeBuilderCount & "/" & $g_iTotalBuilderCount, $COLOR_DEBUG)
Else
$g_iFreeBuilderCountBB = Int($aGetBuilders[0])
$g_iTotalBuilderCountBB = Int($aGetBuilders[1])
If $g_bDebugSetlog And Not $bSuppressLog Then SetLog("No. of Free/Total Builders: " & $g_iFreeBuilderCountBB & "/" & $g_iTotalBuilderCountBB, $COLOR_DEBUG)
EndIf
Return True
Else
SetLog("Bad OCR read Free/Total Builders", $COLOR_ERROR)
EndIf
Else
SetLog("Unable to read Builders info at this time", $COLOR_ERROR)
EndIf
If $g_bDebugSetlog Or $g_bDebugImageSave Then DebugImageSave("getBuilderCount_")
If checkObstacles() Then checkMainScreen()
Return False
EndFunc
Func BuildingInfo($iXstart, $iYstart)
Local $sBldgText, $sBldgLevel, $aString
Local $aResult[3] = ["", "", ""]
$sBldgText = getNameBuilding($iXstart, $iYstart)
If $sBldgText = "" Then
If _Sleep($DELAYBUILDINGINFO1) Then Return
$sBldgText = getNameBuilding($iXstart, $iYstart)
EndIf
If $g_bDebugSetlog Then SetDebugLog("Read building Name String = " & $sBldgText, $COLOR_DEBUG)
If StringInStr($sBldgText, "Cart") Then $sBldgText &= " (FakeLevel 100)"
If StringInStr($sBldgText, "Tree") Then $sBldgText &= " (FakeLevel 99)"
If StringInStr($sBldgText, "Mush") Then $sBldgText &= " (FakeLevel 98)"
If StringInStr($sBldgText, "Trunk") Then $sBldgText &= " (FakeLevel 97)"
If StringInStr($sBldgText, "Bush") Then $sBldgText &= " (FakeLevel 96)"
If StringInStr($sBldgText, "Bark") Then $sBldgText &= " (FakeLevel 95)"
If StringInStr($sBldgText, "Gem") Then $sBldgText &= " (FakeLevel 94)"
$aString = StringSplit($sBldgText, "(")
If $aString[0] = 2 Then
If $g_bDebugSetlog Then SetDebugLog("1st $aString = " & $aString[0] & ", " & $aString[1] & ", " & $aString[2], $COLOR_DEBUG)
If $aString[1] <> "" Then $aResult[1] = StringStripWS($aString[1], 7)
If $aString[2] <> "" Then
$sBldgLevel = $aString[2]
$aString = StringSplit($sBldgLevel, ")")
If $aString[0] = 2 Then
If StringInStr($aString[1], "Broken") Then $aString[1] &= " 200"
If $g_bDebugSetlog Then SetDebugLog("2nd $aString = " & $aString[0] & ", " & $aString[1] & ", " & $aString[2], $COLOR_DEBUG)
If $aString[1] <> "" Then $sBldgLevel = $aString[1]
EndIf
$aString = StringSplit($sBldgLevel, " ")
If $aString[0] = 2 Then
If $g_bDebugSetlog Then SetDebugLog("3rd $aString = " & $aString[0] & ", " & $aString[1] & ", " & $aString[2], $COLOR_DEBUG)
If $aString[2] <> "" Then $aResult[2] = Number($aString[2])
EndIf
EndIf
EndIf
If $aResult[1] <> "" Then $aResult[0] = 1
If $aResult[2] <> "" Then $aResult[0] += 1
If $aResult[2] > 90 Then
If $aResult[2] = 200 Then
$aResult[2] = "Broken"
Else
$aResult[2] = ""
EndIf
EndIf
Return $aResult
EndFunc
Func getNameBuilding($x_start, $y_start)
Return getOcrAndCapture("coc-build", $x_start, $y_start, 377, 27)
EndFunc
Func getGoldVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-g", $x_start, $y_start, 90, 16, True)
EndFunc
Func getRemainTrainTimer($x_start, $y_start, $bNeedCapture = True)
Return getOcrAndCapture("coc-RemainTrain", $x_start, $y_start, 70, 12, True, False, $bNeedCapture)
EndFunc
Func getElixirVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-e", $x_start, $y_start, 90, 16, True)
EndFunc
Func getResourcesValueTrainPage($x_start, $y_start)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 100, 18, True)
EndFunc
Func getDarkElixirVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-de", $x_start, $y_start, 75, 18, True)
EndFunc
Func getTrophyVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-t", $x_start, $y_start, 75, 18, True)
EndFunc
Func getTrophyMainScreen($x_start, $y_start)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 50, 16, True)
EndFunc
Func getTrophyLossAttackScreen($x_start, $y_start)
Return getOcrAndCapture("coc-t-p", $x_start, $y_start, 50, 16, True)
EndFunc
Func getUpgradeResource($x_start, $y_start)
Return getOcrAndCapture("coc-u-r", $x_start, $y_start, 98, 16, True)
EndFunc
Func getResourcesMainScreen($x_start, $y_start)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 110, 16, True)
EndFunc
Func getResourcesLoot($x_start, $y_start)
Return getOcrAndCapture("coc-loot", $x_start, $y_start, 160, 22, True)
EndFunc
Func getResourcesLootDE($x_start, $y_start)
Return getOcrAndCapture("coc-loot", $x_start, $y_start, 75, 22, True)
EndFunc
Func getResourcesLootT($x_start, $y_start)
Return getOcrAndCapture("coc-loot", $x_start, $y_start, 37, 22, True)
EndFunc
Func getResourcesBonus($x_start, $y_start)
Return getOcrAndCapture("coc-bonus", $x_start, $y_start, 98, 16, True)
EndFunc
Func getResourcesBonusPerc($x_start, $y_start)
Return getOcrAndCapture("coc-bonus", $x_start, $y_start, 48, 16, True)
EndFunc
Func getLabUpgrdResourceWht($x_start, $y_start)
Return getOcrAndCapture("coc-lab-w", $x_start, $y_start, 60, 14, True)
EndFunc
Func getLabUpgrdResourceRed($x_start, $y_start)
Return getOcrAndCapture("coc-lab-r", $x_start, $y_start, 60, 14, True)
EndFunc
Func getBldgUpgradeTime($x_start, $y_start)
Return getOcrAndCapture("coc-uptime", $x_start, $y_start, 42, 18)
EndFunc
Func getLabUpgradeTime($x_start, $y_start)
Return getOcrAndCapture("coc-uptime2", $x_start, $y_start, 42, 22)
EndFunc
Func getHeroUpgradeTime($x_start, $y_start)
Return getOcrAndCapture("coc-uptime2", $x_start, $y_start, 68, 20)
EndFunc
Func getChatString($x_start, $y_start, $language)
Return getOcrAndCapture($language, $x_start, $y_start, 280, 16)
EndFunc
Func getBuilders($x_start, $y_start)
Return getOcrAndCapture("coc-Builders", $x_start, $y_start, 40, 18, True)
EndFunc
Func getProfile($x_start, $y_start)
Return getOcrAndCapture("coc-profile", $x_start, $y_start, 55, 13, True)
EndFunc
Func getTroopCountSmall($x_start, $y_start, $bNeedNewCapture = Default)
Return getOcrAndCapture("coc-t-s", $x_start, $y_start, 53, 16, True, Default, $bNeedNewCapture)
EndFunc
Func getTroopCountBig($x_start, $y_start, $bNeedNewCapture = Default)
Return getOcrAndCapture("coc-t-b", $x_start, $y_start, 53, 17, True, Default, $bNeedNewCapture)
EndFunc
Func getTroopsSpellsLevel($x_start, $y_start)
Return getOcrAndCapture("coc-spellslevel", $x_start, $y_start, 20, 14, True)
EndFunc
Func getArmyTroopQuantity($x_start, $y_start)
Return getOcrAndCapture("coc-train-quant", $x_start, $y_start, 45, 12, True)
EndFunc
Func getArmyTroopKind($x_start, $y_start)
Return getOcrAndCapture("coc-train-t-kind", $x_start, $y_start, 59, 11, True)
EndFunc
Func getArmyCampCap($x_start, $y_start, $bNeedCapture = True)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 82, 16, True, False, $bNeedCapture)
EndFunc
Func getCastleDonateCap($x_start, $y_start)
Return getOcrAndCapture("coc-army", $x_start, $y_start, 30, 14, True)
EndFunc
Func getBarracksTroopQuantity($x_start, $y_start)
Return getOcrAndCapture("coc-train", $x_start, $y_start, 52, 16, True)
EndFunc
Func getAttackDisable($x_start, $y_start)
Return getOcrAndCapture("coc-dis", $x_start, $y_start, 118, 24, True)
EndFunc
Func getOcrLanguage($x_start, $y_start)
Return getOcrAndCapture("coc-ms-testl", $x_start, $y_start, 93, 16, True)
EndFunc
Func getOcrSpellDetection($x_start, $y_start)
Local $result = getOcrAndCapture("coc-t-spells2", $x_start, $y_start, 50, 30, True)
Local $PositionSpecialCaracter = 0
$PositionSpecialCaracter = StringInStr($result, "§")
If $PositionSpecialCaracter > 0 Then
Return StringLeft($result, $PositionSpecialCaracter - 1)
Else
Return $result
EndIf
EndFunc
Func getOcrSpellQuantity($x_start, $y_start)
Return getOcrAndCapture("coc-t-t", $x_start, $y_start, 25, 12, True)
EndFunc
Func getOcrClanLevel($x_start, $y_start)
Return getOcrAndCapture("coc-clanlevel", $x_start, $y_start, 20, 19, True)
EndFunc
Func getOcrSpaceCastleDonate($x_start, $y_start)
Return getOcrAndCapture("coc-totalreq", $x_start, $y_start, 45, 12, True)
EndFunc
Func getOcrDonationTroopsDetection($x_start, $y_start)
Local $result = getOcrAndCapture("coc-donationtroop", $x_start, $y_start, 45, 30, True)
Local $PositionSpecialCaracter = 0
$PositionSpecialCaracter = StringInStr($result, "§")
If $PositionSpecialCaracter > 0 Then
Return StringLeft($result, $PositionSpecialCaracter - 1)
Else
Return $result
EndIf
EndFunc
Func getOcrOverAllDamage($x_start, $y_start)
Return getOcrAndCapture("coc-overalldamage", $x_start, $y_start, 50, 20, True)
EndFunc
Func getOcrGuardShield($x_start, $y_start)
Return getOcrAndCapture("coc-guardshield", $x_start, $y_start, 68, 15)
EndFunc
Func getOcrPBTtime($x_start, $y_start)
Return getOcrAndCapture("coc-pbttime", $x_start, $y_start, 59, 15)
EndFunc
Func getOcrMaintenanceTime($x_start, $y_start, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $result = getOcrAndCapture("coc-reloadmsg", $x_start, $y_start, 116, 19, True)
Local $String = ""
If $sLogText = Default Then
$String = "getOcrMaintenanceTime: " & $result
Else
$String = $sLogText & " " & $result
EndIf
If $g_bDebugSetlog Then
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
ElseIf $result <> "" Then
SetDebugLog($String, $LogTextColor, True)
EndIf
Return $result
EndFunc
Func getRemainTLaboratory($x_start, $y_start)
Return getOcrAndCapture("coc-RemainLaboratory", $x_start, $y_start, 194, 25)
EndFunc
Func getRemainTHero($x_start, $y_start, $bNeedCapture = True)
Return getOcrAndCapture("coc-remainhero", $x_start, $y_start, 55, 12, True, False, $bNeedCapture)
EndFunc
Func getHeroStatus($x_start, $y_start)
Return getOcrAndCapture("coc-herostatus", $x_start, $y_start, 20, 20)
EndFunc
Func getRequestRemainTime($x_start, $y_start, $bNeedCapture = True)
Return getOcrAndCapture("coc-CCremainTime", $x_start, $y_start, 30, 14, False, False, $bNeedCapture)
EndFunc
Func getCloudTextShort($x_start, $y_start, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $result = getOcrAndCapture("coc-cloudsearch", $x_start, $y_start, 51, 27)
If $g_bDebugSetlog And $sLogText <> Default And IsString($sLogText) Then
Local $String = $sLogText & $result
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
EndIf
Return $result
EndFunc
Func getCloudFailShort($x_start, $y_start, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $result = getOcrAndCapture("coc-cloudfail", $x_start, $y_start, 72, 24)
If $g_bDebugSetlog And $sLogText <> Default And IsString($sLogText) Then
Local $String = $sLogText & $result
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
EndIf
Return $result
EndFunc
Func getBarracksNewTroopQuantity($x_start, $y_start, $bNeedCapture = True)
Return getOcrAndCapture("coc-newarmy", $x_start, $y_start, 45, 18, True, False, $bNeedCapture)
EndFunc
Func getArmyCapacityOnTrainTroops($x_start, $y_start)
Return getOcrAndCapture("coc-NewCapacity", $x_start, $y_start, 67, 14, True)
EndFunc
Func getQueueTroopsQuantity($x_start, $y_start)
Return StringReplace(getOcrAndCapture("coc-qqtroop", $x_start, $y_start, 71, 22, True), "b", "")
EndFunc
Func getChatStringChinese($x_start, $y_start)
Local $bUseOcrImgLoc = True
Return getOcrAndCapture("chinese-bundle", $x_start, $y_start, 160, 14, Default, $bUseOcrImgLoc)
EndFunc
Func getChatStringKorean($x_start, $y_start)
Local $bUseOcrImgLoc = True
Return getOcrAndCapture("korean-bundle", $x_start, $y_start, 160, 14, Default, $bUseOcrImgLoc)
EndFunc
Func getChatStringPersian($x_start, $y_start, $bConvert = True)
Local $bUseOcrImgLoc = True
Local $OCRString = getOcrAndCapture("persian-bundle", $x_start, $y_start, 240, 20, Default, $bUseOcrImgLoc, True)
If $bConvert = True Then
$OCRString = StringReverse($OCRString)
$OCRString = StringReplace($OCRString, "A", "ا")
$OCRString = StringReplace($OCRString, "B", "ب")
$OCRString = StringReplace($OCRString, "C", "چ")
$OCRString = StringReplace($OCRString, "D", "د")
$OCRString = StringReplace($OCRString, "F", "ف")
$OCRString = StringReplace($OCRString, "G", "گ")
$OCRString = StringReplace($OCRString, "J", "ج")
$OCRString = StringReplace($OCRString, "H", "ه")
$OCRString = StringReplace($OCRString, "R", "ر")
$OCRString = StringReplace($OCRString, "K", "ک")
$OCRString = StringReplace($OCRString, "K", "ل")
$OCRString = StringReplace($OCRString, "M", "م")
$OCRString = StringReplace($OCRString, "N", "ن")
$OCRString = StringReplace($OCRString, "P", "پ")
$OCRString = StringReplace($OCRString, "S", "س")
$OCRString = StringReplace($OCRString, "T", "ت")
$OCRString = StringReplace($OCRString, "V", "و")
$OCRString = StringReplace($OCRString, "Y", "ی")
$OCRString = StringReplace($OCRString, "L", "ل")
$OCRString = StringReplace($OCRString, "Z", "ز")
$OCRString = StringReplace($OCRString, "X", "خ")
$OCRString = StringReplace($OCRString, "Q", "ق")
$OCRString = StringReplace($OCRString, ",", ",")
$OCRString = StringReplace($OCRString, "0", " ")
$OCRString = StringReplace($OCRString, "1", ".")
$OCRString = StringReplace($OCRString, "22", "ع")
$OCRString = StringReplace($OCRString, "44", "ش")
$OCRString = StringReplace($OCRString, "55", "ح")
$OCRString = StringReplace($OCRString, "66", "ض")
$OCRString = StringReplace($OCRString, "77", "ط")
$OCRString = StringReplace($OCRString, "88", "لا")
$OCRString = StringReplace($OCRString, "99", "ث")
$OCRString = StringStripWS($OCRString, 1 + 2)
EndIf
Return $OCRString
EndFunc
Func OcrForceCaptureRegion($bForce = Default)
If $bForce = Default Then Return $g_bOcrForceCaptureRegion
Local $wasForce = $g_bOcrForceCaptureRegion
$g_bOcrForceCaptureRegion = $bForce
Return $wasForce
EndFunc
Func getOcrAndCapture($language, $x_start, $y_start, $width, $height, $removeSpace = Default, $bImgLoc = Default, $bForceCaptureRegion = Default)
If $removeSpace = Default Then $removeSpace = False
If $bImgLoc = Default Then $bImgLoc = False
If $bForceCaptureRegion = Default Then $bForceCaptureRegion = $g_bOcrForceCaptureRegion
Static $_hHBitmap = 0
If $bForceCaptureRegion = True Then
_CaptureRegion2($x_start, $y_start, $x_start + $width, $y_start + $height)
Else
$_hHBitmap = GetHHBitmapArea($g_hHBitmap2, $x_start, $y_start, $x_start + $width, $y_start + $height)
EndIf
Local $result
If $bImgLoc Then
If $_hHBitmap <> 0 Then
$result = getOcrImgLoc($_hHBitmap, $language)
Else
$result = getOcrImgLoc($g_hHBitmap2, $language)
EndIf
Else
If $_hHBitmap <> 0 Then
$result = getOcr($_hHBitmap, $language)
Else
$result = getOcr($g_hHBitmap2, $language)
EndIf
EndIf
If $_hHBitmap <> 0 Then
GdiDeleteHBitmap($_hHBitmap)
EndIf
$_hHBitmap = 0
If($removeSpace) Then
$result = StringReplace($result, " ", "")
Else
$result = StringStripWS($result, BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING, $STR_STRIPSPACES))
EndIf
Return $result
EndFunc
Func getOcr(ByRef Const $_hHBitmap, $language)
Local $result = DllCallMyBot("ocr", "ptr", $_hHBitmap, "str", $language, "int", $g_bDebugOcr ? 1 : 0)
If IsArray($result) Then
Return $result[0]
Else
Return ""
EndIf
EndFunc
Func getOcrImgLoc(ByRef Const $_hHBitmap, $sLanguage)
Local $result = DllCallMyBot("DoOCR", "handle", $_hHBitmap, "str", $sLanguage)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_hLibMyBot, $error)
If $g_bDebugSetlog Then SetDebugLog(" imgloc DLL Error : " & $error & " --- " & $extError)
Return SetError(2, $extError, "")
EndIf
If $g_bDebugImageSave Then DebugImageSave($sLanguage, False)
If IsArray($result) Then
Return $result[0]
Else
Return ""
EndIf
EndFunc
Func getPBTime()
Local $sTimeResult = ""
Local $aString[3]
Local $bPBTStart = False
Local $iPBTSeconds, $Result
Local $iHour = 0, $iMin = 0, $iSec = 0
Local $sPBTReturnResult = ""
If IsMainPage() = False Then
SetLog("Not on Main page to read PB information", $COLOR_ERROR)
Return
EndIf
ClickP($aShieldInfoButton)
If _Sleep($DELAYPERSONALSHIELD3) Then Return
Local $iCount = 0
While _CheckPixel($aIsShieldInfo, $g_bCapturePixel) = False
If _Sleep($DELAYPERSONALSHIELD2) Then Return
$Result = getAttackDisable(180, 156 + $g_iMidOffsetY)
If $g_bDebugSetlog Then SetDebugLog("OCR PBT early warning= " & $Result, $COLOR_DEBUG)
If(StringLen($Result) > 3) And StringRegExp($Result, "[a-w]", $STR_REGEXPMATCH) Then
SetLog("Personal Break Warning found!", $COLOR_INFO)
$bPBTStart = True
ExitLoop
EndIf
$iCount += 1
If $iCount > 20 Then
SetLog("PBT information window failed to open", $COLOR_DEBUG)
If $g_bDebugImageSave Then DebugImageSave("PBTInfo_", $g_bCapturePixel, "png", False)
ClickP($aAway, 1, 0, "#9999")
If _Sleep($DELAYPERSONALSHIELD2) Then Return
Return
EndIf
WEnd
If _CheckPixel($aIsShieldInfo, $g_bCapturePixel) Or $bPBTStart Then
$sTimeResult = getOcrPBTtime(555, 499 + $g_iMidOffsetY)
If $g_bDebugSetlog Then SetDebugLog("OCR PBT Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" Then
If _Sleep($DELAYPERSONALSHIELD2) Then Return
$sTimeResult = getOcrPBTtime(555, 499 + $g_iMidOffsetY)
If $g_bDebugSetlog Then SetDebugLog("OCR2 PBT Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" And $bPBTStart = False Then
SetLog("strange error, no PBT value found?", $COLOR_ERROR)
SetError(1, "Bad OCR of PB time value ")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($DELAYPERSONALSHIELD2) Then Return
Return
EndIf
EndIf
If _Sleep($DELAYRESPOND) Then Return
$aString = StringSplit($sTimeResult, " ")
Switch $aString[0]
Case 1
Select
Case StringInStr($aString[1], "s", $STR_NOCASESENSEBASIC)
$iSec = Number($aString[1])
Case StringInStr($aString[1], "m", $STR_NOCASESENSEBASIC)
$iMin = Number($aString[2])
Case StringInStr($aString[1], "h", $STR_NOCASESENSEBASIC)
$iHour = Number($aString[1])
Case Else
SetLog("strange error, unexpected PBT value? |" & $aString[1], $COLOR_ERROR)
SetError(2, "Error processing time string")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($DELAYPERSONALSHIELD2) Then Return
Return
EndSelect
Case 2
Select
Case StringInStr($aString[1], "h", $STR_NOCASESENSEBASIC)
$iHour = Number($aString[1])
If StringInStr($aString[2], "m", $STR_NOCASESENSEBASIC) Then
$iMin = Number($aString[2])
EndIf
Case StringInStr($aString[1], "m", $STR_NOCASESENSEBASIC)
$iMin = Number($aString[1])
If StringInStr($aString[2], "s", $STR_NOCASESENSEBASIC) Then
$iSec = Number($aString[2])
EndIf
Case Else
SetLog("strange error, unexpected PBT value? |" & $aString[1] & "|" & $aString[2], $COLOR_ERROR)
SetError(3, "Error processing time string")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($DELAYPERSONALSHIELD2) Then Return
Return
EndSelect
Case Else
If $bPBTStart = False Then
SetLog("Error processing PBT time string: " & $sTimeResult, $COLOR_ERROR)
SetError(4, "Error processing time string")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($DELAYPERSONALSHIELD2) Then Return
Return
Else
SetLog("Error processing PBT time string: " & $sTimeResult, $COLOR_INFO)
SetLog("Continue due PB starting now", $COLOR_SUCCESS)
EndIf
EndSwitch
$iPBTSeconds =($iHour * 3600) +($iMin * 60) + $iSec
If $g_bDebugSetlog Then SetDebugLog("Computed PBT Seconds = " & $iPBTSeconds, $COLOR_DEBUG)
If $bPBTStart Then
$sPBTReturnResult = _DateAdd('s', -10, _NowCalc())
Else
$sPBTReturnResult = _DateAdd('s', $iPBTSeconds, _NowCalc())
EndIf
If @error Then SetLog("_DateAdd error= " & @error, $COLOR_ERROR)
If $g_bDebugSetlog Then SetDebugLog("PBT starts: " & $sPBTReturnResult, $COLOR_DEBUG)
If _Sleep($DELAYPERSONALSHIELD1) Then Return
ClickP($aAway, 1, 0, "#9999")
If _Sleep($DELAYPERSONALSHIELD2) Then Return
Return $sPBTReturnResult
Else
If $g_bDebugSetlog Then SetDebugLog("PB Info window failed to open for PB Time OCR", $COLOR_ERROR)
EndIf
EndFunc
Func getShieldInfo()
Local $sTimeResult = ""
Local $aString[3]
Local $iShieldSeconds
Local $iDay = 0, $iHour = 0, $iMin = 0, $iSec = 0
Local $aPBReturnResult[3] = ["", "", ""]
$aPBReturnResult[1] = StringFormat("%02s",($iDay * 24) + $iHour) & ":" & StringFormat("%02s", $iMin) & ":" & StringFormat("%02s", $iSec)
If IsMainPage() = False Then
SetLog("unable to read shield information", $COLOR_ERROR)
Return
EndIf
Select
Case _CheckPixel($aNoShield, $g_bCapturePixel)
$aPBReturnResult[0] = "none"
If $g_bDebugSetlog Then SetDebugLog("No shield active", $COLOR_DEBUG)
Return $aPBReturnResult
Case _CheckPixel($aHaveShield, $g_bCapturePixel)
$aPBReturnResult[0] = "shield"
If $g_bDebugSetlog Then SetDebugLog("Shield Active", $COLOR_DEBUG)
Case _CheckPixel($aHavePerGuard, $g_bCapturePixel)
$aPBReturnResult[0] = "guard"
If $g_bDebugSetlog Then SetDebugLog("Guard Active", $COLOR_DEBUG)
Case Else
SetLog("Sorry, Monkey needs more bananas to read shield type", $COLOR_ERROR)
SetError(1, "Bad shield pixel read")
Return
EndSelect
$sTimeResult = getOcrGuardShield(484, 21)
If $g_bDebugSetlog Then SetDebugLog("OCR Shield Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" Then
If _Sleep($DELAYPERSONALSHIELD2) Then Return
$sTimeResult = getOcrGuardShield(484, 21)
If $g_bDebugSetlog Then SetDebugLog("OCR2 Shield Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" Then
$aPBReturnResult[1] = '00:00:00'
SetLog("strange error, no shield value found?", $COLOR_ERROR)
SetError(2, "Bad time value OCR")
Return $aPBReturnResult
EndIf
EndIf
If _Sleep($DELAYPERSONALSHIELD3) Then Return
$aString = StringSplit($sTimeResult, " ")
Switch $aString[0]
Case 1
If StringInStr($aString[1], "s", $STR_NOCASESENSEBASIC) Then $iSec = Number($aString[1])
Case 2
Select
Case StringInStr($aString[1], "d", $STR_NOCASESENSEBASIC)
$iDay = Number($aString[1])
If StringInStr($aString[2], "h", $STR_NOCASESENSEBASIC) Then
$iHour = Number($aString[2])
EndIf
Case StringInStr($aString[1], "h", $STR_NOCASESENSEBASIC)
$iHour = Number($aString[1])
If StringInStr($aString[2], "m", $STR_NOCASESENSEBASIC) Then
$iMin = Number($aString[2])
EndIf
Case StringInStr($aString[1], "m", $STR_NOCASESENSEBASIC)
$iMin = Number($aString[1])
If StringInStr($aString[2], "s", $STR_NOCASESENSEBASIC) Then
$iSec = Number($aString[2])
EndIf
Case Else
SetLog("strange error, unexpected shield value?", $COLOR_ERROR)
SetError(3, "Error processing time string")
Return $aPBReturnResult
EndSelect
Case Else
SetLog("Error processing time string: " & $sTimeResult, $COLOR_ERROR)
SetError(4, "Error processing time string")
Return $aPBReturnResult
EndSwitch
$aPBReturnResult[1] = StringFormat("%02s",($iDay * 24) + $iHour) & ":" & StringFormat("%02s", $iMin) & ":" & StringFormat("%02s", $iSec)
If $g_bDebugSetlog Then SetDebugLog("Shield Time String = " & $aPBReturnResult[1], $COLOR_DEBUG)
$iShieldSeconds =($iDay * 86400) +($iHour * 3600) +($iMin * 60) + $iSec
If $g_bDebugSetlog Then SetDebugLog("Computed Shield Seconds = " & $iShieldSeconds, $COLOR_DEBUG)
$aPBReturnResult[2] = _DateAdd('s', $iShieldSeconds, _NowCalc())
If @error Then SetLog("_DateAdd error= " & @error, $COLOR_ERROR)
If $g_bDebugSetlog Then SetDebugLog("Shield expires at: " & $aPBReturnResult[2], $COLOR_INFO)
Return $aPBReturnResult
EndFunc
Func updateMultiSearchStats($aResult, $statFile = "")
Switch $statFile
Case $g_sProfileBuildingStatsPath
updateWeakBaseStats($aResult)
Case Else
EndSwitch
EndFunc
Func addInfoToDebugImage(ByRef $hGraphic, ByRef $hPen, $fileName, $x, $y)
_GDIPlus_GraphicsDrawRect($hGraphic, $x - 5, $y - 5, 10, 10, $hPen)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
Local $hFormat = _GDIPlus_StringFormatCreate()
Local $hFamily = _GDIPlus_FontFamilyCreate("Tahoma")
Local $hFont = _GDIPlus_FontCreate($hFamily, 12, 2)
Local $tLayout = _GDIPlus_RectFCreate($x + 10, $y, 0, 0)
Local $sString = String($fileName)
Local $aInfo = _GDIPlus_GraphicsMeasureString($hGraphic, $sString, $hFont, $tLayout, $hFormat)
_GDIPlus_GraphicsDrawStringEx($hGraphic, $sString, $hFont, $aInfo[0], $hFormat, $hBrush)
$tLayout = 0
_GDIPlus_FontDispose($hFont)
_GDIPlus_FontFamilyDispose($hFamily)
_GDIPlus_StringFormatDispose($hFormat)
_GDIPlus_BrushDispose($hBrush)
EndFunc
Func captureDebugImage($aResult, $subDirectory)
If TestCapture() Then Return
Local $coords
If IsArray($aResult) Then
DirCreate($g_sProfileTempDebugPath & $subDirectory)
Local $editedImage = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $fileName = String($Date & "_" & $Time & ".png")
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPen = _GDIPlus_PenCreate(0xFFFF0000, 2)
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][4]) > 0 Then
$coords = $aResult[$i][5]
If IsArray($coords) Then
For $j = 0 To UBound($coords) - 1
Local $coord = $coords[$j]
If UBound($coord) > 1 Then
addInfoToDebugImage($hGraphic, $hPen, $aResult[$i][0], $coord[0], $coord[1])
EndIf
Next
EndIf
EndIf
Next
_GDIPlus_GraphicsDrawString($hGraphic, "Time Taken:" & $aResult[0][2] & " " & $aResult[0][3], 350, 50, "Verdana", 20)
_GDIPlus_ImageSaveToFile($editedImage, $g_sProfileTempDebugPath & $subDirectory & "\" & $fileName)
_GDIPlus_PenDispose($hPen)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($editedImage)
EndIf
EndFunc
Func updateResultsRow(ByRef $aResult, $redLines = "")
Local $numberFound = 0
If IsArray($aResult) Then
If UBound($aResult) > 1 Then
For $j = 1 To UBound($aResult) - 1
$numberFound += Number($aResult[$j][4])
Next
EndIf
$aResult[0][0] = $redLines
$aResult[0][1] = $numberFound
Else
EndIf
EndFunc
Func multiMatches($directory, $maxReturnPoints = 0, $fullCocAreas = "DCD", $redLines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult[1][6] = [["", 0, 0, "Seconds", "", ""]], $aCoordArray[0][0], $aCoords, $aCoordsSplit, $aValue
If $forceCaptureRegion = True Then _CaptureRegion2()
Local $res = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $directory, "str", $fullCocAreas, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
If @error Then _logErrorDLLCall($g_sLibMyBotPath, @error)
$aValue = DllCall($g_hLibMyBot, "str", "GetProperty", "str", "redline", "str", "")
If @error Then _logErrorDLLCall($g_sLibMyBotPath, @error)
$redLines = $aValue[0]
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys) + 1][6]
For $i = 0 To UBound($aKeys) - 1
$aResult[$i + 1][0] = RetrieveImglocProperty($aKeys[$i], "filename")
$aResult[$i + 1][1] = RetrieveImglocProperty($aKeys[$i], "objectname")
$aResult[$i + 1][2] = RetrieveImglocProperty($aKeys[$i], "objectlevel")
$aResult[$i + 1][3] = RetrieveImglocProperty($aKeys[$i], "fillLevel")
$aResult[$i + 1][4] = RetrieveImglocProperty($aKeys[$i], "totalobjects")
$aValue = RetrieveImglocProperty($aKeys[$i], "objectpoints")
$aCoords = StringSplit($aValue, "|", $STR_NOCOUNT)
ReDim $aCoordArray[UBound($aCoords)][2]
For $j = 0 To UBound($aCoords) - 1
$aCoordsSplit = StringSplit($aCoords[$j], ",", $STR_NOCOUNT)
If UBound($aCoordsSplit) = 2 Then
$aCoordArray[$j][0] = $aCoordsSplit[0]
$aCoordArray[$j][1] = $aCoordsSplit[1]
EndIf
Next
$aResult[$i + 1][5] = $aCoordArray
Next
EndIf
updateResultsRow($aResult, $redLines)
updateMultiSearchStats($aResult, $statFile)
Return $aResult
EndFunc
Func returnMultipleMatchesOwnVillage($directory, $maxReturnPoints = 0, $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult = multiMatches($directory, $maxReturnPoints, "ECD", "ECD", $statFile, $minLevel, $maxLevel, $forceCaptureRegion)
Return $aResult
EndFunc
Func returnSingleMatchOwnVillage($directory, $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult = multiMatches($directory, 1, "ECD", "ECD", $statFile, $minLevel, $maxLevel, $forceCaptureRegion)
Return $aResult
EndFunc
Func returnAllMatches($directory, $redLines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult = multiMatches($directory, 0, "DCD", $redLines, $statFile, $minLevel, $maxLevel, $forceCaptureRegion)
Return $aResult
EndFunc
Func returnLowestLevelSingleMatch($directory, $returnMax = 100, $redLines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $defaultCoords[1][2] = [[0, 0]]
Local $return[7] = ["None", "None", $returnMax + 1, 0, 0, $defaultCoords, ""]
Local $aResult = multiMatches($directory, 1, "DCD", $redLines, $statFile, $minLevel, $maxLevel, $forceCaptureRegion)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][2]) < Number($return[2]) Then
$return[0] = $aResult[$i][0]
$return[1] = $aResult[$i][1]
$return[2] = $aResult[$i][2]
$return[3] = $aResult[$i][3]
$return[4] = $aResult[$i][4]
$return[5] = $aResult[$i][5]
EndIf
Next
EndIf
$return[6] = $aResult[0][0]
Return $return
EndFunc
Func returnMultipleMatches($directory, $maxReturnPoints = 0, $redLines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult = multiMatches($directory, $maxReturnPoints, "DCD", $redLines, $statFile, $minLevel, $maxLevel)
Return $aResult
EndFunc
Func createWeakBaseStats()
Local $aKeys = _FileListToArrayRec($g_sImgWeakBaseBuildingsDir, "*.xml", $FLTAR_FILES, $FLTAR_RECUR, $FLTAR_SORT, $FLTAR_NOPATH)
Local $return[UBound($aKeys) - 1][2]
If Not FileExists($g_sProfileBuildingStatsPath) Then _FileCreate($g_sProfileBuildingStatsPath)
For $i = 1 To UBound($aKeys) - 1
$return[$i - 1][0] = $aKeys[$i]
$return[$i - 1][1] = 0
IniWrite($g_sProfileBuildingStatsPath, "WeakBase", $aKeys[$i], "0")
Next
Return $return
EndFunc
Func readWeakBaseStats()
Local $aKeys = _FileListToArrayRec($g_sImgWeakBaseBuildingsDir, "*.xml", $FLTAR_FILES, $FLTAR_RECUR, $FLTAR_SORT, $FLTAR_NOPATH)
Local $return[UBound($aKeys) - 1][2]
If FileExists($g_sProfileBuildingStatsPath) Then
For $i = 1 To UBound($aKeys) - 1
$return[$i - 1][0] = $aKeys[$i]
$return[$i - 1][1] = IniRead($g_sProfileBuildingStatsPath, "WeakBase", $aKeys[$i], "0")
Next
Else
$return = createWeakBaseStats()
EndIf
Return $return
EndFunc
Func updateWeakBaseStats(ByRef $aResult)
If IsArray($aResult) Then
For $i = 1 To UBound($aResult) - 1
For $j = 0 To UBound($g_aiWeakBaseStats) - 1
If $g_aiWeakBaseStats[$j][0] = $aResult[$i][0] Then
$g_aiWeakBaseStats[$j][1] = Number($g_aiWeakBaseStats[$j][1]) + 1
EndIf
Next
Next
EndIf
EndFunc
Func displayWeakBaseLog($aResult, $showLog = False)
If $showLog And IsArray($aResult) Then
SetLog("================ Weak Base Detection Start ================", $COLOR_INFO)
SetLog("Highest Eagle Artillery: " & $aResult[1][0] & " - Level: " & $aResult[1][2], $COLOR_INFO)
SetLog("Highest Inferno Tower: " & $aResult[2][0] & " - Level: " & $aResult[2][2], $COLOR_INFO)
SetLog("Highest X-Bow: " & $aResult[3][0] & " - Level: " & $aResult[3][2], $COLOR_INFO)
SetLog("Highest Wizard Tower: " & $aResult[4][0] & " - Level: " & $aResult[4][2], $COLOR_INFO)
SetLog("Highest Mortar: " & $aResult[5][0] & " - Level: " & $aResult[5][2], $COLOR_INFO)
SetLog("Highest Air Defense: " & $aResult[6][0] & " - Level: " & $aResult[6][2], $COLOR_INFO)
SetLog("Time taken: " & $aResult[0][2] & " " & $aResult[0][3], $COLOR_INFO)
SetLog("================ Weak Base Detection Stop =================", $COLOR_INFO)
EndIf
EndFunc
Func getTHDefenseMax($levelTownHall, $iDefenseType)
If $levelTownHall = 0 Or $levelTownHall = "-" Then $levelTownHall = 11
Local $maxLevel = _ObjGetValue($g_oBldgLevels, $iDefenseType + 7)[$levelTownHall - 1]
If @error Then
_ObjErrMsg("_ObjGetValue $g_oBldgLevels", @error)
$maxLevel = 100
EndIf
Return $maxLevel
EndFunc
Func getMaxUISetting($settingArray, $iDefenseType)
Local $result = 0, $maxDB = 0, $maxLB = 0
If IsArray($settingArray) Then
$maxDB =(IsWeakBaseActive($DB)) ? $settingArray[$DB] : 0
$maxLB =(IsWeakBaseActive($LB)) ? $settingArray[$LB] : 0
$result = _Max(Number($maxDB), Number($maxLB))
EndIf
If $g_bDebugSetlog Then SetDebugLog("Max " & $g_aWeakDefenseNames[$iDefenseType] & " Level: " & $result, $COLOR_INFO)
Return $result
EndFunc
Func getMinUISetting($settingArray, $iDefenseType)
Local $result = 0, $minDB = 0, $minLB = 0
If IsArray($settingArray) Then
$minDB =(IsWeakBaseActive($DB)) ? $settingArray[$DB] : 0
$minLB =(IsWeakBaseActive($LB)) ? $settingArray[$LB] : 0
$result = _Min(Number($minDB), Number($minLB))
EndIf
If $g_bDebugSetlog Then SetDebugLog("Min " & $g_aWeakDefenseNames[$iDefenseType] & " Level: " & $result, $COLOR_INFO)
Return $result
EndFunc
Func getIsWeak($aResults, $searchType)
Return $aResults[$eWeakEagle][2] <= Number($g_aiFilterMaxEagleLevel[$searchType]) And $aResults[$eWeakInferno][2] <= Number($g_aiFilterMaxInfernoLevel[$searchType]) And $aResults[$eWeakXBow][2] <= Number($g_aiFilterMaxXBowLevel[$searchType]) And $aResults[$eWeakWizard][2] <= Number($g_aiFilterMaxWizTowerLevel[$searchType]) And $aResults[$eWeakMortar][2] <= Number($g_aiFilterMaxMortarLevel[$searchType]) And $aResults[$eWeakAirDefense][2] <= Number($g_aiFilterMaxAirDefenseLevel[$searchType])
Local $text = "DB"
If $searchType = 1 Then $text = "LB"
SetLog("================ Weak Base Detection Start ================")
If $g_abFilterMaxEagleEnable[$searchType] Then SetLog("[" & $text & "] Eagle level " & $g_aiFilterMaxEagleLevel[$searchType] & " as max, detection higher level : " & $aResults[$eWeakEagle][2], $COLOR_DEBUG)
If $g_abFilterMaxInfernoEnable[$searchType] Then SetLog("[" & $text & "] Inferno level " & $g_aiFilterMaxInfernoLevel[$searchType] & " as max, detection higher level: " & $aResults[$eWeakInferno][2], $COLOR_DEBUG)
If $g_abFilterMaxXBowEnable[$searchType] Then SetLog("[" & $text & "] XBow level " & $g_aiFilterMaxXBowLevel[$searchType] & " as max, detection higher level: " & $aResults[$eWeakXBow][2], $COLOR_DEBUG)
If $g_abFilterMaxWizTowerEnable[$searchType] Then SetLog("[" & $text & "] WTower level " & $g_aiFilterMaxWizTowerLevel[$searchType] & " as max, detection higher level: " & $aResults[$eWeakWizard][2], $COLOR_DEBUG)
If $g_abFilterMaxMortarEnable[$searchType] Then SetLog("[ " & $text & "] Mortar level " & $g_aiFilterMaxMortarLevel[$searchType] & " as max, detection higher level: " & $aResults[$eWeakMortar][2], $COLOR_DEBUG)
If $g_abFilterMaxAirDefenseEnable[$searchType] Then SetLog("[" & $text & "] AirDef level " & $g_aiFilterMaxAirDefenseLevel[$searchType] & " as max, detection higher level: " & $aResults[$eWeakAirDefense][2], $COLOR_DEBUG)
SetLog("Is a Weak Base? " & $aResults)
SetLog("================ Weak Base Detection Stop =================")
Return $aResults
EndFunc
Func IsWeakBaseActive($type)
Return($g_abFilterMaxEagleEnable[$type] Or $g_abFilterMaxInfernoEnable[$type] Or $g_abFilterMaxXBowEnable[$type] Or $g_abFilterMaxWizTowerEnable[$type] Or $g_abFilterMaxMortarEnable[$type] Or $g_abFilterMaxAirDefenseEnable[$type]) And IsSearchModeActiveMini($type)
EndFunc
Func defenseSearch(ByRef $aResult, $directory, $townHallLevel, $settingArray, $iDefenseType, ByRef $performSearch, $guiEnabledArray, $bForceCaptureRegion = True)
Local $defaultCoords[1][2] = [[0, 0]]
Local $aDefenseResult[7] = ["Skipped", "Skipped", $g_oBldgLevels.Item($iDefenseType + 7), 0, 0, $defaultCoords, ""]
Local $aNotNecessary[7] = ["None", "None", 0, 0, 0, $defaultCoords, ""]
If $performSearch Then
Local $minSearchLevel = getMinUISetting($settingArray, $iDefenseType) + 1
Local $maxSearchLevel = getTHDefenseMax($townHallLevel, $iDefenseType)
Local $bGuiEnableArray = IsArray($guiEnabledArray), $bIsSearchModeActiveDB = IsSearchModeActiveMini($DB), $bIsSearchModeActiveLB = IsSearchModeActiveMini($LB)
Local $guiCheckDefense = $bGuiEnableArray And(($bIsSearchModeActiveDB And $guiEnabledArray[$DB]) Or($bIsSearchModeActiveLB And $guiEnabledArray[$LB]))
Local $defenseTimer = __TimerInit()
If $guiCheckDefense And $maxSearchLevel >= $minSearchLevel Then
Local $sDefenseName = StringSplit($directory, "\", $STR_NOCOUNT)
If $g_bDebugSetlog Then SetDebugLog("checkDefense :" & $sDefenseName[UBound($sDefenseName) - 1] & " > " & $minSearchLevel & " < " & $maxSearchLevel & " For TH:" & $townHallLevel, $COLOR_ORANGE)
$aDefenseResult = DefenseSearchMultiMatch($iDefenseType, $directory, $aResult[0][0], $g_sProfileBuildingStatsPath, $minSearchLevel, $maxSearchLevel, $bForceCaptureRegion)
If $aResult[0][0] = "" Then $aResult[0][0] = $aDefenseResult[6]
If Number($aDefenseResult[2]) > getMaxUISetting($settingArray, $iDefenseType) Then $performSearch = False
If $g_bDebugSetlog Then
SetDebugLog("checkDefense: " & $g_aWeakDefenseNames[$iDefenseType] & " - " & Round(__TimerDiff($defenseTimer) / 1000, 2) & " seconds")
For $i = 0 To UBound($aDefenseResult) - 2
SetDebugLog("$aDefenseResult[" & $i & "]: " & $aDefenseResult[$i])
Next
EndIf
Else
$aDefenseResult = $aNotNecessary
If $g_bDebugSetlog Then SetDebugLog("checkDefense: " & $g_aWeakDefenseNames[$iDefenseType] & " not necessary! $bGuiEnableArray=" & $bGuiEnableArray & ", $bIsSearchModeActiveDB=" & $bIsSearchModeActiveDB & ", $bIsSearchModeActiveLB=" & $bIsSearchModeActiveLB & ", $maxSearchLevel=" & $maxSearchLevel & ", $minSearchLevel=" & $minSearchLevel)
EndIf
EndIf
Return $aDefenseResult
EndFunc
Func weakBaseCheck($townHallLevel = 11, $redlines = "", $bForceCaptureRegion = True)
Local $defaultCoords[1][2] = [[0, 0]]
Local $aResult[7][6] = [[$redlines, 0, 0, "Seconds", "", ""], ["Skipped", "Skipped", $g_oBldgLevels.Item($eWeakEagle + 6), 0, 0, $defaultCoords], ["Skipped", "Skipped", $g_oBldgLevels.Item($eWeakInferno + 6), 0, 0, $defaultCoords], ["Skipped", "Skipped", $g_oBldgLevels.Item($eWeakXBow + 6), 0, 0, $defaultCoords], ["Skipped", "Skipped", $g_oBldgLevels.Item($eWeakWizard + 6), 0, 0, $defaultCoords], ["Skipped", "Skipped", $g_oBldgLevels.Item($eWeakMortar + 6), 0, 0, $defaultCoords], ["Skipped", "Skipped", $g_oBldgLevels.Item($eWeakAirDefense + 6), 0, 0, $defaultCoords]]
Local $aEagleResults, $aInfernoResults, $aMortarResults, $aWizardTowerResults, $aXBowResults, $aAirDefenseResults
Local $performSearch = True
Local $hWeakTimer = __TimerInit()
$aEagleResults = defenseSearch($aResult, $g_sImgWeakBaseBuildingsEagleDir, $townHallLevel, $g_aiFilterMaxEagleLevel, $eWeakEagle, $performSearch, $g_abFilterMaxEagleEnable, $bForceCaptureRegion)
$aInfernoResults = defenseSearch($aResult, $g_sImgWeakBaseBuildingsInfernoDir, $townHallLevel, $g_aiFilterMaxInfernoLevel, $eWeakInferno, $performSearch, $g_abFilterMaxInfernoEnable, $bForceCaptureRegion)
$aXBowResults = defenseSearch($aResult, $g_sImgWeakBaseBuildingsXbowDir, $townHallLevel, $g_aiFilterMaxXBowLevel, $eWeakXBow, $performSearch, $g_abFilterMaxXBowEnable, $bForceCaptureRegion)
If $g_iDetectedImageType = 1 Then
$aWizardTowerResults = defenseSearch($aResult, $g_sImgWeakBaseBuildingsWizTowerSnowDir, $townHallLevel, $g_aiFilterMaxWizTowerLevel, $eWeakWizard, $performSearch, $g_abFilterMaxWizTowerEnable, $bForceCaptureRegion)
Else
$aWizardTowerResults = defenseSearch($aResult, $g_sImgWeakBaseBuildingsWizTowerDir, $townHallLevel, $g_aiFilterMaxWizTowerLevel, $eWeakWizard, $performSearch, $g_abFilterMaxWizTowerEnable, $bForceCaptureRegion)
EndIf
$aMortarResults = defenseSearch($aResult, $g_sImgWeakBaseBuildingsMortarsDir, $townHallLevel, $g_aiFilterMaxMortarLevel, $eWeakMortar, $performSearch, $g_abFilterMaxMortarEnable, $bForceCaptureRegion)
$aAirDefenseResults = defenseSearch($aResult, $g_sImgWeakBaseBuildingsAirDefenseDir, $townHallLevel, $g_aiFilterMaxAirDefenseLevel, $eWeakAirDefense, $performSearch, $g_abFilterMaxAirDefenseEnable, $bForceCaptureRegion)
For $i = 1 To UBound($aResult) - 1
For $j = 0 To UBound($aResult, 2) - 1
Switch $i
Case $eWeakEagle
If IsArray($aEagleResults) Then $aResult[$i][$j] = $aEagleResults[$j]
Case $eWeakInferno
If IsArray($aInfernoResults) Then $aResult[$i][$j] = $aInfernoResults[$j]
Case $eWeakXBow
If IsArray($aXBowResults) Then $aResult[$i][$j] = $aXBowResults[$j]
Case $eWeakWizard
If IsArray($aWizardTowerResults) Then $aResult[$i][$j] = $aWizardTowerResults[$j]
Case $eWeakMortar
If IsArray($aMortarResults) Then $aResult[$i][$j] = $aMortarResults[$j]
Case $eWeakAirDefense
If IsArray($aAirDefenseResults) Then $aResult[$i][$j] = $aAirDefenseResults[$j]
Case Else
EndSwitch
Next
Next
$aResult[0][2] = Round(__TimerDiff($hWeakTimer) / 1000, 2)
$aResult[0][3] = "Seconds"
Return $aResult
EndFunc
Func IsWeakBase($townHallLevel = 11, $redlines = "", $bForceCaptureRegion = True)
Local $aResult = weakBaseCheck($townHallLevel, $redlines, $bForceCaptureRegion)
displayWeakBaseLog($aResult, $g_bDebugSetlog)
If $g_bDebugSetlog Then
_LogObjList($g_oBldgAttackInfo)
Local $text = _ArrayToString($aResult, ",", 0, UBound($aResult, 1) - 1, "|", 0, UBound($aResult, 2) - 1)
If @error Then SetDebugLog("Error _ArrayToString, code:" & @error, $COLOR_ERROR)
SetDebugLog("$aResult Array: " & $text, $COLOR_DEBUG)
EndIf
If Number($aResult[0][2]) > 10 Then
captureDebugImage($aResult, "WeakBase_Detection_TooSlow")
ElseIf $g_bDebugImageSave And Number($aResult[1][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Eagle_NotDetected")
ElseIf $g_bDebugImageSave And Number($aResult[2][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Inferno_NotDetected")
ElseIf $g_bDebugImageSave And Number($aResult[3][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Xbow_NotDetected")
ElseIf $g_bDebugImageSave And Number($aResult[4][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_WTower_NotDetected")
ElseIf $g_bDebugImageSave And Number($aResult[5][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Mortar_NotDetected")
ElseIf $g_bDebugImageSave And Number($aResult[6][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_ADefense_NotDetected")
ElseIf $g_bDebugImageSave Then
captureDebugImage($aResult, "WeakBase_Detection")
EndIf
Return $aResult
EndFunc
Func DefenseSearchMultiMatch($iDefenseType, $directory, $redlines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 100, $bForceCaptureRegion = True)
If $g_bDebugSetlog Then SetDebugLog("Begin DefenseSearchMultiMatch: " & $g_sBldgNames[$iDefenseType + 7], $COLOR_DEBUG1)
Local $hTimer = __TimerInit()
Local $defaultCoords[1][2] = [[0, 0]]
Local $return[7] = ["None", "None", 0, 0, 0, $defaultCoords, ""]
Local $aStatData[1][1] = [[""]]
Local $aCoordArray[0][0], $aCoords, $aCoordsSplit, $aValue, $maxLevelSearch, $iTmpObjectLevel, $iTmpBldTotal, $iBuildingTotal, $sTempCoord
Local $sLocCoord, $sNearCoord, $sFarCoord, $redlinesCount, $iCountUpdate
Local $bRedLineExists = False
Local $maxReturnPoints = _ObjGetValue($g_oBldgMaxQty, $iDefenseType + 7)[($g_iSearchTH = "-" ? 10 : $g_iSearchTH - 1)]
If @error Then
_ObjErrMsg("_ObjGetValue $g_oBldgMaxQty", @error)
EndIf
Local $fullCocAreas = "DCD"
$maxLevelSearch = $maxLevel
If $redlines = "" Or $redlines = "DCD" Then
If _ObjSearch($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS") = True Then
If _ObjGetValue($g_oBldgAttackInfo, $eBldgRedLine & "_COUNT") > 50 Then
$redlines = $g_oBldgAttackInfo.item($eBldgRedLine & "_LOCATION")
If IsString($redlines) And $redlines <> "" And $redlines <> "DCD" Then
$bRedLineExists = True
Else
$bRedLineExists = False
EndIf
Else
$bRedLineExists = False
EndIf
Else
$bRedLineExists = False
EndIf
ElseIf $redlines <> "" And $redlines <> "DCD" Then
$bRedLineExists = True
If _ObjSearch($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS") = False Then
If $redlines <> "DCD" Then
$aCoordsSplit = StringSplit($redlines, "|")
$redlinesCount = $aCoordsSplit[0]
If $redlinesCount > 50 Then
_ObjAdd($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS", $redlines)
If @error Then _ObjErrMsg("_ObjAdd $g_oBldgAttackInfo", @error)
_ObjAdd($g_oBldgAttackInfo, $eBldgRedLine & "_COUNT", $redlinesCount)
If @error Then _ObjErrMsg("_ObjAdd $g_oBldgAttackInfo", @error)
Else
$bRedLineExists = False
EndIf
EndIf
EndIf
Else
$bRedLineExists = False
EndIf
If $bRedLineExists = False Then
$redlines = "DCD"
EndIf
If $g_bDebugSetlog Then
SetDebugLog("> " & $g_sBldgNames[$iDefenseType + 7] & " Max Level: " & $maxLevel & " Max Search Level: " & $maxLevelSearch, $COLOR_DEBUG)
SetDebugLog("> Max return points: " & $maxReturnPoints, $COLOR_DEBUG)
SetDebugLog("> Red Line Exists:" & $bRedLineExists & " , redlines=" & $redlines, $COLOR_DEBUG)
EndIf
If _Sleep($DELAYCHECKARMYCAMP6) Then Return $return
If $bForceCaptureRegion = True Then _CaptureRegion2()
Local $res = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $directory, "str", $fullCocAreas, "Int", $maxReturnPoints, "str", $redlines, "Int", $minLevel, "Int", $maxLevelSearch)
If @error Then _logErrorDLLCall($g_sLibMyBotPath, @error)
If $bRedLineExists = False Then
$aValue = RetrieveImglocProperty("redline", "")
If $aValue <> "" Then
Local $aCoordsSplit = StringSplit($aValue, "|")
If $aCoordsSplit[0] > 50 Then
$redlines = $aValue
_ObjPutValue($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS", $redlines)
If @error Then _ObjErrMsg("_ObjPutValue $g_oBldgAttackInfo redline", @error)
Local $redlinesCount = $aCoordsSplit[0]
_ObjPutValue($g_oBldgAttackInfo, $eBldgRedLine & "_COUNT", $redlinesCount)
If @error Then _ObjErrMsg("_ObjSetValue $g_oBldgAttackInfo", @error)
$return[6] = $redlines
Else
Setdebuglog("> Not enough red line points to save in building dictionary?", $COLOR_WARNING)
EndIf
Else
SetLog("> DLL Error getting Red Lines in DefenseSearchMultiMatch", $COLOR_ERROR)
EndIf
Else
$return[6] = $redlines
EndIf
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aStatData[UBound($aKeys) + 1][1]
For $i = 0 To UBound($aKeys) - 1
$aStatData[$i + 1][0] = RetrieveImglocProperty($aKeys[$i], "filename")
$iTmpObjectLevel = Int(RetrieveImglocProperty($aKeys[$i], "objectlevel"))
$sTempCoord = RetrieveImglocProperty($aKeys[$i], "objectpoints")
If $i = 0 And StringLen($sTempCoord) > 7 Then
$iCountUpdate = RemoveDupNearby($sTempCoord)
EndIf
$iTmpBldTotal = RetrieveImglocProperty($aKeys[$i], "totalobjects")
If $iTmpObjectLevel > Number($return[2]) Then
$return[0] = $aStatData[$i + 1][0]
$return[1] = RetrieveImglocProperty($aKeys[$i], "objectname")
$return[2] = $iTmpObjectLevel
$return[3] = RetrieveImglocProperty($aKeys[$i], "fillLevel")
$return[4] = $iTmpBldTotal
$aCoords = StringSplit($sTempCoord, "|", $STR_NOCOUNT)
ReDim $aCoordArray[UBound($aCoords)][2]
For $j = 0 To UBound($aCoords) - 1
$aCoordsSplit = StringSplit($aCoords[$j], ",", $STR_NOCOUNT)
If UBound($aCoordsSplit) = 2 Then
$aCoordArray[$j][0] = $aCoordsSplit[0]
$aCoordArray[$j][1] = $aCoordsSplit[1]
EndIf
Next
$return[5] = $aCoordArray
EndIf
If isScriptedAttackActive() Then
If UBound($aKeys) > 1 Then
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_LVLFOUND_K" & $i, $iTmpObjectLevel)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _LVLFOUND_K" & $i, @error)
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_FILENAME_K" & $i, $aKeys[$i])
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _FILENAME_K" & $i, @error)
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_COUNT_K" & $i, $iTmpBldTotal)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _COUNT_K" & $i, @error)
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_OBJECTPOINTS_K" & $i, $sTempCoord)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _OBJECTPOINTS_K" & $i, @error)
EndIf
If $iBuildingTotal >= $maxReturnPoints Then ContinueLoop
If $sTempCoord <> "" Then
If $sLocCoord = "" Then
$sLocCoord = $sTempCoord
$iBuildingTotal = $iTmpBldTotal
Else
$iCountUpdate = AddPoints_RemoveDuplicate($sLocCoord, $sTempCoord, $maxReturnPoints)
If $iCountUpdate <> "" Then $iBuildingTotal = $iCountUpdate
EndIf
Else
SetDebugLog("> no data in 'objectpoints' request?", $COLOR_WARNING)
EndIf
EndIf
Next
Local $aBldgCoord = decodeMultipleCoords($sLocCoord)
If IsArray($aBldgCoord) Then $return[5] = $aBldgCoord
If $g_bDebugSetlog Or $g_bDebugBuildingPos Then
SetLog($g_sBldgNames[$iDefenseType + 7] & " Coordinates: " & $sLocCoord, $COLOR_DEBUG)
Local $sText
Select
Case UBound($aBldgCoord, 1) > 1 And IsArray($aBldgCoord[1])
$sText = PixelArrayToString($aBldgCoord, ",")
Case UBound($aBldgCoord) > 0 And UBound($aBldgCoord[0]) = 2
Local $aPixelb = $aBldgCoord[0]
$sText = PixelToString($aPixelb, ":")
Case UBound($aBldgCoord) = 2 And IsArray($aBldgCoord[0]) = 0
$sText = PixelToString($aBldgCoord, ":")
Case Else
$sText = "Monkey ate bad banana!"
EndSelect
SetLog($g_sBldgNames[$iDefenseType + 7] & " $aBldgCoord Array Contents: " & $sText, $COLOR_DEBUG)
EndIf
If isScriptedAttackActive() Then
If $return[2] <> 0 Then
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_MAXLVLFOUND", $return[2])
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _MAXLVLFOUND", @error)
EndIf
If $return[0] <> "None" Then
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_NAMEFOUND", $return[0])
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _NAMEFOUND", @error)
EndIf
If IsArray($aBldgCoord) Then
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_OBJECTPOINTS", $sLocCoord)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _OBJECTPOINTS", @error)
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_LOCATION", $aBldgCoord)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _LOCATION", @error)
EndIf
If $iBuildingTotal <> 0 Then
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_COUNT", $iBuildingTotal)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _COUNT", @error)
EndIf
SetDebugLog("Total " & $g_sBldgNames[$iDefenseType + 7] & " Buildings: " & $iBuildingTotal)
Local $iTime = __TimerDiff($hTimer) * 0.001
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_FINDTIME", $iTime)
If @error Then _ObjErrMsg("_ObjAdd" & $g_sBldgNames[$iDefenseType + 7] & " _FINDTIME", @error)
If $g_bDebugSetlog Then SetDebugLog("  - Location(s) found in: " & Round($iTime, 2) & " seconds ", $COLOR_DEBUG1)
EndIf
EndIf
updateMultiSearchStats($aStatData, $statFile)
Return $return
EndFunc
Func isScriptedAttackActive()
If($g_abAttackTypeEnable[$DB] And $g_aiAttackAlgorithm[$DB] = 1) Or($g_abAttackTypeEnable[$LB] And $g_aiAttackAlgorithm[$LB] = 1) Then Return True
Return False
EndFunc
Func CompareResources($pMode)
If $g_bSearchReductionEnable Then
If $g_iSearchCount <> 0 And Mod($g_iSearchCount, $g_iSearchReductionCount) = 0 Then
If $g_iAimGold[$pMode] - $g_iSearchReductionGold >= 0 Then $g_iAimGold[$pMode] -= $g_iSearchReductionGold
If $g_iAimElixir[$pMode] - $g_iSearchReductionElixir >= 0 Then $g_iAimElixir[$pMode] -= $g_iSearchReductionElixir
If $g_iAimDark[$pMode] - $g_iSearchReductionDark >= 0 Then $g_iAimDark[$pMode] -= $g_iSearchReductionDark
If $g_iAimTrophy[$pMode] - $g_iSearchReductionTrophy >= 0 Then $g_iAimTrophy[$pMode] -= $g_iSearchReductionTrophy
If $g_iAimTrophyMax[$pMode] + $g_iSearchReductionTrophy < 99 Then $g_iAimTrophyMax[$pMode] += $g_iSearchReductionTrophy
If $g_iAimGoldPlusElixir[$pMode] - $g_iSearchReductionGoldPlusElixir >= 0 Then $g_iAimGoldPlusElixir[$pMode] -= $g_iSearchReductionGoldPlusElixir
Local $txtTrophies = "", $txtTownhall = ""
If $g_abFilterMeetTrophyEnable[$pMode] Then $txtTrophies = " [T]:" & StringFormat("%2s", $g_iAimTrophy[$pMode]) & "-" & StringFormat("%2s", $g_iAimTrophyMax[$pMode])
If $g_abFilterMeetTH[$pMode] Then $txtTownhall = " [TH]:" & StringFormat("%2s", $g_aiMaxTH[$pMode])
If $g_abFilterMeetTHOutsideEnable[$pMode] Then $txtTownhall &= ", Out"
If $g_aiFilterMeetGE[$pMode] = 2 Then
SetLog("Aim:           [G+E]:" & StringFormat("%7s", $g_iAimGoldPlusElixir[$pMode]) & " [D]:" & StringFormat("%5s", $g_iAimDark[$pMode]) & $txtTrophies & $txtTownhall & " for: " & $g_asModeText[$pMode], $COLOR_SUCCESS, "Lucida Console", 7.5)
Else
SetLog("Aim: [G]:" & StringFormat("%7s", $g_iAimGold[$pMode]) & " [E]:" & StringFormat("%7s", $g_iAimElixir[$pMode]) & " [D]:" & StringFormat("%5s", $g_iAimDark[$pMode]) & $txtTrophies & $txtTownhall & " for: " & $g_asModeText[$pMode], $COLOR_SUCCESS, "Lucida Console", 7.5)
EndIf
EndIf
EndIf
Local $G =(Number($g_iSearchGold) >= Number($g_iAimGold[$pMode])), $E =(Number($g_iSearchElixir) >= Number($g_iAimElixir[$pMode])), $D =(Number($g_iSearchDark) >= Number($g_iAimDark[$pMode])), $T =(Number($g_iSearchTrophy) >= Number($g_iAimTrophy[$pMode])) And(Number($g_iSearchTrophy) <= Number($g_iAimTrophyMax[$pMode])), $GPE =((Number($g_iSearchGold) + Number($g_iSearchElixir)) >= Number($g_iAimGoldPlusElixir[$pMode]))
If $g_abFilterMeetOneConditionEnable[$pMode] Then
If $g_aiFilterMeetGE[$pMode] = 0 Then
If $G = True And $E = True Then Return True
EndIf
If $g_abFilterMeetDEEnable[$pMode] Then
If $D = True Then Return True
EndIf
If $g_abFilterMeetTrophyEnable[$pMode] Then
If $T = True Then Return True
EndIf
If $g_aiFilterMeetGE[$pMode] = 1 Then
If $G = True Or $E = True Then Return True
EndIf
If $g_aiFilterMeetGE[$pMode] = 2 Then
If $GPE = True Then Return True
EndIf
Return False
Else
If $g_aiFilterMeetGE[$pMode] = 0 Then
If $G = False Or $E = False Then Return False
EndIf
If $g_abFilterMeetDEEnable[$pMode] Then
If $D = False Then Return False
EndIf
If $g_abFilterMeetTrophyEnable[$pMode] Then
If $T = False Then Return False
EndIf
If $g_aiFilterMeetGE[$pMode] = 1 Then
If $G = False And $E = False Then Return False
EndIf
If $g_aiFilterMeetGE[$pMode] = 2 Then
If $GPE = False Then Return False
EndIf
EndIf
Return True
EndFunc
Func CompareTH($pMode)
Local $THL = -1, $THLO = -1
If $g_iSearchTH = 6 Then $g_iSearchTH = "4-6"
For $i = 0 To 5
If $g_iSearchTH = $g_asTHText[$i] Then $THL = $i
Next
Switch $g_sTHLoc
Case "In"
$THLO = 0
Case "Out"
$THLO = 1
EndSwitch
$g_iSearchTHLResult = 0
If $THL > -1 And $THL <= $g_iAtkTBMaxTHLevel And $g_iSearchTH <> "-" Then $g_iSearchTHLResult = 1
If $g_abFilterMeetOneConditionEnable[$pMode] Then
If $g_abFilterMeetTH[$pMode] Then
If $THL <> -1 And $THL <= $g_aiFilterMeetTHMin[$pMode] Then Return True
EndIf
If $g_abFilterMeetTHOutsideEnable[$pMode] Then
If $THLO = 1 Then Return True
EndIf
Return False
Else
If $g_abFilterMeetTH[$pMode] Then
If $THL = -1 Or $THL > $g_aiFilterMeetTHMin[$pMode] Then Return False
EndIf
If $g_abFilterMeetTHOutsideEnable[$pMode] Then
If $THLO <> 1 Then Return False
EndIf
EndIf
Return True
EndFunc
Func GetResources($bLog = True, $pMatchMode = -1)
Static $iStuck = 0, $iSearchGold2 = 0, $iSearchElixir2 = 0
If _Sleep($DELAYRESPOND) Then Return
$g_iSearchGold = ""
$g_iSearchElixir = ""
$g_iSearchDark = ""
$g_iSearchTrophy = ""
SuspendAndroid()
Local $iCount = 0
While(getGoldVillageSearch(48, 69) = "") Or(getElixirVillageSearch(48, 69 + 29) = "")
$iCount += 1
If _Sleep($DELAYGETRESOURCES3) Then Return
If $iCount >= 50 Or isProblemAffect(True) Then ExitLoop
WEnd
If _Sleep($DELAYRESPOND) Then Return
$g_iSearchGold = getGoldVillageSearch(48, 69)
If _Sleep($DELAYRESPOND) Then Return
$g_iSearchElixir = getElixirVillageSearch(48, 69 + 29)
If _Sleep($DELAYRESPOND) Then Return
If _CheckPixel($aAtkHasDarkElixir, $g_bCapturePixel, Default, "HasDarkElixir1") Or  _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x0F0617, 6), 5) Then
$g_iSearchDark = getDarkElixirVillageSearch(48, 126)
$g_iSearchTrophy = getTrophyVillageSearch(45, 168)
Else
$g_iSearchDark = "N/A"
$g_iSearchTrophy = getTrophyVillageSearch(48, 69 + 69)
EndIf
If $g_iSearchGold = $iSearchGold2 And $g_iSearchElixir = $iSearchElixir2 Then $iStuck += 1
If $g_iSearchGold <> $iSearchGold2 Or $g_iSearchElixir <> $iSearchElixir2 Then $iStuck = 0
$iSearchGold2 = $g_iSearchGold
$iSearchElixir2 = $g_iSearchElixir
If $iStuck >= 5 Or isProblemAffect(True) Then
$iStuck = 0
resetAttackSearch(True)
Return
EndIf
$g_iSearchCount += 1
ResumeAndroid()
EndFunc
Func resetAttackSearch($bStuck = False)
$g_bIsClientSyncError = True
checkMainScreen()
If $g_bRestart Then
$g_iNbrOfOoS += 1
UpdateStats()
If $bStuck Then
SetLog("Connection Lost While Searching", $COLOR_ERROR)
Else
SetLog("Disconnected At Search Clouds", $COLOR_ERROR)
EndIf
PushMsg("OoSResources")
Else
If $bStuck Then
SetLog("Attack Is Disabled Or Slow connection issues, Restarting CoC and Bot...", $COLOR_ERROR)
Else
SetLog("Stuck At Search Clouds, Restarting CoC and Bot...", $COLOR_ERROR)
EndIf
$g_bIsClientSyncError = False
CloseCoC(True)
EndIf
Return
EndFunc
Func PrepareSearch()
SetLog("Going to Attack...", $COLOR_INFO)
ChkAttackCSVConfig()
If IsMainPage() Then
If _Sleep($DELAYTREASURY4) Then Return
If _CheckPixel($aAttackForTreasury, $g_bCapturePixel, Default, "Is attack for treasury:") Then
SetLog("It isn't attack for Treasury :-(", $COLOR_SUCCESS)
Return
EndIf
If _Sleep($DELAYTREASURY4) Then Return
If $g_bUseRandomClick = False Then
ClickP($aAttackButton, 1, 0, "#0149")
Else
ClickR($aAttackButtonRND, $aAttackButton[0], $aAttackButton[1], 1, 0)
EndIf
EndIf
If _Sleep($DELAYPREPARESEARCH1) Then Return
Local $j = 0
While Not(IsLaunchAttackPage())
If _Sleep($DELAYPREPARESEARCH1) Then Return
$j += 1
If $j > 15 Then ExitLoop
WEnd
If $j > 15 Then
SetLog("Launch attack Page Fail", $COLOR_ERROR)
AndroidPageError("PrepareSearch")
checkMainScreen()
$g_bRestart = True
$g_bIsClientSyncError = False
Return
Else
If $g_bUseRandomClick = False Then
ClickP($aFindMatchButton, 1, 0, "#0150")
Else
ClickR($aFindMatchButtonRND, $aFindMatchButton[0], $aFindMatchButton[1], 1, 0)
EndIf
If $g_iTownHallLevel <> "" And $g_iTownHallLevel > 0 Then
$g_iSearchCost += $g_aiSearchCost[$g_iTownHallLevel - 1]
$g_iStatsTotalGain[$eLootGold] -= $g_aiSearchCost[$g_iTownHallLevel - 1]
EndIf
UpdateStats()
EndIf
If _Sleep($DELAYPREPARESEARCH2) Then Return
Local $Result = getAttackDisable(346, 182)
If isGemOpen(True) = True Then
SetLog(" Not enough gold to start searching.....", $COLOR_ERROR)
Click(585, 252, 1, 0, "#0151")
If _Sleep($DELAYPREPARESEARCH1) Then Return
Click(822, 32, 1, 0, "#0152")
If _Sleep($DELAYPREPARESEARCH1) Then Return
$g_bOutOfGold = True
EndIf
checkAttackDisable($g_iTaBChkAttack, $Result)
If $g_bDebugSetlog Then SetDebugLog("PrepareSearch exit check $g_bRestart= " & $g_bRestart & ", $g_bOutOfGold= " & $g_bOutOfGold, $COLOR_DEBUG)
If $g_bRestart Or $g_bOutOfGold Then
$g_bIsClientSyncError = False
Return
EndIf
If IsAttackWhileShieldPage(False) Then
Local $offColors[3][3] = [[0x000000, 144, 1], [0xFFFFFF, 54, 17], [0xFFFFFF, 54, 28]]
Local $ButtonPixel = _MultiPixelSearch(359, 404 + $g_iMidOffsetY, 510, 445 + $g_iMidOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $g_bDebugSetlog Then SetDebugLog("Shield btn clr chk-#1: " & _GetPixelColor(441, 344 + $g_iMidOffsetY, True) & ", #2: " &  _GetPixelColor(441 + 144, 344 + $g_iMidOffsetY, True) & ", #3: " & _GetPixelColor(441 + 54, 344 + 17 + $g_iMidOffsetY, True) & ", #4: " &  _GetPixelColor(441 + 54, 344 + 10 + $g_iMidOffsetY, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Then
SetDebugLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetDebugLog("Shld Btn Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 144, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 17, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 27, True), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 1, 0, "#0153")
EndIf
EndIf
EndFunc
Func VillageSearch()
$g_bVillageSearchActive = True
$g_bCloudsActive = True
Local $Result = _VillageSearch()
$g_bVillageSearchActive = False
$g_bCloudsActive = False
Return $Result
EndFunc
Func _VillageSearch()
Local $Result
Local $weakBaseValues
Local $logwrited = False
Local $iSkipped = 0
If $g_bDebugDeadBaseImage Or $g_aiSearchEnableDebugDeadBaseImage > 0 Then
DirCreate($g_sProfileTempDebugPath & "\SkippedZombies\")
DirCreate($g_sProfileTempDebugPath & "\Zombies\")
setZombie()
EndIf
If $g_bIsClientSyncError = False Then
For $i = 0 To $g_iModeCount - 1
$g_iAimGold[$i] = $g_aiFilterMinGold[$i]
$g_iAimElixir[$i] = $g_aiFilterMinElixir[$i]
$g_iAimGoldPlusElixir[$i] = $g_aiFilterMinGoldPlusElixir[$i]
$g_iAimDark[$i] =($g_abFilterMeetDEEnable[$i] ?($g_aiFilterMeetDEMin[$i]) :(0))
$g_iAimTrophy[$i] =($g_abFilterMeetTrophyEnable[$i] ?($g_aiFilterMeetTrophyMin[$i]) :(0))
$g_iAimTrophyMax[$i] =($g_abFilterMeetTrophyEnable[$i] ?($g_aiFilterMeetTrophyMax[$i]) :(99))
Next
EndIf
If _Sleep($DELAYVILLAGESEARCH1) Then Return
$Result = getAttackDisable(346, 182)
checkAttackDisable($g_iTaBChkAttack, $Result)
If $g_bRestart = True Then Return
If Not($g_bIsSearchLimit) Then
SetLogCentered("=", "=", $COLOR_INFO)
EndIf
For $x = 0 To $g_iModeCount - 1
If IsSearchModeActive($x) Then WriteLogVillageSearch($x)
Next
If Not($g_bIsSearchLimit) Then
SetLogCentered("=", "=", $COLOR_INFO)
Else
SetLogCentered(" Restart To Search ", Default, $COLOR_INFO)
EndIf
If $g_bSearchAttackNowEnable Then
GUICtrlSetState($g_hBtnAttackNowDB, $GUI_SHOW)
GUICtrlSetState($g_hBtnAttackNowLB, $GUI_SHOW)
GUICtrlSetState($g_hBtnAttackNowTS, $GUI_SHOW)
GUICtrlSetState($g_hPicTwoArrowShield, $GUI_HIDE)
GUICtrlSetState($g_hLblVersion, $GUI_HIDE)
EndIf
If $g_bIsClientSyncError = False And $g_bIsSearchLimit = False Then
$g_iSearchCount = 0
EndIf
If $g_bIsSearchLimit = True Then $g_bIsSearchLimit = False
While 1
ResetTHsearch()
_ObjDeleteKey($g_oBldgAttackInfo, "")
If $g_bDebugVillageSearchImages Then DebugImageSave("villagesearch")
$logwrited = False
$g_bBtnAttackNowPressed = False
$g_iSearchTHLResult = -1
If $g_bRestart = True Then Return
WaitForClouds()
AttackRemainingTime(True)
If $g_bRestart = True Then Return
$g_bCloudsActive = False
GetResources(False)
If $g_bRestart = True Then Return
SuspendAndroid()
Local $noMatchTxt = ""
Local $dbBase = False
Local $match[$g_iModeCount]
Global $isModeActive[$g_iModeCount]
For $i = 0 To $g_iModeCount - 1
$match[$i] = False
$isModeActive[$i] = False
Next
If _Sleep($DELAYRESPOND) Then Return
For $i = 0 To $g_iModeCount - 1
$isModeActive[$i] = IsSearchModeActive($i)
If $isModeActive[$i] Then
$match[$i] = CompareResources($i)
EndIf
Next
ForceCaptureRegion()
_CaptureRegion2()
For $i = 0 To $g_iModeCount - 1
If $match[$i] Then
If CheckZoomOut("VillageSearch", True, False) = False Then
$i = 0
Local $bMeasured
Do
$i += 1
If _Sleep($DELAYPREPARESEARCH2) Then Return
ForceCaptureRegion()
_CaptureRegion2()
$bMeasured = CheckZoomOut("VillageSearch", $i < 2, False)
Until $bMeasured = True Or $i >= 2
If $bMeasured = False Then Return
EndIf
ExitLoop
EndIf
Next
Local $THString = ""
If $match[$DB] Or $match[$LB] Or $match[$TS] Then
$THString = FindTownhall(False, False)
ElseIf($g_abFilterMeetOneConditionEnable[$DB] Or $g_abFilterMeetOneConditionEnable[$LB]) Then
$THString = FindTownhall(True, False)
ElseIf $g_abAttackTypeEnable[$TB] = 1 And($g_iSearchCount >= $g_iAtkTBEnableCount) Then
$THString = FindTownhall(True, False)
EndIf
For $i = 0 To $g_iModeCount - 2
If $isModeActive[$i] Then
If $g_abFilterMeetOneConditionEnable[$i] Then
If $g_abFilterMeetTH[$i] = False And $g_abFilterMeetTHOutsideEnable[$i] = False Then
Else
If CompareTH($i) Then $match[$i] = True
EndIf
Else
If Not CompareTH($i) Then $match[$i] = False
EndIf
EndIf
Next
If $g_iSearchTHLResult = -1 Then CompareTH(0)
Local $GetResourcesTXT = StringFormat("%3s", $g_iSearchCount) & "> [G]:" & StringFormat("%7s", $g_iSearchGold) & " [E]:" & StringFormat("%7s", $g_iSearchElixir) & " [D]:" & StringFormat("%5s", $g_iSearchDark) & " [T]:" & StringFormat("%2s", $g_iSearchTrophy) & $THString
If Not $g_bRunState Then Return
Local $checkDeadBase =($match[$DB] And $g_aiAttackAlgorithm[$DB] <> 2) Or $match[$LB] Or($match[$DB] And $g_aiAttackAlgorithm[$DB] = 2 And $g_iMilkAttackType = 1)
If $checkDeadBase Then
$dbBase = checkDeadBase()
EndIf
If(IsWeakBaseActive($DB) And $dbBase And($match[$DB] Or $g_abFilterMeetOneConditionEnable[$DB])) Or(IsWeakBaseActive($LB) And($match[$LB] Or $g_abFilterMeetOneConditionEnable[$LB])) Then
If($g_iSearchTH <> "-") Then
$weakBaseValues = IsWeakBase($g_iImglocTHLevel, $g_sImglocRedline, False)
Else
$weakBaseValues = IsWeakBase(11, "", False)
EndIf
For $i = 0 To $g_iModeCount - 2
If IsWeakBaseActive($i) And(($i = $DB And $dbBase) Or $i <> $DB) And($match[$i] Or $g_abFilterMeetOneConditionEnable[$i]) Then
If getIsWeak($weakBaseValues, $i) Then
$match[$i] = True
Else
$match[$i] = False
$noMatchTxt &= ", Not a Weak Base for " & $g_asModeText[$i]
EndIf
EndIf
Next
EndIf
CheckMilkingBase($match[$DB], $dbBase)
ResumeAndroid()
If $match[$DB] And $g_aiAttackAlgorithm[$DB] = 2 And $g_bMilkingAttackOutside = True Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Milking Attack th outside Found!", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $DB
ExitLoop
ElseIf $match[$DB] And $g_aiAttackAlgorithm[$DB] = 2 And $g_iMilkAttackType = 0 And StringLen($g_sMilkFarmObjectivesSTR) > 0 Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Milking Attack HIGH CPU SETTINGS Found!", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $DB
ExitLoop
ElseIf $match[$DB] And $g_aiAttackAlgorithm[$DB] = 2 And $g_iMilkAttackType = 1 And StringLen($g_sMilkFarmObjectivesSTR) > 0 And $dbBase Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Milking Attack LOW CPU SETTINGS Found!", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $DB
ExitLoop
ElseIf $match[$DB] And $dbBase Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Dead Base Found!", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $DB
ExitLoop
ElseIf $match[$LB] And Not $dbBase Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Live Base Found!", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $LB
ExitLoop
ElseIf $match[$LB] And $g_bCollectorFilterDisable Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Live Base Found!*", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $LB
ExitLoop
ElseIf $g_abAttackTypeEnable[$TB] = 1 And($g_iSearchCount >= $g_iAtkTBEnableCount) Then
If $g_iSearchTHLResult = 1 Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Not a match, but TH Bully Level Found! ", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $g_iAtkTBMode
ExitLoop
EndIf
EndIf
If SearchTownHallLoc() And $match[$TS] Then
If CompareResources($TS) Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "TH Outside Found! ", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $TS
ExitLoop
Else
$noMatchTxt &= ", Not a " & $g_asModeText[$TS] & ", fails resource min"
EndIf
EndIf
If $match[$DB] And Not $dbBase Then
$noMatchTxt &= ", Not a " & $g_asModeText[$DB]
ElseIf $match[$LB] And $dbBase Then
$noMatchTxt &= ", Not a " & $g_asModeText[$LB]
EndIf
If $noMatchTxt <> "" Then
SetLog($GetResourcesTXT, $COLOR_BLACK, "Lucida Console", 7.5)
SetLog("      " & StringMid($noMatchTxt, 3), $COLOR_ACTION, "Lucida Console", 7.5)
$logwrited = True
EndIf
If Not($logwrited) Then
SetLog($GetResourcesTXT, $COLOR_BLACK, "Lucida Console", 7.5)
EndIf
If SearchLimit($iSkipped + 1) Then Return True
If CheckAndroidReboot() = True Then
$g_bRestart = True
$g_bIsClientSyncError = True
Return
EndIf
If $g_iSearchDelayMin > 0 And $g_iSearchDelayMax > 0 Then
If $g_iSearchDelayMin <> $g_iSearchDelayMax Then
If _Sleep(Round(1000 * Random($g_iSearchDelayMin, $g_iSearchDelayMax))) Then Return
Else
If _Sleep(1000 * $g_iSearchDelayMin) Then Return
EndIf
EndIf
If _Sleep($DELAYRESPOND) Then Return
If $g_bSearchAttackNowEnable And $g_iSearchAttackNowDelay > 0 Then
If _Sleep(1000 * $g_iSearchAttackNowDelay) Then Return
EndIf
If $g_bBtnAttackNowPressed = True Then ExitLoop
If $checkDeadBase And Not $g_bDebugDeadBaseImage And $g_iSearchCount > $g_aiSearchEnableDebugDeadBaseImage Then
SetLog("Enabled collecting debug images of dead bases (zombies)", $COLOR_DEBUG)
SetLog("- Save skipped dead base when available Elixir with empty storage > " &(($g_aZombie[8] > -1) ?($g_aZombie[8] & "k") :("is disabled")), $COLOR_DEBUG)
SetLog("- Save skipped dead base when available Elixir > " &(($g_aZombie[9] > -1) ?($g_aZombie[9] & "k") :("is disabled")), $COLOR_DEBUG)
SetLog("- Save dead base when available Elixir < " &(($g_aZombie[10] > -1) ?($g_aZombie[10] & "k") :("is disabled")), $COLOR_DEBUG)
SetLog("- Save dead base when raided Elixir < " &(($g_aZombie[7] > -1) ?($g_aZombie[7] & "%") :("is disabled")), $COLOR_DEBUG)
$g_bDebugDeadBaseImage = True
EndIf
If $g_bDebugDeadBaseImage Then setZombie()
Local $i = 0
While $i < 100
If _Sleep($DELAYVILLAGESEARCH2) Then Return
$i += 1
_CaptureRegions()
If( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1]), Hex($NextBtn[2], 6), $NextBtn[3])) And IsAttackPage(False) Then
$g_bCloudsActive = True
If $g_bUseRandomClick = False Then
ClickP($NextBtn, 1, 0, "#0155")
Else
ClickR($NextBtnRND, $NextBtn[0], $NextBtn[1], 1, 0)
EndIf
ExitLoop
Else
If $g_bDebugSetlog Then SetDebugLog("Wait to see Next Button... " & $i, $COLOR_DEBUG)
EndIf
If $i >= 99 Or isProblemAffect() Or(Mod($i, 10) = 0 And checkObstacles_Network(False, False)) Then
$g_bIsClientSyncError = True
checkMainScreen()
If $g_bRestart Then
$g_iNbrOfOoS += 1
UpdateStats()
SetLog("Couldn't locate Next button", $COLOR_ERROR)
PushMsg("OoSResources")
Else
SetLog("Have strange problem Couldn't locate Next button, Restarting CoC and Bot...", $COLOR_ERROR)
$g_bIsClientSyncError = False
CloseCoC(True)
EndIf
Return
EndIf
WEnd
If _Sleep($DELAYRESPOND) Then Return
$Result = getAttackDisable(346, 182)
checkAttackDisable($g_iTaBChkAttack, $Result)
If $g_bRestart = True Then Return
If isGemOpen(True) = True Then
SetLog(" Not enough gold to keep searching.....", $COLOR_ERROR)
Click(585, 252, 1, 0, "#0156")
If _Sleep($DELAYVILLAGESEARCH3) Then Return
$g_bOutOfGold = True
ReturnHome(False, False)
Return
EndIf
$iSkipped = $iSkipped + 1
$g_iSkippedVillageCount += 1
If $g_iTownHallLevel <> "" And $g_iTownHallLevel > 0 Then
$g_iSearchCost += $g_aiSearchCost[$g_iTownHallLevel - 1]
$g_iStatsTotalGain[$eLootGold] -= $g_aiSearchCost[$g_iTownHallLevel - 1]
EndIf
If ProfileSwitchAccountEnabled() Then
$g_aiSkippedVillageCountAcc[$g_iCurAccount] += 1
If $g_iTownHallLevel <> "" And $g_iTownHallLevel > 0 Then $g_aiGoldTotalAcc[$g_iCurAccount] -= $g_aiSearchCost[$g_iTownHallLevel - 1]
EndIf
UpdateStats()
WEnd
If $g_bBtnAttackNowPressed = True Then
SetLogCentered(" Attack Now Pressed! ", "~", $COLOR_SUCCESS)
EndIf
If $g_bSearchAttackNowEnable Then
GUICtrlSetState($g_hBtnAttackNowDB, $GUI_HIDE)
GUICtrlSetState($g_hBtnAttackNowLB, $GUI_HIDE)
GUICtrlSetState($g_hBtnAttackNowTS, $GUI_HIDE)
GUICtrlSetState($g_hPicTwoArrowShield, $GUI_SHOW)
GUICtrlSetState($g_hLblVersion, $GUI_SHOW)
$g_bBtnAttackNowPressed = False
EndIf
If $g_bSearchAlertMe Then
TrayTip($g_asModeText[$g_iMatchMode] & " Match Found!", "Gold: " & $g_iSearchGold & "; Elixir: " & $g_iSearchElixir & "; Dark: " & $g_iSearchDark & "; Trophy: " & $g_iSearchTrophy, "", 0)
If FileExists(@WindowsDir & "\media\Festival\Windows Exclamation.wav") Then
SoundPlay(@WindowsDir & "\media\Festival\Windows Exclamation.wav", 1)
ElseIf FileExists(@WindowsDir & "\media\Windows Exclamation.wav") Then
SoundPlay(@WindowsDir & "\media\Windows Exclamation.wav", 1)
EndIf
EndIf
SetLogCentered(" Search Complete ", Default, $COLOR_INFO)
PushMsg("MatchFound")
$g_bIsClientSyncError = False
EndFunc
Func SearchLimit($iSkipped)
If $g_bSearchRestartEnable And $iSkipped >= Number($g_iSearchRestartLimit) Then
Local $Wcount = 0
While _CheckPixel($aSurrenderButton, $g_bCapturePixel) = False
If _Sleep($DELAYSEARCHLIMIT) Then Return
$Wcount += 1
If $g_bDebugSetlog Then SetDebugLog("wait surrender button " & $Wcount, $COLOR_DEBUG)
If $Wcount >= 50 Or isProblemAffect(True) Then
checkMainScreen()
$g_bIsClientSyncError = False
$g_bRestart = True
Return True
EndIf
WEnd
$g_bIsSearchLimit = True
ReturnHome(False, False)
getArmyTroopCapacity(True, True)
$g_bRestart = True
$g_bIsClientSyncError = True
Return True
Else
Return False
EndIf
EndFunc
Func WriteLogVillageSearch($x)
Local $MeetGxEtext = "", $MeetGorEtext = "", $MeetGplusEtext = "", $MeetDEtext = "", $MeetTrophytext = "", $MeetTHtext = "", $MeetTHOtext = "", $MeetWeakBasetext = "", $EnabledAftertext = ""
If $g_aiFilterMeetGE[$x] = 0 Then $MeetGxEtext = "- Meet: Gold and Elixir"
If $g_aiFilterMeetGE[$x] = 1 Then $MeetGorEtext = "- Meet: Gold or Elixir"
If $g_aiFilterMeetGE[$x] = 2 Then $MeetGplusEtext = "- Meet: Gold + Elixir"
If $g_abFilterMeetDEEnable[$x] Then $MeetDEtext = "- Dark"
If $g_abFilterMeetTrophyEnable[$x] Then $MeetTrophytext = "- Trophy"
If $g_abFilterMeetTH[$x] Then $MeetTHtext = "- Max TH " & $g_aiMaxTH[$x]
If $g_abFilterMeetTHOutsideEnable[$x] Then $MeetTHOtext = "- TH Outside"
If IsWeakBaseActive($x) Then $MeetWeakBasetext = "- Weak Base"
If Not($g_bIsSearchLimit) And $g_bDebugSetlog Then
SetLogCentered(" Searching For " & $g_asModeText[$x] & " ", Default, $COLOR_INFO)
SetLog("Enable " & $g_asModeText[$x] & " search IF ", $COLOR_INFO)
If $g_abSearchSearchesEnable[$x] Then SetLog("- Numbers of searches range " & $g_aiSearchSearchesMin[$x] & " - " & $g_aiSearchSearchesMax[$x], $COLOR_INFO)
If $g_abSearchTropiesEnable[$x] Then SetLog("- Search tropies range " & $g_aiSearchTrophiesMin[$x] & " - " & $g_aiSearchTrophiesMax[$x], $COLOR_INFO)
If $g_abSearchCampsEnable[$x] Then SetLog("- Army Camps % >  " & $g_aiSearchCampsPct[$x], $COLOR_INFO)
SetLog("Match " & $g_asModeText[$x] & "  village IF ", $COLOR_INFO)
If $MeetGxEtext <> "" Then SetLog($MeetGxEtext, $COLOR_INFO)
If $MeetGorEtext <> "" Then SetLog($MeetGorEtext, $COLOR_INFO)
If $MeetGplusEtext <> "" Then SetLog($MeetGplusEtext, $COLOR_INFO)
If $MeetDEtext <> "" Then SetLog($MeetDEtext, $COLOR_INFO)
If $MeetTrophytext <> "" Then SetLog($MeetTrophytext, $COLOR_INFO)
If $MeetTHtext <> "" Then SetLog($MeetTHtext, $COLOR_INFO)
If $MeetTHOtext <> "" Then SetLog($MeetTHOtext, $COLOR_INFO)
If $MeetWeakBasetext <> "" Then SetLog($MeetWeakBasetext, $COLOR_INFO)
If $g_abFilterMeetOneConditionEnable[$x] Then SetLog("Meet One and Attack!")
SetLogCentered(" RESOURCE CONDITIONS ", "~", $COLOR_INFO)
EndIf
If Not($g_bIsSearchLimit) Then
Local $txtTrophies = "", $txtTownhall = ""
If $g_abFilterMeetTrophyEnable[$x] Then $txtTrophies = " [T]:" & StringFormat("%2s", $g_iAimTrophy[$x]) & "-" & StringFormat("%2s", $g_iAimTrophyMax[$x])
If $g_abFilterMeetTH[$x] Then $txtTownhall = " [TH]:" & StringFormat("%2s", $g_aiMaxTH[$x])
If $g_abFilterMeetTHOutsideEnable[$x] Then $txtTownhall &= ", Out"
If $g_aiFilterMeetGE[$x] = 2 Then
SetLog("Aim:           [G+E]:" & StringFormat("%7s", $g_iAimGoldPlusElixir[$x]) & " [D]:" & StringFormat("%5s", $g_iAimDark[$x]) & $txtTrophies & $txtTownhall & " for: " & $g_asModeText[$x], $COLOR_SUCCESS, "Lucida Console", 7.5)
Else
SetLog("Aim: [G]:" & StringFormat("%7s", $g_iAimGold[$x]) & " [E]:" & StringFormat("%7s", $g_iAimElixir[$x]) & " [D]:" & StringFormat("%5s", $g_iAimDark[$x]) & $txtTrophies & $txtTownhall & " for: " & $g_asModeText[$x], $COLOR_SUCCESS, "Lucida Console", 7.5)
EndIf
EndIf
EndFunc
Func CheckZoomOut($sSource = "CheckZoomOut", $bCheckOnly = False, $bForecCapture = True)
If $bForecCapture = True Then
_CaptureRegion2()
EndIf
Local $aVillageResult = SearchZoomOut(False, True, $sSource, False)
If IsArray($aVillageResult) = 0 Or $aVillageResult[0] = "" Then
If $bCheckOnly = False Then
SetLog("Not Zoomed Out! Exiting to MainScreen...", $COLOR_ERROR)
checkMainScreen()
$g_bRestart = True
$g_bIsClientSyncError = True
EndIf
Return False
EndIf
Return True
EndFunc
Func SearchTownHallLoc()
Local $addtiles = 0
Switch $g_iMatchMode
Case $TS
If $g_iArmyCapacity < 100 Then
$addtiles = $g_iAtkTSAddTilesWhileTrain
Else
$addtiles = $g_iAtkTSAddTilesFullTroops
EndIf
Case $LB
$addtiles = $g_iTHSnipeBeforeTiles[$LB]
Case $DB
If $g_bDuringMilkingAttack = True Then
$addtiles = $g_iMilkFarmTHMaxTilesFromBorder
Else
$addtiles = $g_iTHSnipeBeforeTiles[$DB]
EndIf
EndSwitch
If $g_iSearchTH <> "-" Then
If isInsideDiamondXY($g_iTHx, $g_iTHy) = False Then Return False
For $i = 0 To 22
If $g_iTHx < 114 + $i * 16 + Ceiling(($addtiles - 2) / 2 * 16) And $g_iTHy < 359 - $i * 12 + Ceiling(($addtiles - 2) / 2 * 12) Then
$g_iTHi = $i
$g_iTHside = 0
Return True
EndIf
If $g_iTHx < 117 + $i * 16 + Ceiling(($addtiles - 2) / 2 * 16) And $g_iTHy > 268 + $i * 12 - Floor(($addtiles - 2) / 2 * 12) Then
$g_iTHi = $i
$g_iTHside = 1
Return True
EndIf
If $g_iTHx > 743 - $i * 16 - Floor(($addtiles - 2) / 2 * 16) And $g_iTHy < 358 - $i * 12 + Ceiling(($addtiles - 2) / 2 * 12) Then
$g_iTHi = $i
$g_iTHside = 2
Return True
EndIf
If $g_iTHx > 742 - $i * 16 - Floor(($addtiles - 2) / 2 * 16) And $g_iTHy > 268 + $i * 12 - Floor(($addtiles - 2) / 2 * 12) Then
$g_iTHi = $i
$g_iTHside = 3
Return True
EndIf
Next
EndIf
Return False
EndFunc
Func FindTownHall($check = True, $forceCaptureRegion = True)
$g_iSearchTH = "-"
$g_iTHx = 0
$g_iTHy = 0
If $check = True Or IsSearchModeActive($TS) Or($isModeActive[$DB] And($g_abFilterMeetTH[$DB] Or $g_abFilterMeetTHOutsideEnable[$DB])) Or($isModeActive[$LB] And($g_abFilterMeetTH[$LB] Or $g_abFilterMeetTHOutsideEnable[$LB])) Then
$g_iSearchTH = imgloccheckTownHallADV2(0, 0, $forceCaptureRegion)
If $g_iSearchTH <> "-" And SearchTownHallLoc() = False Then
$g_sTHLoc = "In"
ElseIf $g_iSearchTH <> "-" Then
$g_sTHLoc = "Out"
Else
$g_sTHLoc = $g_iSearchTH
$g_iTHx = 0
$g_iTHy = 0
EndIf
Return " [TH]:" & StringFormat("%2s", $g_iSearchTH) & ", " & $g_sTHLoc
EndIf
$g_sTHLoc = $g_iSearchTH
$g_iTHx = 0
$g_iTHy = 0
Return ""
EndFunc
Func IsSearchModeActive($g_iMatchMode, $nocheckHeroes = False, $bNoLog = False)
Local $currentSearch = $g_iSearchCount + 1
Local $currentTropies = $g_aiCurrentLoot[$eLootTrophy]
Local $currentArmyCamps = Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100)
Local $bMatchModeEnabled = False
Local $checkSearches = Int($currentSearch) >= Int($g_aiSearchSearchesMin[$g_iMatchMode]) And Int($currentSearch) <= Int($g_aiSearchSearchesMax[$g_iMatchMode]) And $g_abSearchSearchesEnable[$g_iMatchMode]
Local $checkTropies = Int($currentTropies) >= Int($g_aiSearchTrophiesMin[$g_iMatchMode]) And Int($currentTropies) <= Int($g_aiSearchTrophiesMax[$g_iMatchMode]) And $g_abSearchTropiesEnable[$g_iMatchMode]
Local $checkArmyCamps = Int($currentArmyCamps) >= Int($g_aiSearchCampsPct[$g_iMatchMode]) And $g_abSearchCampsEnable[$g_iMatchMode]
Local $checkHeroes = Not($g_aiSearchHeroWaitEnable[$g_iMatchMode] > $eHeroNone And(BitAND($g_aiAttackUseHeroes[$g_iMatchMode], $g_aiSearchHeroWaitEnable[$g_iMatchMode], $g_iHeroAvailable) = $g_aiSearchHeroWaitEnable[$g_iMatchMode]) = False) Or $nocheckHeroes
If $checkHeroes = False Then
If Abs($g_aiSearchHeroWaitEnable[$g_iMatchMode] - $g_iHeroUpgradingBit) <= $eHeroNone Then $checkHeroes = True
EndIf
Local $g_bCheckSpells =($g_bFullArmySpells And $g_abSearchSpellsWaitEnable[$g_iMatchMode]) Or $g_abSearchSpellsWaitEnable[$g_iMatchMode] = False
Local $totalSpellsToBrew = 0
For $i = 0 To $eSpellCount - 1
$totalSpellsToBrew += $g_aiArmyCompSpells[$i]
Next
If GetCurTotalSpell() = $totalSpellsToBrew And $g_abSearchSpellsWaitEnable[$g_iMatchMode] Then
$g_bCheckSpells = True
ElseIf $g_bFullArmySpells And $g_abSearchSpellsWaitEnable[$g_iMatchMode] Then
$g_bCheckSpells = True
ElseIf $g_abSearchSpellsWaitEnable[$g_iMatchMode] = False Then
$g_bCheckSpells = True
Else
$g_bCheckSpells = False
EndIf
Switch $g_iMatchMode
Case $DB
$bMatchModeEnabled = $g_abAttackTypeEnable[$DB]
Case $LB
$bMatchModeEnabled = $g_abAttackTypeEnable[$LB]
Case $TS
$bMatchModeEnabled = $g_abAttackTypeEnable[$TS]
Case Else
$bMatchModeEnabled = False
EndSwitch
If Not $bMatchModeEnabled Then Return False
If $checkHeroes And $g_bCheckSpells Then
If($checkSearches Or $g_abSearchSearchesEnable[$g_iMatchMode] = False) And($checkTropies Or $g_abSearchTropiesEnable[$g_iMatchMode] = False) And($checkArmyCamps Or $g_abSearchCampsEnable[$g_iMatchMode] = False) Then
If $g_bDebugSetlog And Not $bNoLog Then SetLog($g_asModeText[$g_iMatchMode] & " active! ($checkSearches=" & $checkSearches & ",$checkTropies=" & $checkTropies & ",$checkArmyCamps=" & $checkArmyCamps & ",$checkHeroes=" & $checkHeroes & ",$g_bCheckSpells=" & $g_bCheckSpells & ")", $COLOR_INFO)
Return True
Else
If $g_bDebugSetlog And Not $bNoLog Then
SetLog($g_asModeText[$g_iMatchMode] & " not active!", $COLOR_INFO)
Local $txtsearches = "Fail"
If $checkSearches Then $txtsearches = "Success"
Local $txttropies = "Fail"
If $checkTropies Then $txttropies = "Success"
Local $txtArmyCamp = "Fail"
If $checkArmyCamps Then $txtArmyCamp = "Success"
Local $txtHeroes = "Fail"
If $checkHeroes Then $txtHeroes = "Success"
If $g_abSearchSearchesEnable[$g_iMatchMode] Then SetLog("searches range: " & $g_aiSearchSearchesMin[$g_iMatchMode] & "-" & $g_aiSearchSearchesMax[$g_iMatchMode] & "  actual value: " & $currentSearch & " - " & $txtsearches, $COLOR_INFO)
If $g_abSearchTropiesEnable[$g_iMatchMode] Then SetLog("tropies range: " & $g_aiSearchTrophiesMin[$g_iMatchMode] & "-" & $g_aiSearchTrophiesMax[$g_iMatchMode] & "  actual value: " & $currentTropies & " | " & $txttropies, $COLOR_INFO)
If $g_abSearchCampsEnable[$g_iMatchMode] Then SetLog("Army camps % range >=: " & $g_aiSearchCampsPct[$g_iMatchMode] & " actual value: " & $currentArmyCamps & " | " & $txtArmyCamp, $COLOR_INFO)
If $g_aiSearchHeroWaitEnable[$g_iMatchMode] > $eHeroNone Then SetLog("Hero status " & BitAND($g_aiAttackUseHeroes[$g_iMatchMode], $g_aiSearchHeroWaitEnable[$g_iMatchMode], $g_iHeroAvailable) & " " & $g_iHeroAvailable & " | " & $txtHeroes, $COLOR_INFO)
Local $txtSpells = "Fail"
If $g_bCheckSpells Then $txtSpells = "Success"
If $g_abSearchSpellsWaitEnable[$g_iMatchMode] Then SetLog("Full spell status: " & $g_bFullArmySpells & " | " & $txtSpells, $COLOR_INFO)
EndIf
Return False
EndIf
ElseIf $checkHeroes = 0 Then
If $g_bDebugSetlog And Not $bNoLog Then SetLog("Heroes not ready", $COLOR_DEBUG)
Return False
Else
If $g_bDebugSetlog And Not $bNoLog Then SetLog("Spells not ready", $COLOR_DEBUG)
Return False
EndIf
EndFunc
Func IsSearchModeActiveMini(Const $iMatchMode)
Return $g_abAttackTypeEnable[$iMatchMode]
EndFunc
Func IsWaitforSpellsActive()
For $i = $DB To $g_iModeCount - 1
If $g_abAttackTypeEnable[$i] And $g_abSearchSpellsWaitEnable[$i] Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("IsWaitforSpellsActive = True", $COLOR_DEBUG)
Return True
EndIf
Next
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("IsWaitforSpellsActive = False", $COLOR_DEBUG)
Return False
EndFunc
Func IsWaitforHeroesActive()
For $i = $DB To $g_iModeCount - 1
If $g_abAttackTypeEnable[$i] And($g_aiSearchHeroWaitEnable[$i] > $eHeroNone And(BitAND($g_aiAttackUseHeroes[$i], $g_aiSearchHeroWaitEnable[$i]) = $g_aiSearchHeroWaitEnable[$i]) And(Abs($g_aiSearchHeroWaitEnable[$i] - $g_iHeroUpgradingBit) > $eHeroNone)) Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("IsWaitforHeroesActive = True", $COLOR_DEBUG)
Return True
EndIf
Next
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("IsWaitforHeroesActive = False", $COLOR_DEBUG)
Return False
EndFunc
Func IsSearchAttackEnabled()
If $g_bDebugSetlog Then SetDebugLog("Begin IsSearchAttackScheduled:", $COLOR_DEBUG1)
If $g_bAttackPlannerEnable = False Then Return True
Local $sStartTime = "", $sEndTime = ""
Local $aNoAttackTimes[2] = [$sStartTime, $sEndTime]
Local $iWaitTime = 0
Local $bCloseGame = $g_bAttackPlannerCloseCoC = True Or $g_bAttackPlannerCloseAll = True Or $g_bAttackPlannerSuspendComputer = True
If $g_bDebugSetlog Then SetDebugLog("$bCloseGame:" & $bCloseGame, $COLOR_DEBUG)
If $g_bAttackPlannerDayLimit = True And _OverAttackLimit() Then
SetLog("Daily attack limit reached, skip attacks till new day starts!", $COLOR_INFO)
If _Sleep($DELAYRESPOND) Then Return True
If $bCloseGame Then
$iWaitTime = _getTimeRemainTimeToday()
UniversalCloseWaitOpenCoC($iWaitTime * 1000, "IsSearchAttackScheduled_", $g_bAttackPlannerCloseAll, True, $g_bAttackPlannerSuspendComputer)
$g_bRestart = True
Return
Else
Return False
EndIf
EndIf
If $g_bAttackPlannerRandomEnable = True Then
$aNoAttackTimes = _getDailyRandomStartEnd($g_iAttackPlannerRandomTime)
If @error Then
SetLog(@extended, $COLOR_ERROR)
Return True
EndIf
If _IsTimeInRange($aNoAttackTimes[0], $aNoAttackTimes[1]) Then
SetLog("Attack schedule random skip time found....", $COLOR_INFO)
If _Sleep($DELAYRESPOND) Then Return True
If $bCloseGame Then
$iWaitTime = _DateDiff("s", _NowCalc(), $aNoAttackTimes[1])
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not find NoAttack wait time", True)
Return True
EndIf
UniversalCloseWaitOpenCoC($iWaitTime * 1000, "IsSearchAttackScheduled_", $g_bAttackPlannerCloseAll, True, $g_bAttackPlannerSuspendComputer)
$g_bRestart = True
Return
Else
Return False
EndIf
Else
Return True
EndIf
Else
If IsPlannedTimeNow() = False Then
SetLog("Attack schedule planned skip time found...", $COLOR_INFO)
If _Sleep($DELAYRESPOND) Then Return True
If $bCloseGame Then
If $g_abPlannedAttackWeekDays[@WDAY - 1] = False Then
$iWaitTime = _getTimeRemainTimeToday()
For $i = @WDAY To 6
If $g_abPlannedAttackWeekDays[$i] = False Then $iWaitTime += 86400
If $g_abPlannedAttackWeekDays[$i] = True Then ExitLoop
If $g_bDebugSetlog Then SetDebugLog("Subtotal wait time= " & $iWaitTime & " Seconds", $COLOR_DEBUG)
Next
EndIf
If $iWaitTime = 0 Then
If $g_abPlannedAttackWeekDays[@WDAY - 1] = True And $g_abPlannedattackHours[@HOUR] = False Then
$iWaitTime +=(59 - @MIN) * 60
For $i = @HOUR + 1 To 23
If $g_abPlannedattackHours[$i] = False Then $iWaitTime += 3600
If $g_abPlannedattackHours[$i] = True Then ExitLoop
If $g_bDebugSetlog Then SetDebugLog("Subtotal wait time= " & $iWaitTime & " Seconds", $COLOR_DEBUG)
Next
EndIf
EndIf
If $g_bDebugSetlog Then SetDebugLog("Stop attack wait time= " & $iWaitTime & " Seconds", $COLOR_DEBUG)
UniversalCloseWaitOpenCoC($iWaitTime * 1000, "IsSearchAttackScheduled_", $g_bAttackPlannerCloseAll, True, $g_bAttackPlannerSuspendComputer)
$g_bRestart = True
Return
Else
Return False
EndIf
EndIf
EndIf
Return True
EndFunc
Func _getTimeRemainTimeToday()
Local $iTimeRemain = _DateDiff("s", _NowCalc(), _NowCalcDate() & " 23:59:59")
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not determine time remaining today", 0)
Return
EndIf
If $g_bDebugSetlog Then SetDebugLog("getTimeRemainToday= " & $iTimeRemain & " Seconds", $COLOR_DEBUG)
Return $iTimeRemain
EndFunc
Func _IsTimeAfter($sCompareTime, $sCurrentTime = _NowCalc())
Local $bResult = _DateDiff("s", $sCurrentTime, $sCompareTime) < 0
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not check if time is after", False)
Return
EndIf
If $g_bDebugSetlog Then SetDebugLog("IsTimeAfter: " & $bResult, $COLOR_DEBUG)
Return $bResult
EndFunc
Func _IsTimeBefore($sCompareTime, $sCurrentTime = _NowCalc())
Local $bResult = _DateDiff("s", $sCurrentTime, $sCompareTime) > 0
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not check if time is before", False)
Return
EndIf
If $g_bDebugSetlog Then SetDebugLog("IsTimeBefore: " & $bResult, $COLOR_DEBUG)
Return $bResult
EndFunc
Func _IsTimeInRange($sStartTime, $sEndTime)
Local $sCurrentTime = _NowCalc()
Local $bResult = _IsTimeAfter($sStartTime, $sCurrentTime) And _IsTimeBefore($sEndTime, $sCurrentTime)
If $g_bDebugSetlog Then SetDebugLog("IsTimeInRange: " & $bResult, $COLOR_DEBUG)
Return $bResult
EndFunc
Func _getDailyRandomStartEnd($iDuration = 4)
Local $iStartHour, $iEndHour
Local Static $iNowDay = @YDAY
If Not($iDuration >= 0 And $iDuration <= 24) Then
SetError(1, "Invalid duration for _getDailyRandomStartEnd")
Return
EndIf
Local $sStartTime = _DateAdd("h", Int(_getDailyRandom() *(23 - @HOUR)), _NowCalc())
If @error Then
_logErrorDateDiff(@error)
SetError(2, "Can not create initial random start time")
Return
EndIf
Local $sEndTime = _DateAdd("h", Int($iDuration), $sStartTime)
If @error Then
_logErrorDateDiff(@error)
SetError(3, "Can not create initial random end time")
Return
EndIf
Local Static $aNoAttackTimes[2] = [$sStartTime, $sEndTime]
If $iNowDay <> @YDAY Then
$iStartHour = _getDailyRandom() * 24
If $iStartHour <= @HOUR Then $iStartHour = @HOUR + 1.166
$iEndHour = $iStartHour + $iDuration
If $g_bDebugSetlog Then SetDebugLog("StartHour: " & $iStartHour & "EndHour: " & $iEndHour, $COLOR_DEBUG)
$aNoAttackTimes[0] = _DateAdd("h", $iStartHour, _NowCalc())
If @error Then
_logErrorDateDiff(@error)
SetError(4, "Can not create random start time")
Return
EndIf
$aNoAttackTimes[1] = _DateAdd("h", $iEndHour, _NowCalc())
If @error Then
_logErrorDateDiff(@error)
SetError(5, "Can not create random end time")
Return
EndIf
EndIf
If $g_bDebugSetlog Then SetDebugLog("NoAttackStart: " & $aNoAttackTimes[0] & "NoAttackEnd: " & $aNoAttackTimes[1], $COLOR_DEBUG)
Return $aNoAttackTimes
EndFunc
Func _getDailyRandom()
Local Static $iDailyRandomValue = Random(0.001, 1, 4)
Local Static $iNowDay = @YDAY
If $iNowDay <> @YDAY Then
$iDailyRandomValue = Round(Random(0.001, 1), 4)
$iNowDay = @YDAY
If $g_bDebugSetlog Then SetDebugLog("New day = new random value!", $COLOR_DEBUG)
EndIf
If $g_bDebugSetlog Then SetDebugLog("DailyRandomValue=" & StringFormat("%0.5f", $iDailyRandomValue), $COLOR_DEBUG)
Return $iDailyRandomValue
EndFunc
Func IsPlannedTimeNow()
Local $hour, $hourloot
If $g_abPlannedAttackWeekDays[@WDAY - 1] = True Then
$hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
$hourloot = $hour[0]
If $g_abPlannedattackHours[$hourloot] = True Then
If $g_bDebugSetlog Then SetDebugLog("Attack plan enabled for now..", $COLOR_DEBUG)
Return True
Else
SetLog("Attack plan enabled today, but not this hour", $COLOR_INFO)
If _Sleep($DELAYRESPOND) Then Return False
Return False
EndIf
Else
SetLog("Attack plan not enabled today", $COLOR_INFO)
If _Sleep($DELAYRESPOND) Then Return False
Return False
EndIf
EndFunc
Func _OverAttackLimit()
Local Static $iAttackCountToday = 0
Local Static $iTotalAttackCount = $g_aiAttackedCount
Local Static $iNowDay = @YDAY
If $iNowDay <> @YDAY Then
$iAttackCountToday = 0
$iNowDay = @YDAY
$iTotalAttackCount = $g_aiAttackedCount
Else
$iAttackCountToday = $g_aiAttackedCount - $iTotalAttackCount
EndIf
If $g_bDebugSetlog Then SetDebugLog("AttackCountToday: " & $iAttackCountToday & ", AttackedCount: " & $g_aiAttackedCount & "TotalAttackCount: " & $iTotalAttackCount, $COLOR_DEBUG)
Local $iRandomAttackCountToday = Ceiling(Int($g_iAttackPlannerDayMin) +(_getDailyRandom() *(Int($g_iAttackPlannerDayMax) - Int($g_iAttackPlannerDayMin))))
If $iRandomAttackCountToday > Int($g_iAttackPlannerDayMax) Then $iRandomAttackCountToday = Int($g_iAttackPlannerDayMax)
If $g_bDebugSetlog Then SetDebugLog("RandomAttackCountToday: " & $iRandomAttackCountToday, $COLOR_DEBUG)
If $iAttackCountToday > $iRandomAttackCountToday Then Return True
Return False
EndFunc
Func WaitForClouds()
If $g_bDebugSetlog Then SetDebugLog("Begin WaitForClouds:", $COLOR_DEBUG1)
Local $iCount = 0
Local $bigCount = 0, $iLastTime = 0
Local $hMinuteTimer, $iSearchTime
Local $bEnabledGUI = False
Local $maxSearchCount = 720
Local $maxLongSearchCount = 7
Switch Int($g_aiCurrentLoot[$eLootTrophy])
Case 3700 To 4099
$maxSearchCount = Random(480, 840, 1)
$maxLongSearchCount = Random(10, 12, 1)
Case 4100 To 4399
$maxSearchCount = Random(480, 840, 1)
$maxLongSearchCount = Random(15, 25, 1)
Case 4400 To 4699
$maxSearchCount = Random(600, 840, 1)
$maxLongSearchCount = Random(24, 42, 1)
Case 4700 To 4999
$maxSearchCount = Random(600, 840, 1)
$maxLongSearchCount = Random(36, 50, 1)
Case 5000 To 6500
$maxSearchCount = Random(600, 840, 1)
$maxLongSearchCount = Random(80, 85, 1)
EndSwitch
If $g_bDebugSetlog Then
SetLog("RANDOM: $maxSearchCount= " & $maxSearchCount & "= " & Round($maxSearchCount / $DELAYGETRESOURCES1, 2) & " min between cloud chk", $COLOR_DEBUG)
SetLog("RANDOM: $maxLongSearchCount= " & $maxLongSearchCount & "= " & Round(($maxSearchCount / $DELAYGETRESOURCES1) * $maxLongSearchCount, 2) & " min max search time", $COLOR_DEBUG)
EndIf
ForceCaptureRegion()
Local $hMinuteTimer = __TimerInit()
While $g_bRestart = False And _CaptureRegions() And _CheckPixel($aNoCloudsAttack) = False
If _Sleep($DELAYGETRESOURCES1) Then Return
$iCount += 1
If isProblemAffect(True) Then
resetAttackSearch()
Return
EndIf
If $iCount >= $maxSearchCount Then
If EnableLongSearch() = False Then
resetAttackSearch()
Return
Else
$bigCount += 1
If $bigCount > $maxLongSearchCount Then
$iSearchTime = __TimerDiff($hMinuteTimer) / 60000
SetLog("Spent " & $iSearchTime & " minutes in Clouds searching, Restarting CoC and Bot...", $COLOR_ERROR)
$g_bIsClientSyncError = False
$g_bRestart = True
CloseCoC(True)
Return
EndIf
$iCount = 0
EndIf
EndIf
If(Mod($iCount, 10) = 0 And checkObstacles_Network(False, False)) Then
$g_bIsClientSyncError = True
$g_bRestart = True
CloseCoC(True)
Return
EndIf
If $g_bDebugSetlog Then _GUICtrlStatusBar_SetTextEx($g_hStatusBar, " Status: Loop to clean screen without Clouds, # " & $iCount)
$iSearchTime = __TimerDiff($hMinuteTimer) / 60000
If $iSearchTime >= $iLastTime + 1 Then
SetLog("Cloud wait time " & StringFormat("%.1f", $iSearchTime) & " minute(s)", $COLOR_INFO)
$iLastTime += 1
If chkAttackSearchFail() = 2 Or chkAttackSearchPersonalBreak() = True Or GetAndroidProcessPID() = 0 Then
resetAttackSearch()
Return
EndIf
If _CheckPixel($aIsMain, $g_bCapturePixel) Then
SetLog("Strange error detected! 'WaitforClouds' returned to main base unexpectedly, OOS restart initiated", $COLOR_ERROR)
$g_bRestart = True
resetAttackSearch()
Return
EndIf
If $iSearchTime > 2 And Not $bEnabledGUI Then
AndroidShieldForceDown(True)
EnableGuiControls()
SetLog("Enabled bot controls due to long wait time", $COLOR_SUCCESS)
$bEnabledGUI = True
EndIf
EndIf
ForceCaptureRegion()
WEnd
If $bEnabledGUI = True Then
SetLog("Disable bot controls after long wait time", $COLOR_SUCCESS)
AndroidShieldForceDown(False)
DisableGuiControls()
SaveConfig()
readConfig()
applyConfig()
EndIf
If _Sleep($DELAYCLOUDSCLEARED) Then Return
EndFunc
Func EnableLongSearch()
Local $iCount
If $g_bDebugSetlog Then SetDebugLog("Begin EnableLongSearch:", $COLOR_DEBUG1)
If Int($g_aiCurrentLoot[$eLootTrophy]) < 3700 Then
If $g_bDebugSetlog Then SetDebugLog("Long cloud search not enabled due trophy count: " & $g_aiCurrentLoot[$eLootTrophy], $COLOR_DEBUG)
Return False
EndIf
$iCount = 0
While 1
If chkSurrenderBtn() = True Then Return True
If chkAttackSearchPersonalBreak() = True Then Return False
If chkAttackSearchFail() = 1 Then Return True
If chkSearchText() = False Then
If $g_bDebugSetlog Then SetDebugLog("Cloud Search Text not found...", $COLOR_DEBUG)
Return False
Else
Click(271, 351 + $g_iMidOffsetY)
EndIf
If _Sleep(5000) Then Return
$iCount += 1
If $iCount > 6 Then Return True
WEnd
EndFunc
Func chkSearchText()
Local $result
$result = getCloudTextShort(388, 348 + $g_iMidOffsetY, "Cloud Search Text: for=", $COLOR_DEBUG, Default)
If $result <> "" And StringInStr($result, "for", $STR_NOCASESENSEBASIC) <> 0 Then
Return True
EndIf
Return False
EndFunc
Func chkAttackSearchFail()
If _Sleep($DELAYCLOUDSCLEARED) Then Return
Local $result
$result = getCloudFailShort(271, 351 + $g_iMidOffsetY, "Cloud Search Fail Text: unable=", $COLOR_DEBUG, Default)
If $result <> "" And StringInStr($result, "unable", $STR_NOCASESENSEBASIC) > 0 Then
If btnSearchFailRetry() = True Then
SetLog("Search Fail? Retry search button pushed, continue...", $COLOR_SUCCESS)
Return 1
Else
SetLog("Warning, failed to find/press retry search button", $COLOR_WARNING)
Return 2
EndIf
EndIf
EndFunc
Func chkAttackSearchPersonalBreak()
Local $result
$result = getCloudFailShort(499, 350 + $g_iMidOffsetY, "Cloud Search PB Text: Break=", $COLOR_DEBUG, Default)
If $result <> "" And StringInStr($result, "break", $STR_NOCASESENSEBASIC) > 0 Then
SetLog("Prepare base before Personal Break in clouds..", $COLOR_INFO)
CheckBaseQuick(True, "cloud")
Return True
EndIf
If $g_bForceSinglePBLogoff And _DateIsValid($g_sPBStartTime) Then
Local $iTimeTillPBTstartSec = Int(_DateDiff('s', $g_sPBStartTime, _NowCalc()))
If $g_bDebugSetlog Then SetDebugLog("PB starts in: " & $iTimeTillPBTstartSec & " Seconds", $COLOR_DEBUG)
If $iTimeTillPBTstartSec >= 0 Then
SetLog("Prepare base before user forced Break..", $COLOR_INFO)
CheckBaseQuick(True, "cloud")
Return True
EndIf
EndIf
Return False
EndFunc
Func btnSearchFailRetry()
If QuickMIS("BC1", @ScriptDir & "\imgxml\Resources\Clouds", 270, 400, 600, 500) Then
Click($g_iQuickMISX + 270, $g_iQuickMISY + 400, 1, 0, "#0512")
Return True
EndIf
Return False
EndFunc
Func chkSurrenderBtn()
Local $wCount = 0
While 1
If _CheckPixel($aSurrenderButton, $g_bCapturePixel, Default, "Surrender btn wait #" & $wCount, $COLOR_DEBUG) = True Then
If $g_bDebugSetlog Then SetDebugLog("Surrender button found, clouds gone, continue...", $COLOR_DEBUG)
Return True
EndIf
If _Sleep($DELAYSLEEP) Then Return
$wCount += 1
If $wCount >= 30 Or isProblemAffect(True) Then
Return False
EndIf
WEnd
EndFunc
Func BoostStructure($sName, $sOcrName, $aPos, ByRef $icmbBoostValue, $cmbBoostCtrl)
Local $boosted = False
Local $ok = False
If UBound($aPos) > 1 And $aPos[0] > 0 And $aPos[1] > 0 Then
BuildingClickP($aPos, "#0462")
If _Sleep($DELAYBOOSTHEROES2) Then Return
ForceCaptureRegion()
Local $aResult = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If $aResult[0] > 1 Then
Local $sN = $aResult[1]
Local $sL = $aResult[2]
If $sOcrName = "" Or StringInStr($sN, $sOcrName, $STR_NOCASESENSEBASIC) > 0 Then
SetLog("Boosting " & $sN & " (Level " & $sL & ") located at " & $aPos[0] & ", " & $aPos[1])
$ok = True
Else
SetLog("Cannot boost " & $sN & " (Level " & $sL & ") located at " & $aPos[0] & ", " & $aPos[1], $COLOR_ERROR)
EndIf
EndIf
EndIf
If $ok = True Then
Local $Boost = findButton("BoostOne")
If IsArray($Boost) Then
If $g_bDebugSetlog Then SetDebugLog("Boost Button X|Y = " & $Boost[0] & "|" & $Boost[1], $COLOR_DEBUG)
Click($Boost[0], $Boost[1], 1, 0, "#0463")
If _Sleep($DELAYBOOSTHEROES1) Then Return
$Boost = findButton("GEM")
If IsArray($Boost) Then
Click($Boost[0], $Boost[1], 1, 0, "#0464")
If _Sleep($DELAYBOOSTHEROES4) Then Return
If IsArray(findButton("EnterShop")) Then
SetLog("Not enough gems to boost " & $sName, $COLOR_ERROR)
Else
If $icmbBoostValue <= 24 Then
$icmbBoostValue -= 1
SetLog($sName & ' Boost completed. Remaining iterations: ' & $icmbBoostValue, $COLOR_SUCCESS)
_GUICtrlComboBox_SetCurSel($cmbBoostCtrl, $icmbBoostValue)
Else
SetLog($sName & ' Boost completed. Remaining iterations: Unlimited', $COLOR_SUCCESS)
EndIf
$boosted = True
EndIf
Else
SetLog($sName & " is already Boosted", $COLOR_SUCCESS)
EndIf
If _Sleep($DELAYBOOSTHEROES3) Then Return
ClickP($aAway, 1, 0, "#0465")
Else
SetLog($sName & " Boost Button not found", $COLOR_ERROR)
If _Sleep($DELAYBOOSTHEROES4) Then Return
EndIf
Else
SetLog("Abort boosting " & $sName & ", bad location", $COLOR_ERROR)
EndIf
Return $boosted
EndFunc
Func AllowBoosting($sName, $icmbBoost)
If($g_bTrainEnabled = True And $icmbBoost > 0) = False Then Return False
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abBoostBarracksHours[$hour[0]] = False Then
SetLog("Boosting " & $sName & " is not planned and skipped...", $COLOR_SUCCESS)
Return False
EndIf
Return True
EndFunc
Func BoostBarracks()
Return BoostTrainBuilding("Barracks", $g_iCmbBoostBarracks, $g_hCmbBoostBarracks)
EndFunc
Func BoostSpellFactory()
Return BoostTrainBuilding("Spell Factory", $g_iCmbBoostSpellFactory, $g_hCmbBoostSpellFactory)
EndFunc
Func BoostTrainBuilding($sName, $iCmbBoost, $iCmbBoostCtrl)
Local $boosted = False
If Not $g_bTrainEnabled Or $iCmbBoost <= 0 Then Return $boosted
Local $aHours = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If Not $g_abBoostBarracksHours[$aHours[0]] Then
SetLog("Boosting " & $sName & " isn't planned, skipping", $COLOR_INFO)
Return $boosted
EndIf
Local $sIsAre = "are"
SetLog("Boosting " & $sName, $COLOR_INFO)
If OpenArmyOverview(True, "BoostTrainBuilding()") Then
If $sName = "Barracks" Then
OpenTroopsTab(True, "BoostTrainBuilding()")
ElseIf $sName = "Spell Factory" Then
OpenSpellsTab(True, "BoostTrainBuilding()")
$sIsAre = "is"
Else
SetDebugLog("BoostTrainBuilding(): $sName called with a wrong Value.", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0161")
_Sleep($DELAYBOOSTBARRACKS2)
Return $boosted
EndIf
Local $aBoostBtn = findButton("BoostBarrack")
If IsArray($aBoostBtn) Then
ClickP($aBoostBtn)
_Sleep($DELAYBOOSTBARRACKS1)
Local $aGemWindowBtn = findButton("GEM")
If IsArray($aGemWindowBtn) Then
ClickP($aGemWindowBtn)
_Sleep($DELAYBOOSTBARRACKS2)
If IsArray(findButton("EnterShop")) Then
SetLog("Not enough gems to boost " & $sName, $COLOR_ERROR)
Else
If $iCmbBoost >= 1 And $iCmbBoost <= 24 Then
$iCmbBoost -= 1
_GUICtrlComboBox_SetCurSel($iCmbBoostCtrl, $iCmbBoost)
SetLog("Remaining " & $sName & " Boosts: " & $iCmbBoost, $COLOR_SUCCESS)
ElseIf $iCmbBoost = 25 Then
SetLog("Remain " & $sName & " Boosts: Unlimited", $COLOR_SUCCESS)
EndIf
$boosted = True
EndIf
EndIf
Else
If IsArray(findButton("BarrackBoosted")) Then
SetLog($sName & " " & $sIsAre & " already boosted", $COLOR_SUCCESS)
Else
SetLog($sName & "boost button not found", $COLOR_ERROR)
EndIf
EndIf
EndIf
ClickP($aAway, 1, 0, "#0161")
_Sleep($DELAYBOOSTBARRACKS2)
Return $boosted
EndFunc
Func BotDetectFirstTime()
Local $collx, $colly, $Result, $i = 0, $t = 0
If $g_bIsClientSyncError = True Then Return
ClickP($aAway, 1, 0, "#0166")
If _Sleep($DELAYBOTDETECT1) Then Return
SetLog("Detecting your Buildings..", $COLOR_INFO)
If(isInsideDiamond($g_aiTownHallPos) = False) Then
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) And _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
Collect()
EndIf
_CaptureRegion2()
Local $PixelTHHere = GetLocationItem("getLocationTownHall")
If UBound($PixelTHHere) > 0 Then
Local $pixel = $PixelTHHere[0]
$g_aiTownHallPos[0] = $pixel[0]
$g_aiTownHallPos[1] = $pixel[1]
If $g_bDebugSetlog Then SetDebugLog("DLLc# Townhall: (" & $g_aiTownHallPos[0] & "," & $g_aiTownHallPos[1] & ")", $COLOR_ERROR)
EndIf
If $g_aiTownHallPos[1] = "" Or $g_aiTownHallPos[1] = -1 Then
imglocTHSearch(True, True)
$g_aiTownHallPos[0] = $g_iTHx
$g_aiTownHallPos[1] = $g_iTHy
If $g_bDebugSetlog Then SetDebugLog("OldDDL Townhall: (" & $g_aiTownHallPos[0] & "," & $g_aiTownHallPos[1] & ")", $COLOR_ERROR)
EndIf
SetLog("Townhall: (" & $g_aiTownHallPos[0] & "," & $g_aiTownHallPos[1] & ")", $COLOR_DEBUG)
EndIf
If Number($g_iTownHallLevel) < 2 Then
$Result = GetTownHallLevel(True)
If IsArray($Result) Then $g_iTownHallLevel = 0
EndIf
If Number($g_iTownHallLevel) > 1 And Number($g_iTownHallLevel) < 6 Then
SetLog("Warning: TownHall level below 6 NOT RECOMMENDED!", $COLOR_ERROR)
SetLog("Proceed with caution as errors may occur.", $COLOR_ERROR)
EndIf
If $g_iTownHallLevel < 2 Or($g_aiTownHallPos[1] = "" Or $g_aiTownHallPos[1] = -1) Then LocateTownHall()
If _Sleep($DELAYBOTDETECT1) Then Return
CheckImageType()
If _Sleep($DELAYBOTDETECT1) Then Return
If GUICtrlRead($g_hChkScreenshotHideName) = $GUI_CHECKED Or $g_bScreenshotHideName Then
If _Sleep($DELAYBOTDETECT3) Then Return
If $g_aiClanCastlePos[0] = -1 Then
LocateClanCastle()
SaveConfig()
EndIf
EndIf
If $g_bAutoLabUpgradeEnable = True Then
If _Sleep($DELAYBOTDETECT3) Then Return
If $g_aiLaboratoryPos[0] = "" Or $g_aiLaboratoryPos[0] = -1 Then
LocateLab()
SaveConfig()
EndIf
EndIf
If(GUICtrlRead($g_hCmbBoostBarbarianKing) > 0) Or $g_bUpgradeKingEnable = True Then
If _Sleep($DELAYBOTDETECT3) Then Return
If $g_aiKingAltarPos[0] = -1 Then
LocateKingAltar()
SaveConfig()
EndIf
EndIf
If(GUICtrlRead($g_hCmbBoostArcherQueen) > 0) Or $g_bUpgradeQueenEnable = True Then
If _Sleep($DELAYBOTDETECT3) Then Return
If $g_aiQueenAltarPos[0] = -1 Then
LocateQueenAltar()
SaveConfig()
EndIf
EndIf
If Number($g_iTownHallLevel) > 10 And((GUICtrlRead($g_hCmbBoostWarden) > 0) Or $g_bUpgradeWardenEnable = True) Then
If _Sleep($DELAYBOTDETECT3) Then Return
If $g_aiWardenAltarPos[0] = -1 Then
LocateWardenAltar()
SaveConfig()
EndIf
EndIf
GUICtrlSetData($g_hLblTHLevels, "")
_GUI_Value_STATE("HIDE", $g_aGroupListTHLevels)
If $g_bDebugSetlog Then SetDebugLog("Select TH Level:" & Number($g_iTownHallLevel), $COLOR_DEBUG)
GUICtrlSetState($g_ahPicTHLevels[$g_iTownHallLevel], $GUI_SHOW)
GUICtrlSetData($g_hLblTHLevels, $g_iTownHallLevel)
EndFunc
Func BotCommand()
Static $TimeToStop = -1
Local $bChkBotStop, $iCmbBotCond, $iCmbBotCommand
If $g_bOutOfElixir Or $g_bOutOfGold Then
$bChkBotStop = True
$iCmbBotCond = 18
$iCmbBotCommand = 0
Local $sOutOf =($g_bOutOfGold ? "Gold" : "") &(($g_bOutOfGold And $g_bOutOfElixir)? " and " : "") &($g_bOutOfElixir ? "Elixir" : "")
SetLog("Out of " & $sOutOf & " condition detected, force HALT mode!", $COLOR_WARNING)
Else
$bChkBotStop = $g_bChkBotStop
$iCmbBotCond = $g_iCmbBotCond
$iCmbBotCommand = $g_iCmbBotCommand
EndIf
$g_bMeetCondStop = False
$g_bTrainEnabled = True
$g_bDonationEnabled = True
If $bChkBotStop = True Then
If $iCmbBotCond = 15 And $g_iCmbHoursStop <> 0 Then $TimeToStop = $g_iCmbHoursStop * 3600000
Switch $iCmbBotCond
Case 0
If isGoldFull() And isElixirFull() And isTrophyMax() Then $g_bMeetCondStop = True
Case 1
If(isGoldFull() And isElixirFull()) Or isTrophyMax() Then $g_bMeetCondStop = True
Case 2
If(isGoldFull() Or isElixirFull()) And isTrophyMax() Then $g_bMeetCondStop = True
Case 3
If isGoldFull() Or isElixirFull() Or isTrophyMax() Then $g_bMeetCondStop = True
Case 4
If isGoldFull() And isElixirFull() Then $g_bMeetCondStop = True
Case 5
If isGoldFull() Or isElixirFull() Then $g_bMeetCondStop = True
Case 6
If isGoldFull() And isTrophyMax() Then $g_bMeetCondStop = True
Case 7
If isElixirFull() And isTrophyMax() Then $g_bMeetCondStop = True
Case 8
If isGoldFull() Or isTrophyMax() Then $g_bMeetCondStop = True
Case 9
If isElixirFull() Or isTrophyMax() Then $g_bMeetCondStop = True
Case 10
If isGoldFull() Then $g_bMeetCondStop = True
Case 11
If isElixirFull() Then $g_bMeetCondStop = True
Case 12
If isTrophyMax() Then $g_bMeetCondStop = True
Case 13
If isDarkElixirFull() Then $g_bMeetCondStop = True
Case 14
If isGoldFull() And isElixirFull() And isDarkElixirFull() Then $g_bMeetCondStop = True
Case 15
If Round(__TimerDiff($g_hTimerSinceStarted)) > $TimeToStop Then $g_bMeetCondStop = True
Case 16
$g_bMeetCondStop = True
Case 17
$g_bMeetCondStop = True
$g_bTrainEnabled = False
Case 18
$g_bMeetCondStop = True
$g_bTrainEnabled = False
$g_bDonationEnabled = False
Case 19
If $g_bWaitShield = True Then $g_bMeetCondStop = True
Case 20
If $g_bWaitShield = True Then
$g_bMeetCondStop = True
$g_bTrainEnabled = False
EndIf
Case 21
If $g_bWaitShield = True Then
$g_bMeetCondStop = True
$g_bTrainEnabled = False
$g_bDonationEnabled = False
EndIf
EndSwitch
If $g_bMeetCondStop Then
Switch $iCmbBotCommand
Case 0
If $g_bDonationEnabled = False Then
SetLog("Halt Attack, Stay Online/Collect...", $COLOR_INFO)
ElseIf $g_bTrainEnabled = False Then
SetLog("Halt Attack, Stay Online/Collect/Donate...", $COLOR_INFO)
Else
SetLog("Halt Attack, Stay Online/Train/Collect/Donate...", $COLOR_INFO)
EndIf
$g_iCommandStop = 0
If _Sleep($DELAYBOTCOMMAND1) Then Return
Case 1
SetLog("MyBot.run Bot Stop as requested!!", $COLOR_INFO)
If _Sleep($DELAYBOTCOMMAND1) Then Return
Return True
Case 2
SetLog("MyBot.run Close Bot as requested!!", $COLOR_INFO)
If _Sleep($DELAYBOTCOMMAND1) Then Return
BotClose()
Return True
Case 3
SetLog("Close Android and Bot as requested!!", $COLOR_INFO)
If _Sleep($DELAYBOTCOMMAND1) Then Return
CloseAndroid("BotCommand")
BotClose()
Return True
Case 4
SetLog("Force Shutdown of PC...", $COLOR_INFO)
If _Sleep($DELAYBOTCOMMAND1) Then Return
Shutdown(BitOR($SD_SHUTDOWN, $SD_FORCE))
Return True
Case 5
SetLog("PC Sleep Mode Start now ...", $COLOR_INFO)
If _Sleep($DELAYBOTCOMMAND1) Then Return
Shutdown($SD_STANDBY)
Return True
Case 6
SetLog("Rebooting PC...", $COLOR_INFO)
If _Sleep($DELAYBOTCOMMAND1) Then Return
Shutdown(BitOR($SD_REBOOT, $SD_FORCE))
Return True
EndSwitch
EndIf
EndIf
Return False
EndFunc
Func isTrophyMax()
Local $iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If Number($iTrophyCurrent) > Number($g_iDropTrophyMax) Then
SetLog("Max. Trophy Reached!", $COLOR_SUCCESS)
If _Sleep($DELAYBOTCOMMAND1) Then Return
Return True
EndIf
Return False
EndFunc
Func BreakPersonalShield()
If $g_bDebugSetlog Then SetDebugLog("Begin BreakPersonalShield:", $COLOR_DEBUG1)
If $g_bDebugSetlog Then
SetDebugLog("Checking if Shield available", $COLOR_INFO)
SetDebugLog("Have shield pixel color: " & _GetPixelColor($aHaveShield, $g_bCapturePixel) & " :" & _CheckPixel($aHaveShield, $g_bCapturePixel), $COLOR_DEBUG)
EndIf
If _CheckPixel($aHaveShield, $g_bCapturePixel) Then
If IsMainPage() Then
PureClickP($aShieldInfoButton)
If _Sleep($DELAYPERSONALSHIELD1) Then
SetError(2)
Return
EndIf
Local $result = ClickRemove("Shield")
If($result = False) Or @error Then
SetError(3, "shield remove button not found", "")
Return
EndIf
$result = ClickOkay("Shield")
If($result = False) Or @error Then
SetError(4, "shield Okay button not found", "")
Return
EndIf
SetLog("Shield removed", $COLOR_SUCCESS)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("No shield available", $COLOR_SUCCESS)
EndIf
If _Sleep($DELAYPERSONALSHIELD1) Then
SetError(2)
Return
EndIf
If $g_bDebugSetlog Then
SetDebugLog("Checking if Personal Guard available", $COLOR_INFO)
SetDebugLog("Have guard pixel color: " & _GetPixelColor($aHavePerGuard, $g_bCapturePixel) & " :" & _CheckPixel($aHavePerGuard, $g_bCapturePixel), $COLOR_DEBUG)
EndIf
If _CheckPixel($aHavePerGuard, $g_bCapturePixel) Then
If IsMainPage() Then
PureClickP($aShieldInfoButton)
If _Sleep($DELAYPERSONALSHIELD1) Then
SetError(2)
Return
EndIf
Local $result = ClickRemove("Guard")
If($result = False) Or @error Then
SetError(5, "guard remove button not found")
Return
EndIf
$result = ClickOkay("Guard")
If($result = False) Or @error Then
SetError(6, "guard Okay button not found")
Return
EndIf
SetLog("Personal Guard removed", $COLOR_SUCCESS)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("No guard available", $COLOR_SUCCESS)
EndIf
EndFunc
Func CheckImageType()
SetLog("Detecting your Village Theme", $COLOR_INFO)
ClickP($aAway, 2, 20, "#0467")
If _Sleep($DELAYCHECKIMAGETYPE1) Then Return
If Not IsMainPage() Then ClickP($aAway, 2, 20, "#0467")
Local $x = 165
Local $y = 150
Local $x1 = $x + 60
Local $y1 = $y + 80
Local $directory = @ScriptDir & "\imgxml\SnowTheme"
Local $temp = SearchImgloc($directory, $x, $y, $x1, $y1)
If IsArray($temp) Then
If StringInStr($temp[0], "Snow") > 0 Then
$g_iDetectedImageType = 1
SetLog("Snow Theme detected")
Else
$g_iDetectedImageType = 0
SetLog("Normal Theme detected")
EndIf
Else
$g_iDetectedImageType = 0
SetLog("Normal Theme detected", $COLOR_RED)
EndIf
EndFunc
Func CheckBaseQuick($bStopRecursion = False, $sReturnHome = "")
If $bStopRecursion = True Then $g_bDisableBreakCheck = True
Switch $sReturnHome
Case "cloud"
If _CheckPixel($aRtnHomeCloud1, $g_bCapturePixel, Default, "Return Home Btn chk1", $COLOR_DEBUG) And  _CheckPixel($aRtnHomeCloud2, $g_bCapturePixel, Default, "Return Home Btn chk2", $COLOR_DEBUG) Then
ClickP($aRtnHomeCloud1, 1, 0, "#0513")
Local $wCount = 0
While IsMainPage() = False
If _Sleep($DELAYGETRESOURCES1) Then Return
$wCount += 1
If $wCount > 40 Then
SetLog("Warning, Main page not found", $COLOR_WARNING)
ExitLoop
EndIf
WEnd
EndIf
EndSwitch
If IsMainPage() Then
If $g_bDebugSetlog Then SetDebugLog("CheckBaseQuick now...", $COLOR_DEBUG)
RequestCC()
If _Sleep($DELAYRUNBOT1) Then Return
checkMainScreen(False)
If $g_bRestart = True Then
If $bStopRecursion = True Then $g_bDisableBreakCheck = False
Return
EndIf
DonateCC()
If _Sleep($DELAYRUNBOT1) Then Return
checkMainScreen(False)
If $g_bRestart = True Then
If $bStopRecursion = True Then $g_bDisableBreakCheck = False
Return
EndIf
CheckOverviewFullArmy(True)
If Not($g_bFullArmy) And $g_bTrainEnabled = True Then
If $g_iActualTrainSkip < $g_iMaxTrainSkip Then
TrainRevamp()
If $g_bRestart Then Return
Else
If $g_bDebugSetlogTrain Then SetLog("skip train. " & $g_iActualTrainSkip + 1 & "/" & $g_iMaxTrainSkip, $color_purple)
$g_iActualTrainSkip = $g_iActualTrainSkip + 1
CheckOverviewFullArmy(True, False)
getArmySpells()
getArmyHeroCount(False, True)
If $g_iActualTrainSkip >= $g_iMaxTrainSkip Then
$g_iActualTrainSkip = 0
EndIf
If $bStopRecursion = True Then $g_bDisableBreakCheck = False
Return
EndIf
EndIf
Collect()
If _Sleep($DELAYRUNBOT1) Then Return
Else
If $g_bDebugSetlog Then SetDebugLog("Not on main page, CheckBaseQuick skipped", $COLOR_WARNING)
EndIf
If $bStopRecursion = True Then $g_bDisableBreakCheck = False
EndFunc
Func chkShieldStatus($bChkShield = True, $bForceChkPBT = False)
If($g_bForceSinglePBLogoff = False And($g_bChkBotStop = True And $g_iCmbBotCond >= 19) = False) And $g_bCloseWhileTrainingEnable = False Or Not(IsMainPage()) Then Return
Local $Result, $iTimeTillPBTstartSec, $ichkTime = 0, $ichkSTime = 0, $ichkPBTime = 0
If $bChkShield Or $g_asShieldStatus[0] = "" Or $g_asShieldStatus[1] = "" Or $g_asShieldStatus[2] = "" Or $g_sPBStartTime = "" Or $g_bGForcePBTUpdate = True Then
$Result = getShieldInfo()
If @error Then SetLog("chkShieldStatus Shield OCR error= " & @error & "Extended= " & @extended, $COLOR_ERROR)
If _Sleep($DELAYRESPOND) Then Return
If IsArray($Result) Then
Local $iShieldExp = _DateDiff('n', $Result[2], _NowCalc())
If Abs($iShieldExp) > 0 Then
Local $sFormattedDiff = _Date_Difference(_NowCalc(), $Result[2], 4)
SetLog("Shield expires in: " & $sFormattedDiff)
Else
SetLog("Shield has expired")
EndIf
If _DateIsValid($g_asShieldStatus[2]) Then
$ichkTime = Abs(Int(_DateDiff('s', $g_asShieldStatus[2], $Result[2])))
If $ichkTime > 60 Then
$bForceChkPBT = True
If $g_bDebugSetlog Then SetDebugLog("Shield time changed: " & $ichkTime & " Sec, Force PBT OCR: " & $bForceChkPBT, $COLOR_WARNING)
EndIf
EndIf
$g_asShieldStatus = $Result
If $g_bChkBotStop = True And $g_iCmbBotCond >= 19 Then
If $g_asShieldStatus[0] = "shield" Then
SetLog("Shield found, Halt Attack Now!", $COLOR_INFO)
$g_bWaitShield = True
$g_bIsClientSyncError = False
$g_bIsSearchLimit = False
Else
$g_bWaitShield = False
If $g_bMeetCondStop = True Then
SetLog("Shield expired, resume attacking", $COLOR_INFO)
$g_bTrainEnabled = True
$g_bDonationEnabled = True
$g_bMeetCondStop = False
Else
If $g_bDebugSetlog Then SetDebugLog("Halt With Shield: Shield not found...", $COLOR_DEBUG)
EndIf
EndIf
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("Bad getShieldInfo() return value: " & $Result, $COLOR_ERROR)
If _Sleep($DELAYRESPOND) Then Return
For $i = 0 To UBound($g_asShieldStatus) - 1
$g_asShieldStatus[$i] = ""
Next
EndIf
EndIf
If $g_bForceSinglePBLogoff = False Then Return
If _DateIsValid($g_sPBStartTime) Then
$ichkPBTime = Int(_DateDiff('s', $g_sPBStartTime, _NowCalc()))
If $ichkPBTime >= 295 Then
$bForceChkPBT = True
If $g_bDebugSetlog Then SetDebugLog("Found old PB time= " & $ichkPBTime & " Seconds, Force update:" & $bForceChkPBT, $COLOR_WARNING)
EndIf
EndIf
If $bForceChkPBT Or $g_bGForcePBTUpdate Or $g_sPBStartTime = "" Then
$g_bGForcePBTUpdate = False
$Result = getPBTime()
If @error Then SetLog("chkShieldStatus getPBTime OCR error= " & @error & ", Extended= " & @extended, $COLOR_ERROR)
If _Sleep($DELAYRESPOND) Then Return
If _DateIsValid($Result) Then
Local $iTimeTillPBTstartMin = Int(_DateDiff('n', $Result, _NowCalc()))
If Abs($iTimeTillPBTstartMin) > 0 Then
Local $sFormattedDiff = _Date_Difference(_DateAdd("n", -1, _NowCalc()), $Result, 4)
SetLog("Personal Break starts in: " & $sFormattedDiff)
Local $CorrectstringPB_GUI = StringReplace($sFormattedDiff, StringInStr($sFormattedDiff, " hours ") >= 1 ? " hours " : " hour ", "h")
$CorrectstringPB_GUI = StringReplace($CorrectstringPB_GUI, StringInStr($CorrectstringPB_GUI, " minutes ") >= 1 ? " minutes " : " minute ", "'")
$g_aiPersonalBreak[$g_iCurAccount] = $CorrectstringPB_GUI
Else
$g_aiPersonalBreak[$g_iCurAccount] = ""
EndIf
If $iTimeTillPBTstartMin < -(Int($g_iSinglePBForcedEarlyExitTime)) Then
$g_sPBStartTime = _DateAdd('n', -(Int($g_iSinglePBForcedEarlyExitTime)), $Result)
ElseIf $iTimeTillPBTstartMin < 0 Then
$g_sPBStartTime = $Result
Else
$g_sPBStartTime = ""
EndIf
If $g_bDebugSetlog Then SetDebugLog("Early Log Off time=" & $g_sPBStartTime & ", In " & _DateDiff('n', $g_sPBStartTime, _NowCalc()) & " Minutes", $COLOR_DEBUG)
Else
SetLog("Bad getPBTtime() return value: " & $Result, $COLOR_ERROR)
$g_sPBStartTime = ""
$g_aiPersonalBreak[$g_iCurAccount] = ""
EndIf
EndIf
If checkObstacles() Then checkMainScreen(False)
EndFunc
Func _Date_Difference($sStartDate, Const $sEndDate, Const $iGrain)
Local $aUnit[6] = ["Y", "M", "D", "h", "n", "s"]
Local $aType[6] = ["year", "month", "day", "hour", "minute", "second"]
Local $sReturn = "", $iUnit
For $i = 0 To $iGrain
$iUnit = _DateDiff($aUnit[$i], $sStartDate, $sEndDate)
If $iUnit <> 0 Then
$sReturn &= $iUnit & " " & $aType[$i] &($iUnit > 1 ? "s" : "") & " "
EndIf
$sStartDate = _DateAdd($aUnit[$i], $iUnit, $sStartDate)
Next
Return $sReturn
EndFunc
Func Collect($bCheckTreasury = True)
If Not $g_bChkCollect Then Return
If Not $g_bRunState Then Return
ClickP($aAway, 1, 0, "#0332")
StartGainCost()
checkAttackDisable($g_iTaBChkIdle)
SetLog("Collecting Resources", $COLOR_INFO)
If _Sleep($DELAYCOLLECT2) Then Return
Local $sFileName = ""
Local $aCollectXY, $t
Local $aResult = returnMultipleMatchesOwnVillage($g_sImgCollectRessources)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
$sFileName = $aResult[$i][1]
$aCollectXY = $aResult[$i][5]
If IsArray($aCollectXY) Then
$t = Random(0, UBound($aCollectXY) - 1, 1)
If $g_bDebugSetlog Then SetDebugLog($sFileName & " found, random pick(" & $aCollectXY[$t][0] & "," & $aCollectXY[$t][1] & ")", $COLOR_GREEN)
If IsMainPage() Then Click($aCollectXY[$t][0], $aCollectXY[$t][1], 1, 0, "#0430")
If _Sleep($DELAYCOLLECT2) Then Return
EndIf
Next
EndIf
If _Sleep($DELAYCOLLECT3) Then Return
checkMainScreen(False)
SetLog("Searching for a Loot Cart..", $COLOR_INFO)
Local $aLootCart = decodeSingleCoord(findImage("LootCart", $g_sImgCollectLootCart, "ECD", 1, True))
If UBound($aLootCart) > 1 Then
If isInsideDiamond($aLootCart) Then
If IsMainPage() Then ClickP($aLootCart, 1, 0, "#0330")
If _Sleep($DELAYCOLLECT1) Then Return
Local $sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
If _Sleep($DELAYCOLLECT1) Then Return
$CountGetInfo += 1
If $CountGetInfo >= 5 Then Return
WEnd
If $g_bDebugSetlog Then SetDebugLog(_ArrayToString($sInfo, " "), $COLOR_DEBUG)
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Loot") = 0 Then
If $g_bDebugSetlog Then SetDebugLog("Bad Loot Cart location", $COLOR_ACTION)
Else
If IsMainPage() Then Click($aLootCartBtn[0], $aLootCartBtn[1], 1, 0, "#0331")
EndIf
EndIf
Else
SetLog("Error in Collect(): Loot Cart Coordinates are not inside the Village (X: " & $aLootCart[0] & " | Y: " & $aLootCart[1], $COLOR_ERROR)
EndIf
Else
SetLog("No Loot Cart found on your Village", $COLOR_SUCCESS)
EndIf
If $g_bChkTreasuryCollect And $bCheckTreasury Then TreasuryCollect()
EndGainCost("Collect")
EndFunc
Func TreasuryCollect()
If $g_bDebugSetlog Then SetDebugLog("Begin CollectTreasury:", $COLOR_DEBUG1)
If Not $g_bRunState Then Return
ClickP($aAway, 1, 0, "#0441")
If _Sleep($DELAYRESPOND) Then Return
If($g_aiClanCastlePos[0] = "-1" Or $g_aiClanCastlePos[1] = "-1") Then
SetLog("Need Clan Castle location for the Treasury, Please locate your Clan Castle.", $COLOR_WARNING)
LocateClanCastle()
If($g_aiClanCastlePos[0] = "-1" Or $g_aiClanCastlePos[1] = "-1") Then
SetLog("Treasury skipped, bad Clan Castle location", $COLOR_ERROR)
If _Sleep($DELAYRESPOND) Then Return
Return
EndIf
EndIf
ClickP($aAway, 1, 0, "#0440")
If _Sleep($DELAYCOLLECT3) Then Return
BuildingClick($g_aiClanCastlePos[0], $g_aiClanCastlePos[1], "#0250")
If _Sleep($DELAYTREASURY2) Then Return
Local $aTreasuryButton = findButton("Treasury", Default, 1, True)
If IsArray($aTreasuryButton) And UBound($aTreasuryButton, 1) = 2 Then
If IsMainPage() Then ClickP($aTreasuryButton, 1, 0, "#0330")
If _Sleep($DELAYTREASURY1) Then Return
Else
SetLog("Cannot find the Treasury Button", $COLOR_ERROR)
EndIf
If Not _WaitForCheckPixel($aTreasuryWindow, $g_bCapturePixel, Default, "Wait treasury window:") Then
SetLog("Treasury window not found!", $COLOR_ERROR)
Return
EndIf
Local $bForceCollect = False
Local $aResult = _PixelSearch(689, 237 + $g_iMidOffsetY, 691, 325 + $g_iMidOffsetY, Hex(0x50BD10, 6), 20)
If IsArray($aResult) Then
SetLog("Found full Treasury, collecting loot...", $COLOR_SUCCESS)
$bForceCollect = True
Else
SetLog("Treasury not full yet", $COLOR_INFO)
EndIf
If $bForceCollect Or($g_bChkTreasuryCollect And((Number($g_aiCurrentLoot[$eLootGold]) <= $g_iTxtTreasuryGold) Or(Number($g_aiCurrentLoot[$eLootElixir]) <= $g_iTxtTreasuryElixir) Or(Number($g_aiCurrentLoot[$eLootDarkElixir]) <= $g_iTxtTreasuryDark))) Then
Local $aCollectButton = findButton("Collect", Default, 1, True)
If IsArray($aCollectButton) And UBound($aCollectButton, 1) = 2 Then
ClickP($aCollectButton, 1, 0, "#0330")
If _Sleep($DELAYTREASURY2) Then Return
If ClickOkay("ConfirmCollectTreasury") Then
SetLog("Treasury collected successfully.", $COLOR_SUCCESS)
Else
SetLog("Cannot Click Okay Button on Treasury Collect screen", $COLOR_ERROR)
EndIf
Else
SetDebugLog("Error in TreasuryCollect(): Cannot find the Collect Button", $COLOR_ERROR)
EndIf
Else
ClickP($aAway, 1, 0, "#0438")
If _Sleep($DELAYTREASURY4) Then Return
EndIf
ClickP($aAway, 1, 0, "#0438")
If _Sleep($DELAYTREASURY4) Then Return
EndFunc
Global $g_aiPrepDon[4] = [0, 0, 0, 0]
Global $g_iTotalDonateTroopCapacity, $g_iTotalDonateSpellCapacity, $g_iTotalDonateSiegeMachineCapacity
Global $g_iDonTroopsLimit = 8, $iDonSpellsLimit = 1, $g_iDonTroopsAv = 0, $g_iDonSpellsAv = 0
Global $g_iDonTroopsQuantityAv = 0, $g_iDonTroopsQuantity = 0, $g_iDonSpellsQuantityAv = 0, $g_iDonSpellsQuantity = 0
Global $g_bSkipDonTroops = False, $g_bSkipDonSpells = False
Global $g_bDonateAllRespectBlk = False
Global $g_aiDonatePixel
Func PrepareDonateCC()
$g_aiPrepDon[0] = 0
$g_aiPrepDon[1] = 0
For $i = 0 To $eTroopCount - 1 + $g_iCustomDonateConfigs
$g_aiPrepDon[0] = BitOR($g_aiPrepDon[0],($g_abChkDonateTroop[$i] ? 1 : 0))
$g_aiPrepDon[1] = BitOR($g_aiPrepDon[1],($g_abChkDonateAllTroop[$i] ? 1 : 0))
Next
$g_aiPrepDon[2] = 0
$g_aiPrepDon[3] = 0
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
$g_aiPrepDon[2] = BitOR($g_aiPrepDon[2],($g_abChkDonateSpell[$i] ? 1 : 0))
$g_aiPrepDon[3] = BitOR($g_aiPrepDon[3],($g_abChkDonateAllSpell[$i] ? 1 : 0))
EndIf
Next
$g_iActiveDonate = BitOR($g_aiPrepDon[0], $g_aiPrepDon[1], $g_aiPrepDon[2], $g_aiPrepDon[3])
EndFunc
Func DonateCC($bCheckForNewMsg = False)
Local $bDonateTroop =($g_aiPrepDon[0] = 1)
Local $bDonateAllTroop =($g_aiPrepDon[1] = 1)
Local $bDonateSpell =($g_aiPrepDon[2] = 1)
Local $bDonateAllSpell =($g_aiPrepDon[3] = 1)
Local $bDonate =($g_iActiveDonate = 1)
Local $bOpen = True, $bClose = False
Local $ClanString = ""
If Not $bDonate Or Not $g_bDonationEnabled Then
If $g_bDebugSetlog Then SetDebugLog("Donate Clan Castle troops skip", $COLOR_DEBUG)
Return
EndIf
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If Not $g_abDonateHours[$hour[0]] And $g_bDonateHoursEnable Then
If $g_bDebugSetlog Then SetDebugLog("Donate Clan Castle troops not planned, Skipped..", $COLOR_DEBUG)
Return
EndIf
Local $y = 90
If $bCheckForNewMsg Then
If Not _ColorCheck(_GetPixelColor(26, 312 + $g_iMidOffsetY, True), Hex(0xf00810, 6), 20) And $g_iCommandStop <> 3 Then Return
EndIf
ClickP($aAway, 1, 0, "#0167")
SetLog("Checking for Donate Requests in Clan Chat", $COLOR_INFO)
ForceCaptureRegion()
If Not _CheckPixel($aChatTab, $g_bCapturePixel) Or Not _CheckPixel($aChatTab2, $g_bCapturePixel) Or Not _CheckPixel($aChatTab3, $g_bCapturePixel) Then ClickP($aOpenChat, 1, 0, "#0168")
If _Sleep($DELAYDONATECC4) Then Return
Local $iLoopCount = 0
While 1
If _ColorCheck(_GetPixelColor(189, 24, True), Hex(0x706C50, 6), 20) Then
ExitLoop
EndIf
If _ColorCheck(_GetPixelColor(189, 24, True), Hex(0x383828, 6), 20) Then
If _Sleep($DELAYDONATECC1) Then Return
ClickP($aClanTab, 1, 0, "#0169")
ExitLoop
EndIf
$iLoopCount += 1
If $iLoopCount >= 15 Then
SetLog("Clan Chat Did Not Open - Abandon Donate")
AndroidPageError("DonateCC")
Return
EndIf
If _Sleep($DELAYDONATECC1) Then Return
WEnd
Local $Scroll
Local $donateCCfilter = False
While 1
ForceCaptureRegion()
$y = 90
$Scroll = _PixelSearch(293, 8 + $y, 295, 23 + $y, Hex(0xFFFFFF, 6), 20)
If IsArray($Scroll) And _ColorCheck(_GetPixelColor(300, 110, True), Hex(0x509808, 6), 20) Then
$bDonate = True
Click($Scroll[0], $Scroll[1], 1, 0, "#0172")
$y = 90
If _Sleep($DELAYDONATECC2 + 100) Then ExitLoop
ContinueLoop
EndIf
ExitLoop
WEnd
Local $itime = TimerInit()
Local $iBenchmark
Local $Buttons = 0
While $bDonate
checkAttackDisable($g_iTaBChkIdle)
$ClanString = ""
$itime = TimerInit()
If _Sleep($DELAYDONATECC2) Then ExitLoop
ForceCaptureRegion()
$g_aiDonatePixel = _MultiPixelSearch(200, $y, 230, 660 + $g_iBottomOffsetY, -2, 1, Hex(0x6da725, 6), $aChatDonateBtnColors, 20)
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get all Buttons in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
If IsArray($g_aiDonatePixel) Then
$Buttons += 1
If $g_bDebugSetlog Then SetDebugLog("***** Donate Request Number " & $Buttons & " *****", $COLOR_ACTION)
If $g_bDebugSetlog Then SetDebugLog("$g_aiDonatePixel: (" & $g_aiDonatePixel[0] & "," & $g_aiDonatePixel[1] & ")", $COLOR_DEBUG)
$donateCCfilter = donateCCWBLUserImageCollect($g_aiDonatePixel[0], $g_aiDonatePixel[1])
$bDonate = False
$g_bSkipDonTroops = False
$g_bSkipDonSpells = False
If $bDonateTroop Or $bDonateSpell And $donateCCfilter Then
Local $Alphabets[4] = [$g_bChkExtraAlphabets, $g_bChkExtraChinese, $g_bChkExtraKorean, $g_bChkExtraPersian]
Local $Yaxis[4] = [50, 26, 26, 31]
Local $TextAlphabetsNames[4] = ["Cyrillic and Latin", "Chinese", "Korean", "Persian"]
Local $AlphabetFunctions[4] = ["getChatString", "getChatStringChinese", "getChatStringKorean", "getChatStringPersian"]
Local $BlankSpaces = ""
For $i = 0 To UBound($Alphabets) - 1
If $i = 0 Then
Local $coordinates[3] = [50, 36, 23]
Local $OcrName =($Alphabets[$i] = True) ?("coc-latin-cyr") :("coc-latinA")
Local $log = "Latin"
If $Alphabets[$i] Then $log = $TextAlphabetsNames[$i]
$ClanString = ""
SetLog("Using OCR to read " & $log & " derived alphabets.", $COLOR_ACTION)
For $j = 0 To 2
If $ClanString = "" Or $ClanString = " " Then
$ClanString &= $BlankSpaces & getChatString(30, $g_aiDonatePixel[1] - $coordinates[$j], $OcrName)
If $g_bDebugSetlog Then SetDebugLog("$OcrName: " & $OcrName)
If $g_bDebugSetlog Then SetDebugLog("$coordinates: " & $coordinates[$j])
If $g_bDebugSetlog Then SetDebugLog("$ClanString: " & $ClanString)
If $ClanString <> "" And $ClanString <> " " Then ExitLoop
EndIf
If $ClanString <> "" Then $BlankSpaces = " "
Next
Else
If $Alphabets[$i] Then
If $ClanString = "" Or $ClanString = " " Then
SetLog("Using OCR to read " & $TextAlphabetsNames[$i] & " alphabets.", $COLOR_ACTION)
#Au3Stripper_Off
$ClanString &= $BlankSpaces & Call($AlphabetFunctions[$i], 30, $g_aiDonatePixel[1] - $Yaxis[$i])
#Au3Stripper_On
If @error = 0xDEAD And @extended = 0xBEEF Then SetLog("[DonatCC] Function " & $AlphabetFunctions[$i] & "() had a problem.")
If $g_bDebugSetlog Then SetDebugLog("$OcrName: " & $OcrName)
If $g_bDebugSetlog Then SetDebugLog("$Yaxis: " & $Yaxis[$i])
If $g_bDebugSetlog Then SetDebugLog("$ClanString: " & $ClanString)
If $ClanString <> "" And $ClanString <> " " Then ExitLoop
EndIf
EndIf
EndIf
Next
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get Request OCR in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
If $ClanString = "" Or $ClanString = " " Then
SetLog("Unable to read Chat Request!", $COLOR_ERROR)
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
ContinueLoop
Else
If $g_bChkExtraAlphabets Then
ClipPut($ClanString)
Local $tempClip = ClipGet()
SetLog("Chat Request: " & $tempClip)
Else
SetLog("Chat Request: " & $ClanString)
EndIf
EndIf
ElseIf(($bDonateAllTroop And $bDonateAllSpell) Or($bDonateAllTroop And Not $bDonateSpell) Or(Not $bDonateTroop And $bDonateAllSpell)) And $donateCCfilter Then
SetLog("Skip reading chat requests. Donate all is enabled!", $COLOR_ACTION)
EndIf
RemainingCCcapacity()
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get remaining CC capacity in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
If Not $donateCCfilter Then
SetLog("Skip Donation at this Clan Mate...", $COLOR_ACTION)
$g_bSkipDonTroops = True
$g_bSkipDonSpells = True
Else
If $g_iTotalDonateTroopCapacity <= 0 Then
SetLog("Clan Castle troops are full, skip troop donation...", $COLOR_ACTION)
$g_bSkipDonTroops = True
EndIf
If $g_iTotalDonateSpellCapacity = 0 Then
SetLog("Clan Castle spells are full, skip spell donation...", $COLOR_ACTION)
$g_bSkipDonSpells = True
ElseIf $g_iTotalDonateSpellCapacity = -1 Then
If $g_bDebugSetlog Then SetDebugLog("This CC cannot accept spells, skip spell donation...", $COLOR_DEBUG)
$g_bSkipDonSpells = True
ElseIf $g_iCurrentSpells = 0 Then
SetLog("No spells available, skip spell donation...", $COLOR_ORANGE)
$g_bSkipDonSpells = True
EndIf
EndIf
If $g_bSkipDonTroops And $g_bSkipDonSpells Then
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
ContinueLoop
EndIf
If _Sleep($DELAYDONATECC3) Then Return
If($g_bSkipDonTroops And $g_bSkipDonSpells) Or Not DonateWindow($bOpen) Then
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
SetLog("Donate Window did not open - Exiting Donate", $COLOR_ERROR)
ExitLoop
EndIf
Local $eCustom[4] = [$eCustomA, $eCustomB, $eCustomC, $eCustomD]
Local $eDonateCustom[4] = [$g_aiDonateCustomTrpNumA, $g_aiDonateCustomTrpNumB, $g_aiDonateCustomTrpNumC, $g_aiDonateCustomTrpNumD]
If $bDonateTroop Or $bDonateSpell Then
If $g_bDebugSetlog Then SetDebugLog("Troop/Spell checkpoint.", $COLOR_DEBUG)
DonateWindowCap($g_bSkipDonTroops, $g_bSkipDonSpells)
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get available donate cap in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
If $g_bSkipDonTroops And $g_bSkipDonSpells Then
DonateWindow($bClose)
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
If _Sleep($DELAYDONATECC2) Then ExitLoop
ContinueLoop
EndIf
If $bDonateTroop And Not $g_bSkipDonTroops Then
If $g_bDebugSetlog Then SetDebugLog("Troop checkpoint.", $COLOR_DEBUG)
For $x = 0 To UBound($eDonateCustom) - 1
If $g_abChkDonateTroop[$eCustom[$x]] And CheckDonateTroop(99, $g_asTxtDonateTroop[$eCustom[$x]], $g_asTxtBlacklistTroop[$eCustom[$x]], $ClanString) Then
Local $CorrectDonateCustom = $eDonateCustom[$x]
For $i = 0 To 2
If $CorrectDonateCustom[$i][0] < $eBarb Then
$CorrectDonateCustom[$i][0] = $eArch
ElseIf $CorrectDonateCustom[$i][0] > $eBowl Then
ContinueLoop
EndIf
If $CorrectDonateCustom[$i][1] < 1 Then
ContinueLoop
ElseIf $CorrectDonateCustom[$i][1] > 8 Then
$CorrectDonateCustom[$i][1] = 8
EndIf
DonateTroopType($CorrectDonateCustom[$i][0], $CorrectDonateCustom[$i][1], $g_abChkDonateTroop[$eCustom[$x]])
If _Sleep($DELAYDONATECC3) Then ExitLoop
Next
EndIf
Next
If Not $g_bSkipDonTroops Then
For $i = 0 To UBound($g_aiDonateTroopPriority) - 1
Local $iTroopIndex = $g_aiDonateTroopPriority[$i]
If $g_abChkDonateTroop[$iTroopIndex] Then
If CheckDonateTroop($iTroopIndex, $g_asTxtDonateTroop[$iTroopIndex], $g_asTxtBlacklistTroop[$iTroopIndex], $ClanString) Then
DonateTroopType($iTroopIndex)
If _Sleep($DELAYDONATECC3) Then ExitLoop
EndIf
EndIf
Next
EndIf
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get Donated troops in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
EndIf
If $bDonateSpell And Not $g_bSkipDonSpells Then
If $g_bDebugSetlog Then SetDebugLog("Spell checkpoint.", $COLOR_DEBUG)
For $i = 0 To UBound($g_aiDonateSpellPriority) - 1
Local $iSpellIndex = $g_aiDonateSpellPriority[$i]
If $g_abChkDonateSpell[$iSpellIndex] Then
If CheckDonateSpell($iSpellIndex, $g_asTxtDonateSpell[$iSpellIndex], $g_asTxtBlacklistSpell[$iSpellIndex], $ClanString) Then
DonateSpellType($iSpellIndex)
If _Sleep($DELAYDONATECC3) Then ExitLoop
EndIf
EndIf
Next
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get Donated Spells in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
EndIf
EndIf
If $bDonateAllTroop Or $bDonateAllSpell Then
If $g_bDebugSetlog Then SetDebugLog("Troop/Spell All checkpoint.", $COLOR_DEBUG)
$g_bDonateAllRespectBlk = True
If $bDonateAllTroop And Not $g_bSkipDonTroops Then
DonateWindowCap($g_bSkipDonTroops, $g_bSkipDonSpells)
$iBenchmark = TimerDiff($itime)
Setlog("Get available donate cap (to all) in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
If $g_bSkipDonTroops And $g_bSkipDonSpells Then
DonateWindow($bClose)
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
If _Sleep($DELAYDONATECC2) Then ExitLoop
ContinueLoop
EndIf
If $g_bDebugSetlog Then SetDebugLog("Troop All checkpoint.", $COLOR_DEBUG)
For $x = 0 To 4
If $x <> 4 Then
If $g_abChkDonateAllTroop[$eCustom[$x]] Then
Local $CorrectDonateCustom = $eDonateCustom[$x]
For $i = 0 To 2
If $CorrectDonateCustom[$i][0] < $eBarb Then
$CorrectDonateCustom[$i][0] = $eArch
ElseIf $CorrectDonateCustom[$i][0] > $eBowl Then
DonateWindow($bClose)
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
If _Sleep($DELAYDONATECC2) Then ExitLoop
ContinueLoop
EndIf
If $CorrectDonateCustom[$i][1] < 1 Then
DonateWindow($bClose)
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
If _Sleep($DELAYDONATECC2) Then ExitLoop
ContinueLoop
ElseIf $CorrectDonateCustom[$i][1] > 8 Then
$CorrectDonateCustom[$i][1] = 8
EndIf
DonateTroopType($CorrectDonateCustom[$i][0], $CorrectDonateCustom[$i][1], $g_abChkDonateAllTroop[$eCustom[$x]], $bDonateAllTroop)
Next
EndIf
Else
For $i = 0 To UBound($g_aiDonateTroopPriority) - 1
Local $iTroopIndex = $g_aiDonateTroopPriority[$i]
If $g_abChkDonateAllTroop[$iTroopIndex] Then
If CheckDonateTroop($iTroopIndex, $g_asTxtDonateTroop[$iTroopIndex], $g_asTxtBlacklistTroop[$iTroopIndex], $ClanString) Then
DonateTroopType($iTroopIndex, 0, False, $bDonateAllTroop)
EndIf
ExitLoop
EndIf
Next
EndIf
Next
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get Donated troops (to all) in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
EndIf
If $bDonateAllSpell And Not $g_bSkipDonSpells Then
If $g_bDebugSetlog Then SetDebugLog("Spell All checkpoint.", $COLOR_DEBUG)
For $i = 0 To UBound($g_aiDonateSpellPriority) - 1
Local $iSpellIndex = $g_aiDonateSpellPriority[$i]
If $g_abChkDonateAllSpell[$iSpellIndex] Then
If CheckDonateSpell($iSpellIndex, $g_asTxtDonateSpell[$iSpellIndex], $g_asTxtBlacklistSpell[$iSpellIndex], $ClanString) Then
DonateSpellType($iSpellIndex, 0, False, $bDonateAllSpell)
EndIf
ExitLoop
EndIf
Next
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get Donated Spells (to all)  in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
EndIf
$g_bDonateAllRespectBlk = False
EndIf
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
ClickP($aAway, 1, 0, "#0171")
If _Sleep($DELAYDONATEWINDOW1) Then ExitLoop
EndIf
ForceCaptureRegion()
$g_aiDonatePixel = _MultiPixelSearch(200, $y, 230, 660 + $g_iBottomOffsetY, -2, 1, Hex(0x6da725, 6), $aChatDonateBtnColors, 20)
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get more donate buttons in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
If IsArray($g_aiDonatePixel) Then
If $g_bDebugSetlog Then SetDebugLog("More Donate buttons found, new $g_aiDonatePixel: (" & $g_aiDonatePixel[0] & "," & $g_aiDonatePixel[1] & ")", $COLOR_DEBUG)
ContinueLoop
Else
If $g_bDebugSetlog Then SetDebugLog("No more Donate buttons found, closing chat ($y=" & $y & ")", $COLOR_DEBUG)
EndIf
ForceCaptureRegion()
$Scroll = _PixelSearch(293, 687 - 30, 295, 693 - 30, Hex(0xFFFFFF, 6), 20)
If IsArray($Scroll) Then
$bDonate = True
Click($Scroll[0], $Scroll[1], 1, 0, "#0172")
$y = 600
If _Sleep($DELAYDONATECC2) Then ExitLoop
ContinueLoop
EndIf
$bDonate = False
WEnd
ClickP($aAway, 1, 0, "#0176")
If _Sleep($DELAYDONATECC2) Then Return
$i = 0
While 1
If _Sleep(100) Then Return
If _ColorCheck(_GetPixelColor($aCloseChat[0], $aCloseChat[1], True), Hex($aCloseChat[2], 6), $aCloseChat[3]) Then
Click($aCloseChat[0], $aCloseChat[1], 1, 0, "#0173")
ExitLoop
Else
If _Sleep(100) Then Return
$i += 1
If $i > 30 Then
SetLog("Error finding Clan Tab to close...", $COLOR_ERROR)
AndroidPageError("DonateCC")
ExitLoop
EndIf
EndIf
WEnd
UpdateStats()
If _Sleep($DELAYDONATECC2) Then Return
EndFunc
Func CheckDonateTroop(Const $iTroopIndex, Const $sDonateTroopString, Const $sBlacklistTroopString, Const $sClanString)
Local $sName =($iTroopIndex = 99 ? "Custom" : $g_asTroopNames[$iTroopIndex])
Return CheckDonate($sName, $sDonateTroopString, $sBlacklistTroopString, $sClanString)
EndFunc
Func CheckDonateSpell(Const $iSpellIndex, Const $sDonateSpellString, Const $sBlacklistSpellString, Const $sClanString)
Local $sName = $g_asSpellNames[$iSpellIndex]
Return CheckDonate($sName, $sDonateSpellString, $sBlacklistSpellString, $sClanString)
EndFunc
Func CheckDonate(Const $sName, Const $sDonateString, Const $sBlacklistString, Const $sClanString)
Local $asSplitDonate = StringSplit($sDonateString, @CRLF, $STR_ENTIRESPLIT)
Local $asSplitBlacklist = StringSplit($sBlacklistString, @CRLF, $STR_ENTIRESPLIT)
Local $asSplitGeneralBlacklist = StringSplit($g_sTxtGeneralBlacklist, @CRLF, $STR_ENTIRESPLIT)
For $i = 1 To UBound($asSplitGeneralBlacklist) - 1
If CheckDonateString($asSplitGeneralBlacklist[$i], $sClanString) Then
SetLog("General Blacklist Keyword found: " & $asSplitGeneralBlacklist[$i], $COLOR_ERROR)
Return False
EndIf
Next
For $i = 1 To UBound($asSplitBlacklist) - 1
If CheckDonateString($asSplitBlacklist[$i], $sClanString) Then
SetLog($sName & " Blacklist Keyword found: " & $asSplitBlacklist[$i], $COLOR_ERROR)
Return False
EndIf
Next
If Not $g_bDonateAllRespectBlk Then
For $i = 1 To UBound($asSplitDonate) - 1
If CheckDonateString($asSplitDonate[$i], $sClanString) Then
SetLog($sName & " Keyword found: " & $asSplitDonate[$i], $COLOR_SUCCESS)
Return True
EndIf
Next
EndIf
If $g_bDonateAllRespectBlk Then Return True
If $g_bDebugSetlog Then SetDebugLog("Bad call of CheckDonateTroop: " & $sName, $COLOR_DEBUG)
Return False
EndFunc
Func CheckDonateString($String, $ClanString)
Local $Contains = StringMid($String, 1, 1) & StringMid($String, StringLen($String), 1)
If $Contains = "[]" Then
If $ClanString = StringMid($String, 2, StringLen($String) - 2) Then
Return True
Else
Return False
EndIf
Else
If StringInStr($ClanString, $String, 2) Then
Return True
Else
Return False
EndIf
EndIf
EndFunc
Func DonateTroopType(Const $iTroopIndex, $Quant = 0, Const $Custom = False, Const $bDonateAll = False)
Local $Slot = -1, $detectedSlot = -1
Local $YComp = 0, $donaterow = -1
Local $donateposinrow = -1
Local $sTextToAll = ""
If $g_iTotalDonateTroopCapacity = 0 Then Return
If $g_bDebugSetlog Then SetDebugLog("$DonateTroopType Start: " & $g_asTroopNames[$iTroopIndex], $COLOR_DEBUG)
$g_iDonTroopsQuantityAv = Floor($g_iTotalDonateTroopCapacity / $g_aiTroopSpace[$iTroopIndex])
If $g_iDonTroopsQuantityAv < 1 Then
SetLog("Sorry Chief! " & $g_asTroopNamesPlural[$iTroopIndex] & " don't fit in the remaining space!")
Return
EndIf
If $g_iDonTroopsQuantityAv >= $g_iDonTroopsLimit Then
$g_iDonTroopsQuantity = $g_iDonTroopsLimit
Else
$g_iDonTroopsQuantity = $g_iDonTroopsQuantityAv
EndIf
If $g_bDebugOCRdonate Then
Local $oldDebugOcr = $g_bDebugOcr
$g_bDebugOcr = True
EndIf
$Slot = DetectSlotTroop($iTroopIndex)
$detectedSlot = $Slot
If $g_bDebugOCRdonate Then $g_bDebugOcr = $oldDebugOcr
If $Slot = -1 Then Return
If $Slot < 0 Or $Slot > 11 Then
SetLog("Invalid slot # found = " & $Slot & " for " & $g_asTroopNames[$iTroopIndex], $COLOR_ERROR)
Return
EndIf
If $g_bDebugSetlog Then SetDebugLog("slot found = " & $Slot & ", " & $g_asTroopNames[$iTroopIndex], $COLOR_DEBUG)
$donaterow = 1
$donateposinrow = $Slot
If $Slot >= 6 And $Slot <= 11 Then
$donaterow = 2
$Slot = $Slot - 6
$donateposinrow = $Slot
$YComp = 88
EndIf
SetLog("Troops Condition Matched", $COLOR_ORANGE)
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $g_iDonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $g_iDonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $g_iDonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
If $Custom Then
If $bDonateAll Then $sTextToAll = " (to all requests)"
SetLog("Donating " & $Quant & " " &($Quant > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex]) & $sTextToAll, $COLOR_SUCCESS)
If $g_bDebugOCRdonate Then
SetLog("donate", $COLOR_ERROR)
SetLog("row: " & $donaterow, $COLOR_ERROR)
SetLog("pos in row: " & $donateposinrow, $COLOR_ERROR)
SetLog("coordinate: " & 365 +($Slot * 68) & "," & $g_iDonationWindowY + 100 + $YComp, $COLOR_ERROR)
debugimagesave("LiveDonateCC-r" & $donaterow & "-c" & $donateposinrow & "-" & $g_asTroopNames[$iTroopIndex] & "_")
EndIf
If $g_bQuickTrainEnable Then
Local $icount = 0
For $x = 0 To $Quant
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $g_iDonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $g_iDonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $g_iDonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
Click(365 +($Slot * 68), $g_iDonationWindowY + 100 + $YComp, 1, $DELAYDONATECC3, "#0175")
If $g_iCommandStop = 3 Then
$g_iCommandStop = 0
$g_bFullArmy = False
EndIf
If _Sleep(1000) Then Return
$icount += 1
EndIf
Next
$Quant = $icount
$g_aiDonateStatsTroops[$iTroopIndex][0] += $Quant
Else
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $g_iDonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $g_iDonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $g_iDonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
Click(365 +($Slot * 68), $g_iDonationWindowY + 100 + $YComp, $Quant, $DELAYDONATECC3, "#0175")
$g_aiDonateStatsTroops[$iTroopIndex][0] += $Quant
If $g_iCommandStop = 3 Then
$g_iCommandStop = 0
$g_bFullArmy = False
EndIf
EndIf
EndIf
If $iTroopIndex >= $eTroopBarbarian And $iTroopIndex <= $eTroopBowler Then
$g_iTotalDonateTroopCapacity -=($Quant * $g_aiTroopSpace[$iTroopIndex])
If $g_iDonTroopsLimit = $Quant Then
$g_bSkipDonTroops = True
EndIf
EndIf
Else
If $g_bDebugOCRdonate Then
SetLog("donate", $COLOR_ERROR)
SetLog("row: " & $donaterow, $COLOR_ERROR)
SetLog("pos in row: " & $donateposinrow, $COLOR_ERROR)
SetLog("coordinate: " & 365 +($Slot * 68) & "," & $g_iDonationWindowY + 100 + $YComp, $COLOR_ERROR)
debugimagesave("LiveDonateCC-r" & $donaterow & "-c" & $donateposinrow & "-" & $g_asTroopNames[$iTroopIndex] & "_")
EndIf
If $g_bQuickTrainEnable = True Then
Local $icount = 0
For $x = 0 To $g_iDonTroopsQuantity
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $g_iDonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $g_iDonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $g_iDonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
Click(365 +($Slot * 68), $g_iDonationWindowY + 100 + $YComp, 1, $DELAYDONATECC3, "#0175")
$icount += 1
If $g_iCommandStop = 3 Then
$g_iCommandStop = 0
$g_bFullArmy = False
EndIf
If _Sleep(1000) Then Return
EndIf
Next
$g_iDonTroopsQuantity = $icount
$g_aiDonateStatsTroops[$iTroopIndex][0] += $g_iDonTroopsQuantity
Else
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $g_iDonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $g_iDonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $g_iDonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
Click(365 +($Slot * 68), $g_iDonationWindowY + 100 + $YComp, $g_iDonTroopsQuantity, $DELAYDONATECC3, "#0175")
$g_aiDonateStatsTroops[$iTroopIndex][0] += $g_iDonTroopsQuantity
If $g_iCommandStop = 3 Then
$g_iCommandStop = 0
$g_bFullArmy = False
EndIf
EndIf
EndIf
If $bDonateAll Then $sTextToAll = " (to all requests)"
SetLog("Donating " & $g_iDonTroopsQuantity & " " &($g_iDonTroopsQuantity > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex]) & $sTextToAll, $COLOR_GREEN)
If $iTroopIndex >= $eTroopBarbarian And $iTroopIndex <= $eTroopBowler Then
$g_iTotalDonateTroopCapacity -=($g_iDonTroopsQuantity * $g_aiTroopSpace[$iTroopIndex])
If $g_iDonTroopsLimit = $g_iDonTroopsQuantity Then
$g_bSkipDonTroops = True
EndIf
EndIf
EndIf
If $Custom Then
$g_aiDonateTroops[$iTroopIndex] += $Quant
Else
$g_aiDonateTroops[$iTroopIndex] += $g_iDonTroopsQuantity
EndIf
ElseIf $g_aiDonatePixel[1] - 5 + $YComp > 675 Then
SetLog("Unable to donate " & $g_asTroopNames[$iTroopIndex] & ". Donate screen not visible, will retry next run.", $COLOR_ERROR)
Else
SetLog("No " & $g_asTroopNames[$iTroopIndex] & " available to donate..", $COLOR_ERROR)
EndIf
EndFunc
Func DonateSpellType(Const $iSpellIndex, $Quant = 0, Const $Custom = False, Const $bDonateAll = False)
Local $Slot = -1, $detectedSlot = -1
Local $YComp = 0, $donaterow = -1
Local $donateposinrow = -1
If $g_iTotalDonateSpellCapacity = 0 Then Return
If $g_bDebugSetlog Then SetDebugLog("DonateSpellType Start: " & $g_asSpellNames[$iSpellIndex], $COLOR_DEBUG)
$g_iDonSpellsQuantityAv = Floor($g_iTotalDonateSpellCapacity / $g_aiSpellSpace[$iSpellIndex])
If $g_iDonSpellsQuantityAv < 1 Then
SetLog("Sorry Chief! " & $g_asSpellNames[$iSpellIndex] & " spells don't fit in the remaining space!")
Return
EndIf
If $g_iDonSpellsQuantityAv >= $iDonSpellsLimit Then
$g_iDonSpellsQuantity = $iDonSpellsLimit
Else
$g_iDonSpellsQuantity = $g_iDonSpellsQuantityAv
EndIf
If $g_bDebugOCRdonate Then
Local $oldDebugOcr = $g_bDebugOcr
$g_bDebugOcr = True
EndIf
$Slot = DetectSlotSpell($iSpellIndex)
$detectedSlot = $Slot
If $g_bDebugSetlog Then SetDebugLog("slot found = " & $Slot, $COLOR_DEBUG)
If $g_bDebugOCRdonate Then $g_bDebugOcr = $oldDebugOcr
If $Slot = -1 Then Return
If $Slot < 12 Or $Slot > 17 Then
SetLog("Invalid slot # found = " & $Slot & " for " & $g_asSpellNames[$iSpellIndex], $COLOR_ERROR)
Return
EndIf
$donaterow = 3
$Slot = $Slot - 12
$donateposinrow = $Slot
$YComp = 203
SetLog("Spells Condition Matched", $COLOR_ORANGE)
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $g_iDonationWindowY + 105 + $YComp, True), Hex(0x6038B0, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $g_iDonationWindowY + 106 + $YComp, True), Hex(0x6038B0, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $g_iDonationWindowY + 107 + $YComp, True), Hex(0x6038B0, 6), 20) Then
If $g_bDebugOCRdonate Then
SetLog("donate", $COLOR_ERROR)
SetLog("row: " & $donaterow, $COLOR_ERROR)
SetLog("pos in row: " & $donateposinrow, $COLOR_ERROR)
SetLog("coordinate: " & 365 +($Slot * 68) & "," & $g_iDonationWindowY + 100 + $YComp, $COLOR_ERROR)
debugimagesave("LiveDonateCC-r" & $donaterow & "-c" & $donateposinrow & "-" & $g_asSpellNames[$iSpellIndex] & "_")
EndIf
If Not $g_bDebugOCRdonate Then
Click(365 +($Slot * 68), $g_iDonationWindowY + 100 + $YComp, $g_iDonSpellsQuantity, $DELAYDONATECC3, "#0600")
$g_bFullArmySpells = False
$g_bFullArmy = False
$g_aiDonateSpells[$iSpellIndex] += 1
If $g_iCommandStop = 3 Then
$g_iCommandStop = 0
$g_bFullArmySpells = False
EndIf
$g_aiDonateStatsSpells[$iSpellIndex][0] += $g_iDonSpellsQuantity
EndIf
ElseIf $g_aiDonatePixel[1] - 5 + $YComp > 675 Then
SetLog("Unable to donate " & $g_asSpellNames[$iSpellIndex] & ". Donate screen not visible, will retry next run.", $COLOR_ERROR)
Else
SetLog("No " & $g_asSpellNames[$iSpellIndex] & " available to donate..", $COLOR_ERROR)
EndIf
EndFunc
Func DonateWindow($bOpen = True)
If $g_bDebugSetlog And $bOpen Then SetLog("DonateWindow Open Start", $COLOR_DEBUG)
If $g_bDebugSetlog And Not $bOpen Then SetLog("DonateWindow Close Start", $COLOR_DEBUG)
If Not $bOpen Then
ClickP($aAway, 1, 0, "#0176")
If _Sleep($DELAYDONATEWINDOW1) Then Return
If $g_bDebugSetlog Then SetDebugLog("DonateWindow Close Exit", $COLOR_DEBUG)
Return
EndIf
Local $iLeft = 0, $iTop = 0, $iRight = 0, $iBottom = 0, $i
For $i = 0 To UBound($aChatDonateBtnColors) - 1
If $aChatDonateBtnColors[$i][1] < $iLeft Then $iLeft = $aChatDonateBtnColors[$i][1]
If $aChatDonateBtnColors[$i][1] > $iRight Then $iRight = $aChatDonateBtnColors[$i][1]
If $aChatDonateBtnColors[$i][2] < $iTop Then $iTop = $aChatDonateBtnColors[$i][2]
If $aChatDonateBtnColors[$i][2] > $iBottom Then $iBottom = $aChatDonateBtnColors[$i][2]
Next
$iLeft += $g_aiDonatePixel[0]
$iTop += $g_aiDonatePixel[1]
$iRight += $g_aiDonatePixel[0] + 1
$iBottom += $g_aiDonatePixel[1] + 1
ForceCaptureRegion()
Local $g_aiDonatePixelCheck = _MultiPixelSearch($iLeft, $iTop, $iRight, $iBottom, -2, 1, Hex(0x6da725, 6), $aChatDonateBtnColors, 20)
If IsArray($g_aiDonatePixelCheck) Then
Click($g_aiDonatePixel[0] + 50, $g_aiDonatePixel[1] + 10, 1, 0, "#0174")
Else
If $g_bDebugSetlog Then SetDebugLog("Could not find the Donate Button!", $COLOR_DEBUG)
Return False
EndIf
If _Sleep($DELAYDONATEWINDOW1) Then Return
Local $icount = 0
While Not(_ColorCheck(_GetPixelColor(331, $g_aiDonatePixel[1], True, "DonateWindow"), Hex(0xffffff, 6), 0))
If _Sleep($DELAYDONATEWINDOW2) Then Return
ForceCaptureRegion()
$icount += 1
If $icount = 20 Then ExitLoop
WEnd
$g_iDonationWindowY = 0
ForceCaptureRegion()
Local $aDonWinOffColors[1][3] = [[0xFFFFFF, 0, 2]]
Local $aDonationWindow = _MultiPixelSearch(628, 0, 630, $g_iDEFAULT_HEIGHT, 1, 1, Hex(0xFFFFFF, 6), $aDonWinOffColors, 10)
If IsArray($aDonationWindow) Then
$g_iDonationWindowY = $aDonationWindow[1]
If $g_bDebugSetlog Then SetDebugLog("$g_iDonationWindowY: " & $g_iDonationWindowY, $COLOR_DEBUG)
Else
SetLog("Could not find the Donate Window!", $COLOR_ERROR)
Return False
EndIf
If $g_bDebugSetlog Then SetDebugLog("DonateWindow Open Exit", $COLOR_DEBUG)
Return True
EndFunc
Func DonateWindowCap(ByRef $g_bSkipDonTroops, ByRef $g_bSkipDonSpells)
If $g_bDebugSetlog Then SetDebugLog("DonateCapWindow Start", $COLOR_DEBUG)
If Not $g_bSkipDonTroops Then
Local $sReadCCTroopsCap = getCastleDonateCap(427, $g_iDonationWindowY + 12)
If $g_bDebugSetlog Then SetDebugLog("$sReadCCTroopsCap: " & $sReadCCTroopsCap, $COLOR_DEBUG)
Local $aTempReadCCTroopsCap = StringSplit($sReadCCTroopsCap, "#")
If $aTempReadCCTroopsCap[0] >= 2 Then
If $g_bDebugSetlog Then SetDebugLog("$aTempReadCCTroopsCap splitted :" & $aTempReadCCTroopsCap[1] & "/" & $aTempReadCCTroopsCap[2], $COLOR_DEBUG)
If $aTempReadCCTroopsCap[2] > 0 Then
$g_iDonTroopsAv = $aTempReadCCTroopsCap[1]
$g_iDonTroopsLimit = $aTempReadCCTroopsCap[2]
EndIf
Else
SetLog("Error reading the Castle Troop Capacity", $COLOR_ERROR)
$g_iDonTroopsAv = 0
$g_iDonTroopsLimit = 0
EndIf
EndIf
If Not $g_bSkipDonSpells Then
Local $sReadCCSpellsCap = getCastleDonateCap(420, $g_iDonationWindowY + 218)
If $g_bDebugSetlog Then SetDebugLog("$sReadCCSpellsCap: " & $sReadCCSpellsCap, $COLOR_DEBUG)
Local $aTempReadCCSpellsCap = StringSplit($sReadCCSpellsCap, "#")
If $aTempReadCCSpellsCap[0] >= 2 Then
If $g_bDebugSetlog Then SetDebugLog("$aTempReadCCSpellsCap splitted :" & $aTempReadCCSpellsCap[1] & "/" & $aTempReadCCSpellsCap[2], $COLOR_DEBUG)
If $aTempReadCCSpellsCap[2] > 0 Then
$g_iDonSpellsAv = $aTempReadCCSpellsCap[1]
$iDonSpellsLimit = $aTempReadCCSpellsCap[2]
EndIf
Else
SetLog("Are you able to donate Spells? ", $COLOR_ERROR)
$g_iDonSpellsAv = 0
$iDonSpellsLimit = 0
EndIf
EndIf
If $g_iDonTroopsAv = $g_iDonTroopsLimit Then
$g_bSkipDonTroops = True
SetLog("Donate Troop Limit Reached")
EndIf
If $g_iDonSpellsAv = $iDonSpellsLimit Then
$g_bSkipDonSpells = True
SetLog("Donate Spell Limit Reached")
EndIf
If $g_bSkipDonTroops = True And $g_bSkipDonSpells = True And $g_iDonTroopsAv < $g_iDonTroopsLimit And $g_iDonSpellsAv < $iDonSpellsLimit Then
SetLog("Donate Troops: " & $g_iDonTroopsAv & "/" & $g_iDonTroopsLimit & ", Spells: " & $g_iDonSpellsAv & "/" & $iDonSpellsLimit)
EndIf
If Not $g_bSkipDonSpells And $g_iDonTroopsAv < $g_iDonTroopsLimit And $g_iDonSpellsAv = $iDonSpellsLimit Then SetLog("Donate Troops: " & $g_iDonTroopsAv & "/" & $g_iDonTroopsLimit)
If Not $g_bSkipDonTroops And $g_iDonTroopsAv = $g_iDonTroopsLimit And $g_iDonSpellsAv < $iDonSpellsLimit Then SetLog("Donate Spells: " & $g_iDonSpellsAv & "/" & $iDonSpellsLimit)
If $g_bDebugSetlog Then
SetDebugLog("$g_bSkipDonTroops: " & $g_bSkipDonTroops, $COLOR_DEBUG)
SetDebugLog("$g_bSkipDonSpells: " & $g_bSkipDonSpells, $COLOR_DEBUG)
SetDebugLog("DonateCapWindow End", $COLOR_DEBUG)
EndIf
EndFunc
Func RemainingCCcapacity()
Local $sCapTroops = "", $aTempCapTroops, $sCapSpells = "", $aTempCapSpells, $sCapSiegeMachine = "", $aTempCapSiegeMachine
Local $iDonatedTroops = 0, $iDonatedSpells = 0, $iDonatedSiegeMachine = 0
Local $iCapTroopsTotal = 0, $iCapSpellsTotal = 0, $iCapSiegeMachineTotal = 0
$g_iTotalDonateTroopCapacity = -1
$g_iTotalDonateSpellCapacity = -1
If $g_bDebugSetLog Then SetDebugLog("Start dual getOcrSpaceCastleDonate", $COLOR_DEBUG)
$sCapTroops = getOcrSpaceCastleDonate(27, $g_aiDonatePixel[1])
If StringInStr($sCapTroops, "#") Then
$sCapSpells = getOcrSpaceCastleDonate(110, $g_aiDonatePixel[1])
$sCapSiegeMachine = getOcrSpaceCastleDonate(170, $g_aiDonatePixel[1])
Else
$sCapTroops = getOcrSpaceCastleDonate(60, $g_aiDonatePixel[1])
If StringRegExp($sCapTroops, "#([0-9]{2})") = 1 Then
$sCapSpells = getOcrSpaceCastleDonate(160, $g_aiDonatePixel[1])
$sCapSiegeMachine = -1
Else
$sCapTroops = getOcrSpaceCastleDonate(82, $g_aiDonatePixel[1])
$sCapSpells = -1
$sCapSiegeMachine = -1
EndIf
EndIf
If $g_bDebugSetLog Then
SetDebugLog("$sCapTroops :" & $sCapTroops, $COLOR_DEBUG)
SetDebugLog("$sCapSpells :" & $sCapSpells, $COLOR_DEBUG)
SetDebugLog("$sCapSiegeMachine :" & $sCapSiegeMachine, $COLOR_DEBUG)
EndIf
If $sCapTroops <> "" And StringInStr($sCapTroops, "#") Then
$aTempCapTroops = StringSplit($sCapTroops, "#")
If $aTempCapTroops[0] >= 2 Then
If $g_bDebugSetlog Then SetDebugLog("$aTempCapTroops splitted :" & $aTempCapTroops[1] & "/" & $aTempCapTroops[2], $COLOR_DEBUG)
If $aTempCapTroops[2] > 0 Then
$iDonatedTroops = $aTempCapTroops[1]
$iCapTroopsTotal = $aTempCapTroops[2]
If $iCapTroopsTotal = 0 Then
$iCapTroopsTotal = 30
EndIf
If $iCapTroopsTotal = 5 Then
$iCapTroopsTotal = 35
EndIf
EndIf
Else
SetLog("Error reading the Castle Troop Capacity[1]...", $COLOR_ERROR)
$iDonatedTroops = 0
$iCapTroopsTotal = 0
EndIf
Else
SetLog("Error reading the Castle Troop Capacity[2]...", $COLOR_ERROR)
$iDonatedTroops = 0
$iCapTroopsTotal = 0
EndIf
If $sCapSpells <> -1 Then
If $sCapSpells <> "" Then
$aTempCapSpells = StringSplit($sCapSpells, "#")
If $aTempCapSpells[0] >= 2 Then
If $g_bDebugSetlog Then SetDebugLog("$aTempCapSpells splitted :" & $aTempCapSpells[1] & "/" & $aTempCapSpells[2], $COLOR_DEBUG)
If $aTempCapSpells[2] > 0 Then
$iDonatedSpells = $aTempCapSpells[1]
$iCapSpellsTotal = $aTempCapSpells[2]
EndIf
Else
SetLog("Error reading the Castle Spell Capacity[1]...", $COLOR_ERROR)
$iDonatedSpells = 0
$iCapSpellsTotal = 0
EndIf
Else
SetLog("Error reading the Castle Spell Capacity[2]...", $COLOR_ERROR)
$iDonatedSpells = 0
$iCapSpellsTotal = 0
EndIf
EndIf
If $sCapSiegeMachine <> -1 Then
If $sCapSiegeMachine <> "" Then
$aTempCapSiegeMachine = StringSplit($sCapSiegeMachine, "#")
If $aTempCapSiegeMachine[0] >= 2 Then
If $g_bDebugSetlog Then SetDebugLog("$aTempCapSiegeMachine splitted :" & $aTempCapSiegeMachine[1] & "/" & $aTempCapSiegeMachine[2], $COLOR_DEBUG)
If $aTempCapSiegeMachine[2] > 0 Then
$iDonatedSiegeMachine = $aTempCapSiegeMachine[1]
$iCapSiegeMachineTotal = $aTempCapSiegeMachine[2]
EndIf
Else
SetLog("Error reading the Castle Siege Machine Capacity[1]...", $COLOR_ERROR)
$iDonatedSiegeMachine = 0
$iCapSiegeMachineTotal = 0
EndIf
Else
SetLog("Error reading the Castle Siege Machine Capacity[2]...", $COLOR_ERROR)
$iDonatedSiegeMachine = 0
$iCapSiegeMachineTotal = 0
EndIf
EndIf
$g_iTotalDonateTroopCapacity =($iCapTroopsTotal - $iDonatedTroops)
If $sCapSpells <> -1 Then $g_iTotalDonateSpellCapacity =($iCapSpellsTotal - $iDonatedSpells)
If $sCapSiegeMachine <> -1 Then $g_iTotalDonateSiegeMachineCapacity =($iCapSiegeMachineTotal - $iDonatedSiegeMachine)
If $g_iTotalDonateTroopCapacity < 0 Then
SetLog("Unable to read Clan Castle Capacity!", $COLOR_ERROR)
Else
Local $sSpellText = $sCapSpells <> -1 ? ", Spells: " & $iDonatedSpells & "/" & $iCapSpellsTotal : ""
Local $sSiegeMachineText = $sCapSiegeMachine <> -1 ? ", Siege Machine: " & $iDonatedSiegeMachine & "/" & $iCapSiegeMachineTotal : ""
SetLog("Chat Troops: " & $iDonatedTroops & "/" & $iCapTroopsTotal & $sSpellText & $sSiegeMachineText)
EndIf
EndFunc
Func DetectSlotTroop(Const $iTroopIndex)
Local $FullTemp
For $Slot = 0 To 5
Local $x = 343 +(68 * $Slot)
Local $y = $g_iDonationWindowY + 37
Local $x1 = $x + 75
Local $y1 = $y + 43
$FullTemp = SearchImgloc($g_sImgDonateTroops, $x, $y, $x1, $y1)
If $g_bDebugSetlog Then SetDebugLog("Troop Slot: " & $Slot & " SearchImgloc returned:" & $FullTemp[0] & ".", $COLOR_DEBUG)
If StringInStr($FullTemp[0] & " ", "empty") > 0 Then ExitLoop
If $FullTemp[0] <> "" Then
Local $iFoundTroopIndex = TroopIndexLookup($FullTemp[0])
For $i = $eTroopBarbarian To $eTroopBowler
If $iFoundTroopIndex = $i Then
If $g_bDebugSetlog Then SetDebugLog("Detected " & $g_asTroopNames[$i], $COLOR_DEBUG)
If $iTroopIndex = $i Then Return $Slot
ExitLoop
EndIf
If $i = $eTroopBowler Then
If $g_bDebugSetlog Then SetDebugLog("Slot: " & $Slot & "Troop Detection Failed", $COLOR_DEBUG)
EndIf
Next
EndIf
Next
For $Slot = 6 To 11
Local $x = 343 +(68 *($Slot - 6))
Local $y = $g_iDonationWindowY + 124
Local $x1 = $x + 75
Local $y1 = $y + 43
$FullTemp = SearchImgloc($g_sImgDonateTroops, $x, $y, $x1, $y1)
If $g_bDebugSetlog Then SetDebugLog("Troop Slot: " & $Slot & " SearchImgloc returned:" & $FullTemp[0] & ".", $COLOR_DEBUG)
If StringInStr($FullTemp[0] & " ", "empty") > 0 Then ExitLoop
If $FullTemp[0] <> "" Then
For $i = $eTroopBalloon To $eTroopBowler
Local $iFoundTroopIndex = TroopIndexLookup($FullTemp[0])
If $iFoundTroopIndex = $i Then
If $g_bDebugSetlog Then SetDebugLog("Detected " & $g_asTroopNames[$i], $COLOR_DEBUG)
If $iTroopIndex = $i Then Return $Slot
ExitLoop
EndIf
If $i = $eTroopBowler Then
If $g_bDebugSetlog Then SetDebugLog("Slot: " & $Slot & "Troop Detection Failed", $COLOR_DEBUG)
EndIf
Next
EndIf
Next
Return -1
EndFunc
Func DetectSlotSpell(Const $iSpellIndex)
Local $FullTemp
For $Slot = 12 To 17
Local $x = 343 +(68 *($Slot - 12))
Local $y = $g_iDonationWindowY + 241
Local $x1 = $x + 75
Local $y1 = $y + 43
$FullTemp = SearchImgloc($g_sImgDonateSpells, $x, $y, $x1, $y1)
If $g_bDebugSetlog Then SetDebugLog("Spell Slot: " & $Slot & " SearchImgloc returned:" & $FullTemp[0] & ".", $COLOR_DEBUG)
If StringInStr($FullTemp[0] & " ", "empty") > 0 Then ExitLoop
If $FullTemp[0] <> "" Then
For $i = $eSpellLightning To $eSpellSkeleton
Local $sTmp = StringLeft($g_asSpellNames[$i], 4)
If StringInStr($FullTemp[0] & " ", $sTmp) > 0 Then
If $g_bDebugSetlog Then SetDebugLog("Detected " & $g_asSpellNames[$i], $COLOR_DEBUG)
If $iSpellIndex = $i Then Return $Slot
ExitLoop
EndIf
If $i = $eSpellSkeleton Then
If $g_bDebugSetlog Then SetDebugLog("Slot: " & $Slot & "Spell Detection Failed", $COLOR_DEBUG)
EndIf
Next
EndIf
Next
Return -1
EndFunc
Func SkipDonateNearFullTroops($bSetLog = False, $aHeroResult = Default)
If Not $g_bDonationEnabled Then Return True
If Not $g_bDonateSkipNearFullEnable Then Return False
If $g_iCommandStop = 0 And $g_bTrainEnabled Then Return False
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If Not $g_abDonateHours[$hour[0]] And $g_bDonateHoursEnable Then Return True
If $g_bDonateSkipNearFullEnable Then
If $g_iArmyCapacity > $g_iDonateSkipNearFullPercent Then
Local $rIsWaitforHeroesActive = IsWaitforHeroesActive()
If $rIsWaitforHeroesActive Then
If $aHeroResult = Default Or Not IsArray($aHeroResult) Then
If Not OpenArmyOverview(True, "SkipDonateNearFullTroops()") Then Return False
$aHeroResult = getArmyHeroTime("all")
EndIf
If @error Or UBound($aHeroResult) < 3 Then
SetLog("getArmyHeroTime return error: #" & @error & "|IA:" & IsArray($aHeroResult) & "," & UBound($aHeroResult) & ", exit SkipDonateNearFullTroops!", $COLOR_ERROR)
Return False
EndIf
If $g_bDebugSetlog Then SetDebugLog("getArmyHeroTime returned: " & $aHeroResult[0] & ":" & $aHeroResult[1] & ":" & $aHeroResult[2], $COLOR_DEBUG)
Local $iActiveHero = 0
Local $iHighestTime = -1
For $pTroopType = $eKing To $eWarden
For $pMatchMode = $DB To $g_iModeCount - 1
$iActiveHero = -1
If IsSearchModeActiveMini($pMatchMode) And IsSpecialTroopToBeUsed($pMatchMode, $pTroopType) And $g_iHeroUpgrading[$pTroopType - $eKing] <> 1 And $g_iHeroWaitAttackNoBit[$pMatchMode][$pTroopType - $eKing] = 1 Then
$iActiveHero = $pTroopType - $eKing
EndIf
If $iActiveHero <> -1 And $aHeroResult[$iActiveHero] > 0 Then
If $aHeroResult[$iActiveHero] > $iHighestTime Then
$iHighestTime = $aHeroResult[$iActiveHero]
EndIf
EndIf
Next
If _Sleep($DELAYRESPOND) Then Return
Next
If $g_bDebugSetlog Then SetDebugLog("$iHighestTime = " & $iHighestTime & "|" & String($iHighestTime > 5), $COLOR_DEBUG)
If $iHighestTime > 5 Then
If $bSetLog Then SetLog("Donations enabled, Heroes recover time is long", $COLOR_INFO)
Return False
Else
If $bSetLog Then SetLog("Donation disabled, available troops " & $g_iArmyCapacity & "%, limit " & $g_iDonateSkipNearFullPercent & "%", $COLOR_INFO)
Return True
EndIf
Else
If $bSetLog Then SetLog("Donation disabled, available troops " & $g_iArmyCapacity & "%, limit " & $g_iDonateSkipNearFullPercent & "%", $COLOR_INFO)
Return True
EndIf
Else
If $bSetLog Then SetLog("Donations enabled, available troops " & $g_iArmyCapacity & "%, limit " & $g_iDonateSkipNearFullPercent & "%", $COLOR_INFO)
Return False
EndIf
Else
Return False
EndIf
EndFunc
Func BalanceDonRec($bSetLog = False)
If Not $g_bDonationEnabled Then Return False
If Not $g_bUseCCBalanced Then Return True
If $g_iCommandStop = 0 And $g_bTrainEnabled Then Return True
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If Not $g_abDonateHours[$hour[0]] And $g_bDonateHoursEnable Then Return False
If $g_bUseCCBalanced Then
If $g_iTroopsDonated = 0 And $g_iTroopsReceived = 0 Then ProfileReport()
If Number($g_iTroopsReceived) <> 0 Then
If Number(Number($g_iTroopsDonated) / Number($g_iTroopsReceived)) >=(Number($g_iCCDonated) / Number($g_iCCReceived)) Then
If $bSetLog Then SetLog("Skipping Donation because Donate/Recieve Ratio is wrong", $COLOR_INFO)
Return False
Else
Return True
EndIf
EndIf
Else
Return True
EndIf
EndFunc
Func SearchImgloc($directory = "", $x = 0, $y = 0, $x1 = 0, $y1 = 0)
Local $aResult[1], $aCoordArray[1][2], $aCoords, $aCoordsSplit, $aValue
Local $Redlines = "FV"
_CaptureRegion2($x, $y, $x1, $y1)
Local $res = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $directory, "str", "FV", "Int", 0, "str", $Redlines, "Int", 0, "Int", 1000)
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys)]
For $i = 0 To UBound($aKeys) - 1
$aResult[$i] = RetrieveImglocProperty($aKeys[$i], "objectname")
Next
Return $aResult
EndIf
$aResult[0] = "queued"
Return $aResult
EndFunc
Func donateCCWBLUserImageCollect($x, $y)
Local $imagematch = False
_CaptureRegion2()
If $g_bDebugSetlog Then SetDebugLog("Search into whitelist...", $color_purple)
Local $xyz = _FileListToArrayRec($g_sProfileDonateCaptureWhitelistPath, "*.png", $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($xyz) > 1 Then
For $i = 1 To UBound($xyz) - 1
Local $result = FindImageInPlace("DCCWBL", $g_sProfileDonateCaptureWhitelistPath & $xyz[$i], "0," & $y - 90 & "," & $x - 30 & "," & $y, False)
If StringInStr($result, ",") > 0 Then
If $g_iCmbDonateFilter = 2 Then SetLog("WHITE LIST: image match! " & $xyz[$i], $COLOR_SUCCESS)
$imagematch = True
If $g_iCmbDonateFilter = 2 Then Return True
ExitLoop
EndIf
Next
EndIf
If $g_bDebugSetlog Then SetDebugLog("Search into blacklist...", $color_purple)
Local $xyz1 = _FileListToArrayRec($g_sProfileDonateCaptureBlacklistPath, "*.png", $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($xyz1) > 1 Then
For $i = 1 To UBound($xyz1) - 1
Local $result1 = FindImageInPlace("DCCWBL", $g_sProfileDonateCaptureBlacklistPath & $xyz1[$i], "0," & $y - 90 & "," & $x - 30 & "," & $y, False)
If StringInStr($result1, ",") > 0 Then
If $g_iCmbDonateFilter = 3 Then SetLog("BLACK LIST: image match! " & $xyz1[$i], $COLOR_SUCCESS)
$imagematch = True
If $g_iCmbDonateFilter = 3 Then Return False
ExitLoop
Else
If $g_bDebugSetlog Then SetDebugLog("Image not found", $COLOR_ERROR)
EndIf
Next
EndIf
If $imagematch = False And $g_iCmbDonateFilter > 0 Then
If $g_bDebugSetlog Then SetDebugLog("Search into images to assign...", $color_purple)
Local $xyzw = _FileListToArrayRec($g_sProfileDonateCapturePath, "*.png", $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($xyzw) > 1 Then
For $i = 1 To UBound($xyzw) - 1
Local $resultxyzw = FindImageInPlace("DCCWBL", $g_sProfileDonateCapturePath & $xyzw[$i], "0," & $y - 90 & "," & $x - 30 & "," & $y, False)
If StringInStr($resultxyzw, ",") > 0 Then
If $g_iCmbDonateFilter = 1 Or $g_bDebugSetlog Then SetLog("IMAGES TO ASSIGN: image match! " & $xyzw[$i], $COLOR_SUCCESS)
$imagematch = True
ExitLoop
EndIf
Next
EndIf
If $imagematch = False Then
If $g_bDebugSetlog Then SetDebugLog("save image in images to assign...", $color_purple)
Local $iAllFilesCount = 0
Local $res = FindImageInPlace("DCCWBL", $g_sImgChatDivider, "0," & $y - 90 & "," & $x - 30 & "," & $y, False)
If $res = "" Then
Local $reshidden = FindImageInPlace("DCCWBL", $g_sImgChatDividerHidden, "0," & $y - 90 & "," & $x - 30 & "," & $y, False)
If $reshidden = "" Then
If $g_bDebugSetlog Then SetDebugLog("No Chat divider hidden found", $COLOR_ERROR)
Else
Local $xfound = Int(StringSplit($reshidden, ",", 2)[0])
Local $yfound = Int(StringSplit($reshidden, ",", 2)[1])
If $g_bDebugSetlog Then SetDebugLog("ChatDivider hidden found (" & $xfound & "," & $yfound & ")", $COLOR_SUCCESS)
Local $oBitmap = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
Local $hClone = _GDIPlus_BitmapCloneArea($oBitmap, 31, $yfound + 14, 100, 11, $GDIP_PXF24RGB)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
$iAllFilesCount = _FileListToArrayRec($g_sProfileDonateCapturePath, "*", 1, 0, 0, 0)
If IsArray($iAllFilesCount) Then
$iAllFilesCount = $iAllFilesCount[0]
Else
$iAllFilesCount = 0
EndIf
Local $filename = String("ClanMate-" & $Date & "_" & Number($iAllFilesCount) + 1 & "_98.png")
_GDIPlus_ImageSaveToFile($hClone, $g_sProfileDonateCapturePath & $filename)
If $g_iCmbDonateFilter = 1 Then SetLog("Clan Mate image Stored: " & $filename, $COLOR_SUCCESS)
_GDIPlus_BitmapDispose($hClone)
_GDIPlus_BitmapDispose($oBitmap)
EndIf
Else
Local $xfound = Int(StringSplit($res, ",", 2)[0])
Local $yfound = Int(StringSplit($res, ",", 2)[1])
If $g_bDebugSetlog Then SetDebugLog("ChatDivider found (" & $xfound & "," & $yfound & ")", $COLOR_SUCCESS)
Local $oBitmap = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
Local $hClone = _GDIPlus_BitmapCloneArea($oBitmap, 31, $yfound + 14, 100, 11, $GDIP_PXF24RGB)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
$iAllFilesCount = _FileListToArrayRec($g_sProfileDonateCapturePath, "*", 1, 0, 0, 0)
If IsArray($iAllFilesCount) Then
$iAllFilesCount = $iAllFilesCount[0]
Else
$iAllFilesCount = 0
EndIf
Local $filename = String("ClanMate--" & $Date & "_" & Number($iAllFilesCount) + 1 & "_98.png")
_GDIPlus_ImageSaveToFile($hClone, $g_sProfileDonateCapturePath & $filename)
_GDIPlus_BitmapDispose($hClone)
_GDIPlus_BitmapDispose($oBitmap)
If $g_iCmbDonateFilter = 1 Then SetLog("IMAGES TO ASSIGN: stored!", $COLOR_SUCCESS)
Deletefiles($g_sProfileDonateCapturePath, "*.png", 2, 0)
EndIf
EndIf
EndIf
If $g_iCmbDonateFilter <= 1 Then
Return True
ElseIf $g_iCmbDonateFilter = 3 Then
Return True
Else
Return False
EndIf
EndFunc
Func DropTrophy()
If $g_bDropTrophyEnable Then
SetDebugLog("Drop Trophy()", $COLOR_DEBUG)
If $g_bDebugDeadBaseImage Then
DirCreate($g_sProfileTempDebugPath & "\SkippedZombies\")
DirCreate($g_sProfileTempDebugPath & "\Zombies\")
setZombie()
EndIf
For $i = 0 to 5
$g_aiCurrentLoot[$eLootTrophy] = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
SetDebugLog("Current Trophy Count: " & $g_aiCurrentLoot[$eLootTrophy], $COLOR_DEBUG)
If $g_aiCurrentLoot[$eLootTrophy] <> "" then ExitLoop
If _Sleep(1000) then return
ClickP($aAway, 1, 0, "#0000")
Next
If Number($g_aiCurrentLoot[$eLootTrophy]) <= Number($g_iDropTrophyMax) Then Return
Local $bHaveTroops = False
For $i = 0 To UBound($g_avDTtroopsToBeUsed, 1) - 1
If $g_avDTtroopsToBeUsed[$i][1] > 0 Then
$g_bDisableDropTrophy = False
$bHaveTroops = True
If $g_bDebugSetlog Then
SetDebugLog("Drop Trophy Found " & StringFormat("%3s", $g_avDTtroopsToBeUsed[$i][1]) & " " & $g_avDTtroopsToBeUsed[$i][0], $COLOR_DEBUG)
ContinueLoop
Else
ExitLoop
EndIf
EndIf
Next
If $g_bDropTrophyUseHeroes And $g_iHeroAvailable > 0 Then
If $g_bDebugSetlog Then SetDebugLog("Drop Trophy Found Hero BK|AQ|GW: " & BitOR($g_iHeroAvailable, $eHeroKing) & "|" & BitOR($g_iHeroAvailable, $eHeroQueen) & "|" & BitOR($g_iHeroAvailable, $eHeroWarden), $COLOR_DEBUG)
$g_bDisableDropTrophy = False
$bHaveTroops = True
EndIf
If $g_bDisableDropTrophy Or Not $bHaveTroops Then
SetLog("Drop Trophy temporarily disabled, missing proper troop type", $COLOR_ERROR)
SetDebugLog("Drop Trophy(): No troops in $g_avDTtroopsToBeUsed array", $COLOR_DEBUG)
Return
EndIf
Local $bDropSuccessful, $iCount, $aRandomEdge, $iRandomXY
Local Const $DTArmyPercent = Round(Int($g_iDropTrophyArmyMinPct) / 100, 2)
Local $g_iDropTrophyMaxNeedCheck = $g_iDropTrophyMax
Local Const $iWaitTime = 3
Local $iDateCalc, $sWaitToDate
$sWaitToDate = _DateAdd('n', $iWaitTime, _NowCalc())
SetDebugLog("ChkBaseQuick delay time= " & $sWaitToDate & " Now= " & _NowCalc() & " Diff= " & _DateDiff('s', _NowCalc(), $sWaitToDate), $COLOR_DEBUG)
While Number($g_aiCurrentLoot[$eLootTrophy]) > Number($g_iDropTrophyMaxNeedCheck)
$g_aiCurrentLoot[$eLootTrophy] = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
SetLog("Trophy Count : " & $g_aiCurrentLoot[$eLootTrophy], $COLOR_SUCCESS)
If Number($g_aiCurrentLoot[$eLootTrophy]) > Number($g_iDropTrophyMaxNeedCheck) Then
If $g_bDropTrophyAtkDead Then
If($g_CurrentCampUtilization <=($g_iTotalCampSpace * $DTArmyPercent)) Then
SetLog("Drop Trophy is waiting for " & $g_iDropTrophyArmyMinPct & "% full army to also attack Deadbases.", $COLOR_ACTION)
SetDebugLog("Drop Trophy(): Drop Trophy + Dead Base skipped, army < " & $g_iDropTrophyArmyMinPct & "%.", $COLOR_DEBUG)
ExitLoop
EndIf
Else
If($g_CurrentCampUtilization < 5) And($g_bDropTrophyUseHeroes And $g_iHeroAvailable = $eHeroNone) Then
SetLog("No troops available to use on Drop Trophy", $COLOR_ERROR)
SetDebugLog("Drop Trophy(): Drop Trophy skipped, no army.", $COLOR_DEBUG)
ExitLoop
EndIf
EndIf
$g_iDropTrophyMaxNeedCheck = $g_iDropTrophyMin
SetLog("Dropping Trophies to " & $g_iDropTrophyMin, $COLOR_INFO)
If _Sleep($DELAYDROPTROPHY4) Then ExitLoop
$bDropSuccessful = True
ZoomOut()
PrepareSearch()
If $g_bOutOfGold Or $g_bRestart Then Return
WaitForClouds()
If $g_bRestart Then Return
If _Sleep($DELAYDROPTROPHY4) Then ExitLoop
If $g_bDropTrophyAtkDead Then
$g_iAimGold[$DB] = $g_aiFilterMinGold[$DB]
$g_iAimElixir[$DB] = $g_aiFilterMinElixir[$DB]
$g_iAimGoldPlusElixir[$DB] = $g_aiFilterMinGoldPlusElixir[$DB]
$g_iSearchCount = 0
GetResources(False, $DT)
If $g_bRestart Then Return
SetLog("Identification of your troops:", $COLOR_INFO)
PrepareAttack($DT)
If $g_bRestart Then Return
Local $G =(Number($g_iSearchGold) >= Number($g_iAimGold[$DB]))
Local $E =(Number($g_iSearchElixir) >= Number($g_iAimElixir[$DB]))
Local $GPE =((Number($g_iSearchElixir) + Number($g_iSearchGold)) >= Number($g_iAimGoldPlusElixir[$DB]))
If $G = True And $E = True And $GPE = True Then
SetLog("Found [G]:" & StringFormat("%7s", $g_iSearchGold) & " [E]:" & StringFormat("%7s", $g_iSearchElixir) & " [D]:" & StringFormat("%5s", $g_iSearchDark) & " [T]:" & StringFormat("%2s", $g_iSearchTrophy), $COLOR_BLACK, "Lucida Console", 7.5)
If $g_bDebugDeadBaseImage Then setZombie()
ForceCaptureRegion()
_CaptureRegion2()
If checkDeadBase() Then
SetLog("      " & "Dead Base Found while dropping Trophies!", $COLOR_SUCCESS, "Lucida Console", 7.5)
Attack()
$g_bFirstStart = True
ReturnHome($g_bTakeLootSnapShot)
$g_bIsClientSyncError = False
$g_bIsSearchLimit = False
$g_bRestart = True
If $g_bDebugSetlog Then SetDebugLog("Drop Trophy END: Dead Base was attacked, reset army and return to Village.", $COLOR_DEBUG)
ExitLoop
Else
SetLog("      " & "Not a Dead Base, resuming Trophy Dropping.", $COLOR_BLACK, "Lucida Console", 7.5)
EndIf
EndIf
Else
$g_iSearchCount = 0
GetResources(False, $DT)
If $g_bRestart = True Then Return
SetLog("Identification of your troops:", $COLOR_INFO)
PrepareAttack($DT)
If $g_bRestart Then Return
EndIf
If _Sleep($DELAYDROPTROPHY4) Then ExitLoop
If $g_bDropTrophyUseHeroes Then
$g_iKingSlot = -1
$g_iQueenSlot = -1
$g_iWardenSlot = -1
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $eKing Then
$g_iKingSlot = $i
ElseIf $g_avAttackTroops[$i][0] = $eQueen Then
$g_iQueenSlot = $i
ElseIf $g_avAttackTroops[$i][0] = $eWarden Then
$g_iWardenSlot = $i
EndIf
Next
$aRandomEdge = $g_aaiEdgeDropPoints[Round(Random(0, 3))]
$iRandomXY = Round(Random(0, 4))
If $g_bDebugSetlog Then SetDebugLog("Hero Loc = " & $iRandomXY & ", X:Y= " & $aRandomEdge[$iRandomXY][0] & "|" & $aRandomEdge[$iRandomXY][1], $COLOR_DEBUG)
If($g_iQueenSlot <> -1 Or $g_iKingSlot <> -1 Or $g_iWardenSlot <> -1) Then
Local $sHeroPriority
Switch $g_iDropTrophyHeroesPriority
Case 0
$sHeroPriority = "QKW"
Case 1
$sHeroPriority = "QWK"
Case 2
$sHeroPriority = "KQW"
Case 3
$sHeroPriority = "KWQ"
Case 4
$sHeroPriority = "WKQ"
Case 5
$sHeroPriority = "WQK"
EndSwitch
Local $t
For $i = 1 To 3
$t = StringMid($sHeroPriority, $i, 1)
Switch $t
Case "Q"
If $g_iQueenSlot <> -1 Then
SetTrophyLoss()
SetLog("Deploying Queen", $COLOR_INFO)
Click(GetXPosOfArmySlot($g_iQueenSlot, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0179")
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0180")
If _Sleep($DELAYDROPTROPHY4) Then ExitLoop
SelectDropTroop($g_iQueenSlot)
ReturnHome(False, False)
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
ExitLoop
EndIf
Case "K"
If $g_iKingSlot <> -1 Then
SetTrophyLoss()
SetLog("Deploying King", $COLOR_INFO)
Click(GetXPosOfArmySlot($g_iKingSlot, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0177")
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0178")
If _Sleep($DELAYDROPTROPHY4) Then ExitLoop
SelectDropTroop($g_iKingSlot)
ReturnHome(False, False)
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
ExitLoop
EndIf
Case "W"
If $g_iWardenSlot <> -1 Then
SetTrophyLoss()
SetLog("Deploying Warden", $COLOR_INFO)
Click(GetXPosOfArmySlot($g_iWardenSlot, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0000")
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0000")
If _Sleep($DELAYDROPTROPHY4) Then ExitLoop
SelectDropTroop($g_iWardenSlot)
ReturnHome(False, False)
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
ExitLoop
EndIf
EndSwitch
Next
EndIf
EndIf
If($g_iQueenSlot = -1 And $g_iKingSlot = -1 And $g_iWardenSlot = -1) Or Not $g_bDropTrophyUseHeroes Then
$aRandomEdge = $g_aaiEdgeDropPoints[Round(Random(0, 3))]
$iRandomXY = Round(Random(0, 4))
If $g_bDebugSetlog Then SetDebugLog("Troop Loc = " & $iRandomXY & ", X:Y= " & $aRandomEdge[$iRandomXY][0] & "|" & $aRandomEdge[$iRandomXY][1], $COLOR_DEBUG)
Select
Case $g_avAttackTroops[0][0] = $eBarb
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0181")
$g_aiCurrentTroops[$eTroopBarbarian] += 1
SetLog("Deploying 1 Barbarian", $COLOR_INFO)
Case $g_avAttackTroops[0][0] = $eArch
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0182")
$g_aiCurrentTroops[$eTroopArcher] += 1
SetLog("Deploying 1 Archer", $COLOR_INFO)
Case $g_avAttackTroops[0][0] = $eGiant
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0183")
$g_aiCurrentTroops[$eTroopGiant] += 1
SetLog("Deploying 1 Giant", $COLOR_INFO)
Case $g_avAttackTroops[0][0] = $eWall
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0184")
$g_aiCurrentTroops[$eTroopWallBreaker] += 1
SetLog("Deploying 1 WallBreaker", $COLOR_INFO)
Case $g_avAttackTroops[0][0] = $eGobl
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0185")
$g_aiCurrentTroops[$eTroopGoblin] += 1
SetLog("Deploying 1 Goblin", $COLOR_INFO)
Case $g_avAttackTroops[0][0] = $eMini
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0186")
$g_aiCurrentTroops[$eTroopMinion] += 1
SetLog("Deploying 1 Minion", $COLOR_INFO)
Case Else
SetLog("You don't have Tier 1/2 Troops, Stop dropping trophies.", $COLOR_INFO)
$g_bDisableDropTrophy = True
$bDropSuccessful = False
ExitLoop
EndSelect
If $bDropSuccessful Then SetTrophyLoss()
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
ReturnHome(False, False)
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
EndIf
$iDateCalc = _DateDiff('s', _NowCalc(), $sWaitToDate)
If $g_bDebugSetlog Then SetDebugLog("ChkBaseQuick delay= " & $sWaitToDate & " Now= " & _NowCalc() & " Diff= " & $iDateCalc, $COLOR_DEBUG)
If $iDateCalc <= 0 Then
SetLog(" Checking base during long drop cycle", $COLOR_INFO)
CheckBaseQuick()
$sWaitToDate = _DateAdd('n', $iWaitTime, _NowCalc())
If $g_bDebugSetlog Then SetDebugLog("ChkBaseQuick new delay time= " & $sWaitToDate, $COLOR_DEBUG)
EndIf
Else
SetLog("Trophy Drop Complete", $COLOR_INFO)
EndIf
WEnd
If $g_bDebugSetlog Then SetDebugLog("DropTrophy(): End", $COLOR_DEBUG)
Else
If $g_bDebugSetlog Then SetDebugLog("Drop Trophy SKIP", $COLOR_DEBUG)
EndIf
EndFunc
Func SetTrophyLoss()
Local $sTrophyLoss
If _ColorCheck(_GetPixelColor(33, 148, True), Hex(0x000000, 6), 10) Or  _CheckPixel($aAtkHasDarkElixir, $g_bCapturePixel, Default, "HasDarkElixir") Then
$sTrophyLoss = getTrophyLossAttackScreen(48, 214)
Else
$sTrophyLoss = getTrophyLossAttackScreen(48, 184)
EndIf
SetLog(" Trophy loss = " & $sTrophyLoss, $COLOR_DEBUG)
$g_iDroppedTrophyCount -= Number($sTrophyLoss)
UpdateStats()
EndFunc
Func GetTownHallLevel($bFirstTime = False)
Local $aTHInfo[3] = ["", "", ""]
If $g_bDebugSetlog Then SetDebugLog("Town Hall Position: " & $g_aiTownHallPos[0] & ", " & $g_aiTownHallPos[1], $COLOR_DEBUG)
If isInsideDiamond($g_aiTownHallPos) = False Then
LocateTownHall(True)
If isInsideDiamond($g_aiTownHallPos) Then SaveConfig()
If _Sleep($DELAYGETTHLEVEL1) Then Return
EndIf
If $bFirstTime = True Then
BuildingClickP($g_aiTownHallPos, "#0349")
If _Sleep($DELAYGETTHLEVEL2) Then Return
EndIf
If $g_bDebugImageSave Then DebugImageSave("GetTHLevelView")
$g_iTownHallLevel = 0
$aTHInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If $g_bDebugSetlog Then SetDebugLog("$aTHInfo[0]=" & $aTHInfo[0] & ", $aTHInfo[1]=" & $aTHInfo[1] & ", $aTHInfo[2]=" & $aTHInfo[2], $COLOR_DEBUG)
If $aTHInfo[0] > 1 Then
If StringInStr($aTHInfo[1], "Town") = 0 Then
SetLog("Town Hall not found! I detected a " & $aTHInfo[1] & "! Please locate again!", $COLOR_WARNING)
Return $aTHInfo
EndIf
If $aTHInfo[2] <> "" Then
$g_iTownHallLevel = $aTHInfo[2]
SetLog("Your Town Hall Level read as: " & $g_iTownHallLevel, $COLOR_SUCCESS)
saveConfig()
Else
SetLog("Your Town Hall Level was not found! Please Manually Locate", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0350")
Return False
EndIf
Else
SetLog("Your Town Hall Level was not found! Please Manually Locate", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0351")
Return False
EndIf
ClickP($aAway, 2, $DELAYGETTHLEVEL3, "#0352")
Return True
EndFunc
Func isAtkDarkElixirFull()
If isAttackPage() And _CheckPixel($aIsAtkDarkElixirFull, $g_bCapturePixel) Then
SetLog("Dark Elixir Storages is full!", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func isDarkElixirFull()
If _CheckPixel($aIsDarkElixirFull, $g_bCapturePixel) Then
SetLog("Dark Elixir Storages is full!", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func isGoldFull()
If _CheckPixel($aIsGoldFull, $g_bCapturePixel) Then
SetLog("Gold Storages are full!", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func isElixirFull()
If _CheckPixel($aIsElixirFull, $g_bCapturePixel) Then
SetLog("Elixir Storages are full!", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func LocateUpgrades()
If $g_bBotPaused Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
Local $stext = GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_BotPaused", "Cannot locate Upgrades when bot is paused!")
Local $MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), GetTranslatedFileIni("MBR Popups", "Notice", "Notice"), $stext, 15, $g_hFrmBot)
Return
EndIf
WinGetAndroidHandle()
If $g_hAndroidWindow <> 0 And $g_bAndroidBackgroundLaunched = True Then
SetLog("Reboot " & $g_sAndroidEmulator & " for Window access", $COLOR_ERROR)
RebootAndroid(True)
EndIf
If $g_hAndroidWindow = 0 Then
SetLog($g_sAndroidEmulator & " is not open", $COLOR_ERROR)
SetError(1)
Return
EndIf
AndroidToFront(Default, "LocateUpgrades")
Local $wasDown = AndroidShieldForcedDown()
AndroidShield("LocateUpgrades")
Local $MsgBox, $stext
Local $icount = 0
Local $hGraphic = 0
Local $bInitGraphics = True
While 1
_CaptureRegion(0, 0, $g_iDEFAULT_WIDTH, 2)
If _GetPixelColor(1, 1) <> Hex(0x000000, 6) Or _GetPixelColor(850, 1) <> Hex(0x000000, 6) Then
ZoomOut()
$g_bDisableBreakCheck = True
Collect()
$g_bDisableBreakCheck = False
EndIf
$g_bDisableBreakCheck = True
Collect()
$g_bDisableBreakCheck = False
If $bInitGraphics Then
$bInitGraphics = False
$hGraphic = AndroidGraphicsGdiBegin()
If $hGraphic <> 0 Then
Local $hPen = AndroidGraphicsGdiAddObject("Pen", _GDIPlus_PenCreate(0xFFFFFF00, 2))
SetDebugLog("LocateUpgrades: $hGraphic=" & $hGraphic & ", $hPen=" & $hPen)
For $icount = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $hGraphic <> 0 And $g_avBuildingUpgrades[$icount][0] > 0 And $g_avBuildingUpgrades[$icount][0] > 0 Then
Local $xUpgrade = $g_avBuildingUpgrades[$icount][0]
Local $yUpgrade = $g_avBuildingUpgrades[$icount][1]
ConvertToVillagePos($xUpgrade, $yUpgrade)
Local $bMarkerDrawn = _GDIPlus_GraphicsDrawEllipse($hGraphic, $xUpgrade - 10, $yUpgrade - 10, 20, 20, $hPen)
AndroidGraphicsGdiUpdate()
SetDebugLog("Existing Updgrade #" & $icount & " found at " & $g_avBuildingUpgrades[$icount][0] & "/" & $g_avBuildingUpgrades[$icount][1] & ", marker drawn: " & $bMarkerDrawn)
EndIf
Next
EndIf
EndIf
For $icount = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $g_abUpgradeRepeatEnable[$icount] = True And(GUICtrlRead($g_hTxtUpgradeName[$icount]) <> "") Then
_GUICtrlSetImage($g_hPicUpgradeStatus[$icount], $g_sLibIconPath, $eIcnYellowLight)
GUICtrlSetState($g_hChkUpgrade[$icount], $GUI_CHECKED)
ContinueLoop
EndIf
AndroidShieldForceDown(True, True)
$stext = GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_01", "Click 'Locate Building' button then click on your Building/Hero to upgrade.") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_02", "Click 'Finished' button when done locating all upgrades.") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_03", "Click on Cancel to exit finding buildings.") & @CRLF & @CRLF
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 10, "Comic Sans MS", 500)
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_04", "Locate Building|Finished|Cancel"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_05", "Locate Upgrades"), $stext, 0, $g_hFrmBot)
Switch $MsgBox
Case 1
Local $aPos = FindPos()
$g_avBuildingUpgrades[$icount][0] = $aPos[0]
$g_avBuildingUpgrades[$icount][1] = $aPos[1]
If isInsideDiamondXY($g_avBuildingUpgrades[$icount][0], $g_avBuildingUpgrades[$icount][1]) Then
Local $bMarkerDrawn = False
If $hGraphic <> 0 Then
Local $xUpgrade = $g_avBuildingUpgrades[$icount][0]
Local $yUpgrade = $g_avBuildingUpgrades[$icount][1]
ConvertToVillagePos($xUpgrade, $yUpgrade)
$bMarkerDrawn = _GDIPlus_GraphicsDrawEllipse($hGraphic, $xUpgrade - 10, $yUpgrade - 10, 20, 20, $hPen)
AndroidGraphicsGdiUpdate()
EndIf
SetDebugLog("Updgrade #" & $icount & " added at " & $g_avBuildingUpgrades[$icount][0] & "/" & $g_avBuildingUpgrades[$icount][1] & ", marker drawn: " & $bMarkerDrawn)
_GUICtrlSetImage($g_hPicUpgradeStatus[$icount], $g_sLibIconPath, $eIcnYellowLight)
$g_aiPicUpgradeStatus[$icount] = $eIcnYellowLight
_Sleep(750)
Else
SetLog("Bad location recorded, location skipped?", $COLOR_ERROR)
$g_avBuildingUpgrades[$icount][0] = -1
$g_avBuildingUpgrades[$icount][1] = -1
ContinueLoop
EndIf
Case 2
If $icount = 0 Then
SetLog("Locate Upgrade Cancelled", $COLOR_WARNING)
btnResetUpgrade()
AndroidGraphicsGdiEnd()
AndroidShieldForceDown($wasDown)
Return False
EndIf
ExitLoop
Case 3
SetLog("Locate Upgrade Cancelled", $COLOR_WARNING)
btnResetUpgrade()
AndroidGraphicsGdiEnd()
AndroidShieldForceDown($wasDown)
Return False
Case Else
SetLog("Impossible value (" & $MsgBox & ") from Msgbox, you have been a bad programmer!", $COLOR_DEBUG)
EndSwitch
ClickP($aAway, 1, 0, "#0210")
Next
ExitLoop
WEnd
AndroidGraphicsGdiEnd()
AndroidShieldForceDown($wasDown)
CheckUpgrades()
EndFunc
Func CheckUpgrades()
If AndroidShielded() = False Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
Local $stext = GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_06", "Keep Mouse OUT of Android Emulator Window While I Check Your Upgrades, Thanks!!")
Local $MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), GetTranslatedFileIni("MBR Popups", "Notice", "Notice"), $stext, 15, $g_hFrmBot)
If _Sleep($DELAYCHECKUPGRADES) Then Return
If $MsgBox <> 1 Then
SetLog("Something weird happened in getting upgrade values, try again", $COLOR_ERROR)
Return False
EndIf
EndIf
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If isInsideDiamondXY($g_avBuildingUpgrades[$iz][0], $g_avBuildingUpgrades[$iz][1]) = False Then
_GUICtrlSetImage($g_hPicUpgradeStatus[$iz], $g_sLibIconPath, $eIcnRedLight)
GUICtrlSetState($g_hChkUpgrade[$iz], $GUI_UNCHECKED)
If $g_abUpgradeRepeatEnable[$iz] = True Then GUICtrlSetState($g_hChkUpgradeRepeat[$iz], $GUI_UNCHECKED)
ContinueLoop
EndIf
If UpgradeValue($iz) = False Then
If $g_abUpgradeRepeatEnable[$iz] = True And $g_avBuildingUpgrades[$iz][4] <> "" Then ContinueLoop
SetLog("Locate Upgrade #" & $iz + 1 & " Value Error, try again", $COLOR_ERROR)
_GUICtrlSetImage($g_hPicUpgradeStatus[$iz], $g_sLibIconPath, $eIcnRedLight)
GUICtrlSetData($g_hTxtUpgradeName[$iz], "")
GUICtrlSetData($g_hTxtUpgradeLevel[$iz], "")
GUICtrlSetData($g_hTxtUpgradeValue[$iz], "")
GUICtrlSetData($g_hTxtUpgradeTime[$iz], "")
GUICtrlSetData($g_hTxtUpgradeEndTime[$iz], "")
_GUICtrlSetImage($g_hPicUpgradeType[$iz], $g_sLibIconPath, $eIcnBlank)
If $g_abUpgradeRepeatEnable[$iz] = True Then GUICtrlSetState($g_hChkUpgradeRepeat[$iz], $GUI_UNCHECKED)
ContinueLoop
EndIf
Next
EndFunc
Func UpgradeValue($inum, $bRepeat = False)
Local $inputbox, $iLoot, $aString, $aResult, $ButtonPixel
Local $bOopsFlag = False
If $bRepeat = True Or $g_abUpgradeRepeatEnable[$inum] = True Then
ClickP($aAway, 1, 0, "#0999")
If _Sleep($DELAYUPGRADEVALUE1) Then Return
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1])
If _Sleep($DELAYUPGRADEVALUE4) Then Return
If $bOopsFlag = True Then DebugImageSave("ButtonView")
If StringInStr($g_avBuildingUpgrades[$inum][4], "collect", $STR_NOCASESENSEBASIC) Or StringInStr($g_avBuildingUpgrades[$inum][4], "mine", $STR_NOCASESENSEBASIC) Or StringInStr($g_avBuildingUpgrades[$inum][4], "drill", $STR_NOCASESENSEBASIC) Then
ClickP($aAway, 1, 0, "#0999")
If _Sleep($DELAYUPGRADEVALUE1) Then Return
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1])
If _Sleep($DELAYUPGRADEVALUE4) Then Return
EndIf
Local $offColors[3][3] = [[0x000000, 44, 17], [0xE07740, 69, 31], [0xF2F7F1, 81, 0]]
Local $ButtonPixel = _MultiPixelSearch(284, 572, 570, 615, 1, 1, Hex(0x000000, 6), $offColors, 25)
If $g_bDebugSetlog Then SetDebugLog("Pixel Color #1: " & _GetPixelColor(389, 572, True) & ", #2: " & _GetPixelColor(433, 589, True) & ", #3: " & _GetPixelColor(458, 603, True) & ", #4: " & _GetPixelColor(470, 572, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Or $bOopsFlag Then
SetLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetLog("Pixel Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 44, $ButtonPixel[1] + 17, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 69, $ButtonPixel[1] + 31, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 81, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
SetLog("Selection #" & $inum + 1 & " Upgrade in process - Skipped!", $COLOR_WARNING)
ClickP($aAway, 1, 0, "#0999")
Return False
EndIf
Else
If $g_avBuildingUpgrades[$inum][0] <= 0 Or $g_avBuildingUpgrades[$inum][1] <= 0 Then Return False
$g_avBuildingUpgrades[$inum][2] = 0
GUICtrlSetData($g_hTxtUpgradeValue[$inum], "")
$g_avBuildingUpgrades[$inum][3] = ""
_GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnBlank)
$g_avBuildingUpgrades[$inum][4] = ""
GUICtrlSetData($g_hTxtUpgradeName[$inum], "")
$g_avBuildingUpgrades[$inum][5] = ""
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], "")
$g_avBuildingUpgrades[$inum][6] = ""
GUICtrlSetData($g_hTxtUpgradeTime[$inum], "")
$g_avBuildingUpgrades[$inum][7] = ""
GUICtrlSetData($g_hTxtUpgradeEndTime[$inum], "")
ClickP($aAway, 1, 0, "#0211")
SetLog("-$Upgrade #" & $inum + 1 & " Location =  " & "(" & $g_avBuildingUpgrades[$inum][0] & "," & $g_avBuildingUpgrades[$inum][1] & ")", $COLOR_DEBUG1)
If _Sleep($DELAYUPGRADEVALUE1) Then Return
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1], "#0212")
If _Sleep($DELAYUPGRADEVALUE2) Then Return
If $bOopsFlag = True Then DebugImageSave("ButtonView")
EndIf
If $bOopsFlag = True And $g_bDebugImageSave Then DebugImageSave("ButtonView")
$aResult = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If $aResult[0] > 0 Then
$g_avBuildingUpgrades[$inum][4] = $aResult[1]
GUICtrlSetData($g_hTxtUpgradeName[$inum], $g_avBuildingUpgrades[$inum][4])
If $aResult[0] > 1 Then
$g_avBuildingUpgrades[$inum][5] = $aResult[2]
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], $g_avBuildingUpgrades[$inum][5])
Else
SetLog("Error: Level for Upgrade not found?", $COLOR_ERROR)
EndIf
Else
SetLog("Error: Name & Level for Upgrade not found?", $COLOR_ERROR)
EndIf
SetLog("Upgrade Name = " & $g_avBuildingUpgrades[$inum][4] & ", Level = " & $g_avBuildingUpgrades[$inum][5], $COLOR_INFO)
If QuickMIS("BC1", $g_sImgAUpgradeUpgradeBtn, 120, 630, 740, 680) Then
Local $ButtonPixel[2]
$ButtonPixel[0] = 120 + $g_iQuickMISX
$ButtonPixel[1] = 630 + $g_iQuickMISY
If $g_bDebugSetlog Or $bOopsFlag Then
SetLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetLog("#1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 70, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0213")
If _Sleep($DELAYUPGRADEVALUE5) Then Return
If $bOopsFlag = True And $g_bDebugImageSave Then DebugImageSave("UpgradeView")
_CaptureRegion()
Select
Case _ColorCheck(_GetPixelColor(687, 161 + $g_iMidOffsetY), Hex(0xCD1419, 6), 20)
If _ColorCheck(_GetPixelColor(351, 485 + $g_iMidOffsetY), Hex(0xE0403D, 6), 20) Then
If $g_abUpgradeRepeatEnable[$inum] = True Then
SetLog("Selection #" & $inum + 1 & " can not repeat upgrade, need TH upgrade - Skipped!", $COLOR_ERROR)
$g_abUpgradeRepeatEnable[$inum] = False
GUICtrlSetState($g_hChkUpgradeRepeat[$inum], $GUI_UNCHECKED)
Else
SetLog("Selection #" & $inum + 1 & " upgrade not available, need TH upgrade - Skipped!", $COLOR_ERROR)
EndIf
ClearUpgradeInfo($inum)
_GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnRedLight)
_GUICtrlSetImage($g_hPicUpgradeStatus[$inum], $g_sLibIconPath, $eIcnTroops)
$g_abBuildingUpgradeEnable[$inum] = False
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_UNCHECKED)
$g_avBuildingUpgrades[$inum][7] = ""
GUICtrlSetData($g_hTxtUpgradeEndTime[$inum], "")
ClickP($aAway, 1, 0, "#0214")
Return False
EndIf
If _ColorCheck(_GetPixelColor(485, 500 + $g_iMidOffsetY), Hex(0xFFD115, 6), 20) Then $g_avBuildingUpgrades[$inum][3] = "Gold"
If _ColorCheck(_GetPixelColor(480, 500 + $g_iMidOffsetY), Hex(0xBD21EF, 6), 20) Then $g_avBuildingUpgrades[$inum][3] = "Elixir"
$g_avBuildingUpgrades[$inum][2] = Number(getResourcesBonus(366, 487 + $g_iMidOffsetY))
If $g_avBuildingUpgrades[$inum][2] = "" Then $g_avBuildingUpgrades[$inum][2] = Number(getUpgradeResource(366, 487 + $g_iMidOffsetY))
If $g_avBuildingUpgrades[$inum][2] = "" And $g_abUpgradeRepeatEnable[$inum] = False Then $bOopsFlag = True
$g_avBuildingUpgrades[$inum][6] = getBldgUpgradeTime(195, 307 + $g_iMidOffsetY)
SetLog("Upgrade #" & $inum + 1 & " Time = " & $g_avBuildingUpgrades[$inum][6], $COLOR_INFO)
If $g_avBuildingUpgrades[$inum][6] <> "" Then $g_avBuildingUpgrades[$inum][7] = ""
Case _ColorCheck(_GetPixelColor(719, 118 + $g_iMidOffsetY), Hex(0xDF0408, 6), 20)
If _ColorCheck(_GetPixelColor(400, 485 + $g_iMidOffsetY), Hex(0xE0403D, 6), 20) Then
If $g_abUpgradeRepeatEnable[$inum] = True Then
SetLog("Selection #" & $inum + 1 & " can not repeat upgrade, need TH upgrade - Skipped!", $COLOR_ERROR)
$g_abUpgradeRepeatEnable[$inum] = False
GUICtrlSetState($g_hChkUpgradeRepeat[$inum], $GUI_UNCHECKED)
Else
SetLog("Selection #" & $inum + 1 & " upgrade not available, need TH upgrade - Skipped!", $COLOR_ERROR)
EndIf
ClearUpgradeInfo($inum)
_GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnRedLight)
_GUICtrlSetImage($g_hPicUpgradeStatus[$inum], $g_sLibIconPath, $eIcnTroops)
$g_abBuildingUpgradeEnable[$inum] = False
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_UNCHECKED)
$g_avBuildingUpgrades[$inum][7] = ""
GUICtrlSetData($g_hTxtUpgradeEndTime[$inum], "")
ClickP($aAway, 1, 0, "#0215")
Return False
EndIf
If _ColorCheck(_GetPixelColor(710, 535 + $g_iMidOffsetY), Hex(0x3C3035, 6), 20) Then $g_avBuildingUpgrades[$inum][3] = "Dark"
$g_avBuildingUpgrades[$inum][2] = Number(getResourcesBonus(598, 519 + $g_iMidOffsetY))
If $g_avBuildingUpgrades[$inum][2] = "" Then $g_avBuildingUpgrades[$inum][2] = Number(getUpgradeResource(598, 519 + $g_iMidOffsetY))
If $g_avBuildingUpgrades[$inum][2] = "" And $g_abUpgradeRepeatEnable[$inum] = False Then $bOopsFlag = True
$g_avBuildingUpgrades[$inum][6] = getHeroUpgradeTime(464, 527 + $g_iMidOffsetY)
SetLog("Upgrade #" & $inum + 1 & " Time = " & $g_avBuildingUpgrades[$inum][6], $COLOR_INFO)
If $g_avBuildingUpgrades[$inum][6] <> "" Then $g_avBuildingUpgrades[$inum][7] = ""
Case Else
If isGemOpen(True) Then ClickP($aAway, 1, 0, "#0216")
SetLog("Selected Upgrade Window Opening Error, try again", $COLOR_ERROR)
ClearUpgradeInfo($inum)
ClickP($aAway, 1, 0, "#0217")
Return False
EndSelect
If StringInStr($g_avBuildingUpgrades[$inum][4], "Warden") > 0 Then $g_avBuildingUpgrades[$inum][3] = "Elixir"
If $g_avBuildingUpgrades[$inum][3] <> "" And $bOopsFlag = True And $bRepeat = False Then
$iLoot = $g_avBuildingUpgrades[$inum][2]
If $iLoot = "" Then $iLoot = 8000000
Local $aBotLoc = WinGetPos($g_hFrmBot)
$inputbox = InputBox(GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_07", "Text Read Error"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_08", "Enter the cost of the upgrade"), $iLoot, "", -1, -1, $aBotLoc[0] + 125, $aBotLoc[1] + 225, -1, $g_hFrmBot)
If @error Then
SetLog("InputBox error, data reset. Try again", $COLOR_ERROR)
ClearUpgradeInfo($inum)
Return False
EndIf
$g_avBuildingUpgrades[$inum][2] = Int($inputbox)
SetLog("User input value = " & $g_avBuildingUpgrades[$inum][2], $COLOR_DEBUG)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
Local $stext = GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_09", "Save copy of upgrade image for developer analysis ?")
Local $MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "YES_NO", "YES|NO"), GetTranslatedFileIni("MBR Popups", "Notice", "Notice"), $stext, 60, $g_hFrmBot)
If $MsgBox = 1 And $g_bDebugImageSave Then DebugImageSave("UpgradeReadError_")
EndIf
If $g_avBuildingUpgrades[$inum][3] = "" And $bOopsFlag = True And $bRepeat = False Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 10, "Comic Sans MS", 500)
$inputbox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_10", "   GOLD   |  ELIXIR  |DARK ELIXIR"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_11", "Need User Help"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_12", "Select Upgrade Type:"), 0, $g_hFrmBot)
If $g_bDebugSetlog Then SetDebugLog(" _MsgBox returned = " & $inputbox, $COLOR_DEBUG)
Switch $inputbox
Case 1
$g_avBuildingUpgrades[$inum][3] = "Gold"
Case 2
$g_avBuildingUpgrades[$inum][3] = "Elixir"
Case 3
$g_avBuildingUpgrades[$inum][3] = "Dark"
Case Else
SetLog("Silly programmer made an error!", $COLOR_WARNING)
$g_avBuildingUpgrades[$inum][3] = "HaHa"
EndSwitch
SetLog("User selected type = " & $g_avBuildingUpgrades[$inum][3], $COLOR_DEBUG)
EndIf
If $g_avBuildingUpgrades[$inum][2] = "" Or $g_avBuildingUpgrades[$inum][3] = "" And $g_abUpgradeRepeatEnable[$inum] = False Then
SetLog("Error finding loot info " & $inum & ", Loot = " & $g_avBuildingUpgrades[$inum][2] & ", Type= " & $g_avBuildingUpgrades[$inum][3], $COLOR_ERROR)
$g_avBuildingUpgrades[$inum][0] = -1
$g_avBuildingUpgrades[$inum][1] = -1
ClickP($aAway, 2, 0, "#0218")
Return False
EndIf
SetLog("Upgrade #" & $inum + 1 & " Value = " & _NumberFormat($g_avBuildingUpgrades[$inum][2]) & " " & $g_avBuildingUpgrades[$inum][3], $COLOR_INFO)
Else
If $g_abUpgradeRepeatEnable[$inum] = False Then
SetLog("Upgrade selection problem - data cleared, please try again", $COLOR_ERROR)
ClearUpgradeInfo($inum)
ElseIf $g_abUpgradeRepeatEnable[$inum] = True Then
SetLog("Repeat upgrade problem - will retry value update later", $COLOR_ERROR)
EndIf
ClickP($aAway, 2, 0, "#0219")
Return False
EndIf
ClickP($aAway, 2, 200, "#0220")
Switch $g_avBuildingUpgrades[$inum][3]
Case "Gold"
_GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnGold)
Case "Elixir"
_GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnElixir)
Case "Dark"
_GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnDark)
Case Else
_GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnBlank)
EndSwitch
GUICtrlSetData($g_hTxtUpgradeValue[$inum], _NumberFormat($g_avBuildingUpgrades[$inum][2]))
GUICtrlSetData($g_hTxtUpgradeTime[$inum], StringStripWS($g_avBuildingUpgrades[$inum][6], $STR_STRIPALL))
GUICtrlSetData($g_hTxtUpgradeEndTime[$inum], $g_avBuildingUpgrades[$inum][7])
Return True
EndFunc
Func ClearUpgradeInfo($inum)
$g_aiPicUpgradeStatus[$inum] = $eIcnTroops
$g_avBuildingUpgrades[$inum][0] = -1
$g_avBuildingUpgrades[$inum][1] = -1
$g_avBuildingUpgrades[$inum][2] = 0
$g_avBuildingUpgrades[$inum][3] = ""
$g_avBuildingUpgrades[$inum][4] = ""
$g_avBuildingUpgrades[$inum][5] = ""
$g_avBuildingUpgrades[$inum][6] = ""
$g_avBuildingUpgrades[$inum][7] = ""
EndFunc
Func LocateClanCastle()
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
SetLog("Locating Clan Castle...", $COLOR_INFO)
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) Or _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
Collect(False)
EndIf
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_Clan_Castle_01", "Click OK then click on your Clan Castle") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_01", "Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_02", "Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Clan_Castle_02", "Locate Clan Castle"), $stext, 15)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aAway, 1, 0, "#0373")
Local $aPos = FindPos()
$g_aiClanCastlePos[0] = $aPos[0]
$g_aiClanCastlePos[1] = $aPos[1]
If isInsideDiamond($g_aiClanCastlePos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Clan Castle Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $g_aiClanCastlePos[0] & "," & $g_aiClanCastlePos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Clan Castle Location: " & "(" & $g_aiClanCastlePos[0] & "," & $g_aiClanCastlePos[1] & ")", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0374")
Return False
Case Else
SetLog(" Operator Error - Bad Clan Castle Location: " & "(" & $g_aiClanCastlePos[0] & "," & $g_aiClanCastlePos[1] & ")", $COLOR_ERROR)
$g_aiClanCastlePos[0] = -1
$g_aiClanCastlePos[1] = -1
ClickP($aAway, 1, 0, "#0375")
Return False
EndSelect
EndIf
SetLog("Clan Castle: " & "(" & $g_aiClanCastlePos[0] & "," & $g_aiClanCastlePos[1] & ")", $COLOR_SUCCESS)
Else
SetLog("Locate Clan Castle Cancelled", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0376")
Return
EndIf
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If IsArray($sInfo) and($sInfo[0] > 1 Or $sInfo[0] = "") Then
If StringInStr($sInfo[1], "clan") = 0 Then
Local $sLocMsg =($sInfo[0] = "" ? "Nothing" : $sInfo[1])
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the Clan Castle?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the Clan Castle, or restart bot and try again", $COLOR_ERROR)
$g_aiClanCastlePos[0] = -1
$g_aiClanCastlePos[1] = -1
ClickP($aAway, 1, 0, "#0377")
Return False
EndSelect
EndIf
If $sInfo[2] = "Broken" Then
SetLog("You did not rebuild your Clan Castle yet.", $COLOR_ACTION)
Else
SetLog("Your Clan Castle is at level: " & $sInfo[2], $COLOR_SUCCESS)
EndIf
Else
SetLog(" Operator Error - Bad Clan Castle Location: " & "(" & $g_aiClanCastlePos[0] & "," & $g_aiClanCastlePos[1] & ")", $COLOR_ERROR)
$g_aiClanCastlePos[0] = -1
$g_aiClanCastlePos[1] = -1
ClickP($aAway, 1, 0, "#0378")
Return False
EndIf
ExitLoop
WEnd
ClickP($aAway, 1, 200, "#0327")
EndFunc
Func LocateLab()
Local $stext, $MsgBox, $iStupid = 0, $iSilly = 0, $sErrorText = ""
SetLog("Locating Laboratory...", $COLOR_INFO)
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) Or _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
Collect()
EndIf
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
$stext = $sErrorText & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_Laboratory_01", "Click OK then click on your Laboratory building") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_02", -1) & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Laboratory_02", "Locate Laboratory"), $stext, 15)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aAway, 1, 0, "#0379")
Local $aPos = FindPos()
$g_aiLaboratoryPos[0] = Int($aPos[0])
$g_aiLaboratoryPos[1] = Int($aPos[1])
If isInsideDiamond($g_aiLaboratoryPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Laboratory Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Laboratory Location.", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0380")
Return False
Case Else
SetLog(" Operator Error - Bad Laboratory Location.", $COLOR_ERROR)
$g_aiLaboratoryPos[0] = -1
$g_aiLaboratoryPos[1] = -1
ClickP($aAway, 1, 0, "#0381")
Return False
EndSelect
EndIf
Else
SetLog("Locate Laboratory Cancelled", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0382")
Return
EndIf
Local $sLabInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If $sLabInfo[0] > 1 Or $sLabInfo[0] = "" Then
If StringInStr($sLabInfo[1], "Lab") = 0 Then
Local $sLocMsg =($sLabInfo[0] = "" ? "Nothing" : $sLabInfo[1])
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the laboratory?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the Army Camp, or restart bot and try again", $COLOR_ERROR)
$g_aiLaboratoryPos[0] = -1
$g_aiLaboratoryPos[1] = -1
ClickP($aAway, 1, 0, "#0383")
Return False
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad Laboratory Location: " & "(" & $g_aiLaboratoryPos[0] & "," & $g_aiLaboratoryPos[1] & ")", $COLOR_ERROR)
$g_aiLaboratoryPos[0] = -1
$g_aiLaboratoryPos[1] = -1
ClickP($aAway, 1, 0, "#0384")
Return False
EndIf
SetLog("Locate Laboratory Success: " & "(" & $g_aiLaboratoryPos[0] & "," & $g_aiLaboratoryPos[1] & ")", $COLOR_SUCCESS)
ExitLoop
WEnd
Clickp($aAway, 2, 0, "#0207")
EndFunc
Func LocateTownHall($bLocationOnly = False)
Local $stext, $MsgBox, $Success, $sLocMsg
Local $iStupid = 0, $iSilly = 0, $sErrorText = ""
SetLog("Locating Town Hall ...", $COLOR_INFO)
WinGetAndroidHandle()
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) Or _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
Collect()
EndIf
While 1
_ExtMsgBoxSet(1 + 64, 1, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
$stext = $sErrorText & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_TownHall_01", "Click OK then click on your Town Hall") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_02", -1) & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Func_Locate_TownHall_02", "Locate TownHall"), $stext, 30)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aAway, 1, 0, "#0391")
Local $aPos = FindPos()
$g_aiTownHallPos[0] = $aPos[0]
$g_aiTownHallPos[1] = $aPos[1]
If _Sleep($DELAYLOCATETH1) Then Return
If isInsideDiamond($g_aiTownHallPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "TownHall Location not valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $g_aiTownHallPos[0] & "," & $g_aiTownHallPos[1] & ")?" & @CRLF & "Please stop!" & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Townhall Location: " & "(" & $g_aiTownHallPos[0] & "," & $g_aiTownHallPos[1] & ")", $COLOR_ERROR)
$g_aiTownHallPos[0] = -1
$g_aiTownHallPos[1] = -1
ClickP($aAway, 1, 0, "#0392")
Return False
EndSelect
EndIf
SetLog("Townhall: " & "(" & $g_aiTownHallPos[0] & "," & $g_aiTownHallPos[1] & ")", $COLOR_SUCCESS)
Else
SetLog("Locate TownHall Cancelled", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0393")
Return
EndIf
If $bLocationOnly = False Then
$Success = GetTownHallLevel()
$iSilly += 1
If IsArray($Success) Or $Success = False Then
If $Success = False Then
$sLocMsg = "Nothing"
Else
$sLocMsg = $Success[1]
EndIf
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not a TownHall?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click on the TH, or restart bot and try again", $COLOR_ERROR)
$g_aiTownHallPos[0] = -1
$g_aiTownHallPos[1] = -1
ClickP($aAway, 1, 0, "#0394")
Return False
EndSelect
Else
SetLog("Locate TH Success!", $COLOR_ERROR)
EndIf
EndIf
ExitLoop
WEnd
ClickP($aAway, 1, 50, "#0209")
EndFunc
Func LocateQueenAltar()
Local $wasRunState = $g_bRunState
$g_bRunState = True
AndroidShield("LocateQueenAltar 1")
Local $Result = _LocateQueenAltar()
$g_bRunState = $wasRunState
AndroidShield("LocateQueenAltar 2")
Return $Result
EndFunc
Func _LocateQueenAltar()
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
WinGetAndroidHandle()
checkMainScreen(False)
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) Or _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
$g_bDisableBreakCheck = True
Collect()
$g_bDisableBreakCheck = False
EndIf
SetLog("Locating Queen Altar...", $COLOR_INFO)
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_Queen_Altar_01", "Click OK then click on your Queen Altar") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_02", -1) & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Queen_Altar_02", "Locate Queen Altar"), $stext, 15)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aTopLeftClient)
Local $aPos = FindPos()
$g_aiQueenAltarPos[0] = $aPos[0]
$g_aiQueenAltarPos[1] = $aPos[1]
If isInsideDiamond($g_aiQueenAltarPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Queen Altar Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $g_aiQueenAltarPos[0] & "," & $g_aiQueenAltarPos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Queen Altar Location: " & "(" & $g_aiQueenAltarPos[0] & "," & $g_aiQueenAltarPos[1] & ")", $COLOR_ERROR)
ClickP($aTopLeftClient)
Return False
Case Else
SetLog(" Operator Error - Bad Queen Altar Location: " & "(" & $g_aiQueenAltarPos[0] & "," & $g_aiQueenAltarPos[1] & ")", $COLOR_ERROR)
$g_aiQueenAltarPos[0] = -1
$g_aiQueenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
SetLog("Queen Altar: " & "(" & $g_aiQueenAltarPos[0] & "," & $g_aiQueenAltarPos[1] & ")", $COLOR_SUCCESS)
Else
SetLog("Locate Queen Altar Cancelled", $COLOR_INFO)
ClickP($aTopLeftClient)
Return
EndIf
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $g_bDebugSetlog Then SetDebugLog($sInfo[1] & $sInfo[2])
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If @error Then Return SetError(0, 0, 0)
If StringInStr($sInfo[1], "Quee") = 0 Then
Local $sLocMsg =($sInfo[0] = "" ? "Nothing" : $sInfo[1])
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the Queen Altar?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the Queen Altar, or restart bot and try again", $COLOR_ERROR)
$g_aiQueenAltarPos[0] = -1
$g_aiQueenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad Queen Altar Location: " & "(" & $g_aiQueenAltarPos[0] & "," & $g_aiQueenAltarPos[1] & ")", $COLOR_ERROR)
$g_aiQueenAltarPos[0] = -1
$g_aiQueenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndIf
ExitLoop
WEnd
ClickP($aTopLeftClient, 1, 200, "#0327")
If _Sleep(1000) Then Return
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = GetTranslatedFileIni("MBR Popups", "Locate_building_03", "Now you can remove mouse out of Android Emulator, Thanks!!")
$MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), GetTranslatedFileIni("MBR Popups", "Locate_building_04", "Notice!"), $stext, 15)
IniWrite($g_sProfileBuildingPath, "other", "xQueenAltarPos", $g_aiQueenAltarPos[0])
IniWrite($g_sProfileBuildingPath, "other", "yQueenAltarPos", $g_aiQueenAltarPos[1])
EndFunc
Func LocateKingAltar()
Local $wasRunState = $g_bRunState
$g_bRunState = True
AndroidShield("LocateKingAltar 1")
Local $Result = _LocateKingAltar()
$g_bRunState = $wasRunState
AndroidShield("LocateKingAltar 2")
Return $Result
EndFunc
Func _LocateKingAltar()
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
WinGetAndroidHandle()
checkMainScreen(False)
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) Or _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
$g_bDisableBreakCheck = True
Collect()
$g_bDisableBreakCheck = False
EndIf
SetLog("Locating King Altar...", $COLOR_INFO)
While 1
ClickP($aTopLeftClient)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_King_Altar_01", "Click OK then click on your King Altar") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_01", "Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_02", "Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Func_Locate_King_Altar_02", "Locate King Altar"), $stext, 15)
If $MsgBox = 1 Then
WinGetAndroidHandle()
Local $aPos = FindPos()
$g_aiKingAltarPos[0] = $aPos[0]
$g_aiKingAltarPos[1] = $aPos[1]
If isInsideDiamond($g_aiKingAltarPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "King Altar Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $g_aiKingAltarPos[0] & "," & $g_aiKingAltarPos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad King Altar Location: " & "(" & $g_aiKingAltarPos[0] & "," & $g_aiKingAltarPos[1] & ")", $COLOR_ERROR)
ClickP($aTopLeftClient)
Return False
Case Else
SetLog(" Operator Error - Bad King Altar Location: " & "(" & $g_aiKingAltarPos[0] & "," & $g_aiKingAltarPos[1] & ")", $COLOR_ERROR)
$g_aiKingAltarPos[0] = -1
$g_aiKingAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
SetLog("King Altar: " & "(" & $g_aiKingAltarPos[0] & "," & $g_aiKingAltarPos[1] & ")", $COLOR_SUCCESS)
Else
SetLog("Locate King Altar Cancelled", $COLOR_INFO)
ClickP($aTopLeftClient)
Return
EndIf
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $g_bDebugSetlog Then SetDebugLog($sInfo[1] & $sInfo[2])
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If(StringInStr($sInfo[1], "Barb") = 0) And(StringInStr($sInfo[1], "King") = 0) Then
Local $sLocMsg =($sInfo[0] = "" ? "Nothing" : $sInfo[1])
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the King Altar?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the King Altar, or restart bot and try again", $COLOR_ERROR)
$g_aiKingAltarPos[0] = -1
$g_aiKingAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad King Altar Location: " & "(" & $g_aiKingAltarPos[0] & "," & $g_aiKingAltarPos[1] & ")", $COLOR_ERROR)
$g_aiKingAltarPos[0] = -1
$g_aiKingAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndIf
ExitLoop
WEnd
ClickP($aTopLeftClient, 1, 200, "#0327")
If _Sleep(1000) Then Return
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = GetTranslatedFileIni("MBR Popups", "Locate_building_03", "Now you can remove mouse out of Android Emulator, Thanks!!")
$MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), GetTranslatedFileIni("MBR Popups", "Locate_building_04", "Notice!"), $stext, 15)
IniWrite($g_sProfileBuildingPath, "other", "xKingAltarPos", $g_aiKingAltarPos[0])
IniWrite($g_sProfileBuildingPath, "other", "yKingAltarPos", $g_aiKingAltarPos[1])
EndFunc
Func LocateWardenAltar()
Local $wasRunState = $g_bRunState
$g_bRunState = True
AndroidShield("LocateWardenAltar 1")
Local $Result = _LocateWardenAltar()
$g_bRunState = $wasRunState
AndroidShield("LocateWardenAltar 2")
Return $Result
EndFunc
Func _LocateWardenAltar()
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
If Number($g_iTownHallLevel) < 11 Then
SetLog("Grand Warden requires TH11, Cancel locate Altar!", $COLOR_ERROR)
Return
EndIf
WinGetAndroidHandle()
checkMainScreen(False)
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) And _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
$g_bDisableBreakCheck = True
Collect()
$g_bDisableBreakCheck = False
EndIf
SetLog("Locating Grand Warden Altar... work in progress!", $COLOR_INFO)
While 1
ClickP($aTopLeftClient)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_Warden_Altar_01", "Click OK then click on your Grand Warden Altar") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_01", "Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_02", "Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Warden_Altar_02", "Locate Grand Warden Altar"), $stext, 15)
If $MsgBox = 1 Then
WinGetAndroidHandle()
Local $aPos = FindPos()
$g_aiWardenAltarPos[0] = $aPos[0]
$g_aiWardenAltarPos[1] = $aPos[1]
If isInsideDiamond($g_aiWardenAltarPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Grand Warden Altar Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $g_aiWardenAltarPos[0] & "," & $g_aiWardenAltarPos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Grand Warden Altar Location: " & "(" & $g_aiWardenAltarPos[0] & "," & $g_aiWardenAltarPos[1] & ")", $COLOR_ERROR)
ClickP($aTopLeftClient)
Return False
Case Else
SetLog(" Operator Error - Bad Grand Warden Altar Location: " & "(" & $g_aiWardenAltarPos[0] & "," & $g_aiWardenAltarPos[1] & ")", $COLOR_ERROR)
$g_aiWardenAltarPos[0] = -1
$g_aiWardenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
SetLog("Grand Warden Altar: " & "(" & $g_aiWardenAltarPos[0] & "," & $g_aiWardenAltarPos[1] & ")", $COLOR_SUCCESS)
Else
SetLog("Locate Grand Warden Altar Cancelled", $COLOR_INFO)
ClickP($aTopLeftClient)
Return
EndIf
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $g_bDebugSetlog Then SetDebugLog($sInfo[1] & $sInfo[2])
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If @error Then Return SetError(0, 0, 0)
If StringInStr($sInfo[1], "Warden") = 0 Then
Local $sLocMsg =($sInfo[0] = "" ? "Nothing" : $sInfo[1])
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the Grand Warden Altar?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the Grand Warden Altar, or restart bot and try again", $COLOR_ERROR)
$g_aiWardenAltarPos[0] = -1
$g_aiWardenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad Grand Warden Altar Location: " & "(" & $g_aiWardenAltarPos[0] & "," & $g_aiWardenAltarPos[1] & ")", $COLOR_ERROR)
$g_aiWardenAltarPos[0] = -1
$g_aiWardenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndIf
ExitLoop
WEnd
ClickP($aTopLeftClient, 1, 200, "#0327")
If _Sleep(1000) Then Return
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = GetTranslatedFileIni("MBR Popups", "Locate_building_03", "Now you can remove mouse out of Android Emulator, Thanks!!")
$MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), GetTranslatedFileIni("MBR Popups", "Locate_building_04", "Notice!"), $stext, 15)
IniWrite($g_sProfileBuildingPath, "other", "xWardenAltarPos", $g_aiWardenAltarPos[0])
IniWrite($g_sProfileBuildingPath, "other", "yWardenAltarPos", $g_aiWardenAltarPos[1])
EndFunc
Func ProfileReport()
Local $iAttacksWon = 0, $iDefensesWon = 0
Local $iCount
ClickP($aAway, 1, 0, "#0221")
If _Sleep($DELAYPROFILEREPORT1) Then Return
SetLog("Profile Report", $COLOR_INFO)
SetLog("Opening Profile page to read Attacks, Defenses, Donations and Recieved Troops", $COLOR_INFO)
Click(30, 40, 1, 0, "#0222")
If _Sleep($DELAYPROFILEREPORT2) Then Return
While Not _ColorCheck(_GetPixelColor(252, 69, True), Hex(0xF4F4F0, 6), 5)
$iCount += 1
If _Sleep($DELAYPROFILEREPORT1) Then Return
If $iCount >= 25 Then ExitLoop
WEnd
If $iCount >= 25 Then SetDebugLog("Profile Page did not open after " & $iCount & " Loops", $COLOR_DEBUG)
For $i = 0 to 1
If QuickMIS("BC1", $g_sImgCollectReward, 680, 165, 855, 680) Then
Click($g_iQuickMISX + 680, $g_iQuickMISY + 165)
SetLog("Reward collected", $COLOR_SUCCESS)
For $i = 0 To 9
ClickDrag(421, 200, 421, 630, 2000)
If _Sleep(2000) Then Return
If _ColorCheck(_GetPixelColor($aCheckTopProfile[0], $aCheckTopProfile[1], True), Hex($aCheckTopProfile[2], 6), $aCheckTopProfile[3])= True And _ColorCheck(_GetPixelColor($aCheckTopProfile2[0], $aCheckTopProfile2[1], True), Hex($aCheckTopProfile2[2], 6), $aCheckTopProfile2[3]) = True Then ExitLoop
Next
ExitLoop
EndIf
If _Sleep($DELAYPROFILEREPORT1) Then Return
Next
If _Sleep($DELAYPROFILEREPORT1) Then Return
$iAttacksWon = ""
If _ColorCheck(_GetPixelColor($aProfileReport[0], $aProfileReport[1], True), Hex($aProfileReport[2], 6), $aProfileReport[3]) Then
SetDebugLog("Profile seems to be currently unranked", $COLOR_DEBUG)
$iAttacksWon = 0
$iDefensesWon = 0
Else
$iAttacksWon = getProfile(578, 347)
If $g_bDebugSetlog Then SetDebugLog("$iAttacksWon: " & $iAttacksWon, $COLOR_DEBUG)
$iCount = 0
While $iAttacksWon = ""
If _Sleep($DELAYPROFILEREPORT1) Then Return
$iAttacksWon = getProfile(578, 347)
If $g_bDebugSetlog Then SetDebugLog("Read Loop $iAttacksWon: " & $iAttacksWon & ", Count: " & $iCount, $COLOR_DEBUG)
$iCount += 1
If $iCount >= 20 Then ExitLoop
WEnd
If $g_bDebugSetlog And $iCount >= 20 Then SetLog("Excess wait time for reading $AttacksWon: " & getProfile(578, 347), $COLOR_DEBUG)
$iDefensesWon = getProfile(790, 347)
EndIf
$g_iTroopsDonated = getProfile(158, 347)
$g_iTroopsReceived = getProfile(360, 347)
SetLog(" [ATKW]: " & _NumberFormat($iAttacksWon) & " [DEFW]: " & _NumberFormat($iDefensesWon) & " [TDON]: " & _NumberFormat($g_iTroopsDonated) & " [TREC]: " & _NumberFormat($g_iTroopsReceived), $COLOR_SUCCESS)
Click(830, 80, 1, 0, "#0223")
If _Sleep($DELAYPROFILEREPORT3) Then Return
$iCount = 0
While Not _CheckPixel($aIsMain, $g_bCapturePixel)
If _Sleep($DELAYPROFILEREPORT3) Then Return
$iCount += 1
If $iCount > 50 Then
SetDebugLog("Main Window did not appear after " & $iCount & " Loops", $COLOR_DEBUG)
ExitLoop
EndIf
WEnd
EndFunc
Func ReArm()
If Not $g_bChkTrap Then Return
If Not $g_abNotNeedAllTime[0] Then Return
SetLog("Checking if Village needs Rearming..", $COLOR_INFO)
If Not isInsideDiamond($g_aiTownHallPos) Then
LocateTownHall(True)
SaveConfig()
If _Sleep($DELAYREARM3) Then Return
EndIf
ClickP($aAway, 1, 0, "#0224")
If _Sleep($DELAYREARM4) Then Return
If IsMainPage() Then BuildingClickP($g_aiTownHallPos, "#0225")
If _Sleep($DELAYREARM2) Then Return
Local $bReArmed = False
Local $sDiamond = GetDiamondFromRect("245,620,615,700")
Local $aTempArray, $aTempBtnCoords
Local $aRearmOptions = findMultiple($g_sImgRearm, $sDiamond, $sDiamond, 0, 1000, 3, "objectname,objectpoints", True)
If $aRearmOptions <> "" And IsArray($aRearmOptions) Then
For $i = 0 To UBound($aRearmOptions, 1) - 1
$aTempArray = $aRearmOptions[$i]
If UBound($aTempArray, 1) = 2 Then
$aTempBtnCoords = StringSplit($aTempArray[1], ",", $STR_NOCOUNT)
If IsMainPage() Then ClickP($aTempBtnCoords, 1, 0, "#0330")
If _Sleep($DELAYREARM1) Then Return
Click(515, 400, 1, 0, "#0226")
If _Sleep($DELAYREARM4) Then Return
If isGemOpen(True) Then
SetLog("Not enough loot to rearm traps.....", $COLOR_ERROR)
Click(585, 252, 1, 0, "#0227")
If _Sleep($DELAYREARM1) Then Return
Else
Local $sVerb = StringInStr($aTempArray[0], "Trap") ? "Rearmed" : "Reloaded"
SetLog($sVerb & " " & $aTempArray[0] & "(s)", $COLOR_SUCCESS)
$g_abNotNeedAllTime[0] = False
$bReArmed = True
If _Sleep($DELAYREARM1) Then Return
EndIf
EndIf
Next
EndIf
If Not $bReArmed Then
SetLog("Rearm not needed!", $COLOR_SUCCESS)
$g_abNotNeedAllTime[0] = False
EndIf
ClickP($aAway, 1, 0, "#0234")
If _Sleep($DELAYREARM2) Then Return
checkMainScreen(False)
EndFunc
Func RequestCC($ClickPAtEnd = True, $specifyText = "")
If Not $g_bRequestTroopsEnable Or Not $g_bCanRequestCC Or Not $g_bDonationEnabled Then
Return
EndIf
If $g_bRequestTroopsEnable Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abRequestCCHours[$hour[0]] = False Then
SetLog("Request Clan Castle troops not planned, Skipped..", $COLOR_ACTION)
Return
EndIf
EndIf
SetLog("Requesting Clan Castle Troops", $COLOR_INFO)
If IsMainPage() Then
If Not $g_bUseRandomClick Then
Click($aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0, "#0334")
Else
ClickR($aArmyTrainButtonRND, $aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0)
EndIf
EndIf
If _Sleep($DELAYREQUESTCC1) Then Return
checkAttackDisable($g_iTaBChkIdle)
Local $iCount = 0
While IsTrainPage() = False
If _Sleep($DELAYREQUESTCC1) Then ExitLoop
$iCount += 1
If $iCount > 5 Then
If $g_bDebugSetlog Then SetDebugLog("RequestCC Army Window issue!", $COLOR_DEBUG)
ExitLoop
EndIf
WEnd
Local $color1 = _GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1] + 20, True)
Local $color2 = _GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True)
If _ColorCheck($color1, Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5]) Then
SetLog("Your Clan Castle is already full or you are not in a clan.")
$g_bCanRequestCC = False
ElseIf _ColorCheck($color1, Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) Then
If _ColorCheck($color2, Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5]) Then
Local $x = _makerequest()
Else
SetLog("Request has already been made")
EndIf
Else
SetLog("Cannot detect button request troops.")
SetLog("The Pixel on " & $aRequestTroopsAO[0] & "-" & $aRequestTroopsAO[1] & " was: " & $color1, $COLOR_ERROR)
EndIf
If _Sleep($DELAYREQUESTCC1) Then Return
If $ClickPAtEnd Then ClickP($aAway, 2, 0, "#0335")
EndFunc
Func _makerequest()
Click($aRequestTroopsAO[0], $aRequestTroopsAO[1], 1, 0, "0336")
Local $icount = 0
While Not( _ColorCheck(_GetPixelColor($aCancRequestCCBtn[0], $aCancRequestCCBtn[1], True), Hex($aCancRequestCCBtn[2], 6), $aCancRequestCCBtn[3]))
If _Sleep($DELAYMAKEREQUEST1) Then ExitLoop
$icount += 1
If $g_bDebugSetlog Then SetDebugLog("$icount2 = " & $icount & ", " & _GetPixelColor($aCancRequestCCBtn[0], $aCancRequestCCBtn[1], True), $COLOR_DEBUG)
If $icount > 20 Then ExitLoop
WEnd
If $icount > 20 Then
SetLog("Request has already been made, or request window not available", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0257")
If _Sleep($DELAYMAKEREQUEST2) Then Return
Else
If $g_sRequestTroopsText <> "" Then
If $g_bChkBackgroundMode = False And $g_bNoFocusTampering = False Then ControlFocus($g_hAndroidWindow, "", "")
AndroidSendText($g_sRequestTroopsText, True)
Click($atxtRequestCCBtn[0], $atxtRequestCCBtn[1], 1, 0, "#0254")
_Sleep($DELAYMAKEREQUEST2)
If SendText($g_sRequestTroopsText) = 0 Then
SetLog(" Request text entry failed, try again", $COLOR_ERROR)
Return
EndIf
EndIf
If _Sleep($DELAYMAKEREQUEST2) Then Return
$icount = 0
While Not _ColorCheck(_GetPixelColor($aSendRequestCCBtn[0], $aSendRequestCCBtn[1], True), Hex(0x5fac10, 6), 20)
If _Sleep($DELAYMAKEREQUEST1) Then ExitLoop
$icount += 1
If $g_bDebugSetlog Then SetDebugLog("$icount3 = " & $icount & ", " & _GetPixelColor($aSendRequestCCBtn[0], $aSendRequestCCBtn[1], True), $COLOR_DEBUG)
If $icount > 25 Then ExitLoop
WEnd
If $icount > 25 Then
If $g_bDebugSetlog Then SetDebugLog("Send request button not found", $COLOR_DEBUG)
CheckMainScreen(False)
EndIf
If $g_bChkBackgroundMode = False And $g_bNoFocusTampering = False Then ControlFocus($g_hAndroidWindow, "", "")
Click($aSendRequestCCBtn[0], $aSendRequestCCBtn[1], 1, 100, "#0256")
$g_bCanRequestCC = False
EndIf
EndFunc
Func VillageReport($bBypass = False, $bSuppressLog = False)
PureClickP($aAway, 1, 0, "#0319")
If _Sleep($DELAYVILLAGEREPORT1) Then Return
Switch $bBypass
Case False
If Not $bSuppressLog Then SetLog("Village Report", $COLOR_INFO)
Case True
If Not $bSuppressLog Then SetLog("Updating Village Resource Values", $COLOR_INFO)
Case Else
If Not $bSuppressLog Then SetLog("Village Report Error, You have been a BAD programmer!", $COLOR_ERROR)
EndSwitch
getBuilderCount($bSuppressLog)
If _Sleep($DELAYRESPOND) Then Return
$g_aiCurrentLoot[$eLootTrophy] = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If Not $bSuppressLog Then SetLog(" [T]: " & _NumberFormat($g_aiCurrentLoot[$eLootTrophy]), $COLOR_SUCCESS)
If _CheckPixel($aVillageHasDarkElixir, $g_bCapturePixel) Then
$g_aiCurrentLoot[$eLootGold] = getResourcesMainScreen(696, 23)
$g_aiCurrentLoot[$eLootElixir] = getResourcesMainScreen(696, 74)
$g_aiCurrentLoot[$eLootDarkElixir] = getResourcesMainScreen(728, 123)
$g_iGemAmount = getResourcesMainScreen(740, 171)
If Not $bSuppressLog Then SetLog(" [G]: " & _NumberFormat($g_aiCurrentLoot[$eLootGold]) & " [E]: " & _NumberFormat($g_aiCurrentLoot[$eLootElixir]) & " [D]: " & _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir]) & " [GEM]: " & _NumberFormat($g_iGemAmount), $COLOR_SUCCESS)
Else
$g_aiCurrentLoot[$eLootGold] = getResourcesMainScreen(701, 23)
$g_aiCurrentLoot[$eLootElixir] = getResourcesMainScreen(701, 74)
$g_iGemAmount = getResourcesMainScreen(719, 123)
If Not $bSuppressLog Then SetLog(" [G]: " & _NumberFormat($g_aiCurrentLoot[$eLootGold]) & " [E]: " & _NumberFormat($g_aiCurrentLoot[$eLootElixir]) & " [GEM]: " & _NumberFormat($g_iGemAmount), $COLOR_SUCCESS)
If ProfileSwitchAccountEnabled() Then $g_aiCurrentLoot[$eLootDarkElixir] = ""
EndIf
If ProfileSwitchAccountEnabled() Then
$g_aiFreeBuilderCountAcc[$g_iCurAccount] = $g_iFreeBuilderCount
$g_aiTotalBuilderCountAcc[$g_iCurAccount] = $g_iTotalBuilderCount
$g_aiTrophyCurrentAcc[$g_iCurAccount] = $g_aiCurrentLoot[$eLootTrophy]
$g_aiGoldCurrentAcc[$g_iCurAccount] = $g_aiCurrentLoot[$eLootGold]
$g_aiElixirCurrentAcc[$g_iCurAccount] = $g_aiCurrentLoot[$eLootElixir]
$g_aiDarkCurrentAcc[$g_iCurAccount] = $g_aiCurrentLoot[$eLootDarkElixir]
$g_aiGemAmountAcc[$g_iCurAccount] = $g_iGemAmount
EndIf
If $bBypass = False Then
UpdateStats()
EndIf
Local $i = 0
While _ColorCheck(_GetPixelColor(819, 39, True), Hex(0xF8FCFF, 6), 20) = True
$i += 1
If _Sleep($DELAYVILLAGEREPORT1) Then Return
If $i >= 20 Then ExitLoop
WEnd
EndFunc
Global $g_aiUpgradeLevel[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Func UpgradeBuilding()
Local $iz = 0
Local $iUpgradeAction = -1
Local $iAvailBldr, $iAvailGold, $iAvailElixir, $iAvailDark
Local $iUpGrdEndTimeDiff = 0
Local $aCheckFrequency[9] = [5, 15, 20, 30, 60, 60, 120, 240, 240]
Local $iDTDiff
Local $bChkAllRptUpgrade = False
Local $sTime
Static Local $sNextCheckTime = _DateAdd("n", -1, _NowCalc())
If @error Then _logErrorDateAdd(@error)
$g_iUpgradeMinGold = Number($g_iUpgradeMinGold)
$g_iUpgradeMinElixir = Number($g_iUpgradeMinElixir)
$g_iUpgradeMinDark = Number($g_iUpgradeMinDark)
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $g_abBuildingUpgradeEnable[$iz] = True Then
$iUpgradeAction += 2 ^($iz + 1)
EndIf
Next
If $iUpgradeAction < 0 Then Return False
$iUpgradeAction = 0
SetLog("Checking Upgrades", $COLOR_INFO)
VillageReport(True, True)
$iAvailGold = Number($g_aiCurrentLoot[$eLootGold])
$iAvailElixir = Number($g_aiCurrentLoot[$eLootElixir])
$iAvailDark = Number($g_aiCurrentLoot[$eLootDarkElixir])
$iAvailBldr = $g_iFreeBuilderCount -($g_bUpgradeWallSaveBuilder = True ? 1 : 0)
If $iAvailBldr <= 0 Then
SetLog("No builder available for upgrade process")
Return False
EndIf
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $g_bDebugSetlog Then SetlogUpgradeValues($iz)
If $g_abBuildingUpgradeEnable[$iz] = False Then ContinueLoop
If $g_avBuildingUpgrades[$iz][0] <= 0 Or $g_avBuildingUpgrades[$iz][1] <= 0 Or $g_avBuildingUpgrades[$iz][3] = "" Then ContinueLoop
If $iAvailBldr <= 0 And $bChkAllRptUpgrade = False Then
SetLog("No builder available for #" & $iz + 1 & ", " & $g_avBuildingUpgrades[$iz][4])
Return False
EndIf
If $g_abUpgradeRepeatEnable[$iz] = True Then
If $bChkAllRptUpgrade = False Then
$iDTDiff = Int(_DateDiff("n", _NowCalc(), $sNextCheckTime))
If @error Then _logErrorDateDiff(@error)
If $g_bDebugSetlog Then
SetDebugLog("Delay time between repeat upgrade checks = " & $aCheckFrequency[($g_iTownHallLevel < 3 ? 0 : $g_iTownHallLevel - 3)] & " Min", $COLOR_DEBUG)
SetDebugLog("Delay time remaining = " & $iDTDiff & " Min", $COLOR_DEBUG)
EndIf
If $iDTDiff < 0 Then
$sNextCheckTime = _DateAdd("n", $aCheckFrequency[($g_iTownHallLevel < 3 ? 0 : $g_iTownHallLevel - 3)], _NowCalc())
If @error Then _logErrorDateAdd(@error)
$bChkAllRptUpgrade = True
If $g_bDebugSetlog Then SetDebugLog("New delayed check time=  " & $sNextCheckTime, $COLOR_DEBUG)
EndIf
EndIf
If _DateIsValid($g_avBuildingUpgrades[$iz][7]) Then
$iUpGrdEndTimeDiff = Int(_DateDiff("n", _NowCalc(), $g_avBuildingUpgrades[$iz][7]))
If @error Then
_logErrorDateDiff(@error)
$iUpGrdEndTimeDiff = 0
EndIf
If $g_bDebugSetlog Then SetDebugLog("Difference between upgrade end and NOW= " & $iUpGrdEndTimeDiff & " Min", $COLOR_DEBUG)
EndIf
If $bChkAllRptUpgrade = True Or $iUpGrdEndTimeDiff < 0 Then
If UpgradeValue($iz, True) = False Then
If $g_bDebugSetlog Then SetlogUpgradeValues($iz)
SetLog("Repeat upgrade #" & $iz + 1 & " " & $g_avBuildingUpgrades[$iz][4] & " not ready yet", $COLOR_ERROR)
ContinueLoop
ElseIf($iAvailBldr <= 0) Then
SetLog("No builder available for " & $g_avBuildingUpgrades[$iz][4])
ContinueLoop
EndIf
EndIf
EndIf
SetLog("Upgrade #" & $iz + 1 & " " & $g_avBuildingUpgrades[$iz][4] & " Selected", $COLOR_SUCCESS)
If $g_bDebugSetlog Then SetDebugLog("-Upgrade location =  " & "(" & $g_avBuildingUpgrades[$iz][0] & "," & $g_avBuildingUpgrades[$iz][1] & ")", $COLOR_DEBUG)
If _Sleep($DELAYUPGRADEBUILDING1) Then Return
Switch $g_avBuildingUpgrades[$iz][3]
Case "Gold"
If $iAvailGold < $g_avBuildingUpgrades[$iz][2] + $g_iUpgradeMinGold Then
SetLog("Insufficent Gold for #" & $iz + 1 & ", requires: " & $g_avBuildingUpgrades[$iz][2] & " + " & $g_iUpgradeMinGold, $COLOR_INFO)
ContinueLoop
EndIf
If UpgradeNormal($iz) = False Then ContinueLoop
$iUpgradeAction += 2 ^($iz + 1)
SetLog("Gold used = " & $g_avBuildingUpgrades[$iz][2], $COLOR_INFO)
$g_iNbrOfBuildingsUppedGold += 1
$g_iCostGoldBuilding += $g_avBuildingUpgrades[$iz][2]
UpdateStats()
$iAvailGold -= $g_avBuildingUpgrades[$iz][2]
$iAvailBldr -= 1
Case "Elixir"
If $iAvailElixir < $g_avBuildingUpgrades[$iz][2] + $g_iUpgradeMinElixir Then
SetLog("Insufficent Elixir for #" & $iz + 1 & ", requires: " & $g_avBuildingUpgrades[$iz][2] & " + " & $g_iUpgradeMinElixir, $COLOR_INFO)
ContinueLoop
EndIf
If UpgradeNormal($iz) = False Then ContinueLoop
$iUpgradeAction += 2 ^($iz + 1)
SetLog("Elixir used = " & $g_avBuildingUpgrades[$iz][2], $COLOR_INFO)
$g_iNbrOfBuildingsUppedElixir += 1
$g_iCostElixirBuilding += $g_avBuildingUpgrades[$iz][2]
UpdateStats()
$iAvailElixir -= $g_avBuildingUpgrades[$iz][2]
$iAvailBldr -= 1
Case "Dark"
If $iAvailDark < $g_avBuildingUpgrades[$iz][2] + $g_iUpgradeMinDark Then
SetLog("Insufficent Dark for #" & $iz + 1 & ", requires: " & $g_avBuildingUpgrades[$iz][2] & " + " & $g_iUpgradeMinDark, $COLOR_INFO)
ContinueLoop
EndIf
If UpgradeHero($iz) = False Then ContinueLoop
$iUpgradeAction += 2 ^($iz + 1)
SetLog("Dark Elixir used = " & $g_avBuildingUpgrades[$iz][2], $COLOR_INFO)
$g_iNbrOfHeroesUpped += 1
$g_iCostDElixirHero += $g_avBuildingUpgrades[$iz][2]
UpdateStats()
$iAvailDark -= $g_avBuildingUpgrades[$iz][2]
$iAvailBldr -= 1
Case Else
SetLog("Something went wrong with loot type on Upgradebuilding module on #" & $iz + 1, $COLOR_ERROR)
ExitLoop
EndSwitch
$g_avBuildingUpgrades[$iz][7] = _NowCalc()
If $g_bDebugSetlog Then SetDebugLog("Upgrade #" & $iz + 1 & " " & $g_avBuildingUpgrades[$iz][4] & " Started @ " & $g_avBuildingUpgrades[$iz][7], $COLOR_SUCCESS)
Local $aArray = StringSplit($g_avBuildingUpgrades[$iz][6], ' ', BitOR($STR_CHRSPLIT, $STR_NOCOUNT))
If IsArray($aArray) Then
Local $iRemainingTimeMin = 0
For $i = 0 To UBound($aArray) - 1
$sTime = ""
Select
Case StringInStr($aArray[$i], "d", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin +=(Int($sTime) * 24 * 60) - 7
Case StringInStr($aArray[$i], "h", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin +=(Int($sTime) * 60) - 3
Case StringInStr($aArray[$i], "m", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += Int($sTime)
Case Else
SetLog("Upgrade #" & $iz + 1 & " OCR time invalid" & $aArray[$i], $COLOR_WARNING)
EndSelect
If $g_bDebugSetlog Then SetDebugLog("Upgrade Time: " & $aArray[$i] & ", Minutes= " & $iRemainingTimeMin, $COLOR_DEBUG)
Next
$g_avBuildingUpgrades[$iz][7] = _DateAdd('n', Floor($iRemainingTimeMin), _NowCalc())
If @error Then _logErrorDateAdd(@error)
SetLog("Upgrade #" & $iz + 1 & " " & $g_avBuildingUpgrades[$iz][4] & " Finishes @ " & $g_avBuildingUpgrades[$iz][7], $COLOR_SUCCESS)
GUICtrlSetData($g_hTxtUpgradeEndTime[$iz], $g_avBuildingUpgrades[$iz][7])
Else
SetLog("Non critical error processing upgrade time for " & "#" & $iz + 1 & ": " & $g_avBuildingUpgrades[$iz][4], $COLOR_WARNING)
EndIf
Next
If $iUpgradeAction <= 0 Then
SetLog("No Upgrades Available", $COLOR_SUCCESS)
Else
saveConfig()
EndIf
If _Sleep($DELAYUPGRADEBUILDING2) Then Return
checkMainScreen(False)
Return $iUpgradeAction
EndFunc
Func UpgradeNormal($inum)
Local $aResult, $ButtonPixel
ClickP($aAway, 1, 0, "#0211")
If _Sleep($DELAYUPGRADENORMAL1) Then Return
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1], "#0296")
If _Sleep($DELAYUPGRADENORMAL1) Then Return
$aResult = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If UBound($aResult) < 2 Then
Return False
EndIf
If StringStripWS($aResult[1], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) <> StringStripWS($g_avBuildingUpgrades[$inum][4], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) Then
SetLog("#" & $inum + 1 & ":" & $g_avBuildingUpgrades[$inum][4] & ": Not same as :" & $aResult[1] & ":? Retry now...", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0211")
If _Sleep($DELAYUPGRADENORMAL1) Then Return
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1], "#0296")
If _Sleep($DELAYUPGRADENORMAL1) Then Return
$aResult = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If $aResult[0] > 1 Then
If StringStripWS($aResult[1], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) <> StringStripWS($g_avBuildingUpgrades[$inum][4], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) Then
SetLog("Found #" & $inum + 1 & ":" & $g_avBuildingUpgrades[$inum][4] & ": Not same as : " & $aResult[1] & ":, May need new location?", $COLOR_ERROR)
Return False
EndIf
EndIf
EndIf
If $g_avBuildingUpgrades[$inum][3] = "Gold" Then
Local $offColors[3][3] = [[0xD6714B, 47, 37], [0xF0E850, 70, 0], [0xF4F8F2, 79, 0]]
$ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 650 + $g_iBottomOffsetY, 1, 1, Hex(0xF3F3F1, 6), $offColors, 30)
If $g_bDebugSetlog And IsArray($ButtonPixel) Then
SetLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetLog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 47, $ButtonPixel[1] + 37, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 70, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
Else
Local $offColors[3][3] = [[0xBC5B31, 38, 32], [0xF84CF9, 72, 0], [0xF5F9F2, 79, 0]]
$ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 650 + $g_iBottomOffsetY, 1, 1, Hex(0xF4F7F2, 6), $offColors, 30)
If $g_bDebugSetlog And IsArray($ButtonPixel) Then
SetLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetLog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 38, $ButtonPixel[1] + 32, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
EndIf
If IsArray($ButtonPixel) Then
If _Sleep($DELAYUPGRADENORMAL2) Then Return
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0297")
If _Sleep($DELAYUPGRADENORMAL3) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeRegBtn1")
Local $aBldgUpgradeWinChk[4] = [687, 161 + $g_iMidOffsetY, 0xCD1419, 20]
If _WaitForCheckPixel($aBldgUpgradeWinChk, $g_bCapturePixel,Default, "BldgUpgradeWinChk", Default, Default, 100) Then
If _ColorCheck(_GetPixelColor(459, 490 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(459, 494 + $g_iMidOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(459, 498 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Upgrade Fail #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & ", No Loot!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0298")
Return False
Else
Click(440, 480 + $g_iMidOffsetY, 1, 0, "#0299")
If _Sleep($DELAYUPGRADENORMAL3) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeRegBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
SetLog("Upgrade Fail #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & " No Loot!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0300")
Return False
EndIf
SetLog("Upgrade #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & " started", $COLOR_SUCCESS)
_GUICtrlSetImage($g_hPicUpgradeStatus[$inum], $g_sLibIconPath, $eIcnGreenLight)
$g_aiPicUpgradeStatus[$inum] = $eIcnGreenLight
GUICtrlSetData($g_hTxtUpgradeValue[$inum], -($g_avBuildingUpgrades[$inum][2]))
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], $g_avBuildingUpgrades[$inum][5] & "+")
$g_aiUpgradeLevel[$inum] = $g_avBuildingUpgrades[$inum][5] & "+"
If $g_abUpgradeRepeatEnable[$inum] = False Then
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_UNCHECKED)
$g_abBuildingUpgradeEnable[$inum] = False
$g_avBuildingUpgrades[$inum][0] = -1
$g_avBuildingUpgrades[$inum][1] = -1
$g_avBuildingUpgrades[$inum][3] = ""
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], $g_avBuildingUpgrades[$inum][5] & "+")
$g_avBuildingUpgrades[$inum][5] = $g_avBuildingUpgrades[$inum][5] & "+"
ElseIf $g_abUpgradeRepeatEnable[$inum] = True Then
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_CHECKED)
$g_abBuildingUpgradeEnable[$inum] = True
EndIf
ClickP($aAway, 2, 0, "#0301")
If _Sleep($DELAYUPGRADENORMAL3) Then Return
Return True
EndIf
ElseIf _ColorCheck(_GetPixelColor(721, 118 + $g_iMidOffsetY, True), Hex(0xDF0408, 6), 20) Then
If _ColorCheck(_GetPixelColor(459, 490 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(459, 494 + $g_iMidOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(459, 498 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Upgrade Fail #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & ", No Loot!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0298")
Return False
Else
Click(670, 510 + $g_iMidOffsetY, 1, 0, "#0299")
If _Sleep($DELAYUPGRADENORMAL3) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeRegBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
SetLog("Upgrade Fail #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & " No Loot!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0300")
Return False
EndIf
SetLog("Upgrade #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & " started", $COLOR_GREEN)
_GUICtrlSetImage($g_hPicUpgradeStatus[$inum], $g_sLibIconPath, $eIcnGreenLight)
$g_aiPicUpgradeStatus[$inum] = $eIcnGreenLight
GUICtrlSetData($g_hTxtUpgradeValue[$inum], -($g_avBuildingUpgrades[$inum][2]))
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], $g_avBuildingUpgrades[$inum][5] & "+")
$g_aiUpgradeLevel[$inum] = $g_avBuildingUpgrades[$inum][5] & "+"
If $g_abUpgradeRepeatEnable[$inum] = False Then
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_UNCHECKED)
$g_abBuildingUpgradeEnable[$inum] = False
$g_avBuildingUpgrades[$inum][0] = -1
$g_avBuildingUpgrades[$inum][1] = -1
$g_avBuildingUpgrades[$inum][3] = ""
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], $g_avBuildingUpgrades[$inum][5] & "+")
$g_avBuildingUpgrades[$inum][5] = $g_avBuildingUpgrades[$inum][5] & "+"
ElseIf $g_abUpgradeRepeatEnable[$inum] = True Then
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_CHECKED)
$g_abBuildingUpgradeEnable[$inum] = True
EndIf
ClickP($aAway, 2, 0, "#0301")
If _Sleep($DELAYUPGRADENORMAL3) Then Return
Return True
EndIf
Else
SetLog("Upgrade #" & $inum + 1 & " window open fail", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0302")
EndIf
Else
SetLog("Upgrade #" & $inum + 1 & " Error finding button", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0303")
Return False
EndIf
EndFunc
Func UpgradeHero($inum)
Local $ButtonPixel
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1], "#0304")
If _Sleep($DELAYUPGRADEHERO1) Then Return
Local $offColors[3][3] = [[0xE07B50, 41, 23], [0x282020, 72, 0], [0xF4F5F2, 79, 0]]
$ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 620 + $g_iBottomOffsetY, 1, 1, Hex(0xF5F6F2, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog And IsArray($ButtonPixel) Then
SetLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetLog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
If _Sleep($DELAYUPGRADEHERO2) Then Return
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0305")
If _Sleep($DELAYUPGRADEHERO3) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeDarkBtn1")
Local $aHeroUpgradeWinChk[4] = [729, 128 + $g_iMidOffsetY, 0xCD161D, 20]
If _WaitForCheckPixel($aHeroUpgradeWinChk, $g_bCapturePixel,Default, "HeroUpgradeWinChk", Default, Default, 100) Then
If _ColorCheck(_GetPixelColor(691, 523 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(691, 527 + $g_iMidOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Hero Upgrade Fail #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & " No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0306")
Return False
Else
Click(660, 515 + $g_iMidOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($DELAYUPGRADEHERO1) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeDarkBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
SetLog("Upgrade Fail #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & " No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0309")
Return False
EndIf
SetLog("Hero Upgrade #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & " started", $COLOR_SUCCESS)
_GUICtrlSetImage($g_hPicUpgradeStatus[$inum], $g_sLibIconPath, $eIcnGreenLight)
$g_aiPicUpgradeStatus[$inum] = $eIcnGreenLight
GUICtrlSetData($g_hTxtUpgradeValue[$inum], -($g_avBuildingUpgrades[$inum][2]))
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], $g_avBuildingUpgrades[$inum][5] & "+")
$g_aiUpgradeLevel[$inum] = $g_avBuildingUpgrades[$inum][5] & "+"
If $g_abUpgradeRepeatEnable[$inum] = False Then
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_UNCHECKED)
$g_abBuildingUpgradeEnable[$inum] = False
$g_avBuildingUpgrades[$inum][0] = -1
$g_avBuildingUpgrades[$inum][1] = -1
$g_avBuildingUpgrades[$inum][3] = ""
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], $g_avBuildingUpgrades[$inum][5] & "+")
$g_avBuildingUpgrades[$inum][5] = $g_avBuildingUpgrades[$inum][5] & "+"
ElseIf $g_abUpgradeRepeatEnable[$inum] = True Then
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_CHECKED)
$g_abBuildingUpgradeEnable[$inum] = True
EndIf
ClickP($aAway, 2, 0, "#0310")
If _Sleep($DELAYUPGRADEHERO2) Then Return
Return True
EndIf
Else
SetLog("Upgrade #" & $inum + 1 & " window open fail", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0311")
EndIf
Else
SetLog("Upgrade #" & $inum + 1 & " Error finding button", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0312")
Return False
EndIf
EndFunc
Func SetlogUpgradeValues($i)
Local $j
For $j = 0 To UBound($g_avBuildingUpgrades, 2) - 1
SetLog("$g_avBuildingUpgrades[" & $i & "][" & $j & "]= " & $g_avBuildingUpgrades[$i][$j], $COLOR_DEBUG)
Next
SetLog("$g_hChkUpgrade= " & $g_abBuildingUpgradeEnable[$i], $COLOR_DEBUG)
SetLog("$g_hTxtUpgradeName= " & $g_avBuildingUpgrades[$i][4], $COLOR_DEBUG)
SetLog("$g_hTxtUpgradeLevel= " & $g_aiUpgradeLevel[$i], $COLOR_DEBUG)
SetLog("$g_hPicUpgradeType= " & $g_aiPicUpgradeStatus[$i], $COLOR_DEBUG)
SetLog("$g_hTxtUpgradeValue= " & $g_avBuildingUpgrades[$i][2], $COLOR_DEBUG)
SetLog("$g_hTxtUpgradeTime= " & $g_avBuildingUpgrades[$i][6], $COLOR_DEBUG)
SetLog("$g_hTxtUpgradeEndTime= " & $g_avBuildingUpgrades[$i][7], $COLOR_DEBUG)
SetLog("$g_hChkUpgradeRepeat= " & $g_abUpgradeRepeatEnable, $COLOR_DEBUG)
EndFunc
Func randomSleep($SleepTime, $Range = 0)
If $g_bRunState = False Then Return
If $Range = 0 Then $Range = Round($SleepTime / 5)
Local $SleepTimeF = Random($SleepTime - $Range, $SleepTime + $Range, 1)
If $g_bDebugClick Then SetLog("Default sleep : " & $SleepTime & " - Random sleep : " & $SleepTimeF, $COLOR_ORANGE)
If _Sleep($SleepTimeF) Then Return
EndFunc
Func AutoUpgrade($bTest = False)
Local $bWasRunState = $g_bRunState
$g_bRunState = True
Local $Result = _AutoUpgrade()
$g_bRunState = $bWasRunState
Return $Result
EndFunc
Func _AutoUpgrade()
If $g_iChkAutoUpgrade = 0 Then Return
SetLog("Entering Auto Upgrade...", $COLOR_INFO)
Local $iLoopAmount = 0
Local $iLoopMax = 6
While 1
$iLoopAmount += 1
If $iLoopAmount >= $iLoopMax Or $iLoopAmount >= 12 Then ExitLoop
ClickP($aAway, 1, 0, "#0000")
randomSleep($DELAYAUTOUPGRADEBUILDING1)
VillageReport()
If $g_iFreeBuilderCount < 1 Then
SetLog("No builder available... Skipping Auto Upgrade...", $COLOR_WARNING)
ExitLoop
EndIf
If $g_bUpgradeWallSaveBuilder And($g_iFreeBuilderCount < 2) Then
SetLog("The only builder available must be kept for walls... Skipping Auto Upgrade...", $COLOR_WARNING)
ExitLoop
EndIf
If Not(_ColorCheck(_GetPixelColor(275, 15, True), "F5F5ED", 20) = True) Then
SetLog("Unable to find the Builder menu button... Exiting Auto Upgrade...", $COLOR_ERROR)
ExitLoop
EndIf
Click(295, 30)
If _Sleep($DELAYAUTOUPGRADEBUILDING1) Then Return
If QuickMIS("BC1", $g_sImgAUpgradeZero, 180, 80 + $g_iNextLineOffset, 480, 350) Then
SetLog("Possible upgrade found !", $COLOR_SUCCESS)
$g_iCurrentLineOffset = $g_iNextLineOffset + $g_iQuickMISY
Else
SetLog("No upgrade available... Exiting Auto Upgrade...", $COLOR_INFO)
ExitLoop
EndIf
If QuickMIS("NX",$g_sImgAUpgradeObst, 180, 80 + $g_iCurrentLineOffset - 15, 480, 80 + $g_iCurrentLineOffset + 15) <> "none" Then
SetLog("This is a New Building or an Equipment, looking next...", $COLOR_WARNING)
$g_iNextLineOffset = $g_iCurrentLineOffset
ContinueLoop
EndIf
Click(180 + $g_iQuickMISX, 80 + $g_iCurrentLineOffset)
If _Sleep($DELAYAUTOUPGRADEBUILDING1) Then Return
If Not QuickMIS("BC1", $g_sImgAUpgradeUpgradeBtn, 120, 630, 740, 680) Then
SetLog("No upgrade here... Wrong click, looking next...", $COLOR_WARNING)
$g_iNextLineOffset = $g_iCurrentLineOffset
ContinueLoop
EndIf
$g_aUpgradeNameLevel = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If $g_aUpgradeNameLevel[0] = "" Then
SetLog("Error when trying to get upgrade name and level, looking next...", $COLOR_ERROR)
$g_iNextLineOffset = $g_iCurrentLineOffset
ContinueLoop
EndIf
Local $bMustIgnoreUpgrade = False
Switch $g_aUpgradeNameLevel[1]
Case "Town Hall"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[0] = 1) ? True : False
Case "Barbarian King"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[1] = 1 Or $g_bUpgradeKingEnable = True) ? True : False
Case "Archer Queen"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[2] = 1 Or $g_bUpgradeQueenEnable = True) ? True : False
Case "Grand Warden"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[3] = 1 Or $g_bUpgradeWardenEnable = True) ? True : False
Case "Clan Castle"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[4] = 1) ? True : False
Case "Laboratory"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[5] = 1) ? True : False
Case "Barracks"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[6] = 1) ? True : False
Case "Dark Barracks"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[7] = 1) ? True : False
Case "Spell Factory"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[8] = 1) ? True : False
Case "Dark Spell Factory"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[9] = 1) ? True : False
Case "Gold Mine"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[10] = 1) ? True : False
Case "Elixir Collector"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[11] = 1) ? True : False
Case "Dark Elixir Drill"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[12] = 1) ? True : False
Case Else
$bMustIgnoreUpgrade = False
EndSwitch
If $bMustIgnoreUpgrade = True Then
SetLog("This upgrade must be ignored, looking next...", $COLOR_WARNING)
$g_iNextLineOffset = $g_iCurrentLineOffset
ContinueLoop
EndIf
Click(120 + $g_iQuickMISX, 630 + $g_iQuickMISY)
If _Sleep($DELAYAUTOUPGRADEBUILDING1) Then Return
Switch $g_aUpgradeNameLevel[1]
Case "Barbarian King", "Archer Queen", "Grand Warden"
$g_aUpgradeResourceCostDuration[0] = QuickMIS("N1", $g_sImgAUpgradeRes, 690, 540, 730, 580)
$g_aUpgradeResourceCostDuration[1] = getResourcesBonus(598, 519 + $g_iMidOffsetY)
$g_aUpgradeResourceCostDuration[2] = getHeroUpgradeTime(464, 527 + $g_iMidOffsetY)
Case Else
$g_aUpgradeResourceCostDuration[0] = QuickMIS("N1", $g_sImgAUpgradeRes, 460, 510, 500, 550)
$g_aUpgradeResourceCostDuration[1] = getResourcesBonus(366, 487 + $g_iMidOffsetY)
$g_aUpgradeResourceCostDuration[2] = getBldgUpgradeTime(195, 307 + $g_iMidOffsetY)
EndSwitch
For $i = 0 To 2
If $g_aUpgradeResourceCostDuration[$i] = "" Then
SetLog("Error when trying to get upgrade details, looking next...", $COLOR_ERROR)
$g_iNextLineOffset = $g_iCurrentLineOffset
ContinueLoop 2
EndIf
Next
Local $bMustIgnoreResource = False
Switch $g_aUpgradeResourceCostDuration[0]
Case "Gold"
$bMustIgnoreResource =($g_iChkResourcesToIgnore[0] = 1) ? True : False
Case "Elixir"
$bMustIgnoreResource =($g_iChkResourcesToIgnore[1] = 1) ? True : False
Case "Dark Elixir"
$bMustIgnoreResource =($g_iChkResourcesToIgnore[2] = 1) ? True : False
Case Else
$bMustIgnoreResource = False
EndSwitch
If $bMustIgnoreResource = True Then
SetLog("This resource must be ignored, looking next...", $COLOR_WARNING)
$g_iNextLineOffset = $g_iCurrentLineOffset
ContinueLoop
EndIf
Local $bSufficentResourceToUpgrade = False
Switch $g_aUpgradeResourceCostDuration[0]
Case "Gold"
If $g_aiCurrentLoot[$eLootGold] >=($g_aUpgradeResourceCostDuration[1] + $g_iTxtSmartMinGold) Then $bSufficentResourceToUpgrade = True
Case "Elixir"
If $g_aiCurrentLoot[$eLootElixir] >=($g_aUpgradeResourceCostDuration[1] + $g_iTxtSmartMinElixir) Then $bSufficentResourceToUpgrade = True
Case "Dark Elixir"
If $g_aiCurrentLoot[$eLootDarkElixir] >=($g_aUpgradeResourceCostDuration[1] + $g_iTxtSmartMinDark) Then $bSufficentResourceToUpgrade = True
EndSwitch
If Not $bSufficentResourceToUpgrade Then
SetLog("Unsufficent " & $g_aUpgradeResourceCostDuration[0] & " to launch this upgrade, looking Next...", $COLOR_WARNING)
$g_iNextLineOffset = $g_iCurrentLineOffset
ContinueLoop
EndIf
Switch $g_aUpgradeNameLevel[1]
Case "Barbarian King", "Archer Queen", "Grand Warden"
Click(660, 560)
Case Else
Click(440, 530)
EndSwitch
$g_iCurrentLineOffset -= $g_iQuickMISY
$iLoopMax += 1
SetLog("Launched upgrade of " & $g_aUpgradeNameLevel[1] & " to level " & $g_aUpgradeNameLevel[2] + 1 & " successfully !", $COLOR_SUCCESS)
SetLog(" - Cost : " & _NumberFormat($g_aUpgradeResourceCostDuration[1]) & " " & $g_aUpgradeResourceCostDuration[0], $COLOR_SUCCESS)
SetLog(" - Duration : " & $g_aUpgradeResourceCostDuration[2], $COLOR_SUCCESS)
_GUICtrlEdit_AppendText($g_hTxtAutoUpgradeLog, @CRLF & _NowDate() & " " & _NowTime() & " - Upgrading " & $g_aUpgradeNameLevel[1] & " to level " & $g_aUpgradeNameLevel[2] + 1 & " for " & _NumberFormat($g_aUpgradeResourceCostDuration[1]) & " " & $g_aUpgradeResourceCostDuration[0] & " - Duration : " & $g_aUpgradeResourceCostDuration[2])
_FileWriteLog($g_sProfileLogsPath & "\AutoUpgradeHistory.log", "Upgrading " & $g_aUpgradeNameLevel[1] & " to level " & $g_aUpgradeNameLevel[2] + 1 & " for " & _NumberFormat($g_aUpgradeResourceCostDuration[1]) & " " & $g_aUpgradeResourceCostDuration[0] & " - Duration : " & $g_aUpgradeResourceCostDuration[2])
WEnd
$g_iCurrentLineOffset = 0
$g_iNextLineOffset = 0
SetLog("Auto Upgrade finished", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0000")
EndFunc
Func UpgradeWall()
If $g_bAutoUpgradeWallsEnable = True Then
SetLog("Checking Upgrade Walls", $COLOR_INFO)
If SkipWallUpgrade() Then Return
If $g_iFreeBuilderCount > 0 Then
ClickP($aAway, 1, 0, "#0313")
Local $MinWallGold = Number($g_aiCurrentLoot[$eLootGold] - $g_iWallCost) > Number($g_iUpgradeWallMinGold)
Local $MinWallElixir = Number($g_aiCurrentLoot[$eLootElixir] - $g_iWallCost) > Number($g_iUpgradeWallMinElixir)
While($g_iUpgradeWallLootType = 0 And $MinWallGold) Or($g_iUpgradeWallLootType = 1 And $MinWallElixir) Or($g_iUpgradeWallLootType = 2 And($MinWallGold Or $MinWallElixir))
Switch $g_iUpgradeWallLootType
Case 0
If $MinWallGold Then
SetLog("Upgrading Wall using Gold", $COLOR_SUCCESS)
If imglocCheckWall() Then
If Not UpgradeWallGold() Then
SetLog("Upgrade with Gold failed, skipping...", $COLOR_ERROR)
Return
EndIf
ElseIf SwitchToNextWallLevel() Then
SetLog("No more walls of current level, switching to next", $COLOR_ACTION)
Else
Return
EndIf
Else
SetLog("Gold is below minimum, Skipping Upgrade", $COLOR_ERROR)
EndIf
Case 1
If $MinWallElixir Then
SetLog("Upgrading Wall using Elixir", $COLOR_SUCCESS)
If imglocCheckWall() Then
If Not UpgradeWallElixir() Then
SetLog("Upgrade with Elixier failed, skipping...", $COLOR_ERROR)
Return
EndIf
ElseIf SwitchToNextWallLevel() Then
SetLog("No more walls of current level, switching to next", $COLOR_ACTION)
Else
Return
EndIf
Else
SetLog("Elixir is below minimum, Skipping Upgrade", $COLOR_ERROR)
EndIf
Case 2
If $MinWallElixir Then
SetLog("Upgrading Wall using Elixir", $COLOR_SUCCESS)
If imglocCheckWall() Then
If Not UpgradeWallElixir() Then
SetLog("Upgrade with Elixir failed, attempt to upgrade using Gold", $COLOR_ERROR)
If Not UpgradeWallGold() Then
SetLog("Upgrade with Gold failed, skipping...", $COLOR_ERROR)
Return
EndIf
EndIf
ElseIf SwitchToNextWallLevel() Then
SetLog("No more walls of current level, switching to next", $COLOR_ACTION)
Else
Return
EndIf
Else
SetLog("Elixir is below minimum, attempt to upgrade using Gold", $COLOR_ERROR)
If $MinWallGold Then
If imglocCheckWall() Then
If Not UpgradeWallGold() Then
SetLog("Upgrade with Gold failed, skipping...", $COLOR_ERROR)
Return
EndIf
ElseIf SwitchToNextWallLevel() Then
SetLog("No more walls of current level, switching to next", $COLOR_ACTION)
Else
Return
EndIf
Else
SetLog("Gold is below minimum, Skipping Upgrade", $COLOR_ERROR)
EndIf
EndIf
EndSwitch
If _CheckPixel($g_aShopWindowOpen, $g_bCapturePixel, Default, "ChkShopOpen", $COLOR_DEBUG) = True Then
Click(820, 40, 1, 0, "#0315")
EndIf
ClickP($aAway, 1, 0, "#0314")
VillageReport(True, True)
$MinWallGold = Number($g_aiCurrentLoot[$eLootGold] - $g_iWallCost) > Number($g_iUpgradeWallMinGold)
$MinWallElixir = Number($g_aiCurrentLoot[$eLootElixir] - $g_iWallCost) > Number($g_iUpgradeWallMinElixir)
WEnd
Else
SetLog("No free builder, Upgrade Walls skipped..", $COLOR_ERROR)
EndIf
EndIf
If _Sleep($DELAYUPGRADEWALL1) Then Return
checkMainScreen(False)
EndFunc
Func UpgradeWallGold()
If _Sleep($DELAYRESPOND) Then Return
Local $offColors[3][3] = [[0xD6714B, 47, 37], [0xF0E850, 70, 0], [0xF4F8F2, 79, 0]]
Local $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 650 + $g_iBottomOffsetY, 1, 1, Hex(0xF3F3F1, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Then
SetDebugLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetDebugLog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 47, $ButtonPixel[1] + 37, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 70, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0316")
If _Sleep($DELAYUPGRADEWALLGOLD2) Then Return
If _ColorCheck(_GetPixelColor(677, 150 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
If isNoUpgradeLoot(False) = True Then
SetLog("Upgrade stopped due no loot", $COLOR_ERROR)
Return False
EndIf
Click(440, 480 + $g_iMidOffsetY, 1, 0, "#0317")
If _Sleep(1000) Then Return
If isGemOpen(True) Then
ClickP($aAway, 1, 0, "#0314")
SetLog("Upgrade stopped due no loot", $COLOR_ERROR)
Return False
ElseIf _ColorCheck(_GetPixelColor(677, 150 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
ClickP($aAway, 1, 0, "#0314")
SetLog("unable to upgrade", $COLOR_ERROR)
Return False
Else
If _Sleep($DELAYUPGRADEWALLGOLD3) Then Return
SetLog("Upgrade complete", $COLOR_SUCCESS)
PushMsg("UpgradeWithGold")
$g_iNbrOfWallsUppedGold += 1
$g_iNbrOfWallsUpped += 1
$g_iCostGoldWall += $g_iWallCost
UpdateStats()
Return True
EndIf
EndIf
Else
SetLog("No Upgrade Gold Button", $COLOR_ERROR)
Pushmsg("NowUpgradeGoldButton")
Return False
EndIf
EndFunc
Func UpgradeWallElixir()
If _Sleep($DELAYRESPOND) Then Return
Local $offColors[3][3] = [[0xBC5B31, 38, 32], [0xF84CF9, 72, 0], [0xF5F9F2, 79, 0]]
Local $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 650 + $g_iBottomOffsetY, 1, 1, Hex(0xF4F7F2, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0322")
If _Sleep($DELAYUPGRADEWALLELIXIR2) Then Return
If _ColorCheck(_GetPixelColor(677, 150 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
If isNoUpgradeLoot(False) = True Then
SetLog("Upgrade stopped due to insufficient loot", $COLOR_ERROR)
Return False
EndIf
Click(440, 480 + $g_iMidOffsetY, 1, 0, "#0318")
If _Sleep(1000) Then Return
If isGemOpen(True) Then
ClickP($aAway, 1, 0, "#0314")
SetLog("Upgrade stopped due to insufficient loot", $COLOR_ERROR)
Return False
ElseIf _ColorCheck(_GetPixelColor(677, 150 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
ClickP($aAway, 1, 0, "#0314")
SetLog("unable to upgrade", $COLOR_ERROR)
Return False
Else
If _Sleep($DELAYUPGRADEWALLELIXIR3) Then Return
SetLog("Upgrade complete", $COLOR_SUCCESS)
PushMsg("UpgradeWithElixir")
$g_iNbrOfWallsUppedElixir += 1
$g_iNbrOfWallsUpped += 1
$g_iCostElixirWall += $g_iWallCost
UpdateStats()
Return True
EndIf
EndIf
Else
SetLog("No Upgrade Elixir Button", $COLOR_ERROR)
Pushmsg("NowUpgradeElixirButton")
Return False
EndIf
EndFunc
Func SkipWallUpgrade()
IniReadS($g_iUpgradeWallLootType, $g_sProfileConfigPath, "upgrade", "use-storage", "0")
Local $iUpgradeAction = 0
Local $iBuildingsNeedGold = 0
Local $iBuildingsNeedElixir = 0
Local $iAvailBuilderCount = 0
Switch $g_iTownHallLevel
Case 5 To 8
If $g_iTownHallLevel < $g_iCmbUpgradeWallsLevel + 4 Then
SetLog("Skip Wall upgrade -insufficient TH-Level", $COLOR_WARNING)
Return True
EndIf
Case 9 To 12
If $g_iTownHallLevel < $g_iCmbUpgradeWallsLevel + 3 Then
SetLog("Skip Wall upgrade -insufficient TH-Level", $COLOR_WARNING)
Return True
EndIf
Case Else
Return True
EndSwitch
If Not getBuilderCount() Then Return True
If _Sleep($DELAYRESPOND) Then Return True
$iAvailBuilderCount = $g_iFreeBuilderCount
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $g_abBuildingUpgradeEnable[$iz] = True Then $iUpgradeAction += 1
Next
If $g_iFreeBuilderCount >($g_bUpgradeWallSaveBuilder ? 1 : 0) And $iUpgradeAction > 0 Then
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $iAvailBuilderCount >($g_bUpgradeWallSaveBuilder ? 1 : 0) And $g_abBuildingUpgradeEnable[$iz] = True And $g_avBuildingUpgrades[$iz][7] = "" Then
Switch $g_avBuildingUpgrades[$iz][3]
Case "Gold"
$iBuildingsNeedGold += Number($g_avBuildingUpgrades[$iz][2])
$iAvailBuilderCount -= 1
Case "Elixir"
$iBuildingsNeedElixir += Number($g_avBuildingUpgrades[$iz][2])
$iAvailBuilderCount -= 1
EndSwitch
EndIf
Next
SetLog("SkipWall-Upgrade Summary: G:" & $iBuildingsNeedGold & ", E:" & $iBuildingsNeedElixir & ", Wall: " & $g_iWallCost & ", MinG: " & $g_iUpgradeWallMinGold & ", MinE: " & $g_iUpgradeWallMinElixir)
If $iBuildingsNeedGold > 0 Or $iBuildingsNeedElixir > 0 Then
Switch $g_iUpgradeWallLootType
Case 0
If $g_aiCurrentLoot[$eLootGold] -($iBuildingsNeedGold + $g_iWallCost + Number($g_iUpgradeWallMinGold)) < 0 Then
SetLog("Skip Wall upgrade -insufficient gold for selected upgrades", $COLOR_WARNING)
Return True
EndIf
Case 1
If $g_aiCurrentLoot[$eLootElixir] -($iBuildingsNeedElixir + $g_iWallCost + Number($g_iUpgradeWallMinElixir)) < 0 Then
SetLog("Skip Wall upgrade - insufficient elixir for selected upgrades", $COLOR_WARNING)
Return True
EndIf
Case 2
If $g_aiCurrentLoot[$eLootGold] -($iBuildingsNeedGold + $g_iWallCost + Number($g_iUpgradeWallMinGold)) < 0 Then
SetLog("Wall upgrade: insufficient gold for selected upgrades", $COLOR_WARNING)
If $g_aiCurrentLoot[$eLootElixir] -($iBuildingsNeedElixir + $g_iWallCost + Number($g_iUpgradeWallMinElixir)) >= 0 Then
SetLog("Using Elixir only for wall Upgrade", $COLOR_SUCCESS1)
$g_iUpgradeWallLootType = 1
Else
SetLog("Skip Wall upgrade -insufficient resources for selected upgrades", $COLOR_WARNING)
Return True
EndIf
EndIf
If $g_aiCurrentLoot[$eLootElixir] -($iBuildingsNeedElixir + $g_iWallCost + Number($g_iUpgradeWallMinElixir)) < 0 Then
SetLog("Wall upgrade: insufficient elixir for selected upgrades", $COLOR_WARNING)
If $g_aiCurrentLoot[$eLootGold] -($iBuildingsNeedGold + $g_iWallCost + Number($g_iUpgradeWallMinGold)) >= 0 Then
SetLog("Using Gold only for Wall Upgrade", $COLOR_SUCCESS1)
$g_iUpgradeWallLootType = 0
Else
SetLog("Skip Wall upgrade -insufficient resources for selected upgrades", $COLOR_WARNING)
Return True
EndIf
EndIf
EndSwitch
EndIf
If _Sleep($DELAYRESPOND) Then Return True
EndIf
If($g_iWardenLevel <> -1) And($g_iWardenLevel < $g_iMaxWardenLevel) And $g_bUpgradeWardenEnable And($g_iFreeBuilderCount >($g_bUpgradeWallSaveBuilder ? 1 : 0)) Then
Local $bMinWardenElixir = Number($g_aiCurrentLoot[$eLootElixir]) >($g_iWallCost + $g_afWardenUpgCost[$g_iWardenLevel] * 1000000 + Number($g_iUpgradeWallMinElixir))
If Not $bMinWardenElixir Then
Switch $g_iUpgradeWallLootType
Case 1
SetLog("Grand Warden needs " &($g_afWardenUpgCost[$g_iWardenLevel] * 1000000) & " Elixir for next Level", $COLOR_WARNING)
SetLog("Skipping Wall Upgrade", $COLOR_WARNING)
Return True
Case 2
SetLog("Grand Warden needs " &($g_afWardenUpgCost[$g_iWardenLevel] * 1000000) & " Elixir for next Level", $COLOR_SUCCESS1)
SetLog("Using Gold only for Wall Upgrade", $COLOR_SUCCESS1)
$g_iUpgradeWallLootType = 0
EndSwitch
EndIf
EndIf
Local $bMinWallElixir = Number($g_aiCurrentLoot[$eLootElixir]) >($g_iWallCost + Number($g_iLaboratoryElixirCost) + Number($g_iUpgradeWallMinElixir))
If $g_bAutoLabUpgradeEnable And $g_iCmbLaboratory >= 1 And $g_iCmbLaboratory <= 18 And Not $bMinWallElixir Then
For $i = 1 To 18
If $g_iCmbLaboratory = $i Then
Local $sName = $g_avLabTroops[$i][3]
ExitLoop
EndIf
Next
Local $LabElixirNeeded = $g_iLaboratoryElixirCost
If $LabElixirNeeded = 0 Then $LabElixirNeeded = "unknown"
Switch $g_iUpgradeWallLootType
Case 0
Case 1
SetLog("Laboratory needs " & $LabElixirNeeded & " Elixir to Upgrade:  " & $sName, $COLOR_SUCCESS1)
SetLog("Skipping Wall Upgrade", $COLOR_SUCCESS1)
Return True
Case 2
SetLog("Laboratory needs " & $LabElixirNeeded & " Elixir to Upgrade:  " & $sName, $COLOR_SUCCESS1)
SetLog("Using Gold only for Wall Upgrade", $COLOR_SUCCESS1)
$g_iUpgradeWallLootType = 0
EndSwitch
EndIf
Return False
EndFunc
Func SwitchToNextWallLevel()
If $g_aiWallsCurrentCount[$g_iCmbUpgradeWallsLevel + 4] = 0 And $g_iCmbUpgradeWallsLevel < 7 Then
EnableGuiControls()
_GUICtrlComboBox_SetCurSel($g_hCmbWalls, $g_iCmbUpgradeWallsLevel + 1)
cmbWalls()
SaveConfig()
DisableGuiControls()
Return True
EndIf
Return False
EndFunc
Func NotifyRemoteControl()
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyRemoteControl()")
If $g_bNotifyRemoteEnable = True Then NotifyRemoteControlProc()
EndFunc
Func NotifyReport()
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyReport()")
If $g_bNotifyAlertVillageReport = True Then
NotifylPushBulletMessage($g_sNotifyOrigin & ":" & "\n" & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-G_Info_01", "G") & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootGold]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-E_Info_01", "E") & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-DE_Info_01", "DE") & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir]) & "  [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-T_Info_01", "T") & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootTrophy]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Free-Builders_Info_01", "No. of Free Builders") & "]: " & _NumberFormat($g_iFreeBuilderCount))
EndIf
If $g_bNotifyAlertLastAttack = True Then
If Not($g_iStatsLastAttack[$eLootGold] = "" And $g_iStatsLastAttack[$eLootElixir] = "") Then NotifylPushBulletMessage($g_sNotifyOrigin & " | Last Gain :" & "\n" & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-G_Info_01", "G") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootGold]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-E_Info_01", "E") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-DE_Info_01", "DE") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootDarkElixir]) & "  [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-T_Info_01", "T") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootTrophy]))
EndIf
If _Sleep($DELAYNOTIFY1) Then Return
checkMainScreen(False)
EndFunc
Func _DeletePush()
If $g_bDebugSetlog Then SetDebugLog("Notify | _DeletePush()")
NotifyDeletePushBullet()
SetLog("Delete all previous PushBullet messages...", $COLOR_INFO)
EndFunc
Func PushMsg($Message, $Source = "")
If $g_bDebugSetlog Then SetDebugLog("Notify | PushMsg()")
NotifyPushMessageToBoth($Message, $Source)
EndFunc
Func _DeleteOldPushes()
If $g_bDebugSetlog Then SetDebugLog("Notify | _DeleteOldPushes()")
NotifyDeleteOldPushesFromPushBullet()
EndFunc
Func _GetDateFromUnix($nPosix)
If $g_bDebugSetlog Then SetDebugLog("Notify | _GetDateFromUnix($nPosix): " & $nPosix)
Local $nYear = 1970, $nMon = 1, $nDay = 1, $nHour = 00, $nMin = 00, $nSec = 00, $aNumDays = StringSplit("31,28,31,30,31,30,31,31,30,31,30,31", ",")
While 1
If(Mod($nYear + 1, 400) = 0) Or(Mod($nYear + 1, 4) = 0 And Mod($nYear + 1, 100) <> 0) Then
If $nPosix < 31536000 + 86400 Then ExitLoop
$nPosix -= 31536000 + 86400
$nYear += 1
Else
If $nPosix < 31536000 Then ExitLoop
$nPosix -= 31536000
$nYear += 1
EndIf
WEnd
While $nPosix > 86400
$nPosix -= 86400
$nDay += 1
WEnd
While $nPosix > 3600
$nPosix -= 3600
$nHour += 1
WEnd
While $nPosix > 60
$nPosix -= 60
$nMin += 1
WEnd
$nSec = $nPosix
For $i = 1 To 12
If $nDay < $aNumDays[$i] Then ExitLoop
$nDay -= $aNumDays[$i]
$nMon += 1
Next
Return $nYear & "-" & $nMon & "-" & $nDay & " " & $nHour & ":" & $nMin & ":" & StringFormat("%02i", $nSec)
EndFunc
Func NotifyPendingActions()
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyPendingActions()")
If($g_bNotifyPBEnable = False Or $g_sNotifyPBToken = "") And($g_bNotifyTGEnable = False Or $g_sNotifyTGToken = "") Then Return
NotifyRemoteControl()
If $g_bPBRequestScreenshot = True Or $g_bTGRequestScreenshot = True Then
$g_bNotifyForced = True
PushMsg("RequestScreenshot")
EndIf
If $g_bPBRequestBuilderInfo = True Or $g_bTGRequestBuilderInfo = True Then
$g_bNotifyForced = True
PushMsg("BuilderInfo")
EndIf
If $g_bPBRequestShieldInfo = True Or $g_bTGRequestShieldInfo = True Then
$g_bNotifyForced = True
PushMsg("ShieldInfo")
EndIf
PushMsg("BuilderIdle")
EndFunc
Func PushBulletDeleteOldPushes()
If $g_bDebugSetlog Then SetDebugLog("Notify | PushBulletDeleteOldPushes()")
If $g_bNotifyPBEnable = True And $g_bNotifyDeletePushesOlderThan = True Then _DeleteOldPushes()
EndFunc
Func NotifylPushBulletMessage($pMessage = "")
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifylPushBulletMessage($pMessage): " & $pMessage)
If(Not $g_bNotifyPBEnable Or $g_sNotifyPBToken = "") And(Not $g_bNotifyTGEnable Or $g_sNotifyTGToken = "") Then Return
If Not $g_bNotifyForced Then
If $g_bNotifyScheduleWeekDaysEnable Then
If $g_abNotifyScheduleWeekDays[@WDAY - 1] Then
If $g_bNotifyScheduleHoursEnable Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If Not $g_abNotifyScheduleHours[$hour[0]] Then
SetLog("Notify not planned for this hour! Notification skipped", $COLOR_ORANGE)
SetLog($pMessage, $COLOR_WARNING)
Return
EndIf
EndIf
Else
Return
EndIf
Else
If $g_bNotifyScheduleHoursEnable Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If Not $g_abNotifyScheduleHours[$hour[0]] Then
SetLog("Notify not planned for this hour! Notification skipped", $COLOR_ORANGE)
SetLog($pMessage, $COLOR_WARNING)
Return
EndIf
EndIf
EndIf
EndIf
If $g_bNotifyPBEnable And $g_sNotifyPBToken <> "" Then
$g_bNotifyForced = False
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("PushBullet Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
$oHTTP.Open("Get", "https://api.pushbullet.com/v2/devices", False)
$oHTTP.SetCredentials($g_sNotifyPBToken, "", 0)
$oHTTP.Send()
$oHTTP.WaitForResponse
Local $Result = $oHTTP.ResponseText
If $oHTTP.Status <> 200 Then
SetLog("PushBullet status is: " & $oHTTP.Status, $COLOR_ERROR)
Return
EndIf
Local $g_sAnotherDevice_iden = _StringBetween($Result, 'iden":"', '"')
Local $g_sAnotherDevice_name = _StringBetween($Result, 'nickname":"', '"')
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/pushes", False)
$oHTTP.SetCredentials($g_sNotifyPBToken, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
Local $pPush = '{"type": "note", "body": "' & $pMessage & "\n" & $Date & "__" & $Time & '"}'
$oHTTP.Send($pPush)
EndIf
If $g_bNotifyTGEnable And $g_sNotifyTGToken <> "" Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("Telegram Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
$oHTTP.Open("Get", "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/getupdates", False)
$oHTTP.Send()
$oHTTP.WaitForResponse
Local $Result = $oHTTP.ResponseText
If $oHTTP.Status <> 200 Then
SetLog("Telegram status is: " & $oHTTP.Status, $COLOR_ERROR)
Return
EndIf
Local $chat_id = _StringBetween($Result, 'm":{"id":', ',"f')
$g_sTGChatID = _ArrayPop($chat_id)
$oHTTP.Open("Post", "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/sendmessage", False)
$oHTTP.SetRequestHeader("Content-Type", "application/json; charset=ISO-8859-1,utf-8")
Local $Date = @YEAR & '-' & @MON & '-' & @MDAY
Local $Time = @HOUR & '.' & @MIN
Local $TGPushMsg = '{"text":"' & $pMessage & '\n' & $Date & '__' & $Time & '", "chat_id":' & $g_sTGChatID & '}}'
$oHTTP.Send($TGPushMsg)
$oHTTP.WaitForResponse
EndIf
EndFunc
Func NotifyPushToPushBullet($pMessage)
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyPushToPushBullet($pMessage): " & $pMessage)
If(Not $g_bNotifyPBEnable Or $g_sNotifyPBToken = "") And(Not $g_bNotifyTGEnable Or $g_sNotifyTGToken = "") Then Return
If $g_bNotifyPBEnable And $g_sNotifyPBToken <> "" Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("PushBullet Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/pushes", False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
Local $pPush = '{"type": "note", "body": "' & $pMessage & "\n" & $Date & "__" & $Time & '"}'
$oHTTP.Send($pPush)
$oHTTP.WaitForResponse
EndIf
EndFunc
Func NotifyDeletePushBullet()
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyDeletePushBullet()")
If Not $g_bNotifyPBEnable Or $g_sNotifyPBToken = "" Then Return
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("PushBullet Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
$oHTTP.Open("DELETE", "https://api.pushbullet.com/v2/pushes", False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
$oHTTP.Send()
$oHTTP.WaitForResponse
EndFunc
Func NotifyDeleteMessageFromPushBullet($iden)
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyDeleteMessageFromPushBullet($iden): " & $iden)
If Not $g_bNotifyPBEnable Or $g_sNotifyPBToken = "" Then Return
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("PushBullet Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
$oHTTP.Open("Delete", "https://api.pushbullet.com/v2/pushes/" & $iden, False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
$oHTTP.Send()
$oHTTP.WaitForResponse
$iden = ""
EndFunc
Func NotifyDeleteOldPushesFromPushBullet()
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyDeleteOldPushesFromPushBullet()")
If Not $g_bNotifyPBEnable Or $g_sNotifyPBToken = "" Or Not $g_bNotifyDeletePushesOlderThan Then Return
Local $tLocal = _Date_Time_GetLocalTime()
Local $tSystem = _Date_Time_TzSpecificLocalTimeToSystemTime(DllStructGetPtr($tLocal))
Local $timeUTC = _Date_Time_SystemTimeToDateTimeStr($tSystem, 1)
Local $timestamplimit = 0
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("PushBullet Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
$oHTTP.Open("Get", "https://api.pushbullet.com/v2/pushes?active=true&modified_after=" & $timestamplimit, False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
$oHTTP.Send()
$oHTTP.WaitForResponse
Local $Result = $oHTTP.ResponseText
If $oHTTP.Status <> 200 Then
SetLog("PushBullet status is: " & $oHTTP.Status, $COLOR_ERROR)
Return
EndIf
Local $findstr = StringRegExp($Result, ',"created":')
Local $msgdeleted = 0
If $findstr = 1 Then
Local $body = _StringBetween($Result, '"body":"', '"', "", False)
Local $iden = _StringBetween($Result, '"iden":"', '"', "", False)
Local $created = _StringBetween($Result, '"created":', ',', "", False)
If IsArray($body) And IsArray($iden) And IsArray($created) Then
For $x = 0 To UBound($created) - 1
If $iden <> "" And $created <> "" Then
Local $hdif = _DateDiff('h', _GetDateFromUnix($created[$x]), $timeUTC)
If $hdif >= $g_iNotifyDeletePushesOlderThanHours Then
$msgdeleted += 1
NotifyDeleteMessageFromPushBullet($iden[$x])
EndIf
EndIf
$body[$x] = ""
$iden[$x] = ""
Next
EndIf
EndIf
If $msgdeleted > 0 Then
SetLog("Notify PushBullet: removed " & $msgdeleted & " messages older than " & $g_iNotifyDeletePushesOlderThanHours & " h ", $COLOR_SUCCESS)
EndIf
EndFunc
Func NotifyPushFileToPushBullet($File, $Folder, $FileType, $body)
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyPushFileToPushBullet($File, $Folder, $FileType, $body): " & $File & "," & $Folder & "," & $FileType & "," & $body)
If(Not $g_bNotifyPBEnable Or $g_sNotifyPBToken = "") And(Not $g_bNotifyTGEnable Or $g_sNotifyTGToken = "") Then Return
If $g_bNotifyPBEnable = True And $g_sNotifyPBToken <> "" Then
If FileExists($g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File) Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("PushBullet Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/upload-request", False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"file_name": "' & $File & '", "file_type": "' & $FileType & '"}'
$oHTTP.Send($pPush)
$oHTTP.WaitForResponse
Local $Result = $oHTTP.ResponseText
If $oHTTP.Status <> 200 Then
SetLog("PushBullet status is: " & $oHTTP.Status, $COLOR_ERROR)
Return
EndIf
Local $upload_url = _StringBetween($Result, 'upload_url":"', '"')
Local $awsaccesskeyid = _StringBetween($Result, 'awsaccesskeyid":"', '"')
Local $acl = _StringBetween($Result, 'acl":"', '"')
Local $key = _StringBetween($Result, 'key":"', '"')
Local $signature = _StringBetween($Result, 'signature":"', '"')
Local $policy = _StringBetween($Result, 'policy":"', '"')
Local $file_url = _StringBetween($Result, 'file_url":"', '"')
If IsArray($upload_url) And IsArray($awsaccesskeyid) And IsArray($acl) And IsArray($key) And IsArray($signature) And IsArray($policy) Then
$Result = RunWait($g_sCurlPath & " -i -X POST " & $upload_url[0] & ' -F awsaccesskeyid="' & $awsaccesskeyid[0] & '" -F acl="' & $acl[0] & '" -F key="' & $key[0] & '" -F signature="' & $signature[0] & '" -F policy="' & $policy[0] & '" -F content-type="' & $FileType & '" -F file=@"' & $g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File & '"', "", @SW_HIDE)
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/pushes", False)
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"type": "file", "file_name": "' & $File & '", "file_type": "' & $FileType & '", "file_url": "' & $file_url[0] & '", "body": "' & $body & '"}'
$oHTTP.Send($pPush)
Else
SetLog("Notify PushBullet: Unable to send file " & $File, $COLOR_ERROR)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_03", "Unable to Upload File") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_04", "Occured an error type") & " 1 " & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_01", "uploading file to PushBullet server") & "...")
EndIf
Else
SetLog("Notify PushBullet: Unable to send file " & $File, $COLOR_ERROR)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_03", "Unable to Upload File") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_04", "Occured an error type") & " 2 " & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_01", "uploading file to PushBullet server") & "...")
EndIf
EndIf
EndFunc
Func NotifyPushToTelegram($pMessage)
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyPushToTelegram($pMessage): " & $pMessage)
If(Not $g_bNotifyPBEnable Or $g_sNotifyPBToken = "") And(Not $g_bNotifyTGEnable Or $g_sNotifyTGToken = "") Then Return
If $g_bNotifyTGEnable And $g_sNotifyTGToken <> "" Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("Telegram Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
Local $url = "https://api.telegram.org/bot"
$oHTTP.Open("Post", $url & $g_sNotifyTGToken & "/sendMessage", False)
$oHTTP.SetRequestHeader("Content-Type", "application/json; charset=ISO-8859-1,utf-8")
Local $Date = @YEAR & '-' & @MON & '-' & @MDAY
Local $Time = @HOUR & '.' & @MIN
Local $TGPushMsg = '{"text":"' & $pMessage & '\n' & $Date & '__' & $Time & '", "chat_id":' & $g_sTGChatID & '}}'
$oHTTP.Send($TGPushMsg)
EndIf
EndFunc
Func NotifyPushFileToTelegram($File, $Folder, $FileType, $body)
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyPushFileToTelegram($File, $Folder, $FileType, $body): " & $File & "," & $Folder & "," & $FileType & "," & $body)
If(Not $g_bNotifyPBEnable Or $g_sNotifyPBToken = "") And(Not $g_bNotifyTGEnable Or $g_sNotifyTGToken = "") Then Return
If $g_bNotifyTGEnable And $g_sNotifyTGToken <> "" Then
If FileExists($g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File) Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("Telegram Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
Local $sCmd = "/sendPhoto"
Local $sCmd1 = "photo"
If $FileType = "text\/plain; charset=utf-8" Then
$sCmd = "/sendDocument"
$sCmd1 = "document"
EndIf
Local $telegram_url = "https://api.telegram.org/bot" & $g_sNotifyTGToken & $sCmd
Local $Result = RunWait($g_sCurlPath & " -i -X POST " & $telegram_url & ' -F chat_id="' & $g_sTGChatID & '" -F ' & $sCmd1 & '=@"' & $g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File & '"', "", @SW_HIDE)
$oHTTP.Open("Post", "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/sendMessage", False)
$oHTTP.SetRequestHeader("Content-Type", "application/json; charset=ISO-8859-1,utf-8")
Local $pPush = '{"text":"' & $body & '", "chat_id":' & $g_sTGChatID & '}}'
$oHTTP.Send($pPush)
$oHTTP.WaitForResponse
If $g_bDebugSetlog Then SetDebugLog("$oHTTP.ResponseText: " & $oHTTP.ResponseText)
Else
SetLog("Notify Telegram: Unable to send file " & $File, $COLOR_ERROR)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_03", "Unable to Upload File") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_02", "Occured an error type 2 uploading file to Telegram server..."))
EndIf
EndIf
EndFunc
Func NotifyGetLastMessageFromTelegram()
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyGetLastMessageFromTelegram()")
Local $TGLastMessage = ""
If Not $g_bNotifyTGEnable Or $g_sNotifyTGToken = "" Then Return
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("Telegram Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
$oHTTP.Open("Get", "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/getupdates", False)
$oHTTP.Send()
$oHTTP.WaitForResponse
Local $Result = $oHTTP.ResponseText
If $oHTTP.Status <> 200 Then
SetLog("Telegram status is: " & $oHTTP.Status, $COLOR_ERROR)
Return
EndIf
Local $chat_id = _StringBetween($Result, 'm":{"id":', ',"f')
$g_sTGChatID = _ArrayPop($chat_id)
If $g_bDebugSetlog Then SetDebugLog("Telegram $g_sTGChatID:" & $g_sTGChatID)
Local $uid = _StringBetween($Result, 'update_id":', '"message"')
$g_sTGLast_UID = StringTrimRight(_ArrayPop($uid), 2)
Local $findstr2 = StringRegExp(StringUpper($Result), '"TEXT":"')
If $findstr2 = 1 Then
Local $rmessage = _StringBetween($Result, 'text":"', '"}}')
$TGLastMessage = _ArrayPop($rmessage)
If $g_bDebugSetlog Then SetDebugLog("Telegram $TGLastMessage:" & $TGLastMessage)
EndIf
If $g_bDebugSetlog Then SetDebugLog("Telegram $g_sTGLast_UID:" & $g_sTGLast_UID)
$oHTTP.Open("Get", "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/getupdates?offset=" & $g_sTGLast_UID, False)
$oHTTP.Send()
$oHTTP.WaitForResponse
Local $Result2 = $oHTTP.ResponseText
If $oHTTP.Status <> 200 Then
SetLog("Telegram status is: " & $oHTTP.Status, $COLOR_ERROR)
Return
EndIf
Local $findstr2 = StringRegExp(StringUpper($Result2), '"TEXT":"')
If $findstr2 = 1 Then
Local $rmessage = _StringBetween($Result2, 'text":"', '"}}')
$TGLastMessage = _ArrayPop($rmessage)
If $TGLastMessage = "" Then
Local $rmessage = _StringBetween($Result2, 'text":"', '","entities"')
$TGLastMessage = _ArrayPop($rmessage)
EndIf
If $g_bDebugSetlog Then SetDebugLog("Telegram - $TGLastMessage:" & $TGLastMessage)
Return $TGLastMessage
EndIf
EndFunc
Func _IsInternet()
Local $Ret = DllCall('wininet.dll', 'int', 'InternetGetConnectedState', 'dword*', 0x20, 'dword', 0)
If @error Then
Return SetError(1, 0, 0)
EndIf
Local $Error = _WinAPI_GetLastError()
Return SetError((Not($Error = 0)), $Error, $Ret[0])
EndFunc
Func NotifyGetLastMessageFromTelegramBtnStart()
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyGetLastMessageFromTelegramBtnStart()")
Local $TGLastMessage = ""
If Not $g_bNotifyTGEnable Or $g_sNotifyTGToken = "" Then Return
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("Telegram Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
$oHTTP.Open("Get", "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/getupdates", False)
Execute('$oHTTP.Send()')
$oHTTP.WaitForResponse
Local $Result = Execute('$oHTTP.ResponseText')
Local $chat_id = _StringBetween($Result, 'm":{"id":', ',"f')
$g_sTGChatID = _ArrayPop($chat_id)
If $g_bDebugSetlog Then SetDebugLog("Telegram $g_sTGChatID:" & $g_sTGChatID)
Local $uid = _StringBetween($Result, 'update_id":', '"message"')
$g_sTGLast_UID = StringTrimRight(_ArrayPop($uid), 2)
Local $findstr2 = StringRegExp(StringUpper($Result), '"TEXT":"')
If $findstr2 = 1 Then
Local $rmessage = _StringBetween($Result, 'text":"', '"}}')
$TGLastMessage = _ArrayPop($rmessage)
If $g_bDebugSetlog Then SetDebugLog("Telegram $TGLastMessage:" & $TGLastMessage)
EndIf
If $g_bDebugSetlog Then SetDebugLog("Telegram $g_sTGLast_UID:" & $g_sTGLast_UID)
$oHTTP.Open("Get", "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/getupdates?offset=" & $g_sTGLast_UID, False)
Execute('$oHTTP.Send()')
$oHTTP.WaitForResponse
Local $Result2 = Execute('$oHTTP.ResponseText')
If _IsInternet() < 1 Then
SetLog("Telegram: Check your internet connection! No Connection..", $COLOR_ERROR)
Return
EndIf
Local $findstr2 = StringRegExp(StringUpper($Result2), '"TEXT":"')
If $findstr2 = 1 Then
Local $rmessage = _StringBetween($Result2, 'text":"', '"}}')
$TGLastMessage = _ArrayPop($rmessage)
If $TGLastMessage = "" Then
Local $rmessage = _StringBetween($Result2, 'text":"', '","entities"')
$TGLastMessage = _ArrayPop($rmessage)
EndIf
If $g_bDebugSetlog Then SetDebugLog("Telegram - $TGLastMessage:" & $TGLastMessage)
Return $TGLastMessage
EndIf
EndFunc
Func NotifyActivateKeyboardOnTelegram($TGMsg)
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyActivateKeyboardOnTelegram($TGMsg): " & $TGMsg)
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("Telegram Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
Local $url = "https://api.telegram.org/bot"
$oHTTP.Open("Post", $url & $g_sNotifyTGToken & "/sendMessage", False)
$oHTTP.SetRequestHeader("Content-Type", "application/json; charset=ISO-8859-1,utf-8")
Local $TGPushMsg = '{"text": "' & $TGMsg & '", "chat_id":' & $g_sTGChatID & ', "reply_markup": {"keyboard": [["' & '\ud83d\udcf7 ' & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT", "SCREENSHOT") & '","' & '\ud83d\udd28 ' & GetTranslatedFileIni("MBR Func_Notify", "BUILDER", "BUILDER") & '","' & '\ud83d\udd30 ' & GetTranslatedFileIni("MBR Func_Notify", "SHIELD", "SHIELD") & '"],["' & '\ud83d\udcc8 ' & GetTranslatedFileIni("MBR Func_Notify", "STATS", "STATS") & '","' & '\ud83d\udcaa ' & GetTranslatedFileIni("MBR Func_Notify", "TROOPS", "TROOPS") & '","' & '\u2753 ' & GetTranslatedFileIni("MBR Func_Notify", "HELP", "HELP") & '"],["' & '\u25aa ' & GetTranslatedFileIni("MBR Func_Notify", "STOP", "STOP") & '","' & '\u25b6 ' & GetTranslatedFileIni("MBR Func_Notify", "START", "START") & '","' & '\ud83d\udd00 ' & GetTranslatedFileIni("MBR Func_Notify", "PAUSE", "PAUSE") & '","' & '\u25b6 ' & GetTranslatedFileIni("MBR Func_Notify", "RESUME", "RESUME") & '","' & '\ud83d\udd01 ' & GetTranslatedFileIni("MBR Func_Notify", "RESTART", "RESTART") & '"],["' & '\ud83d\udccb ' & GetTranslatedFileIni("MBR Func_Notify", "LOG", "LOG") & '","' & '\ud83c\udf04 ' & GetTranslatedFileIni("MBR Func_Notify", "LASTRAID", "LASTRAID") & '","' & '\ud83d\udcc4 ' & GetTranslatedFileIni("MBR Func_Notify", "LASTRAIDTXT", "LASTRAIDTXT") & '"],["' & '\u2705 ' & GetTranslatedFileIni("MBR Func_Notify", "ATTACK ON_Info_01", "ATTACK ON") & '","' & '\u274C ' & GetTranslatedFileIni("MBR Func_Notify", "ATTACK OFF", "ATTACK OFF") & '"],["' & '\ud83d\udca4 ' & GetTranslatedFileIni("MBR Func_Notify", "HIBERNATE", "HIBERNATE") & '","' & '\u26a1 ' & GetTranslatedFileIni("MBR Func_Notify", "SHUTDOWN", "SHUTDOWN") & '","' & '\ud83d\udd06 ' & GetTranslatedFileIni("MBR Func_Notify", "STANDBY", "STANDBY") & '"]],"one_time_keyboard": false,"resize_keyboard":true}}'
$oHTTP.Send($TGPushMsg)
$g_iTGLastRemote = $g_sTGLast_UID
EndFunc
Func NotifyRemoteControlProcBtnStart()
Local $bWasSilent = SetDebugLogSilent()
If $g_bNotifyTGEnable And $g_sNotifyTGToken <> "" Then
$g_sTGLastMessage = NotifyGetLastMessageFromTelegramBtnStart()
Local $TGActionMSG = StringUpper(StringStripWS($g_sTGLastMessage, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES))
If $g_bDebugSetlog Then SetDebugLog("Telegram | NotifyRemoteControlProcBtnStart $TGActionMSG : " & $TGActionMSG)
If $g_bDebugSetlog Then SetDebugLog("Telegram | NotifyRemoteControlProcBtnStart $g_iTGLastRemote : " & $g_iTGLastRemote)
If $g_bDebugSetlog Then SetDebugLog("Telegram | NotifyRemoteControlProcBtnStart $g_sTGLast_UID : " & $g_sTGLast_UID)
If $g_iTGLastRemote <> $g_sTGLast_UID Then
$g_iTGLastRemote = $g_sTGLast_UID
Switch $TGActionMSG
Case GetTranslatedFileIni("MBR Func_Notify", "START", "START"), '\u25b6 ' & GetTranslatedFileIni("MBR Func_Notify", "START", "START")
btnStart()
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Start_Info_01", "Request to Start...") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-Start_Info_02", "Your bot is now started..."))
EndSwitch
EndIf
EndIf
SetDebugLogSilent($bWasSilent)
EndFunc
Func NotifyRemoteControlProc()
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyRemoteControlProc()")
Static $pushLastModified = 0
If(Not $g_bNotifyPBEnable And Not $g_bNotifyTGEnable) Or Not $g_bNotifyRemoteEnable Then Return
If $g_bNotifyPBEnable And $g_sNotifyPBToken <> "" Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
Local $pushbulletApiUrl
If $pushLastModified = 0 Then
$pushbulletApiUrl = "https://api.pushbullet.com/v2/pushes?active=true&limit=1"
Else
$pushbulletApiUrl = "https://api.pushbullet.com/v2/pushes?active=true&modified_after=" & $pushLastModified
EndIf
$oHTTP.Open("Get", $pushbulletApiUrl, False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
$oHTTP.Send()
$oHTTP.WaitForResponse
Local $Result = $oHTTP.ResponseText
If $oHTTP.Status <> 200 Then
SetLog("PushBullet status is: " & $oHTTP.Status, $COLOR_ERROR)
Return
EndIf
Local $modified = _StringBetween($Result, '"modified":', ',', "", False)
If UBound($modified) > 0 Then
$pushLastModified = Number($modified[0])
$pushLastModified -= 120
EndIf
Local $findstr = StringRegExp(StringUpper($Result), '"BODY":"BOT')
If $findstr = 1 Then
Local $body = _StringBetween($Result, '"body":"', '"', "", False)
Local $iden = _StringBetween($Result, '"iden":"', '"', "", False)
For $x = UBound($body) - 1 To 0 Step -1
If $body <> "" Or $iden <> "" Then
$body[$x] = StringUpper(StringStripWS($body[$x], $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES))
$iden[$x] = StringStripWS($iden[$x], $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES)
$g_bNotifyForced = True
Switch $body[$x]
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", "BOT") & " " & GetTranslatedFileIni("MBR Func_Notify", "HELP", "HELP")
Local $txtHelp = "PushBullet " & GetTranslatedFileIni("MBR Func_Notify", "HELP", "HELP") & " " & GetTranslatedFileIni("MBR Func_Notify", "Bot_Info_01", "- You can remotely control your bot sending COMMANDS from the following list:")
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & GetTranslatedFileIni("MBR Func_Notify", "HELP", -1) & " " & GetTranslatedFileIni("MBR Func_Notify", "HELP_Info_01", "- send this help message")
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & GetTranslatedFileIni("MBR Func_Notify", "DELETE", "DELETE") & " " & GetTranslatedFileIni("MBR Func_Notify", "DELETE_Info_01", "- delete all your previous PushBullet messages")
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "RESTART", "RESTART") & " " & GetTranslatedFileIni("MBR Func_Notify", "RESTART_Info_01", "- restart the Emulator and bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "STOP", "STOP") & " " & GetTranslatedFileIni("MBR Func_Notify", "STOP_Info_01", "- stop the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "PAUSE", "PAUSE") & " " & GetTranslatedFileIni("MBR Func_Notify", "PAUSE_Info_01", "- pause the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "RESUME", "RESUME") & " " & GetTranslatedFileIni("MBR Func_Notify", "RESUME_Info_01", "- resume the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "STATS", "STATS") & " " & GetTranslatedFileIni("MBR Func_Notify", "STATS_Info_01", "- send Village Statistics of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "LOG", "LOG") & " " & GetTranslatedFileIni("MBR Func_Notify", "LOG_Info_01", "- send the current log file of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "LASTRAID", "LASTRAID") & GetTranslatedFileIni("MBR Func_Notify", "LASTRAID_Info_01", "- send the last raid loot screenshot of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "LASTRAIDTXT", "LASTRAIDTXT") & " " & GetTranslatedFileIni("MBR Func_Notify", "LASTRAIDTXT_Info_01", "- send the last raid loot values of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT", "SCREENSHOT") & " " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT_Info_01", "- send a screenshot of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOTHD", "SCREENSHOTHD") & " " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOTHD_Info_01", "- send a screenshot in high resolution of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "BUILDER", "BUILDER") & " " & GetTranslatedFileIni("MBR Func_Notify", "BUILDER_Info_01", "- send a screenshot of builder status of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "SHIELD", "SHIELD") & " " & GetTranslatedFileIni("MBR Func_Notify", "SHIELD_Info_01", "- send a screenshot of shield status of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "RESETSTATS", "RESETSTATS") & " " & GetTranslatedFileIni("MBR Func_Notify", "RESETSTATS_Info_01", "- reset Village Statistics")
$txtHelp &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "TROOPS", "TROOPS") & " " & GetTranslatedFileIni("MBR Func_Notify", "TROOPS_Info_01", "- send Troops & Spells Stats")
$txtHelp &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "HALTATTACKON", "HALTATTACKON") & " " & GetTranslatedFileIni("MBR Func_Notify", "ATTACK OFF_Info_01", "- Turn On 'Halt Attack' in the 'Misc' Tab with the 'stay online' option")
$txtHelp &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "HALTATTACKOFF", "HALTATTACKOFF") & " " & GetTranslatedFileIni("MBR Func_Notify", "ATTACK ON_Info_01", "- Turn Off 'Halt Attack' in the 'Misc' Tab")
$txtHelp &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "HIBERNATE", "HIBERNATE") & " " & GetTranslatedFileIni("MBR Func_Notify", "HIBERNATE_Info_01", "- Hibernate host PC")
$txtHelp &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "SHUTDOWN", "SHUTDOWN") & " " & GetTranslatedFileIni("MBR Func_Notify", "SHUTDOWN_Info_01", "- Shut down host PC")
$txtHelp &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslatedFileIni("MBR Func_Notify", "STANDBY", "STANDBY") & " " & GetTranslatedFileIni("MBR Func_Notify", "STANDBY_Info_01", "- Standby host PC")
$txtHelp &= '\n'
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Examples", "Examples:")
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & $g_sNotifyOrigin & " " & GetTranslatedFileIni("MBR Func_Notify", "STATS", "STATS")
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & GetTranslatedFileIni("MBR Func_Notify", "BUILDER", "BUILDER")
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & $g_sNotifyOrigin & " " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOTHD", "SCREENSHOTHD")
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-For-Help_Info_02", "Request for Help") & "\n" & $txtHelp)
SetLog("Notify PushBullet: Your request has been received from " & $g_sNotifyOrigin & ". Help has been sent", $COLOR_SUCCESS)
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & GetTranslatedFileIni("MBR Func_Notify", "DELETE", "DELETE")
NotifyDeletePushBullet()
SetLog("Notify PushBullet: Your request has been received.", $COLOR_SUCCESS)
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "RESTART", "RESTART")
NotifyDeleteMessageFromPushBullet($iden[$x])
SetLog("Notify PushBullet: Your request has been received. Bot and Android Emulator restarting...", $COLOR_SUCCESS)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_16", "Request to Restart") & "...\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_05", "Your bot and Emulator are now restarting") & "...")
SaveConfig()
RestartBot()
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "STOP", "STOP")
NotifyDeleteMessageFromPushBullet($iden[$x])
SetLog("Notify PushBullet: Your request has been received. Bot is now stopped", $COLOR_SUCCESS)
If $g_bRunState = True Then
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_01", "Request to Stop") & "..." & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_06", "Your bot is now stopping") & "...")
btnStop()
Else
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_01", "Request to Stop") & "..." & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_07", "Your bot is currently stopped, no action was taken"))
EndIf
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "PAUSE", "PAUSE")
If $g_bBotPaused = False And $g_bRunState = True Then
If( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) = False And IsAttackPage() Then
SetLog("Notify PushBullet: Unable to pause during attack", $COLOR_RED)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_17", "Request to Pause") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_15", "Unable to pause during attack, try again later."))
ElseIf( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) = True And IsAttackPage() Then
ReturnHome(False, False)
$g_bIsSearchLimit = True
$g_bIsClientSyncError = False
UpdateStats()
$g_bRestart = True
TogglePauseImpl("Push")
Else
TogglePauseImpl("Push")
EndIf
Else
SetLog("Notify PushBullet: Your bot is currently paused, no action was taken", $COLOR_SUCCESS)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_17", "Request to Pause") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_11", "Your bot is currently paused, no action was taken"))
EndIf
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "RESUME", "RESUME")
If $g_bBotPaused = True And $g_bRunState = True Then
TogglePauseImpl("Push")
Else
SetLog("Notify PushBullet: Your bot is currently resumed, no action was taken", $COLOR_SUCCESS)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_18", "Request to Resume") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Resumed_Info_01", "Your bot is currently resumed, no action was taken"))
EndIf
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "STATS", "STATS")
SetLog("Notify PushBullet: Your request has been received. Statistics sent", $COLOR_SUCCESS)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_02", "Stats Village Report") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_05", "At Start") & "\n[" & GetTranslatedFileIni("MBR Func_Notify", "Stats-G_Info_01", "G") & "]: " & _NumberFormat($g_iStatsStartedWith[$eLootGold]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-E_Info_01", "E") & "]: " & _NumberFormat($g_iStatsStartedWith[$eLootElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-DE_Info_01", "DE") & "]: " & _NumberFormat($g_iStatsStartedWith[$eLootDarkElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-T_Info_01", "T") & "]: " & $g_iStatsStartedWith[$eLootTrophy] & "\n\n" & GetTranslatedFileIni("MBR Func_Notify", "Stats-Now_Info_01", "Now (Current Resources)") & "\n[" & GetTranslatedFileIni("MBR Func_Notify", "Stats-G_Info_01", "G") & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootGold]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-E_Info_01", "E") & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-DE_Info_01", "DE") & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-T_Info_01", "T") & "]: " & $g_aiCurrentLoot[$eLootTrophy] & " [" & GetTranslatedFileIni("MBR Func_Notify", "GEM_Info_01", "GEM") & "]: " & $g_iGemAmount & "\n \n [" & GetTranslatedFileIni("MBR Func_Notify", "Free-Builders_Info_01", "No. of Free Builders") & "]: " & $g_iFreeBuilderCount & "\n [" & GetTranslatedFileIni("MBR Func_Notify", "Wall-Up_Info_01", "No. of Wall Up") & "]: " & GetTranslatedFileIni("MBR Func_Notify", "Stats-G_Info_01", "G") & ": " & $g_iNbrOfWallsUppedGold & "/ " & GetTranslatedFileIni("MBR Func_Notify", "Stats-E_Info_01", "E") & ": " & $g_iNbrOfWallsUppedElixir & "\n\n" & GetTranslatedFileIni("MBR Func_Notify", "Attack_Info_01", "Attacked") & ": " & $g_aiAttackedCount & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Skip_Info_02", "Skipped") & ": " & $g_iSkippedVillageCount)
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "LOG", "LOG")
SetLog("Notify PushBullet: Your request has been received from " & $g_sNotifyOrigin & ". Log is now sent", $COLOR_SUCCESS)
NotifyPushFileToPushBullet($g_sLogFileName, GetTranslatedFileIni("MBR Func_Notify", "LOG_Info_02", "logs"), "text/plain; charset=utf-8", $g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "LOG_Info_03", "Current Log") & " \n")
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "LASTRAID", "LASTRAID")
If $g_sAttackFile <> "" Then
SetLog("Notify PushBullet: Push Last Raid Snapshot...", $COLOR_SUCCESS)
NotifyPushFileToPushBullet($g_sAttackFile, GetTranslatedFileIni("MBR Func_Notify", "Loots_Info_01", "Loots"), "image/jpeg", $g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Last-Raid_Info_01", "Last Raid") & " \n" & $g_sAttackFile)
Else
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT_Info_02", "There is no last raid screenshot") & ".")
SetLog("There is no last raid screenshot.")
SetLog("Notify PushBullet: Your request has been received. Last Raid txt sent", $COLOR_SUCCESS)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Last-Raid_Info_02", "Last Raid txt") & "\n" & "[" & GetTranslatedFileIni("MBR Func_Notify", "Stats-G_Info_01", "G") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootGold]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-E_Info_01", "E") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-DE_Info_01", "DE") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootDarkElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-T_Info_01", "T") & "]: " & $g_iStatsLastAttack[$eLootTrophy])
EndIf
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "LASTRAIDTXT", "LASTRAIDTXT")
SetLog("Notify PushBullet: Your request has been received. Last Raid txt sent", $COLOR_SUCCESS)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Last-Raid_Info_02", "Last Raid txt") & "\n" & "[" & GetTranslatedFileIni("MBR Func_Notify", "Stats-G_Info_01", "G") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootGold]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-E_Info_01", "E") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-DE_Info_01", "DE") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootDarkElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-T_Info_01", "T") & "]: " & $g_iStatsLastAttack[$eLootTrophy])
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT", "SCREENSHOT")
SetLog("Notify PushBullet: ScreenShot request received", $COLOR_SUCCESS)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT_Info_03", "Chief, your request for Screenshot will be processed ASAP"))
$g_bPBRequestScreenshot = True
$g_bNotifyForced = False
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOTHD", "SCREENSHOTHD")
SetLog("Notify PushBullet: ScreenShot HD request received", $COLOR_SUCCESS)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT_Info_03", "Chief, your request for Screenshot will be processed ASAP"))
$g_bPBRequestScreenshot = True
$g_bPBRequestScreenshotHD = True
$g_bNotifyForced = False
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "BUILDER", "BUILDER")
SetLog("Notify PushBullet: Builder Status request received", $COLOR_SUCCESS)
$g_bPBRequestBuilderInfo = True
NotifyDeleteMessageFromPushBullet($iden[$x])
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "BUILDER_Info_04", "Chief, your request for Builder Info will be processed ASAP"))
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "SHIELD", "SHIELD")
SetLog("Notify PushBullet: Shield Status request received", $COLOR_SUCCESS)
$g_bPBRequestShieldInfo = True
$g_bNotifyForced = False
NotifyDeleteMessageFromPushBullet($iden[$x])
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "SHIELD_Info_02", "Chief, your request for Shield Info will be processed ASAP"))
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "RESETSTATS", "RESETSTATS")
btnResetStats()
SetLog("Notify PushBullet: Your request has been received. Statistics resetted", $COLOR_SUCCESS)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "RESETSTATS_Info_02", "Statistics resetted."))
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "TROOPS", "TROOPS")
SetLog("Notify PushBullet: Your request has been received. Sending Troop/Spell Stats...", $COLOR_SUCCESS)
Local $txtTroopStats = " | " & GetTranslatedFileIni("MBR Func_Notify", "Train_Info_01", "Troops/Spells set to Train") & ":\n" & "Barbs:" & $g_aiArmyCompTroops[$eTroopBarbarian] & " Arch:" & $g_aiArmyCompTroops[$eTroopArcher] & " Gobl:" & $g_aiArmyCompTroops[$eTroopGoblin] & "\n" & "Giant:" & $g_aiArmyCompTroops[$eTroopGiant] & " WallB:" & $g_aiArmyCompTroops[$eTroopWallBreaker] & " Wiza:" & $g_aiArmyCompTroops[$eTroopWizard] & "\n" & "Balloon:" & $g_aiArmyCompTroops[$eTroopBalloon] & " Heal:" & $g_aiArmyCompTroops[$eTroopHealer] & " Dragon:" & $g_aiArmyCompTroops[$eTroopDragon] & " Pekka:" & $g_aiArmyCompTroops[$eTroopPekka] & "\n" & "Mini:" & $g_aiArmyCompTroops[$eTroopMinion] & " Hogs:" & $g_aiArmyCompTroops[$eTroopHogRider] & " Valks:" & $g_aiArmyCompTroops[$eTroopValkyrie] & "\n" & "Golem:" & $g_aiArmyCompTroops[$eTroopGolem] & " Witch:" & $g_aiArmyCompTroops[$eTroopWitch] & " Lava:" & $g_aiArmyCompTroops[$eTroopLavaHound] & "\n" & "LSpell:" & $g_aiArmyCompSpells[$eSpellLightning] & " HeSpell:" & $g_aiArmyCompSpells[$eSpellHeal] & " RSpell:" & $g_aiArmyCompSpells[$eSpellRage] & " JSpell:" & $g_aiArmyCompSpells[$eSpellJump] & "\n" & "FSpell:" & $g_aiArmyCompSpells[$eSpellFreeze] & " PSpell:" & $g_aiArmyCompSpells[$eSpellPoison] & " ESpell:" & $g_aiArmyCompSpells[$eSpellEarthquake] & " HaSpell:" & $g_aiArmyCompSpells[$eSpellHaste] & "\n"
$txtTroopStats &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "Train_Info_02", "Current Trained Troops & Spells") & ":"
$txtTroopStats &= "\n\n" & GetTranslatedFileIni("MBR Func_Notify", "Train_Info_03", "Current Army Camp") & ": " & $g_CurrentCampUtilization & "/" & $g_iTotalCampSpace
NotifyPushToPushBullet($g_sNotifyOrigin & $txtTroopStats)
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "HALTATTACKON", "HALTATTACKON")
GUICtrlSetState($g_hChkBotStop, $GUI_CHECKED)
btnStop()
$g_bChkBotStop = True
$g_iCmbBotCond = 18
btnStart()
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "HALTATTACKOFF", "HALTATTACKOFF")
GUICtrlSetState($g_hChkBotStop, $GUI_UNCHECKED)
btnStop()
btnStart()
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "HIBERNATE", "HIBERNATE")
SetLog("Notify PushBullet: Your request has been received from " & $g_sNotifyOrigin & ". Hibernate PC", $COLOR_SUCCESS)
NotifyPushToPushBullet(GetTranslatedFileIni("MBR Func_Notify", "HIBERNATE_Info_02", "PC Hibernate sequence initiated"))
Shutdown(64)
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "SHUTDOWN", "SHUTDOWN")
SetLog("Notify PushBullet: Your request has been received from " & $g_sNotifyOrigin & ". Shutdown PC", $COLOR_SUCCESS)
NotifyPushToPushBullet(GetTranslatedFileIni("MBR Func_Notify", "SHUTDOWN_Info_02", "PC Shutdown sequence initiated"))
Shutdown(5)
Case GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslatedFileIni("MBR Func_Notify", "STANDBY", "STANDBY")
SetLog("Notify PushBullet: Your request has been received from " & $g_sNotifyOrigin & ". Standby PC", $COLOR_SUCCESS)
NotifyPushToPushBullet(GetTranslatedFileIni("MBR Func_Notify", "STANDBY_Info_02", "PC Standby sequence initiated"))
Shutdown(32)
Case Else
Local $lenstr = StringLen(GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & "")
Local $teststr = StringLeft($body[$x], $lenstr)
If $teststr =(GetTranslatedFileIni("MBR Func_Notify", "Bot", -1) & " " & StringUpper($g_sNotifyOrigin) & " " & "") Then
SetLog("Notify PushBullet: received command syntax wrong, command ignored.", $COLOR_ERROR)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Command-Not-Recognized", "Command not recognized") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-For-Help_Info_01", "Please push BOT HELP to obtain a complete command list."))
NotifyDeleteMessageFromPushBullet($iden[$x])
EndIf
EndSwitch
$body[$x] = ""
$iden[$x] = ""
$g_bNotifyForced = False
EndIf
Next
EndIf
EndIf
If $g_bNotifyTGEnable And $g_sNotifyTGToken <> "" And $g_bRunState Then
$g_sTGLastMessage = NotifyGetLastMessageFromTelegram()
Local $TGActionMSG = StringUpper(StringStripWS($g_sTGLastMessage, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES))
If $g_bDebugSetlog Then SetDebugLog("Telegram | NotifyRemoteControlProc $TGActionMSG : " & $TGActionMSG)
If $g_bDebugSetlog Then SetDebugLog("Telegram | NotifyRemoteControlProc $g_iTGLastRemote : " & $g_iTGLastRemote)
If $g_bDebugSetlog Then SetDebugLog("Telegram | NotifyRemoteControlProc $g_sTGLast_UID : " & $g_sTGLast_UID)
If($TGActionMSG = "/START" Or $TGActionMSG = "KEYB") And $g_iTGLastRemote <> $g_sTGLast_UID Then
$g_iTGLastRemote = $g_sTGLast_UID
NotifyActivateKeyboardOnTelegram($g_sBotTitle & " | Notify " & $g_sNotifyVersion)
Else
If $g_iTGLastRemote <> $g_sTGLast_UID Then
$g_iTGLastRemote = $g_sTGLast_UID
Switch $TGActionMSG
Case GetTranslatedFileIni("MBR Func_Notify", "HELP", "HELP"), '\U2753 ' & GetTranslatedFileIni("MBR Func_Notify", "HELP", "HELP")
Local $txtHelp = "Telegram " & GetTranslatedFileIni("MBR Func_Notify", "HELP", "HELP") & " " & GetTranslatedFileIni("MBR Func_Notify", "Bot_Info_01", "- You can remotely control your bot sending COMMANDS from the following list:")
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "HELP", -1) & " " & GetTranslatedFileIni("MBR Func_Notify", "HELP_Info_01", "- send this help message")
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "RESTART", "RESTART") & " " & GetTranslatedFileIni("MBR Func_Notify", "RESTART_Info_01", "- restart the Emulator and bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "START", "START") & " " & GetTranslatedFileIni("MBR Func_Notify", "START_Info_01", "- start the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "STOP", "STOP") & " " & GetTranslatedFileIni("MBR Func_Notify", "STOP_Info_01", "- stop the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "PAUSE", "PAUSE") & " " & GetTranslatedFileIni("MBR Func_Notify", "PAUSE_Info_01", "- pause the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "RESUME", "RESUME") & " " & GetTranslatedFileIni("MBR Func_Notify", "RESUME_Info_01", "- resume the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "STATS", "STATS") & " " & GetTranslatedFileIni("MBR Func_Notify", "STATS_Info_01", "- send Village Statistics of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "LOG", "LOG") & GetTranslatedFileIni("MBR Func_Notify", "LOG_Info_01", "- send the current log file of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "LASTRAID", "LASTRAID") & " " & GetTranslatedFileIni("MBR Func_Notify", "LASTRAID_Info_01", "- send the last raid loot screenshot of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "LASTRAIDTXT", "LASTRAIDTXT") & " " & GetTranslatedFileIni("MBR Func_Notify", "LASTRAIDTXT_Info_01", "- send the last raid loot values of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT", "SCREENSHOT") & " " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT_Info_01", "- send a screenshot of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOTHD", "SCREENSHOTHD") & " " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOTHD_Info_01", "- send a screenshot in high resolution of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "BUILDER", "BUILDER") & " " & GetTranslatedFileIni("MBR Func_Notify", "BUILDER_Info_01", "- send a screenshot of builder status of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslatedFileIni("MBR Func_Notify", "SHIELD", "SHIELD") & " " & GetTranslatedFileIni("MBR Func_Notify", "SHIELD_Info_01", "- send a screenshot of shield status of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "RESETSTATS", "RESETSTATS") & " " & GetTranslatedFileIni("MBR Func_Notify", "RESETSTATS_Info_01", "- reset Village Statistics")
$txtHelp &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "TROOPS", "TROOPS") & " " & GetTranslatedFileIni("MBR Func_Notify", "TROOPS_Info_01", "- send Troops & Spells Stats")
$txtHelp &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "HALTATTACKON", "HALTATTACKON") & " " & GetTranslatedFileIni("MBR Func_Notify", "ATTACK OFF_Info_01", "- Turn On 'Halt Attack' in the 'Misc' Tab with the 'stay online' option")
$txtHelp &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "HALTATTACKOFF", "HALTATTACKOFF") & " " & GetTranslatedFileIni("MBR Func_Notify", "ATTACK ON_Info_01", "- Turn Off 'Halt Attack' in the 'Misc' Tab")
$txtHelp &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "HIBERNATE", "HIBERNATE") & " " & GetTranslatedFileIni("MBR Func_Notify", "HIBERNATE_Info_01", "- Hibernate host PC")
$txtHelp &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "SHUTDOWN", "SHUTDOWN") & " " & GetTranslatedFileIni("MBR Func_Notify", "SHUTDOWN_Info_01", "- Shut down host PC")
$txtHelp &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "STANDBY", "STANDBY") & " " & GetTranslatedFileIni("MBR Func_Notify", "STANDBY_Info_01", "- Standby host PC")
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-For-Help_Info_02", "Request for Help") & "\n" & $txtHelp)
SetLog("Notify Telegram: Your request has been received from " & $g_sNotifyOrigin & ". Help has been sent", $COLOR_SUCCESS)
Case GetTranslatedFileIni("MBR Func_Notify", "RESTART", "RESTART"), '\UD83D\UDD01 ' & GetTranslatedFileIni("MBR Func_Notify", "RESTART", "RESTART")
SetLog("Notify Telegram: Your request has been received.", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_16", "Request to Restart") & "...\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_09", "Your bot and Emulator are now restarting..."))
SaveConfig()
RestartBot()
Case GetTranslatedFileIni("MBR Func_Notify", "START", "START"), '\u25b6 ' & GetTranslatedFileIni("MBR Func_Notify", "START", "START")
If $g_bRunState = True Then
SetLog("Notify Telegram" & ": " & "Your bot is currently started, no action was taken", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Start_Info_01", "Request to Start...") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-Start_Info_03", "Your bot is currently started, no action was taken"))
EndIf
Case GetTranslatedFileIni("MBR Func_Notify", "STOP", "STOP"), '\U25AA ' & GetTranslatedFileIni("MBR Func_Notify", "STOP", "STOP")
SetLog("Notify Telegram: Your request has been received. Bot is now stopped", $COLOR_SUCCESS)
If $g_bRunState = True Then
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_02", "Request to Stop...") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_03", "Your bot is now stopping..."))
btnStop()
Else
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_02", "Request to Stop...") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_04", "Your bot is currently stopped, no action was taken"))
EndIf
Case GetTranslatedFileIni("MBR Func_Notify", "PAUSE", "PAUSE"), '\UD83D\UDD00 ' & GetTranslatedFileIni("MBR Func_Notify", "PAUSE", "PAUSE")
If $g_bBotPaused = False And $g_bRunState = True Then
If( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) = False And IsAttackPage() Then
SetLog("Notify Telegram: Unable to pause during attack", $COLOR_ERROR)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_17", "Request to Pause") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_08", "Unable to pause during attack, try again later."))
ElseIf( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) = True And IsAttackPage() Then
ReturnHome(False, False)
$g_bIsSearchLimit = True
$g_bIsClientSyncError = True
$g_bRestart = True
TogglePauseImpl("Push")
Return True
Else
TogglePauseImpl("Push")
EndIf
Else
SetLog("Notify Telegram: Your bot is currently paused, no action was taken", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_17", "Request to Pause") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_11", "Your bot is currently paused, no action was taken"))
EndIf
Case GetTranslatedFileIni("MBR Func_Notify", "RESUME", "RESUME"), '\U25B6 ' & GetTranslatedFileIni("MBR Func_Notify", "RESUME", "RESUME")
If $g_bBotPaused = True And $g_bRunState = True Then
TogglePauseImpl("Push")
Else
SetLog("Notify Telegram: Your bot is currently resumed, no action was taken", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_18", "Request to Resume") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_12", "Your bot is currently resumed, no action was taken"))
EndIf
Case GetTranslatedFileIni("MBR Func_Notify", "STATS", "STATS"), '\UD83D\UDCC8 ' & GetTranslatedFileIni("MBR Func_Notify", "STATS", "STATS")
SetLog("Notify Telegram: Your request has been received. Statistics sent", $COLOR_SUCCESS)
Local $GoldGainPerHour = "0 / h"
Local $ElixirGainPerHour = "0 / h"
Local $DarkGainPerHour = "0 / h"
Local $TrophyGainPerHour = "0 / h"
If $g_iFirstAttack = 2 Then
$GoldGainPerHour = _NumberFormat(Round($g_iStatsTotalGain[$eLootGold] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "K / h"
$ElixirGainPerHour = _NumberFormat(Round($g_iStatsTotalGain[$eLootElixir] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "K / h"
EndIf
If $g_iStatsStartedWith[$eLootDarkElixir] <> "" Then
$DarkGainPerHour = _NumberFormat(Round($g_iStatsTotalGain[$eLootDarkElixir] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h"
EndIf
$TrophyGainPerHour = _NumberFormat(Round($g_iStatsTotalGain[$eLootTrophy] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h"
Local $txtStats = " | " & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_02", "Stats Village Report") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_05", "At Start") & "\n[" & GetTranslatedFileIni("MBR Func_Notify", "Stats-G_Info_01", "G") & "]: " & _NumberFormat($g_iStatsStartedWith[$eLootGold]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-E_Info_01", "E") & "]: "
$txtStats &= _NumberFormat($g_iStatsStartedWith[$eLootElixir]) & " [D]: " & _NumberFormat($g_iStatsStartedWith[$eLootDarkElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-T_Info_01", "T") & "]: " & $g_iStatsStartedWith[$eLootTrophy]
$txtStats &= "\n\n" & GetTranslatedFileIni("MBR Func_Notify", "Stats-Now_Info_01", "Now (Current Resources)") & "\n[" & GetTranslatedFileIni("MBR Func_Notify", "Stats-G_Info_01", "G") & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootGold]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-E_Info_01", "E") & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootElixir])
$txtStats &= " [D]: " & _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-T_Info_01", "T") & "]: " & $g_aiCurrentLoot[$eLootTrophy] & " [GEM]: " & $g_iGemAmount
$txtStats &= "\n\n" & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_04", "Gain per Hour") & ":\n[" & GetTranslatedFileIni("MBR Func_Notify", "Stats-G_Info_01", "G") & "]: " & $GoldGainPerHour & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-E_Info_01", "E") & "]: " & $ElixirGainPerHour
$txtStats &= "\n[D]: " & $DarkGainPerHour & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-T_Info_01", "T") & "]: " & $TrophyGainPerHour
$txtStats &= "\n\n" & GetTranslatedFileIni("MBR Func_Notify", "Free-Builders_Info_01", "No. of Free Builders") & ": " & $g_iFreeBuilderCount & "\n[" & GetTranslatedFileIni("MBR Func_Notify", "Wall-Up_Info_01", "No. of Wall Up") & "]: [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-G_Info_01", "G") & "]: "
$txtStats &= $g_iNbrOfWallsUppedGold & "/ [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-E_Info_01", "E") & "]: " & $g_iNbrOfWallsUppedElixir & "\n\n" & GetTranslatedFileIni("MBR Func_Notify", "Attack_Info_01", "Attacked") & ": "
$txtStats &= $g_aiAttackedCount & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Skip_Info_02", "Skipped") & ": " & $g_iSkippedVillageCount
$txtStats &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "LOG_Info_07", "Run Time") & ": " & GUICtrlRead($g_hLblResultRuntime)
$txtStats &= "\n\n" & "Clan Games:"
$txtStats &= "\n" & "[T]: " & GUICtrlRead($g_hLblRemainTime) & " [S]: " & GUICtrlRead($g_hLblYourScore)
$txtStats &= "\n" & " "
NotifyPushToTelegram($g_sNotifyOrigin & $txtStats)
Case GetTranslatedFileIni("MBR Func_Notify", "LOG", "LOG"), '\UD83D\UDCCB ' & GetTranslatedFileIni("MBR Func_Notify", "LOG", "LOG")
SetLog("Notify Telegram: Your request has been received from " & $g_sNotifyOrigin & ". Log is now sent", $COLOR_SUCCESS)
NotifyPushFileToTelegram($g_sLogFileName, "Logs", "text\/plain; charset=utf-8", $g_sNotifyOrigin & " | Current Log " & "\n")
Case GetTranslatedFileIni("MBR Func_Notify", "LASTRAID", "LASTRAID"), '\UD83C\UDF04 ' & GetTranslatedFileIni("MBR Func_Notify", "LASTRAID", "LASTRAID")
If $g_sLootFileName <> "" Then
NotifyPushFileToTelegram($g_sLootFileName, "Loots", "image/jpeg", $g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Last-Raid_Info_05", "Last Raid") & "\n" & $g_sLootFileName)
SetLog("Notify Telegram: Push Last Raid Snapshot...", $COLOR_SUCCESS)
Else
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Last-Raid_Info_03", "There is no last raid screenshot."))
SetLog("There is no last raid screenshot.")
SetLog("Notify Telegram: Your request has been received. Last Raid txt sent", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Last-Raid_Info_04", "Last Raid txt") & "\n" & "[" & GetTranslatedFileIni("MBR Func_Notify", "Stats-G_Info_01", "G") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootGold]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-E_Info_01", "E") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootElixir]) & " [D]: " & _NumberFormat($g_iStatsLastAttack[$eLootDarkElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-T_Info_01", "T") & "]: " & $g_iStatsLastAttack[$eLootTrophy])
EndIf
Case GetTranslatedFileIni("MBR Func_Notify", "LASTRAIDTXT", "LASTRAIDTXT"), '\UD83D\UDCC4 ' & GetTranslatedFileIni("MBR Func_Notify", "LASTRAIDTXT", "LASTRAIDTXT")
SetLog("Notify Telegram: Your request has been received. Last Raid txt sent", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Last-Raid_Info_04", "Last Raid txt") & "\n" & "[" & GetTranslatedFileIni("MBR Func_Notify", "Stats-G_Info_01", "G") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootGold]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-E_Info_01", "E") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootElixir]) & " [D]: " & _NumberFormat($g_iStatsLastAttack[$eLootDarkElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-T_Info_01", "T") & "]: " & $g_iStatsLastAttack[$eLootTrophy])
Case GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT", "SCREENSHOT")
SetLog("Notify Telegram: ScreenShot request received", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT_Info_03", "Chief, your request for Screenshot will be processed ASAP"))
$g_bTGRequestScreenshot = True
Case GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOTHD", "SCREENSHOTHD"), '\UD83D\UDCF7 ' & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT", "SCREENSHOT")
SetLog("Notify Telegram: ScreenShot HD request received", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT_Info_03", "Chief, your request for Screenshot will be processed ASAP"))
$g_bTGRequestScreenshot = True
$g_bTGRequestScreenshotHD = True
$g_bNotifyForced = False
Case GetTranslatedFileIni("MBR Func_Notify", "BUILDER", "BUILDER"), '\UD83D\UDD28 ' & GetTranslatedFileIni("MBR Func_Notify", "BUILDER", "BUILDER")
SetLog("Notify Telegram: Builder Status request received", $COLOR_SUCCESS)
$g_bTGRequestBuilderInfo = True
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "BUILDER_Info_04", "Chief, your request for Builder Info will be processed ASAP"))
Case GetTranslatedFileIni("MBR Func_Notify", "SHIELD", "SHIELD"), '\UD83D\UDD30 ' & GetTranslatedFileIni("MBR Func_Notify", "SHIELD", "SHIELD")
SetLog("Notify Telegram: Shield Status request received", $COLOR_SUCCESS)
$g_bTGRequestShieldInfo = True
$g_bNotifyForced = False
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "SHIELD_Info_02", "Chief, your request for Shield Info will be processed ASAP"))
Case GetTranslatedFileIni("MBR Func_Notify", "RESETSTATS", "RESETSTATS")
btnResetStats()
SetLog("Notify Telegram: Your request has been received. Statistics resetted", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "RESETSTATS_Info_02", "Statistics resetted."))
Case GetTranslatedFileIni("MBR Func_Notify", "TROOPS", "TROOPS"), '\UD83D\UDCAA ' & GetTranslatedFileIni("MBR Func_Notify", "TROOPS", "TROOPS")
SetLog("Notify Telegram: Your request has been received. Sending Troop/Spell Stats...", $COLOR_SUCCESS)
Local $txtTroopStats = " | " & GetTranslatedFileIni("MBR Func_Notify", "Train_Info_01", "Troops/Spells Train Status") & ":\n" & "Barbs:" & $g_aiCurrentTroops[$eTroopBarbarian] & " of " & $g_aiArmyCompTroops[$eTroopBarbarian] & " | Arch:" & $g_aiCurrentTroops[$eTroopArcher] & " of " & $g_aiArmyCompTroops[$eTroopArcher] & " | Gobl:" & $g_aiCurrentTroops[$eTroopGoblin] & " of " & $g_aiArmyCompTroops[$eTroopGoblin] & "\n" & "Giant:" & $g_aiCurrentTroops[$eTroopGiant] & " of " & $g_aiArmyCompTroops[$eTroopGiant] & " | WallB:" & $g_aiCurrentTroops[$eTroopWallBreaker] & " of " & $g_aiArmyCompTroops[$eTroopWallBreaker] & " | Wiza:" & $g_aiCurrentTroops[$eTroopWizard] & " of " & $g_aiArmyCompTroops[$eTroopWizard] & "\n" & "Balloon:" & $g_aiCurrentTroops[$eTroopBalloon] & " of " & $g_aiArmyCompTroops[$eTroopBalloon] & " | Heal:" & $g_aiCurrentTroops[$eTroopHealer] & " of " & $g_aiArmyCompTroops[$eTroopHealer] & " | Dragon:" & $g_aiCurrentTroops[$eTroopDragon] & " of " & $g_aiArmyCompTroops[$eTroopDragon] & " | Pekka:" & $g_aiCurrentTroops[$eTroopPekka] & " of " & $g_aiArmyCompTroops[$eTroopPekka] & "\n" & "Mini:" & $g_aiCurrentTroops[$eTroopMinion] & " of " & $g_aiArmyCompTroops[$eTroopMinion] & " | Hogs:" & $g_aiCurrentTroops[$eTroopHogRider] & " of " & $g_aiArmyCompTroops[$eTroopHogRider] & " | Valks:" & $g_aiCurrentTroops[$eTroopValkyrie] & " of " & $g_aiArmyCompTroops[$eTroopValkyrie] & "\n" & "Golem:" & $g_aiCurrentTroops[$eTroopGolem] & " of " & $g_aiArmyCompTroops[$eTroopGolem] & " | Witch:" & $g_aiCurrentTroops[$eTroopWitch] & " of " & $g_aiArmyCompTroops[$eTroopWitch] & " | Lava:" & $g_aiCurrentTroops[$eTroopLavaHound] & " of " & $g_aiArmyCompTroops[$eTroopLavaHound] & "\n" & "LSpell:" & $g_aiCurrentSpells[$eSpellLightning] & " of " & $g_aiArmyCompSpells[$eSpellLightning] & " | HeSpell:" & $g_aiCurrentSpells[$eSpellHeal] & " of " & $g_aiArmyCompSpells[$eSpellHeal] & " | RSpell:" & $g_aiCurrentSpells[$eSpellRage] & " of " & $g_aiArmyCompSpells[$eSpellRage] & " | JSpell:" & $g_aiCurrentSpells[$eSpellJump] & " of " & $g_aiArmyCompSpells[$eSpellJump] & "\n" & "FSpell:" & $g_aiCurrentSpells[$eSpellFreeze] & " of " & $g_aiArmyCompSpells[$eSpellFreeze] & " | PSpell:" & $g_aiCurrentSpells[$eSpellPoison] & " of " & $g_aiArmyCompSpells[$eSpellPoison] & " | ESpell:" & $g_aiCurrentSpells[$eSpellEarthquake] & " of " & $g_aiArmyCompSpells[$eSpellEarthquake] & " | HaSpell:" & $g_aiCurrentSpells[$eSpellHaste] & " of " & $g_aiArmyCompSpells[$eSpellHaste] & "\n"
$txtTroopStats &= "\n" & GetTranslatedFileIni("MBR Func_Notify", "Train_Info_05", "Current Capacities") & ":"
$txtTroopStats &= "\n" & " " & GetTranslatedFileIni("MBR Func_Notify", "Train_Info_06", "- Army Camp") & ": " & $g_CurrentCampUtilization & "/" & $g_iTotalCampSpace
$txtTroopStats &= "\n" & " " & GetTranslatedFileIni("MBR Func_Notify", "Train_Info_04", "- Spells") & ": " & $g_iCurrentSpells & "/" & $g_iTotalTrainSpaceSpell
NotifyPushToTelegram($g_sNotifyOrigin & $txtTroopStats)
Case GetTranslatedFileIni("MBR Func_Notify", "HALTATTACKON", "HALTATTACKON"), '\U274C ' & StringUpper(GetTranslatedFileIni("MBR Func_Notify", "ATTACK OFF", "ATTACK OFF"))
GUICtrlSetState($g_hChkBotStop, $GUI_CHECKED)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "ATTACK ON_Info_02", "Set Halt Attack ON."))
btnStop()
$g_bChkBotStop = True
$g_iCmbBotCond = 18
btnStart()
Case GetTranslatedFileIni("MBR Func_Notify", "HALTATTACKOFF", "HALTATTACKOFF"), '\U2705 ' & StringUpper(GetTranslatedFileIni("MBR Func_Notify", "ATTACK ON_Info_01", "ATTACK ON"))
GUICtrlSetState($g_hChkBotStop, $GUI_UNCHECKED)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "ATTACK OFF_Info_02", "Set Halt Attack OFF."))
btnStop()
btnStart()
Case GetTranslatedFileIni("MBR Func_Notify", "HIBERNATE", "HIBERNATE"), '\UD83D\UDCA4 ' & GetTranslatedFileIni("MBR Func_Notify", "HIBERNATE", "HIBERNATE")
SetLog("Notify Telegram: Your request has been received from " & $g_sNotifyOrigin & ". Hibernate PC", $COLOR_SUCCESS)
NotifyPushToTelegram(GetTranslatedFileIni("MBR Func_Notify", "HIBERNATE_Info_02", "PC Hibernate sequence initiated"))
Shutdown(64)
Case GetTranslatedFileIni("MBR Func_Notify", "SHUTDOWN", "SHUTDOWN"), '\U26A1 ' & StringUpper(GetTranslatedFileIni("MBR Func_Notify", "SHUTDOWN", "SHUTDOWN"))
SetLog("Notify Telegram: Your request has been received from " & $g_sNotifyOrigin & ". Shutdown PC", $COLOR_SUCCESS)
NotifyPushToTelegram(GetTranslatedFileIni("MBR Func_Notify", "SHUTDOWN_Info_02", "PC Shutdown sequence initiated"))
Shutdown(5)
Case GetTranslatedFileIni("MBR Func_Notify", "STANDBY", "STANDBY"), GetTranslatedFileIni("MBR Func_Notify", "STANDBY", "STANDBY")
SetLog("Notify Telegram: Your request has been received from " & $g_sNotifyOrigin & ". Standby PC", $COLOR_SUCCESS)
NotifyPushToTelegram(GetTranslatedFileIni("MBR Func_Notify", "STANDBY_Info_02", "PC Standby sequence initiated"))
Shutdown(32)
EndSwitch
EndIf
EndIf
EndIf
EndFunc
Func NotifyPushToBoth($pMessage)
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyPushToBoth($pMessage): " & $pMessage)
If(Not $g_bNotifyPBEnable Or $g_sNotifyPBToken = "") And(Not $g_bNotifyTGEnable Or $g_sNotifyTGToken = "") Then Return
If $g_bNotifyPBEnable And $g_sNotifyPBToken <> "" Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("PushBullet Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/pushes", False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
Local $pPush = '{"type": "note", "body": "' & $pMessage & "\n" & $Date & "__" & $Time & '"}'
$oHTTP.Send($pPush)
$oHTTP.WaitForResponse
EndIf
If $g_bNotifyTGEnable And $g_sNotifyTGToken <> "" Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("Telegram Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
Local $url = "https://api.telegram.org/bot"
$oHTTP.Open("Post", $url & $g_sNotifyTGToken & "/sendMessage", False)
$oHTTP.SetRequestHeader("Content-Type", "application/json; charset=ISO-8859-1,utf-8")
Local $Date = @YEAR & '-' & @MON & '-' & @MDAY
Local $Time = @HOUR & '.' & @MIN
Local $TGPushMsg = '{"text":"' & $pMessage & '\n' & $Date & '__' & $Time & '", "chat_id":' & $g_sTGChatID & '}}'
$oHTTP.Send($TGPushMsg)
$oHTTP.WaitForResponse
EndIf
EndFunc
Func NotifyPushMessageToBoth($Message, $Source = "")
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyPushMessageToBoth($Message, $Source = ""): " & $Message & "," & $Source)
Static $iReportIdleBuilder = 0
If Not $g_bNotifyForced And $Message <> "DeleteAllPBMessages" Then
If $g_bNotifyScheduleWeekDaysEnable Then
If $g_abNotifyScheduleWeekDays[@WDAY - 1] Then
If $g_bNotifyScheduleHoursEnable Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If Not $g_abNotifyScheduleHours[$hour[0]] Then
SetLog("Notify not planned for this hour! Notification skipped", $COLOR_WARNING)
SetLog($Message, $COLOR_ORANGE)
Return
EndIf
EndIf
Else
Return
EndIf
Else
If $g_bNotifyScheduleHoursEnable Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If Not $g_abNotifyScheduleHours[$hour[0]] Then
SetLog("Notify not planned for this hour! Notification skipped", $COLOR_WARNING)
SetLog($Message, $COLOR_ORANGE)
Return
EndIf
EndIf
EndIf
EndIf
$g_bNotifyForced = False
Local $hBitmap_Scaled
Switch $Message
Case "Restarted"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyRemoteEnable Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_10", "Bot restarted"))
Case "OutOfSync"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertOutOfSync Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "LOG_Info_05", "Restarted after Out of Sync Error") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_06", "Attacking now") & "...")
Case "LastRaid"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlerLastRaidTXT Then
NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Last-Raid_Info_02", "Last Raid txt") & "\n" & "[" & GetTranslatedFileIni("MBR Func_Notify", "Stats-G_Info_01", "G") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootGold]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-E_Info_01", "E") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-DE_Info_01", "DE") & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootDarkElixir]) & " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-T_Info_01", "T") & "]: " & $g_iStatsLastAttack[$eLootTrophy])
If _Sleep($DELAYPUSHMSG1) Then Return
If $g_bNotifyPBEnable = True Then SetLog("Notify PushBullet: Last Raid Text has been sent!", $COLOR_SUCCESS)
If $g_bNotifyTGEnable = True Then SetLog("Notify Telegram: Last Raid Text has been sent!", $COLOR_SUCCESS)
EndIf
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlerLastRaidIMG Then
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
If $g_bScreenshotLootInfo Then
$g_sAttackFile = $g_sLootFileName
Else
_CaptureRegion()
$g_sAttackFile = "Notify_" & $Date & "__" & $Time & ".jpg"
$hBitmap_Scaled = _GDIPlus_ImageResize($g_hBitmap, _GDIPlus_ImageGetWidth($g_hBitmap) / 2, _GDIPlus_ImageGetHeight($g_hBitmap) / 2)
_GDIPlus_ImageSaveToFile($hBitmap_Scaled, $g_sProfileLootsPath & $g_sAttackFile)
_GDIPlus_ImageDispose($hBitmap_Scaled)
EndIf
If $g_bNotifyPBEnable Then SetLog("Notify PushBullet: Last Raid screenshot has been sent!", $COLOR_SUCCESS)
If $g_bNotifyTGEnable Then SetLog("Notify Telegram: Last Raid screenshot has been sent!", $COLOR_SUCCESS)
NotifyPushFileToBoth($g_sAttackFile, "Loots", "image/jpeg", $g_sNotifyOrigin & " | " & "Last Raid" & "\n" & $g_sAttackFile)
If _Sleep($DELAYPUSHMSG1) Then Return
Local $iDelete = FileDelete($g_sProfileLootsPath & $g_sAttackFile)
If Not $iDelete Then
If $g_bNotifyPBEnable Then SetLog("Notify PushBullet: An error occurred deleting temporary screenshot file.", $COLOR_ERROR)
If $g_bNotifyTGEnable Then SetLog("Notify Telegram: An error occurred deleting temporary screenshot file.", $COLOR_ERROR)
EndIf
EndIf
Case "FoundWalls"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertUpgradeWalls Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Wall-Up_Info_02", "Found Wall level") & " " & $g_iCmbUpgradeWallsLevel + 4 & "\n" & " " & GetTranslatedFileIni("MBR Func_Notify", "Wall-Up_Info_04", "Wall segment has been located") & "...\n" & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_01", "Upgrading") & "...")
Case "SkipWalls"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertUpgradeWalls Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Wall-Up_Info_03", "Cannot find Wall level") & $g_iCmbUpgradeWallsLevel + 4 & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_02", "Skip upgrade") & "...")
Case "AnotherDevice3600"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertAnotherDevice Then NotifyPushToBoth($g_sNotifyOrigin & " | 1. " & GetTranslatedFileIni("MBR Func_Notify", "Another-Device_Info_01", "Another Device has connected") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Another-Device_Info_02", "Another Device has connected, waiting") & " " & Floor(Floor($g_iAnotherDeviceWaitTime / 60) / 60) & " " & GetTranslatedFileIni("MBR Global GUI Design", "Hours", -1) & " " & Floor(Mod(Floor($g_iAnotherDeviceWaitTime / 60), 60)) & " " & GetTranslatedFileIni("MBR Global GUI Design", "Min", -1) & " " & Floor(Mod($g_iAnotherDeviceWaitTime, 60)) & " " & GetTranslatedFileIni("MBR Global GUI Design", "seconds", -1))
Case "AnotherDevice60"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertAnotherDevice Then NotifyPushToBoth($g_sNotifyOrigin & " | 2. " & GetTranslatedFileIni("MBR Func_Notify", "Another-Device_Info_01", "Another Device has connected") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Another-Device_Info_02", "Another Device has connected, waiting") & " " & Floor(Mod(Floor($g_iAnotherDeviceWaitTime / 60), 60)) & " " & GetTranslatedFileIni("MBR Global GUI Design", "Min", -1) & " " & Floor(Mod($g_iAnotherDeviceWaitTime, 60)) & " " & GetTranslatedFileIni("MBR Global GUI Design", "seconds", -1))
Case "AnotherDevice"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertAnotherDevice Then NotifyPushToBoth($g_sNotifyOrigin & " | 3. " & GetTranslatedFileIni("MBR Func_Notify", "Another-Device_Info_01", "Another Device has connected") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Another-Device_Info_02", "Another Device has connected, waiting") & " " & Floor(Mod($g_iAnotherDeviceWaitTime, 60)) & " " & GetTranslatedFileIni("MBR Global GUI Design", "seconds", -1))
Case "TakeBreak"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertTakeBreak Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Need-Rest_Info_01", "Chief, we need some rest!") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Take-Break_Info_01", "Village must take a break.."))
Case "Update"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertBOTUpdate Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "New-Version_Info_01", "Chief, there is a new version of the bot available"))
Case "BuilderIdle"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertBulderIdle Then
Local $iAvailBldr = $g_iFreeBuilderCount -($g_bUpgradeWallSaveBuilder ? 1 : 0)
If $iAvailBldr > 0 Then
If $iReportIdleBuilder <> $iAvailBldr Then
NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_03", "You have") & " " & $iAvailBldr & " " & GetTranslatedFileIni("MBR Func_Notify", "BUILDER_Info_03", "builder(s) idle."))
SetLog("You have " & $iAvailBldr & " builder(s) idle.", $COLOR_SUCCESS)
$iReportIdleBuilder = $iAvailBldr
EndIf
Else
$iReportIdleBuilder = 0
EndIf
EndIf
Case "CocError"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertOutOfSync Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "LOG_Info_04", "CoC Has Stopped Error") & ".....")
Case "Pause"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyRemoteEnable And $Source = "Push" Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_17", "Request to Pause") & "..." & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_13", "Your request has been received. Bot is now paused"))
Case "Resume"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyRemoteEnable And $Source = "Push" Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_18", "Request to Resume") & "..." & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_14", "Your request has been received. Bot is now resumed"))
Case "OoSResources"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertOutOfSync Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "LOG_Info_06", "Disconnected after") & " " & StringFormat("%3s", $g_iSearchCount) & " " & GetTranslatedFileIni("MBR Func_Notify", "Skip_Info_01", "skip(s)") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Attack_Info_02", "Cannot locate Next button, Restarting Bot") & "...")
Case "MatchFound"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertMatchFound Then NotifyPushToBoth($g_sNotifyOrigin & " | " & $g_asModeText[$g_iMatchMode] & " " & GetTranslatedFileIni("MBR Func_Notify", "Match-Found_Info_01", "Match Found! after") & " " & StringFormat("%3s", $g_iSearchCount) & " " & GetTranslatedFileIni("MBR Func_Notify", "Skip_Info_01", "skip(s)") & "\n" & "[" & GetTranslatedFileIni("MBR Func_Notify", "Stats-G_Info_01", "G") & "]: " & _NumberFormat($g_iSearchGold) & "; [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-E_Info_01", "E") & "]: " & _NumberFormat($g_iSearchElixir) & "; [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-DE_Info_01", "DE") & "]: " & _NumberFormat($g_iSearchDark) & "; [" & GetTranslatedFileIni("MBR Func_Notify", "Stats-T_Info_01", "T") & "]: " & $g_iSearchTrophy)
Case "UpgradeWithGold"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertUpgradeWalls Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_07", "Upgrade completed by using GOLD") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_03", "Complete by using GOLD") & "...")
Case "UpgradeWithElixir"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertUpgradeWalls Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_08", "Upgrade completed by using ELIXIR") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_04", "Complete by using ELIXIR") & "...")
Case "NoUpgradeWallButton"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertUpgradeWalls Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_05", "No Upgrade Gold Button") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_10", "Cannot find gold upgrade button") & "...")
Case "NoUpgradeElixirButton"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertUpgradeWalls Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_09", "No Upgrade Elixir Button") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_06", "Cannot find elixir upgrade button") & "...")
Case "RequestScreenshot"
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion()
If $g_bPBRequestScreenshotHD Or $g_bTGRequestScreenshotHD Then
$hBitmap_Scaled = $g_hBitmap
Else
$hBitmap_Scaled = _GDIPlus_ImageResize($g_hBitmap, _GDIPlus_ImageGetWidth($g_hBitmap) / 2, _GDIPlus_ImageGetHeight($g_hBitmap) / 2)
EndIf
Local $Screnshotfilename = "Screenshot_" & $Date & "_" & $Time & ".jpg"
_GDIPlus_ImageSaveToFile($hBitmap_Scaled, $g_sProfileTempPath & $Screnshotfilename)
_GDIPlus_ImageDispose($hBitmap_Scaled)
If $g_bPBRequestScreenshot Or $g_bTGRequestScreenshot Then
If $g_bPBRequestScreenshot And $g_bNotifyPBEnable Then
NotifyPushFileToPushBullet($Screnshotfilename, "Temp", "image/jpeg", $g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT_Info_04", "Screenshot of your village") & " " & "\n" & $Screnshotfilename)
SetLog("Notify PushBullet: Screenshot sent!", $COLOR_SUCCESS)
EndIf
If $g_bTGRequestScreenshot And $g_bNotifyTGEnable Then
NotifyPushFileToTelegram($Screnshotfilename, "Temp", "image/jpeg", $g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT_Info_04", "Screenshot of your village") & " " & "\n" & $Screnshotfilename)
SetLog("Notify Telegram: Screenshot sent!", $COLOR_SUCCESS)
EndIf
EndIf
$g_bPBRequestScreenshot = False
$g_bPBRequestScreenshotHD = False
$g_bTGRequestScreenshot = False
$g_bTGRequestScreenshotHD = False
If _Sleep($DELAYPUSHMSG2) Then Return
Local $iDelete = FileDelete($g_sProfileTempPath & $Screnshotfilename)
If Not $iDelete Then
If $g_bNotifyPBEnable Then SetLog("Notify PushBullet: An error occurred deleting temporary screenshot file.", $COLOR_ERROR)
If $g_bNotifyTGEnable Then SetLog("Notify Telegram: An error occurred deleting temporary screenshot file.", $COLOR_ERROR)
EndIf
Case "BuilderInfo"
Click(0, 0, 5)
Click(274, 8)
_Sleep(500)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion(224, 74, 446, 262)
Local $Screnshotfilename = "Screenshot_" & $Date & "_" & $Time & ".jpg"
_GDIPlus_ImageSaveToFile($g_hBitmap, $g_sProfileTempPath & $Screnshotfilename)
If $g_bPBRequestBuilderInfo Or $g_bTGRequestBuilderInfo Then
If $g_bPBRequestBuilderInfo And $g_bNotifyPBEnable Then
NotifyPushFileToPushBullet($Screnshotfilename, "Temp", "image/jpeg", $g_sNotifyOrigin & " | " & "Builder Information" & "\n" & $Screnshotfilename)
SetLog("Notify PushBullet: Builder Information sent!", $COLOR_GREEN)
EndIf
If $g_bTGRequestBuilderInfo And $g_bNotifyTGEnable Then
NotifyPushFileToTelegram($Screnshotfilename, "Temp", "image/jpeg", $g_sNotifyOrigin & " | " & "Builder Information" & "\n" & $Screnshotfilename)
SetLog("Notify Telegram: Builder Information sent!", $COLOR_GREEN)
EndIf
EndIf
$g_bPBRequestBuilderInfo = False
$g_bTGRequestBuilderInfo = False
If _Sleep($DELAYPUSHMSG2) Then Return
Local $iDelete = FileDelete($g_sProfileTempPath & $Screnshotfilename)
If Not $iDelete Then
If $g_bNotifyPBEnable Then SetLog("Notify PushBullet: An error occurred deleting temporary screenshot file.", $COLOR_ERROR)
If $g_bNotifyTGEnable Then SetLog("Notify Telegram: An error occurred deleting temporary screenshot file.", $COLOR_ERROR)
EndIf
Click(0, 0, 5)
Case "ShieldInfo"
Click(0, 0, 5)
Click(435, 8)
_Sleep(500)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion(200, 165, 660, 568)
Local $Screnshotfilename = "Screenshot_" & $Date & "_" & $Time & ".jpg"
_GDIPlus_ImageSaveToFile($g_hBitmap, $g_sProfileTempPath & $Screnshotfilename)
If $g_bPBRequestShieldInfo Or $g_bTGRequestShieldInfo Then
If $g_bPBRequestShieldInfo And $g_bNotifyPBEnable Then
NotifyPushFileToPushBullet($Screnshotfilename, "Temp", "image/jpeg", $g_sNotifyOrigin & " | " & "Shield Information" & "\n" & $Screnshotfilename)
SetLog("Notify PushBullet: Shield Information sent!", $COLOR_SUCCESS)
EndIf
If $g_bTGRequestShieldInfo And $g_bNotifyTGEnable Then
NotifyPushFileToTelegram($Screnshotfilename, "Temp", "image/jpeg", $g_sNotifyOrigin & " | " & "Shield Information" & "\n" & $Screnshotfilename)
SetLog("Notify Telegram: Shield Information sent!", $COLOR_SUCCESS)
EndIf
EndIf
$g_bPBRequestShieldInfo = False
$g_bTGRequestShieldInfo = False
If _Sleep($DELAYPUSHMSG2) Then Return
Local $iDelete = FileDelete($g_sProfileTempPath & $Screnshotfilename)
If Not $iDelete Then
If $g_bNotifyPBEnable Then SetLog("Notify PushBullet: An error occurred deleting temporary screenshot file.", $COLOR_ERROR)
If $g_bNotifyTGEnable Then SetLog("Notify Telegram: An error occurred deleting temporary screenshot file.", $COLOR_ERROR)
EndIf
Click(0, 0, 5)
Case "DeleteAllPBMessages"
NotifyDeletePushBullet()
If $g_bNotifyPBEnable Then SetLog("Notify PushBullet: All messages deleted.", $COLOR_SUCCESS)
If $g_bNotifyTGEnable Then SetLog("Notify Telegram: All messages deleted.", $COLOR_SUCCESS)
$g_bNotifyDeleteAllPushesNow = False
Case "CampFull"
If($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyAlertCampFull Then
NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Camps-Full_Info_01", "Your Army Camps are now Full"))
If $g_bNotifyPBEnable Then SetLog("Notify PushBullet: Your Army Camps are now Full", $COLOR_SUCCESS)
If $g_bNotifyTGEnable Then SetLog("Notify Telegram: Your Army Camps are now Full", $COLOR_SUCCESS)
EndIf
Case "Misc"
NotifyPushToBoth($Message)
EndSwitch
EndFunc
Func NotifyPushFileToBoth($File, $Folder, $FileType, $body)
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyPushFileToBoth($File, $Folder, $FileType, $body): " & $File & "," & $Folder & "," & $FileType & "," & $body)
If(Not $g_bNotifyPBEnable Or $g_sNotifyPBToken = "") And(Not $g_bNotifyTGEnable Or $g_sNotifyTGToken = "") Then Return
If $g_bNotifyPBEnable And $g_sNotifyPBToken <> "" Then
If FileExists($g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File) Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("PushBullet Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/upload-request", False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"file_name": "' & $File & '", "file_type": "' & $FileType & '"}'
$oHTTP.Send($pPush)
$oHTTP.WaitForResponse
Local $Result = $oHTTP.ResponseText
If $oHTTP.Status <> 200 Then
SetLog("PushBullet status is: " & $oHTTP.Status, $COLOR_ERROR)
Return
EndIf
Local $upload_url = _StringBetween($Result, 'upload_url":"', '"')
Local $awsaccesskeyid = _StringBetween($Result, 'awsaccesskeyid":"', '"')
Local $acl = _StringBetween($Result, 'acl":"', '"')
Local $key = _StringBetween($Result, 'key":"', '"')
Local $signature = _StringBetween($Result, 'signature":"', '"')
Local $policy = _StringBetween($Result, 'policy":"', '"')
Local $file_url = _StringBetween($Result, 'file_url":"', '"')
If IsArray($upload_url) And IsArray($awsaccesskeyid) And IsArray($acl) And IsArray($key) And IsArray($signature) And IsArray($policy) Then
$Result = RunWait($g_sCurlPath & " -i -X POST " & $upload_url[0] & ' -F awsaccesskeyid="' & $awsaccesskeyid[0] & '" -F acl="' & $acl[0] & '" -F key="' & $key[0] & '" -F signature="' & $signature[0] & '" -F policy="' & $policy[0] & '" -F content-type="' & $FileType & '" -F file=@"' & $g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File & '"', "", @SW_HIDE)
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/pushes", False)
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"type": "file", "file_name": "' & $File & '", "file_type": "' & $FileType & '", "file_url": "' & $file_url[0] & '", "body": "' & $body & '"}'
$oHTTP.Send($pPush)
$oHTTP.WaitForResponse
Else
SetLog(GetTranslatedFileIni("MBR Func_Notify", "Notify_001", "Notify PushBullet") & ": " & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_05", "Unable to send file") & " " & $File, $COLOR_ERROR)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_03", "Unable to Upload File") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_04", "Occured an error type") & " 1 " & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_01", "uploading file to PushBullet server") & "...")
EndIf
Else
SetLog("Notify PushBullet: Unable to send file " & $File, $COLOR_ERROR)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_03", "Unable to Upload File") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_04", "Occured an error type") & " 2 " & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_01", "uploading file to PushBullet server") & "...")
EndIf
EndIf
If $g_bNotifyTGEnable And $g_sNotifyTGToken <> "" Then
If FileExists($g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File) Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
If @error Then
SetLog("Telegram Obj Error code: " & Hex(@error, 8), $COLOR_ERROR)
Return
EndIf
Local $telegram_url = "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/sendPhoto"
Local $Result = RunWait($g_sCurlPath & " -i -X POST " & $telegram_url & ' -F chat_id="' & $g_sTGChatID & ' " -F photo=@"' & $g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File & '"', "", @SW_HIDE)
$oHTTP.Open("Post", "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/sendPhoto", False)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"type": "file", "file_name": "' & $File & '", "file_type": "' & $FileType & '", "file_url": "' & $telegram_url & '", "body": "' & $body & '"}'
$oHTTP.Send($pPush)
$oHTTP.WaitForResponse
Else
SetLog("Notify Telegram: Unable to send file " & $File, $COLOR_ERROR)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_03", "Unable to Upload File") & "\n" & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_02", "Occured an error type 2 uploading file to Telegram server..."))
EndIf
EndIf
EndFunc
Func __ErrFunc($oError)
SetLog("COM Error intercepted !" & @CRLF & "Scriptline is: " & $oError.scriptline & @CRLF & "Number is: " & Hex($oError.number, 8) & @CRLF & "Returncode is: " & Hex($oError.retcode, 8) & @CRLF & "WinDescription is: " & $oError.windescription & @CRLF & "Description is: " & $oError.description, $COLOR_RED)
EndFunc
Func __ObjEventIni()
$g_oCOMErrorHandler = ObjEvent("AutoIt.Error", "__ErrFunc")
EndFunc
Func __ObjEventEnds()
$g_oCOMErrorHandler = 0
EndFunc
Global Const $sColorNA = Hex(0xD3D3CB, 6)
Global Const $sColorNoLoot = Hex(0xFD877E, 6)
Global Const $sColorMaxLvl = Hex(0xFFFFFF, 6)
Global Const $sColorNotPossible = Hex(0xC0C0C0, 6)
Global Const $sColorMaxTroop = Hex(0xFFC360, 6)
Func Laboratory()
Static $aUpgradeValue[30] = [-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $iAvailElixir, $iAvailDark, $sElixirCount, $sDarkCount, $TimeDiff, $aArray, $Result
$g_iUpgradeMinElixir = Number($g_iUpgradeMinElixir)
$g_iUpgradeMinDark = Number($g_iUpgradeMinDark)
$g_iLaboratoryElixirCost = 0
If Not $g_bAutoLabUpgradeEnable Then Return
If $g_iCmbLaboratory = 0 Then
SetLog("Laboratory enabled, but no troop upgrade selected", $COLOR_WARNING)
Return False
EndIf
If $g_aiLaboratoryPos[0] = 0 Or $g_aiLaboratoryPos[1] = 0 Then
SetLog("Laboratory Location not found!", $COLOR_ERROR)
LocateLab()
If $g_aiLaboratoryPos[0] = 0 Or $g_aiLaboratoryPos[1] = 0 Then
SetLog("Problem locating Laboratory, train laboratory position before proceeding", $COLOR_ERROR)
Return False
EndIf
EndIf
If $g_sLabUpgradeTime <> "" Then $TimeDiff = _DateDiff("n", _NowCalc(), $g_sLabUpgradeTime)
If @error Then _logErrorDateDiff(@error)
If $g_bDebugSetlog Then SetDebugLog($g_avLabTroops[$g_iCmbLaboratory][3] & " Lab end time: " & $g_sLabUpgradeTime & ", DIFF= " & $TimeDiff, $COLOR_DEBUG)
If Not $g_bRunState Then Return
If $TimeDiff <= 0 Then
SetLog("Checking Troop Upgrade in Laboratory ...", $COLOR_INFO)
Else
SetLog("Laboratory Upgrade in progress, waiting for completion", $COLOR_INFO)
Return False
EndIf
If _CheckPixel($aVillageHasDarkElixir, $g_bCapturePixel) Then
$sElixirCount = getResourcesMainScreen(696, 74)
$sDarkCount = getResourcesMainScreen(728, 123)
SetLog("Updating village values [E]: " & $sElixirCount & " [D]: " & $sDarkCount, $COLOR_SUCCESS)
Else
$sElixirCount = getResourcesMainScreen(701, 74)
SetLog("Updating village values [E]: " & $sElixirCount, $COLOR_SUCCESS)
EndIf
$iAvailElixir = Number($sElixirCount)
$iAvailDark = Number($sDarkCount)
BuildingClickP($g_aiLaboratoryPos, "#0197")
If _Sleep($DELAYLABORATORY3) Then Return
Local $offColors[4][3] = [[0x708CB0, 37, 34], [0x603818, 50, 43], [0xD5FC58, 61, 8], [0x000000, 82, 0]]
Local $ButtonPixel = _MultiPixelSearch(433, 565 + $g_iBottomOffsetY, 562, 619 + $g_iBottomOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Then
SetDebugLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetDebugLog("#1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 37, $ButtonPixel[1] + 34, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 50, $ButtonPixel[1] + 43, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 61, $ButtonPixel[1] + 8, True), $COLOR_DEBUG)
EndIf
If $g_bDebugImageSave Then DebugImageSave("LabUpgrade")
Click($ButtonPixel[0] + 40, $ButtonPixel[1] + 25, 1, 0, "#0198")
If _Sleep($DELAYLABORATORY1) Then Return
Else
SetLog("Trouble finding research button, try again...", $COLOR_WARNING)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0199")
Return False
EndIf
If $g_bDebugSetlog Then LabTroopImages1()
If $g_iFirstTimeLab = 0 Then
For $i = 1 To 10
$aUpgradeValue[$i] = getLabUpgrdResourceRed($g_avLabTroops[$i][0] + 13, $g_avLabTroops[$i][1] + 74)
If $g_bDebugSetlog Then SetDebugLog($g_avLabTroops[$i][3] & " Red text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 49999 Then
$aUpgradeValue[$i] = getLabUpgrdResourceWht($g_avLabTroops[$i][0] + 13, $g_avLabTroops[$i][1] + 74)
If $g_bDebugSetlog Then SetDebugLog($g_avLabTroops[$i][3] & " White text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 49999 Then
If _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 77, $g_avLabTroops[$i][1] + 77, True), $sColorMaxLvl, 20) And _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 77, $g_avLabTroops[$i][1] + 82, True), $sColorMaxLvl, 20) Then
$aUpgradeValue[$i] = -1
If $g_bDebugSetlog Then SetDebugLog($g_avLabTroops[$i][3] & " Is Maxed already, now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
EndIf
If Not $g_bRunState Then Return
Next
$g_iFirstTimeLab = 1
EndIf
If $g_avLabTroops[$g_iCmbLaboratory][2] >= 1 Then
ClickDrag(650, 443 + $g_iMidOffsetY, 323, 443 + $g_iMidOffsetY, 1000)
If _Sleep($DELAYLABORATORY3) Then Return
If $g_bDebugSetlog Then LabTroopImages2()
If $g_iFirstTimeLab < 2 Then
For $i = 11 To 18
$aUpgradeValue[$i] = getLabUpgrdResourceRed($g_avLabTroops[$i][0] + 13, $g_avLabTroops[$i][1] + 74)
If $g_bDebugSetlog Then SetDebugLog($g_avLabTroops[$i][3] & " Red text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 9999 Then
$aUpgradeValue[$i] = getLabUpgrdResourceWht($g_avLabTroops[$i][0] + 13, $g_avLabTroops[$i][1] + 74)
If $g_bDebugSetlog Then SetDebugLog($g_avLabTroops[$i][3] & " White text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 9999 Then
If _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 77, $g_avLabTroops[$i][1] + 77, True), $sColorMaxLvl, 20) And _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 77, $g_avLabTroops[$i][1] + 82, True), $sColorMaxLvl, 20) Then
$aUpgradeValue[$i] = -1
If $g_bDebugSetlog Then SetDebugLog($g_avLabTroops[$i][3] & " Is Maxed already, $aUpgradeValue now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
EndIf
If Not $g_bRunState Then Return
Next
$g_iFirstTimeLab += 2
EndIf
EndIf
If $g_avLabTroops[$g_iCmbLaboratory][2] = 2 Then
ClickDrag(734, 443 + $g_iMidOffsetY, 3, 443 + $g_iMidOffsetY, 2000)
If _Sleep($DELAYLABORATORY3) Then Return
If $g_bDebugSetlog Then LabTroopImages3()
If $g_iFirstTimeLab < 4 Then
For $i = 19 To 29
$aUpgradeValue[$i] = getLabUpgrdResourceRed($g_avLabTroops[$i][0] + 13, $g_avLabTroops[$i][1] + 74)
If $g_bDebugSetlog Then SetDebugLog($g_avLabTroops[$i][3] & " Red text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 9999 Then
$aUpgradeValue[$i] = getLabUpgrdResourceWht($g_avLabTroops[$i][0] + 13, $g_avLabTroops[$i][1] + 74)
If $g_bDebugSetlog Then SetDebugLog($g_avLabTroops[$i][3] & " White text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 9999 Then
If _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 77, $g_avLabTroops[$i][1] + 77, True), $sColorMaxLvl, 20) And _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 77, $g_avLabTroops[$i][1] + 82, True), $sColorMaxLvl, 20) Then
$aUpgradeValue[$i] = -1
If $g_bDebugSetlog Then SetDebugLog($g_avLabTroops[$i][3] & " Is Maxed already, $aUpgradeValue now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
EndIf
If Not $g_bRunState Then Return
Next
$g_iFirstTimeLab += 4
EndIf
EndIf
Switch $g_iCmbLaboratory
Case 1 To 18
If $aUpgradeValue[$g_iCmbLaboratory] > 0 Then $g_iLaboratoryElixirCost = $aUpgradeValue[$g_iCmbLaboratory]
EndSwitch
If _ColorCheck(_GetPixelColor(625, 266 + $g_iMidOffsetY, True), Hex(0x6CB91D, 6), 20) Or _ColorCheck(_GetPixelColor(660, 266 + $g_iMidOffsetY, True), Hex(0x6CB91D, 6), 20) Then
SetLog("Upgrade in progress, waiting for completion of other troops", $COLOR_INFO)
If _Sleep($DELAYLABORATORY2) Then Return
If $g_sLabUpgradeTime = "" Or $TimeDiff <= 0 Then
$Result = getRemainTLaboratory(270, 257)
If $g_bDebugSetlog Then SetDebugLog($g_avLabTroops[$g_iCmbLaboratory][3] & " OCR Remaining Lab Time = " & $Result, $COLOR_DEBUG)
$aArray = StringSplit($Result, ' ', BitOR($STR_CHRSPLIT, $STR_NOCOUNT))
If IsArray($aArray) Then
Local $iRemainingTimeMin = 0
For $i = 0 To UBound($aArray) - 1
Local $sTime = ""
Select
Case StringInStr($aArray[$i], "d", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin +=(Int($sTime) * 24 * 60)
Case StringInStr($aArray[$i], "h", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin +=(Int($sTime) * 60)
Case StringInStr($aArray[$i], "m", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += Int($sTime)
Case StringInStr($aArray[$i], "s", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += Int($sTime) / 60
Case Else
SetLog("Remaining lab time OCR invalid:" & $aArray[$i], $COLOR_WARNING)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0328")
Return False
EndSelect
If $g_bDebugSetlog Then SetDebugLog("Remain Lab Time: " & $aArray[$i] & ", Minutes= " & $iRemainingTimeMin, $COLOR_DEBUG)
Next
$g_sLabUpgradeTime = _DateAdd('n', Ceiling($iRemainingTimeMin), _NowCalc())
If @error Then _logErrorDateAdd(@error)
SetLog("Updated Lab finishing time: " & $g_sLabUpgradeTime, $COLOR_SUCCESS)
LabStatusGUIUpdate()
Else
If $g_bDebugSetlog Then SetDebugLog("Invalid getRemainTLaboratory OCR", $COLOR_DEBUG)
EndIf
EndIf
ClickP($aAway, 2, $DELAYLABORATORY4, "#0328")
Return False
EndIf
If $aUpgradeValue[$g_iCmbLaboratory] = -1 Then
SetLog($g_avLabTroops[$g_iCmbLaboratory][3] & " already max level, select another troop", $COLOR_ERROR)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0353")
Return False
EndIf
If $aUpgradeValue[$g_iCmbLaboratory] = 0 Then
If _ColorCheck(_GetPixelColor($g_avLabTroops[$g_iCmbLaboratory][0] + 3, $g_avLabTroops[$g_iCmbLaboratory][1] + 19, True), Hex(0xC0C0C0, 6), 25) = True Then
SetLog("Lab upgrade not available for " & $g_avLabTroops[$g_iCmbLaboratory][3] & ", Pick different troop!", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
Else
SetLog($g_avLabTroops[$g_iCmbLaboratory][3] & " value read error, close bot and try again!", $COLOR_ERROR)
EndIf
$g_iFirstTimeLab = 2
ClickP($aAway, 2, $DELAYLABORATORY4, "#0354")
Return False
EndIf
Switch $g_iCmbLaboratory
Case 1 To 18
If $iAvailElixir <($aUpgradeValue[$g_iCmbLaboratory] + $g_iUpgradeMinElixir) Then
SetLog("Insufficent Elixir for " & $g_avLabTroops[$g_iCmbLaboratory][3] & ", Lab requires: " & $aUpgradeValue[$g_iCmbLaboratory] & " + " & $g_iUpgradeMinElixir & " user reserve, available: " & $iAvailElixir, $COLOR_INFO)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0355")
Return False
EndIf
If LabUpgrade() = True Then
SetLog("Elixir used = " & $aUpgradeValue[$g_iCmbLaboratory], $COLOR_INFO)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0356")
Return True
EndIf
Case 19 To 29
If $iAvailDark < $aUpgradeValue[$g_iCmbLaboratory] + $g_iUpgradeMinDark Then
SetLog("Insufficent Dark Elixir for " & $g_avLabTroops[$g_iCmbLaboratory][3] & ", Lab requires: " & $aUpgradeValue[$g_iCmbLaboratory] & " + " & $g_iUpgradeMinDark & " user reserve, available: " & $iAvailDark, $COLOR_INFO)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0357")
Return False
EndIf
If LabUpgrade() = True Then
SetLog("Dark Elixir used = " & $aUpgradeValue[$g_iCmbLaboratory], $COLOR_INFO)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0358")
Return True
EndIf
Case Else
SetLog("Something went wrong with loot value on Lab upgrade on #" & $g_avLabTroops[$g_iCmbLaboratory][3], $COLOR_ERROR)
Return False
EndSwitch
ClickP($aAway, 2, $DELAYLABORATORY4, "#0359")
Return False
EndFunc
Func LabUpgrade()
Local $StartTime, $EndTime, $EndPeriod, $Result, $TimeAdd = 0
Select
Case _ColorCheck(_GetPixelColor($g_avLabTroops[$g_iCmbLaboratory][0] + 47, $g_avLabTroops[$g_iCmbLaboratory][1] + 6, True), $sColorNA, 20) = True
SetLog($g_avLabTroops[$g_iCmbLaboratory][3] & " not unlocked yet, select another troop", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
Case _PixelSearch($g_avLabTroops[$g_iCmbLaboratory][0] + 67, $g_avLabTroops[$g_iCmbLaboratory][1] + 79, $g_avLabTroops[$g_iCmbLaboratory][0] + 69, $g_avLabTroops[$g_iCmbLaboratory][0] + 84, $sColorNoLoot, 20) <> 0
SetLog("Value check error and Not enough Loot to upgrade " & $g_avLabTroops[$g_iCmbLaboratory][3] & "...", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
Case _ColorCheck(_GetPixelColor($g_avLabTroops[$g_iCmbLaboratory][0] + 22, $g_avLabTroops[$g_iCmbLaboratory][1] + 60, True), Hex(0xFFC360, 6), 20) = True
SetLog($g_avLabTroops[$g_iCmbLaboratory][3] & " already max level, select another troop", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
Case _ColorCheck(_GetPixelColor($g_avLabTroops[$g_iCmbLaboratory][0] + 3, $g_avLabTroops[$g_iCmbLaboratory][1] + 19, True), Hex(0xB7B7B7, 6), 20) = True
SetLog("Laboratory upgrade not available now for " & $g_avLabTroops[$g_iCmbLaboratory][3] & "...", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
Case Else
Click($g_avLabTroops[$g_iCmbLaboratory][0] + 40, $g_avLabTroops[$g_iCmbLaboratory][1] + 40, 1, 0, "#0200")
If _Sleep($DELAYLABUPGRADE1) Then Return
If $g_bDebugImageSave Then DebugImageSave("LabUpgrade")
If _ColorCheck(_GetPixelColor(258, 192, True), Hex(0xFF1919, 6), 20) And _ColorCheck(_GetPixelColor(272, 194, True), Hex(0xFF1919, 6), 20) Then
SetLog($g_avLabTroops[$g_iCmbLaboratory][3] & " Previously maxxed, select another troop", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
ClickP($aAway, 2, $DELAYLABUPGRADE3, "#0201")
Return False
EndIf
If _PixelSearch($g_avLabTroops[$g_iCmbLaboratory][0] + 67, $g_avLabTroops[$g_iCmbLaboratory][1] + 79, $g_avLabTroops[$g_iCmbLaboratory][0] + 69, $g_avLabTroops[$g_iCmbLaboratory][0] + 84, $sColorNoLoot, 20) <> 0 Then
SetLog("Missing Loot to upgrade " & $g_avLabTroops[$g_iCmbLaboratory][3] & " (secondary check after Upgrade Value read failed)", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
ClickP($aAway, 2, $DELAYLABUPGRADE3, "#0333")
Return False
EndIf
If _ColorCheck(_GetPixelColor(625, 250 + $g_iMidOffsetY, True), Hex(0x848484, 6), 20) And _ColorCheck(_GetPixelColor(660, 250 + $g_iMidOffsetY, True), Hex(0x848484, 6), 20) Then
SetLog("Upgrade in progress, waiting for completion of other troops", $COLOR_WARNING)
If _Sleep($DELAYLABORATORY2) Then Return
ClickP($aAway, 2, $DELAYLABORATORY4, "#0000")
Return False
Else
$Result = getLabUpgradeTime(481, 557)
SetLog($g_avLabTroops[$g_iCmbLaboratory][3] & " Upgrade OCR Time = " & $Result, $COLOR_INFO)
$StartTime = _NowCalc()
If $g_bDebugSetlog Then SetDebugLog($g_avLabTroops[$g_iCmbLaboratory][3] & "Upgrade Started @ " & $StartTime, $COLOR_SUCCESS)
$EndTime = ""
$EndPeriod = ""
$TimeAdd = 0
$g_sLabUpgradeTime = StringStripWS($Result, $STR_STRIPALL)
Local $aArray = StringRegExp($g_sLabUpgradeTime, '\d+', $STR_REGEXPARRAYMATCH)
If IsArray($aArray) Then
If $g_bDebugSetlog Then
For $i = 0 To UBound($aArray) - 1
SetLog("UpgradeTime $aArray[" & $i & "] = " & $aArray[$i])
Next
EndIf
$EndTime = $aArray[0]
$EndPeriod = StringReplace($g_sLabUpgradeTime, $EndTime, "")
Switch $EndPeriod
Case "d"
$TimeAdd =(Int($EndTime) * 24 * 60) - 10
$g_sLabUpgradeTime = _DateAdd('n', $TimeAdd, $StartTime)
Case "h"
$TimeAdd =(Int($EndTime) * 60) - 3
$g_sLabUpgradeTime = _DateAdd('n', $TimeAdd, $StartTime)
Case "m"
$TimeAdd = Int($EndTime)
$g_sLabUpgradeTime = _DateAdd('n', $TimeAdd, $StartTime)
Case Else
SetLog("Upgrade time period invalid, try again!", $COLOR_WARNING)
EndSwitch
If $g_bDebugSetlog Then SetDebugLog("$EndTime = " & $EndTime & " , $EndPeriod = " & $EndPeriod & ", $timeadd = " & $TimeAdd, $COLOR_DEBUG)
SetLog($g_avLabTroops[$g_iCmbLaboratory][3] & "Upgrade Finishes @ " & $g_sLabUpgradeTime, $COLOR_SUCCESS)
Else
SetLog("Error reading the upgrade time required, try again!", $COLOR_WARNING)
EndIf
If _DateIsValid($g_sLabUpgradeTime) = 0 Then
SetLog("Error processing upgrade time required, try again!", $COLOR_WARNING)
Return False
Else
Local $txtTip = GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_01", "Visible Red button means that laboratory upgrade in process") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_02", "This will automatically disappear when near time for upgrade to be completed.") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_03", "If upgrade has been manually finished with gems before normal end time,") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_04", "Click red button to reset internal upgrade timer BEFORE STARTING NEW UPGRADE") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_05", "Caution - Unnecessary timer reset will force constant checks for lab status") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_06", "Troop Upgrade started") & ": " & $StartTime & ", " & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_07", "Will begin to check completion at:") & " " & $g_sLabUpgradeTime & @CRLF & " "
_GUICtrlSetTip($g_hBtnResetLabUpgradeTime, $txtTip)
EndIf
Click(660, 520 + $g_iMidOffsetY, 1, 0, "#0202")
If _Sleep($DELAYLABUPGRADE1) Then Return
EndIf
If isGemOpen(True) = False Then
If Not(_ColorCheck(_GetPixelColor(625, 266 + $g_iMidOffsetY, True), Hex(0x6CB91D, 6), 20) Or _ColorCheck(_GetPixelColor(660, 266 + $g_iMidOffsetY, True), Hex(0x6CB91D, 6), 20)) Then
SetLog("Something went wrong with " & $g_avLabTroops[$g_iCmbLaboratory][3] & " Upgrade, try again.", $COLOR_ERROR)
ClickP($aAway, 2, $DELAYLABUPGRADE3, "#0360")
Return False
EndIf
SetLog("Upgrade " & $g_avLabTroops[$g_iCmbLaboratory][3] & " in your laboratory is complete...", $COLOR_SUCCESS)
PushMsg("LabSuccess")
If _Sleep($DELAYLABUPGRADE2) Then Return
$g_bAutoLabUpgradeEnable = False
GUICtrlSetState($g_hChkAutoLabUpgrades, $GUI_UNCHECKED)
ClickP($aAway, 2, 0, "#0204")
Return True
Else
SetLog("Oops, Gems required for " & $g_avLabTroops[$g_iCmbLaboratory][3] & " Upgrade, try again.", $COLOR_ERROR)
EndIf
EndSelect
ClickP($aAway, 2, $DELAYLABUPGRADE3, "#0205")
Return False
EndFunc
Func DebugRegionSave($sTxtName = "Unknown", $iLeft = 0, $iTop = 0, $iRight = $g_iDEFAULT_WIDTH, $iBottom = $g_iDEFAULT_HEIGHT)
SetLog("Taking debug snapshot for later review", $COLOR_SUCCESS)
Local $Date = @MDAY & "_" & @MON & "_" & @YEAR
Local $Time = @HOUR & "_" & @MIN & "_" & @SEC
Local $sName = $g_sProfileTempDebugPath & "LabUpgrade\" & $sTxtName & "_" & $Date & "_" & $Time & ".png"
DirCreate($g_sProfileTempDebugPath & "LabUpgrade\")
ForceCaptureRegion()
_CaptureRegion($iLeft, $iTop, $iRight, $iBottom)
_GDIPlus_ImageSaveToFile($g_hBitmap, $sName)
If @error Then SetLog("DebugRegionSave failed to save LabUpgrade image: " & $sName, $COLOR_WARNING)
If _Sleep($DELAYLABORATORY2) Then Return
EndFunc
Func LabTroopImages1()
If $g_bDebugImageSave Then DebugImageSave("LabUpgrade")
For $i = 1 To 10
DebugRegionSave($g_avLabTroops[$i][3], $g_avLabTroops[$i][0], $g_avLabTroops[$i][1], $g_avLabTroops[$i][0] + 98, $g_avLabTroops[$i][1] + 98)
SetLog($g_avLabTroops[$i][3], $COLOR_WARNING)
SetLog("_GetPixelColor(+47, +6): " & _GetPixelColor($g_avLabTroops[$i][0] + 47, $g_avLabTroops[$i][1] + 6, True) & ":D3D3CB =Not unlocked", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +79): " & _GetPixelColor($g_avLabTroops[$i][0] + 68, $g_avLabTroops[$i][1] + 79, True) & ":FD877E =No Loot1", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +82): " & _GetPixelColor($g_avLabTroops[$i][0] + 68, $g_avLabTroops[$i][1] + 84, True) & ":FD877E =No Loot2", $COLOR_DEBUG)
SetLog("_GetPixelColor(+81, +82): " & _GetPixelColor($g_avLabTroops[$i][0] + 81, $g_avLabTroops[$i][1] + 82, True) & ":XXXXXX =Loot type", $COLOR_DEBUG)
SetLog("_GetPixelColor(+77, +82): " & _GetPixelColor($g_avLabTroops[$i][0] + 77, $g_avLabTroops[$i][1] + 82, True) & ":FFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+77, +77): " & _GetPixelColor($g_avLabTroops[$i][0] + 77, $g_avLabTroops[$i][1] + 77, True) & ":EFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+3, +19): " & _GetPixelColor($g_avLabTroops[$i][0] + 3, $g_avLabTroops[$i][1] + 19, True) & ":C0C0C0 =Not possible", $COLOR_DEBUG)
SetLog("_GetPixelColor(+8, +59): " & _GetPixelColor($g_avLabTroops[$i][0] + 23, $g_avLabTroops[$i][1] + 60, True) & ":FFC360 =Max troop", $COLOR_DEBUG)
Next
EndFunc
Func LabTroopImages2()
If $g_bDebugImageSave Then DebugImageSave("LabUpgrade")
For $i = 11 To 18
DebugRegionSave($g_avLabTroops[$i][3], $g_avLabTroops[$i][0], $g_avLabTroops[$i][1], $g_avLabTroops[$i][0] + 98, $g_avLabTroops[$i][1] + 98)
SetLog($g_avLabTroops[$i][3], $COLOR_WARNING)
SetLog("_GetPixelColor(+47, +6): " & _GetPixelColor($g_avLabTroops[$i][0] + 47, $g_avLabTroops[$i][1] + 6, True) & ":D3D3CB =Not unlocked", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +79): " & _GetPixelColor($g_avLabTroops[$i][0] + 68, $g_avLabTroops[$i][1] + 79, True) & ":FD877E =No Loot1", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +82): " & _GetPixelColor($g_avLabTroops[$i][0] + 68, $g_avLabTroops[$i][1] + 84, True) & ":FD877E =No Loot2", $COLOR_DEBUG)
SetLog("_GetPixelColor(+81, +82): " & _GetPixelColor($g_avLabTroops[$i][0] + 81, $g_avLabTroops[$i][1] + 82, True) & ":XXXXXX =Loot type", $COLOR_DEBUG)
SetLog("_GetPixelColor(+77, +82): " & _GetPixelColor($g_avLabTroops[$i][0] + 77, $g_avLabTroops[$i][1] + 82, True) & ":FFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+77, +77): " & _GetPixelColor($g_avLabTroops[$i][0] + 77, $g_avLabTroops[$i][1] + 77, True) & ":EFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+3, +19): " & _GetPixelColor($g_avLabTroops[$i][0] + 3, $g_avLabTroops[$i][1] + 19, True) & ":C0C0C0 =Not possible", $COLOR_DEBUG)
SetLog("_GetPixelColor(+8, +59): " & _GetPixelColor($g_avLabTroops[$i][0] + 23, $g_avLabTroops[$i][1] + 60, True) & ":FFC360 =Max troop", $COLOR_DEBUG)
Next
EndFunc
Func LabTroopImages3()
If $g_bDebugImageSave Then DebugImageSave("LabUpgrade")
For $i = 19 To 29
DebugRegionSave($g_avLabTroops[$i][3], $g_avLabTroops[$i][0], $g_avLabTroops[$i][1], $g_avLabTroops[$i][0] + 98, $g_avLabTroops[$i][1] + 98)
SetLog($g_avLabTroops[$i][3], $COLOR_WARNING)
SetLog("_GetPixelColor(+47, +6): " & _GetPixelColor($g_avLabTroops[$i][0] + 47, $g_avLabTroops[$i][1] + 6, True) & ":D3D3CB =Not unlocked", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +79): " & _GetPixelColor($g_avLabTroops[$i][0] + 68, $g_avLabTroops[$i][1] + 79, True) & ":FD877E =No Loot1", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +82): " & _GetPixelColor($g_avLabTroops[$i][0] + 68, $g_avLabTroops[$i][1] + 84, True) & ":FD877E =No Loot2", $COLOR_DEBUG)
SetLog("_GetPixelColor(+81, +82): " & _GetPixelColor($g_avLabTroops[$i][0] + 81, $g_avLabTroops[$i][1] + 82, True) & ":XXXXXX =Loot type", $COLOR_DEBUG)
SetLog("_GetPixelColor(+77, +82): " & _GetPixelColor($g_avLabTroops[$i][0] + 77, $g_avLabTroops[$i][1] + 82, True) & ":FFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+77, +77): " & _GetPixelColor($g_avLabTroops[$i][0] + 77, $g_avLabTroops[$i][1] + 77, True) & ":EFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+3, +19): " & _GetPixelColor($g_avLabTroops[$i][0] + 3, $g_avLabTroops[$i][1] + 19, True) & ":C0C0C0 =Not possible", $COLOR_DEBUG)
SetLog("_GetPixelColor(+8, +59): " & _GetPixelColor($g_avLabTroops[$i][0] + 23, $g_avLabTroops[$i][1] + 60, True) & ":FFC360 =Max troop", $COLOR_DEBUG)
Next
EndFunc
Func ReplayShare($bShareLastReplay)
If Not $g_bShareAttackEnable Or Not $bShareLastReplay Then Return
Local Static $sLastTimeShared = ""
If $sLastTimeShared = "" Or _DateDiff("m", $sLastTimeShared, _NowCalc()) > 30 Then
SetLog("Going to share the last Attack!")
ClickP($aAway, 1, 0, "#0235")
If _Sleep($DELAYREPLAYSHARE2) Then Return
ClickP($aMessageButton, 1, 0, "#0236")
If Not _WaitForCheckPixel($aAttackLogPage, $g_bCapturePixel) Then
SetLog("Error while checking if the Attack Log Page opened up", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0235")
Return
EndIf
Click(380, 90 + $g_iMidOffsetY, 1, 0, "#0237")
If Not _WaitForCheckPixel($aAttackLogAttackTab, $g_bCapturePixel) Then
SetLog("Error while trying to open Attacks Page", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0235")
Return
EndIf
Local $asReplayText = StringSplit($g_sShareMessage, "|")
Local $sRndMessage
If @error Then
$sRndMessage = $asReplayText[1]
Else
$sRndMessage = $asReplayText[Random(1, $asReplayText[0], 1)]
EndIf
If _CheckPixel($aBlueShareReplayButton, True) Then
ClickP($aBlueShareReplayButton, 1, 0, "#0238")
If _Sleep($DELAYREPLAYSHARE1) Then Return
Click(300, 120, 1, 0, "#0239")
If _Sleep($DELAYREPLAYSHARE1) Then Return
If Not $g_bChkBackgroundMode And Not $g_bNoFocusTampering Then ControlFocus($g_hAndroidWindow, "", "")
AndroidSendText($sRndMessage, True)
If _Sleep($DELAYREPLAYSHARE1) Then Return
If SendText($sRndMessage) = 0 Then
SetLog("Failed to insert Share Replay Text!", $COLOR_ERROR)
Return
EndIf
If _Sleep($DELAYREPLAYSHARE1) Then Return
Click(530, 210 + $g_iMidOffsetY, 1, 0, "#0240")
$sLastTimeShared = _NowCalc
ElseIf _CheckPixel($aGrayShareReplayButton, True) Then
SetLog("Sharing latest Attack is not enabled right now, storing it and share later!")
ClickP($aAway, 1, 0, "#0235")
Else
SetLog("Error checking Share Button State. Replay might be not available anymore or Bot made mistakes", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0235")
EndIf
Else
SetLog("Skip Replay Sharing because the 30 minutes cooldown is not over yet!")
EndIf
ClickP($aAway, 1, 0, "#0235")
EndFunc
Func BoostKing()
If AllowBoosting("Barbarian King", $g_iCmbBoostBarbarianKing) = False Then Return
SetLog("Boost Barbarian King...", $COLOR_INFO)
If $g_aiKingAltarPos[0] = "" Or $g_aiKingAltarPos[0] = -1 Then
LocateKingAltar()
SaveConfig()
If _Sleep($DELAYBOOSTHEROES4) Then Return
EndIf
If BoostStructure("Barbarian King", "King", $g_aiKingAltarPos, $g_iCmbBoostBarbarianKing, $g_hCmbBoostBarbarianKing) Then $g_aiHeroBoost[$eHeroBarbarianKing] = _NowCalc()
If _Sleep($DELAYBOOSTBARRACKS3) Then Return
checkMainScreen(False)
EndFunc
Func BoostQueen()
If AllowBoosting("Archer Queen", $g_iCmbBoostArcherQueen) = False Then Return
SetLog("Boost Archer Queen...", $COLOR_INFO)
If $g_aiQueenAltarPos[0] = "" Or $g_aiQueenAltarPos[0] = -1 Then
LocateQueenAltar()
SaveConfig()
If _Sleep($DELAYBOOSTHEROES4) Then Return
EndIf
If BoostStructure("Archer Queen", "Quee", $g_aiQueenAltarPos, $g_iCmbBoostArcherQueen, $g_hCmbBoostArcherQueen) Then $g_aiHeroBoost[$eHeroArcherQueen] = _NowCalc()
If _Sleep($DELAYBOOSTBARRACKS3) Then Return
checkMainScreen(False)
EndFunc
Func BoostWarden()
If AllowBoosting("Grand Warden", $g_iCmbBoostWarden) = False Then Return
SetLog("Boost Grand Warden...", $COLOR_INFO)
If $g_aiWardenAltarPos[0] = "" Or $g_aiWardenAltarPos[0] = -1 Then
LocateWardenAltar()
SaveConfig()
If _Sleep($DELAYBOOSTHEROES4) Then Return
EndIf
If BoostStructure("Grand Warden", "Warden", $g_aiWardenAltarPos, $g_iCmbBoostWarden, $g_hCmbBoostWarden) Then $g_aiHeroBoost[$eHeroGrandWarden] = _NowCalc()
If _Sleep($DELAYBOOSTBARRACKS3) Then Return
checkMainScreen(False)
EndFunc
Func UpgradeHeroes()
If Not $g_bUpgradeKingEnable And Not $g_bUpgradeQueenEnable And Not $g_bUpgradeWardenEnable Then Return
If _Sleep(500) Then Return
checkMainScreen(False)
If $g_bRestart Then Return
If $g_bUpgradeKingEnable Then
If Not isInsideDiamond($g_aiKingAltarPos) Then LocateKingAltar()
If $g_aiKingAltarPos[0] = -1 Or $g_aiKingAltarPos[1] = -1 Then LocateKingAltar()
SaveConfig()
EndIf
If $g_bUpgradeQueenEnable Then
If Not isInsideDiamond($g_aiQueenAltarPos) Then LocateQueenAltar()
If $g_aiQueenAltarPos[0] = -1 Or $g_aiQueenAltarPos[1] = -1 Then LocateQueenAltar()
SaveConfig()
EndIf
If $g_bUpgradeWardenEnable Then
If Not isInsideDiamond($g_aiWardenAltarPos) Then LocateWardenAltar()
If $g_aiWardenAltarPos[0] = -1 Or $g_aiWardenAltarPos[1] = -1 Then LocateWardenAltar()
EndIf
If $g_bAutoLabUpgradeEnable And $g_iCmbLaboratory >= 19 Then
SetLog("Laboratory needs DE to Upgrade :  " & $g_avLabTroops[$g_iCmbLaboratory][3])
SetLog("Skipping the Heroes Upgrade!")
Return
EndIf
SetLog("Upgrading Heroes", $COLOR_INFO)
If $g_bUpgradeQueenEnable Then
If Not getBuilderCount() Then Return
If _Sleep($DELAYRESPOND) Then Return
If $g_iFreeBuilderCount < 1 +($g_bUpgradeWallSaveBuilder ? 1 : 0) Then
SetLog("Not enough Builders available to upgrade the Archer Queen")
Return
EndIf
QueenUpgrade()
If _Sleep($DELAYUPGRADEHERO1) Then Return
EndIf
If $g_bUpgradeKingEnable Then
If Not getBuilderCount() Then Return
If _Sleep($DELAYRESPOND) Then Return
If $g_iFreeBuilderCount < 1 +($g_bUpgradeWallSaveBuilder ? 1 : 0) Then
SetLog("Not enough Builders available to upgrade the Barbarian King")
Return
EndIf
KingUpgrade()
If _Sleep($DELAYUPGRADEHERO1) Then Return
EndIf
If $g_bUpgradeWardenEnable Then
If Not getBuilderCount() Then Return
If _Sleep($DELAYRESPOND) Then Return
If $g_iFreeBuilderCount < 1 +($g_bUpgradeWallSaveBuilder ? 1 : 0) Then
SetLog("Not enough Builders available to upgrade the Grand Warden")
Return
EndIf
WardenUpgrade()
EndIf
EndFunc
Func QueenUpgrade()
If Not $g_bUpgradeQueenEnable Then Return
Local $aHeroLevel = 0
SetLog("Upgrade Queen")
ClickP($aTopLeftClient, 1, 0, "#0166")
If _Sleep($DELAYUPGRADEHERO2) Then Return
BuildingClickP($g_aiQueenAltarPos)
If _Sleep($DELAYUPGRADEHERO2) Then Return
Local $sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo >= 50 Then Return
WEnd
If $g_bDebugSetlog Then SetDebugLog(_ArrayToString($sInfo, " "), $COLOR_DEBUG)
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Quee") = 0 Then
SetLog("Bad Archer Queen location", $COLOR_ACTION)
Return
Else
If $sInfo[2] <> "" Then
$aHeroLevel = Number($sInfo[2])
SetLog("Your Archer Queen level read as: " & $aHeroLevel, $COLOR_SUCCESS)
If $aHeroLevel = $g_iMaxQueenLevel Then
SetLog("Your Archer Queen is at max level, cannot upgrade anymore!", $COLOR_INFO)
$g_bUpgradeQueenEnable = False
Return
EndIf
Else
SetLog("Your Queen Level was not found!", $COLOR_INFO)
Return
EndIf
EndIf
Else
SetLog("Bad Queen OCR", $COLOR_ERROR)
Return
EndIf
If _Sleep($DELAYUPGRADEHERO1) Then Return
If _CheckPixel($aVillageHasDarkElixir, $g_bCapturePixel) Then
$g_aiCurrentLoot[$eLootDarkElixir] = Number(getResourcesMainScreen(728, 123))
If $g_bDebugSetlog Then SetDebugLog("Updating village values [D]: " & $g_aiCurrentLoot[$eLootDarkElixir], $COLOR_DEBUG)
Else
If $g_bDebugSetlog Then SetDebugLog("getResourcesMainScreen didn't get the DE value", $COLOR_DEBUG)
EndIf
If $g_aiCurrentLoot[$eLootDarkElixir] <($g_afQueenUpgCost[$aHeroLevel] * 1000) + $g_iUpgradeMinDark Then
SetLog("Insufficient DE for Upg Queen, requires: " &($g_afQueenUpgCost[$aHeroLevel] * 1000) & " + " & $g_iUpgradeMinDark, $COLOR_INFO)
Return
EndIf
Local $offColors[3][3] = [[0xE07B50, 41, 23], [0x282020, 72, 0], [0xF5F9F2, 79, 0]]
Local $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 620 + $g_iBottomOffsetY, 1, 1, Hex(0xF5F6F2, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog And IsArray($ButtonPixel) Then
SetLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetLog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
If _Sleep($DELAYUPGRADEHERO2) Then Return
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0305")
If _Sleep($DELAYUPGRADEHERO3) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeDarkBtn1")
If _ColorCheck(_GetPixelColor(721, 118 + $g_iMidOffsetY, True), Hex(0xE00408, 6), 20) Then
If _ColorCheck(_GetPixelColor(691, 523 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(691, 527 + $g_iMidOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Queen Upgrade Fail! No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0306")
Return
Else
Click(665, 515 + $g_iMidOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($DELAYUPGRADEHERO1) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeDarkBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xDB0408, 6), 20) Then
SetLog("Queen Upgrade Fail! No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0309")
Return
EndIf
SetLog("Queen Upgrade complete", $COLOR_SUCCESS)
If _Sleep($DELAYUPGRADEHERO2) Then Return
$g_iNbrOfHeroesUpped += 1
$g_iCostDElixirHero += $g_afQueenUpgCost[$aHeroLevel - 1] * 1000
UpdateStats()
EndIf
Else
SetLog("Upgrade Queen window open fail", $COLOR_ERROR)
EndIf
Else
SetLog("Upgrade Queen error finding button", $COLOR_ERROR)
EndIf
ClickP($aAway, 2, 0, "#0312")
EndFunc
Func KingUpgrade()
If Not $g_bUpgradeKingEnable Then Return
Local $aHeroLevel = 0
SetLog("Upgrade King")
ClickP($aTopLeftClient, 1, 0, "#0166")
If _Sleep($DELAYUPGRADEHERO2) Then Return
BuildingClickP($g_aiKingAltarPos)
If _Sleep($DELAYUPGRADEHERO2) Then Return
Local $sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
If _Sleep(100) Then Return
$CountGetInfo += 1
If $CountGetInfo >= 50 Then Return
WEnd
If $g_bDebugSetlog Then SetDebugLog(_ArrayToString($sInfo, " "), $COLOR_DEBUG)
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Barbarian") = 0 Then
SetLog("Bad Barbarian King location", $COLOR_ACTION)
Return
Else
If $sInfo[2] <> "" Then
$aHeroLevel = Number($sInfo[2])
SetLog("Your King Level read as: " & $aHeroLevel, $COLOR_SUCCESS)
If $aHeroLevel = $g_iMaxKingLevel Then
SetLog("Your Babarian King is at max level, cannot upgrade anymore!", $COLOR_INFO)
$g_bUpgradeKingEnable = False
Return
EndIf
Else
SetLog("Your Barbarian King Level was not found!", $COLOR_INFO)
Return
EndIf
EndIf
Else
SetLog("Bad King OCR", $COLOR_ERROR)
Return
EndIf
If _Sleep($DELAYUPGRADEHERO1) Then Return
If _CheckPixel($aVillageHasDarkElixir, $g_bCapturePixel) Then
$g_aiCurrentLoot[$eLootDarkElixir] = Number(getResourcesMainScreen(728, 123))
If $g_bDebugSetlog Then SetDebugLog("Updating village values [D]: " & $g_aiCurrentLoot[$eLootDarkElixir], $COLOR_DEBUG)
Else
If $g_bDebugSetlog Then SetDebugLog("getResourcesMainScreen didn't get the DE value", $COLOR_DEBUG)
EndIf
If _Sleep(100) Then Return
If $g_aiCurrentLoot[$eLootDarkElixir] <($g_afKingUpgCost[$aHeroLevel] * 1000) + $g_iUpgradeMinDark Then
SetLog("Insufficient DE for Upg King, requires: " &($g_afKingUpgCost[$aHeroLevel] * 1000) & " + " & $g_iUpgradeMinDark, $COLOR_INFO)
Return
EndIf
Local $offColors[3][3] = [[0xE07B50, 41, 23], [0x282020, 72, 0], [0xF4F5F2, 79, 0]]
Local $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 620 + $g_iBottomOffsetY, 1, 1, Hex(0xF5F6F2, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog And IsArray($ButtonPixel) Then
SetLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetLog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
If _Sleep($DELAYUPGRADEHERO2) Then Return
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0305")
If _Sleep($DELAYUPGRADEHERO3) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeDarkBtn1")
If _ColorCheck(_GetPixelColor(715, 120 + $g_iMidOffsetY, True), Hex(0xE01C20, 6), 20) Then
If _ColorCheck(_GetPixelColor(691, 523 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(691, 527 + $g_iMidOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("King Upgrade Fail! No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0306")
Return
Else
Click(660, 515 + $g_iMidOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($DELAYUPGRADEHERO1) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeDarkBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xDB0408, 6), 20) Then
SetLog("King Upgrade Fail! No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0309")
Return
EndIf
SetLog("King Upgrade complete", $COLOR_SUCCESS)
If _Sleep($DELAYUPGRADEHERO2) Then Return
$g_iNbrOfHeroesUpped += 1
$g_iCostDElixirHero += $g_afKingUpgCost[$aHeroLevel - 1] * 1000
UpdateStats()
EndIf
Else
SetLog("Upgrade King window open fail", $COLOR_ERROR)
EndIf
Else
SetLog("Upgrade King error finding button", $COLOR_ERROR)
EndIf
ClickP($aAway, 2, 0, "#0312")
EndFunc
Func WardenUpgrade()
If Not $g_bUpgradeWardenEnable Then Return
If Number($g_iTownHallLevel) <= 10 Then
SetLog("Must have TH 11 for Grand Warden upgrade", $COLOR_ERROR)
Return
EndIf
SetLog("Upgrade Grand Warden")
ClickP($aTopLeftClient, 1, 0, "#0166")
If _Sleep($DELAYUPGRADEHERO2) Then Return
ClickP($g_aiWardenAltarPos, 1, 0, "#8888")
If _Sleep($DELAYUPGRADEHERO2) Then Return
Local $sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
If _Sleep(100) Then Return
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $g_bDebugSetlog Then SetDebugLog(_ArrayToString($sInfo, " "))
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Grand") = 0 Then
SetLog("Bad Warden location", $COLOR_ACTION)
Return
Else
If $sInfo[2] <> "" Then
$g_iWardenLevel = Number($sInfo[2])
SetLog("Your Grand Warden Warden Level read as: " & $g_iWardenLevel, $COLOR_SUCCESS)
If $g_iWardenLevel = $g_iMaxWardenLevel Then
SetLog("Your Grand Warden is at max level, cannot upgrade anymore!", $COLOR_INFO)
$g_bUpgradeWardenEnable = False
Return
EndIf
Else
SetLog("Your Grand Warden Level was not found!", $COLOR_INFO)
Return
EndIf
EndIf
Else
SetLog("Bad Warden OCR", $COLOR_ERROR)
Return
EndIf
If _Sleep($DELAYUPGRADEHERO1) Then Return
If _CheckPixel($aVillageHasDarkElixir, $g_bCapturePixel) Then
$g_aiCurrentLoot[$eLootElixir] = getResourcesMainScreen(705, 74)
If $g_bDebugSetlog Then SetDebugLog("Updating village values [E]: " & $g_aiCurrentLoot[$eLootElixir], $COLOR_DEBUG)
Else
$g_aiCurrentLoot[$eLootElixir] = getResourcesMainScreen(710, 74)
EndIf
If _Sleep(100) Then Return
If $g_aiCurrentLoot[$eLootElixir] <($g_afWardenUpgCost[$g_iWardenLevel] * 1000000) + $g_iUpgradeMinElixir Then
SetLog("Insufficient Elixir for Warden Upgrade, requires: " &($g_afWardenUpgCost[$g_iWardenLevel] * 1000000) & " + " & $g_iUpgradeMinElixir, $COLOR_INFO)
Return
EndIf
If _Sleep($DELAYUPGRADEHERO2) Then Return
Local $offColors[3][3] = [[0xBC5B31, 38, 32], [0xF84CF9, 72, 0], [0xF5F9F2, 79, 0]]
Local $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 620 + $g_iBottomOffsetY, 1, 1, Hex(0xF4F7F2, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog And IsArray($ButtonPixel) Then
SetLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetLog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
If _Sleep($DELAYUPGRADEHERO2) Then Return
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0305")
If _Sleep($DELAYUPGRADEHERO3) Then Return
If $g_bDebugSetlog Then DebugImageSave("UpgradeElixirBtn1")
If $g_bDebugSetlog Then SetDebugLog("pixel: " & _GetPixelColor(718, 120 + $g_iMidOffsetY, True) & " expected " & Hex(0xDD0408, 6) & " result: " & _ColorCheck(_GetPixelColor(718, 120 + $g_iMidOffsetY, True), Hex(0xDD0408, 6), 20), $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor(718, 120 + $g_iMidOffsetY, True), Hex(0xDD0408, 6), 20) Then
If $g_bDebugSetlog Then SetDebugLog("pixel1: " & _GetPixelColor(692, 525 + $g_iMidOffsetY, True) & " expected " & Hex(0xFFFFFF, 6) & " result: " &(_ColorCheck(_GetPixelColor(692, 525 + $g_iMidOffsetY, True), Hex(0xFFFFFF, 6), 20)), $COLOR_DEBUG)
If Not(_ColorCheck(_GetPixelColor(692, 525 + $g_iMidOffsetY, True), Hex(0xFFFFFF, 6), 20)) Then
SetLog("Warden Upgrade Fail! No Elixir!", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0306")
Return
Else
Click(660, 515 + $g_iMidOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($DELAYUPGRADEHERO1) Then Return
If $g_bDebugSetlog Then DebugImageSave("UpgradeElixirBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xDB0408, 6), 20) Then
SetLog("Warden Upgrade Fail! No Elixir!", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0309")
Return
EndIf
SetLog("Warden Upgrade Started", $COLOR_SUCCESS)
If _Sleep($DELAYUPGRADEHERO2) Then Return
$g_iNbrOfHeroesUpped += 1
$g_iCostElixirBuilding += $g_afWardenUpgCost[$g_iWardenLevel - 1] * 1000
$g_iWardenLevel += 1
UpdateStats()
EndIf
Else
SetLog("Upgrade Warden window open fail", $COLOR_ERROR)
EndIf
Else
SetLog("Upgrade Warden error finding button", $COLOR_ERROR)
EndIf
ClickP($aAway, 2, 0, "#0312")
EndFunc
Func StarBonus()
If $g_bDebugSetlog Then SetDebugLog("Begin Star Bonus window check", $COLOR_DEBUG1)
If _CheckPixel($aIsMainGrayed, $g_bCapturePixel, Default, "IsMainGrayed") = False Then Return
Local $aWindowChk1[4] = [640, 184 + $g_iMidOffsetY, 0xCD1A1F, 15]
Local $aWindowChk2[4] = [650, 462 + $g_iBottomOffsetY, 0xE8E8E0, 10]
If _Sleep($DELAYSTARBONUS100) Then Return
If _CheckPixel($aWindowChk1, $g_bCapturePixel, Default, "Starbonus1") And _CheckPixel($aWindowChk2, $g_bCapturePixel, Default, "Starbonus2") Then
Local $offColors[3][3] = [[0x000000, 145, 0], [0xFFFFFF, 55, 16], [0xFFFFFF, 51, 23]]
Local $ButtonPixel = _MultiPixelSearch(353, 442 + $g_iMidOffsetY, 502, 474 + $g_iMidOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $g_bDebugSetlog Then SetDebugLog("Okay btn chk-#1: " & _GetPixelColor(354, 442 + $g_iMidOffsetY, $g_bCapturePixel) & ", #2: " & _GetPixelColor(354 + 145, 442 + $g_iMidOffsetY, $g_bCapturePixel) & ", #3: " & _GetPixelColor(354 + 55, 442 + 16 + $g_iMidOffsetY, $g_bCapturePixel) & ", #4: " & _GetPixelColor(355 + 51, 442 + 23 + $g_iMidOffsetY, $g_bCapturePixel), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Then
SetDebugLog("ButtonPixelLocation = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetDebugLog("Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], $g_bCapturePixel) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 144, $ButtonPixel[1], $g_bCapturePixel) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 52, $ButtonPixel[1] + 17, $g_bCapturePixel) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 51, $ButtonPixel[1] + 24, $g_bCapturePixel), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 2, 50, "#0117")
If _Sleep($DELAYSTARBONUS500) Then Return
Return True
EndIf
EndIf
If $g_bDebugSetlog Then SetDebugLog("Star Bonus window not found?", $COLOR_DEBUG)
Return False
EndFunc
Func AddIdleTime()
If $g_bTrainAddRandomDelayEnable = False Then Return
Local $iTimeToWait
If $g_iTrainAddRandomDelayMin < $g_iTrainAddRandomDelayMax Then
$iTimeToWait = Random($g_iTrainAddRandomDelayMin, $g_iTrainAddRandomDelayMax, 1)
Else
$iTimeToWait = Random($g_iTrainAddRandomDelayMax, $g_iTrainAddRandomDelayMin, 1)
EndIf
SetLog("Waiting, Add random delay of " & $iTimeToWait & " seconds.", $COLOR_INFO)
If _SleepStatus($iTimeToWait * 1000) Then Return
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, "")
EndFunc
Func GetVillageSize($DebugLog = False, $sStonePrefix = Default, $sTreePrefix = Default)
If $sStonePrefix = Default Then $sStonePrefix = "stone"
If $sTreePrefix = Default Then $sTreePrefix = "tree"
Local $aResult = 0
Local $sDirectory
Local $stone[6] = [0, 0, 0, 0, 0, ""], $tree[6] = [0, 0, 0, 0, 0, ""]
Local $x0, $y0, $d0, $x, $y, $x1, $y1, $right, $bottom, $a
Local $iAdditional = 75
If isOnBuilderBase(True) Then
$sDirectory = $g_sImgZoomOutDirBB
Else
$sDirectory = $g_sImgZoomOutDir
EndIf
Local $aStoneFiles = _FileListToArray($sDirectory, $sStonePrefix & "*.*", $FLTA_FILES)
If @error Then
SetLog("Error: Missing stone files (" & @error & ")", $COLOR_ERROR)
Return $aResult
EndIf
Local $iNewIdx = 1
For $i = 1 To $aStoneFiles[0]
If StringInStr($aStoneFiles[$i], "stoneBlueStacks2A") = 1 Then
Local $s = $aStoneFiles[$iNewIdx]
$aStoneFiles[$iNewIdx] = $aStoneFiles[$i]
$aStoneFiles[$i] = $s
$iNewIdx += 1
EndIf
Next
Local $aTreeFiles = _FileListToArray($sDirectory, $sTreePrefix & "*.*", $FLTA_FILES)
If @error Then
SetLog("Error: Missing tree (" & @error & ")", $COLOR_ERROR)
Return $aResult
EndIf
Local $i, $findImage, $sArea, $a
For $i = 1 To $aStoneFiles[0]
$findImage = $aStoneFiles[$i]
$a = StringRegExp($findImage, ".*-(\d+)-(\d+)-(\d*,*\d+)_.*[.](xml|png|bmp)$", $STR_REGEXPARRAYMATCH)
If UBound($a) = 4 Then
$x0 = $a[0]
$y0 = $a[1]
$d0 = StringReplace($a[2], ",", ".")
$x1 = $x0 - $iAdditional
$y1 = $y0 - $iAdditional
$right = $x0 + $iAdditional
$bottom = $y0 + $iAdditional
$sArea = Int($x1) & "," & Int($y1) & "|" & Int($right) & "," & Int($y1) & "|" & Int($right) & "," & Int($bottom) & "|" & Int($x1) & "," & Int($bottom)
$a = decodeSingleCoord(findImage($findImage, $sDirectory & $findImage, $sArea, 1, False))
If UBound($a) = 2 Then
$x = Int($a[0])
$y = Int($a[1])
$stone[0] = $x
$stone[1] = $y
$stone[2] = $x0
$stone[3] = $y0
$stone[4] = $d0
$stone[5] = $findImage
ExitLoop
EndIf
Else
EndIf
Next
If $stone[0] = 0 Then
SetDebugLog("GetVillageSize cannot find stone", $COLOR_WARNING)
Return $aResult
EndIf
For $i = 1 To $aTreeFiles[0]
$findImage = $aTreeFiles[$i]
$a = StringRegExp($findImage, ".*-(\d+)-(\d+)-(\d*,*\d+)_.*[.](xml|png|bmp)$", $STR_REGEXPARRAYMATCH)
If UBound($a) = 4 Then
$x0 = $a[0]
$y0 = $a[1]
$d0 = StringReplace($a[2], ",", ".")
$x1 = $x0 - $iAdditional
$y1 = $y0 - $iAdditional
$right = $x0 + $iAdditional
$bottom = $y0 + $iAdditional
$sArea = Int($x1) & "," & Int($y1) & "|" & Int($right) & "," & Int($y1) & "|" & Int($right) & "," & Int($bottom) & "|" & Int($x1) & "," & Int($bottom)
$a = decodeSingleCoord(findImage($findImage, $sDirectory & "\" & $findImage, $sArea, 1, False))
If UBound($a) = 2 Then
$x = Int($a[0])
$y = Int($a[1])
$tree[0] = $x
$tree[1] = $y
$tree[2] = $x0
$tree[3] = $y0
$tree[4] = $d0
$tree[5] = $findImage
ExitLoop
EndIf
Else
EndIf
Next
If $tree[0] = 0 Then
SetDebugLog("GetVillageSize cannot find tree", $COLOR_WARNING)
Return $aResult
EndIf
Local $a = $tree[0] - $stone[0]
Local $b = $stone[1] - $tree[1]
Local $c = Sqrt($a * $a + $b * $b) - $stone[4] - $tree[4]
Local $z = $c / 473.60282919315
Local $stone_x_exp = $stone[2]
Local $stone_y_exp = $stone[3]
ConvertVillagePos($stone_x_exp, $stone_y_exp, $z)
$x = $stone[0] - $stone_x_exp
$y = $stone[1] - $stone_y_exp
If $DebugLog Then SetDebugLog("GetVillageSize measured: " & $c & ", Zoom factor: " & $z & ", Offset: " & $x & ", " & $y, $COLOR_INFO)
Dim $aResult[10]
$aResult[0] = $c
$aResult[1] = $z
$aResult[2] = $x
$aResult[4] = $stone[0]
$aResult[3] = $y
$aResult[5] = $stone[1]
$aResult[6] = $stone[5]
$aResult[7] = $tree[0]
$aResult[8] = $tree[1]
$aResult[9] = $tree[5]
Return $aResult
EndFunc
Func UpdateGlobalVillageOffset($x, $y)
Local $updated = False
If $g_sImglocRedline <> "" Then
Local $newReadLine = ""
Local $aPoints = StringSplit($g_sImglocRedline, "|", $STR_NOCOUNT)
For $sPoint In $aPoints
Local $aPoint = GetPixel($sPoint, ",")
$aPoint[0] += $x
$aPoint[1] += $y
If StringLen($newReadLine) > 0 Then $newReadLine &= "|"
$newReadLine &=($aPoint[0] & "," & $aPoint[1])
Next
$g_sImglocRedline = $newReadLine
$updated = True
EndIf
If $g_aiTownHallDetails[0] <> 0 And $g_aiTownHallDetails[1] <> 0 Then
$g_aiTownHallDetails[0] += $x
$g_aiTownHallDetails[1] += $y
$updated = True
EndIf
If $g_iTHx <> 0 And $g_iTHy <> 0 Then
$g_iTHx += $x
$g_iTHy += $y
$updated = True
EndIf
ConvertInternalExternArea()
Return $updated
EndFunc
Global $g_aiTempGainCost[3] = [0, 0, 0]
Func StartGainCost()
$g_aiTempGainCost[0] = 0
$g_aiTempGainCost[1] = 0
$g_aiTempGainCost[2] = 0
VillageReport(True, True)
Local $tempCounter = 0
While($g_aiCurrentLoot[$eLootGold] = "" Or $g_aiCurrentLoot[$eLootElixir] = "" Or($g_aiCurrentLoot[$eLootDarkElixir] = "" And $g_iStatsStartedWith[$eLootDarkElixir] <> "")) And $tempCounter < 5
$tempCounter += 1
If _Sleep(100) Then Return
VillageReport(True, True)
WEnd
$g_aiTempGainCost[0] = $g_aiCurrentLoot[$eLootGold]
$g_aiTempGainCost[1] = $g_aiCurrentLoot[$eLootElixir]
$g_aiTempGainCost[2] = $g_aiCurrentLoot[$eLootDarkElixir]
EndFunc
Func EndGainCost($Type)
VillageReport(True, True)
Local $tempCounter = 0
While($g_aiCurrentLoot[$eLootGold] = "" Or $g_aiCurrentLoot[$eLootElixir] = "" Or($g_aiCurrentLoot[$eLootDarkElixir] = "" And $g_iStatsStartedWith[$eLootDarkElixir] <> "")) And $tempCounter < 5
$tempCounter += 1
VillageReport(True, True)
WEnd
Switch $Type
Case "Collect"
Local $tempGoldCollected = 0
Local $tempElixirCollected = 0
Local $tempDElixirCollected = 0
If $g_aiTempGainCost[0] <> "" And $g_aiCurrentLoot[$eLootGold] <> "" And $g_aiTempGainCost[0] <> $g_aiCurrentLoot[$eLootGold] Then
$tempGoldCollected = $g_aiCurrentLoot[$eLootGold] - $g_aiTempGainCost[0]
$g_iGoldFromMines += $tempGoldCollected
$g_iStatsTotalGain[$eLootGold] += $tempGoldCollected
EndIf
If $g_aiTempGainCost[1] <> "" And $g_aiCurrentLoot[$eLootElixir] <> "" And $g_aiTempGainCost[1] <> $g_aiCurrentLoot[$eLootElixir] Then
$tempElixirCollected = $g_aiCurrentLoot[$eLootElixir] - $g_aiTempGainCost[1]
$g_iElixirFromCollectors += $tempElixirCollected
$g_iStatsTotalGain[$eLootElixir] += $tempElixirCollected
EndIf
If $g_aiTempGainCost[2] <> "" And $g_aiCurrentLoot[$eLootDarkElixir] <> "" And $g_aiTempGainCost[2] <> $g_aiCurrentLoot[$eLootDarkElixir] Then
$tempDElixirCollected = $g_aiCurrentLoot[$eLootDarkElixir] - $g_aiTempGainCost[2]
$g_iDElixirFromDrills += $tempDElixirCollected
$g_iStatsTotalGain[$eLootDarkElixir] += $tempDElixirCollected
EndIf
If ProfileSwitchAccountEnabled() Then
$g_aiGoldTotalAcc[$g_iCurAccount] += $tempGoldCollected
$g_aiElixirTotalAcc[$g_iCurAccount] += $tempElixirCollected
$g_aiDarkTotalAcc[$g_iCurAccount] += $tempDElixirCollected
EndIf
Case "Train"
Local $tempElixirSpent = 0
Local $tempDElixirSpent = 0
If $g_aiTempGainCost[1] <> "" And $g_aiCurrentLoot[$eLootElixir] <> "" And $g_aiTempGainCost[1] <> $g_aiCurrentLoot[$eLootElixir] Then
$tempElixirSpent =($g_aiTempGainCost[1] - $g_aiCurrentLoot[$eLootElixir])
$g_iTrainCostElixir += $tempElixirSpent
$g_iStatsTotalGain[$eLootElixir] -= $tempElixirSpent
EndIf
If $g_aiTempGainCost[2] <> "" And $g_aiCurrentLoot[$eLootDarkElixir] <> "" And $g_aiTempGainCost[2] <> $g_aiCurrentLoot[$eLootDarkElixir] Then
$tempDElixirSpent =($g_aiTempGainCost[2] - $g_aiCurrentLoot[$eLootDarkElixir])
$g_iTrainCostDElixir += $tempDElixirSpent
$g_iStatsTotalGain[$eLootDarkElixir] -= $tempDElixirSpent
EndIf
If ProfileSwitchAccountEnabled() Then
$g_aiElixirTotalAcc[$g_iCurAccount] -= $tempElixirSpent
$g_aiDarkTotalAcc[$g_iCurAccount] -= $tempDElixirSpent
EndIf
EndSwitch
UpdateStats()
EndFunc
Func ConvertOCRTime($WhereRead, $ToConvert, $bSetLog = True)
Local $iRemainTimer = 0, $sResultMinutes = "", $aResult
If $ToConvert <> "" Then
If StringInStr($ToConvert, "h") > 1 Then
$aResult = StringSplit($ToConvert, "h", $STR_NOCOUNT)
$sResultMinutes = StringTrimRight($aResult[1], 1)
$iRemainTimer =(Number($aResult[0]) * 60) + Number($sResultMinutes)
ElseIf StringInStr($ToConvert, "m") > 1 Then
$iRemainTimer = Number(StringTrimRight($ToConvert, 1))
ElseIf StringInStr($ToConvert, "s") > 1 Then
$iRemainTimer = Number(StringTrimRight($ToConvert, 1)) / 60
Else
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog($WhereRead & ": Bad OCR string", $COLOR_ERROR)
EndIf
If $bSetLog Then SetLog($WhereRead & " time: " & StringFormat("%.2f", $iRemainTimer) & " min", $COLOR_INFO)
Else
If Not $g_bFullArmySpells Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Can not read remaining time for " & $WhereRead, $COLOR_ERROR)
EndIf
EndIf
Return $iRemainTimer
EndFunc
Func ClickR($boundingBox, $x, $y, $times = 1, $speed = 0, $OutScreen =(680 + $g_iBottomOffsetY), $scale = 3, $density = 1, $centerX = 0, $centerY = 0)
Local $AncVal = " ValIn: X=" & $x & " Y=" & $y
Local Const $PI = 3.141592653589793
Local $boxWidth = $boundingBox[2] - $boundingBox[0]
Local $boxHeight = $boundingBox[3] - $boundingBox[1]
Local $boxCenterX = $boundingBox[0] + $boxWidth/2 + $centerX
Local $boxCenterY = $boundingBox[1] + $boxHeight/2 + $centerY
Local $loopStartTime = __TimerInit()
Do
Local $angle = Random() * 2 *$PI
Local $xR = Random()
If $xR = 0 Then $xR = 0.000001
Local $distance = $scale *(($xR ^(-1.0/$density)) - 1)
Local $offsetX = $distance * Sin($angle)
Local $offsetY = $distance * Cos($angle)
$x = $boxCenterX + $boxWidth * $offsetX/4
$y = $boxCenterY + $boxHeight * $offsetY/4
If __TimerDiff($loopStartTime)>5000 Then
$x = $boxCenterX
$y = $boxCenterY
ExitLoop
EndIf
Until $x >= $boundingBox[0] And $x <= $boundingBox[2] And $y >= $boundingBox[1] And $y <= $boundingBox[3]
If $y > $OutScreen Then
$y = $OutScreen
Else
$y = $y
EndIf
$x = Round($x, 3)
$y = Round($y, 3)
If $times <> 1 Then
For $i = 0 To($times - 1)
If $g_bDebugClick Then SetLog("_ControlClick " & "X=" & $x & " Y=" & $y & " ,t" & $times & ",s" & $speed & $AncVal, $COLOR_ACTION, "Verdana", "7.5", 0)
Click($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
If $g_bDebugClick Then SetLog("_ControlClick " & "X=" & $x & " Y=" & $y & $AncVal, $COLOR_ACTION, "Verdana", "7.5", 0)
Click($x, $y)
EndIf
EndFunc
Func PureClickR($boundingBox, $x, $y, $times = 1, $speed = 0, $OutScreen =(680 + $g_iBottomOffsetY), $scale = 3, $density = 1, $centerX = 0, $centerY = 0)
Local $AncVal = " ValIn: X=" & $x & " Y=" & $y
Local Const $PI = 3.141592653589793
Local $boxWidth = $boundingBox[2] - $boundingBox[0]
Local $boxHeight = $boundingBox[3] - $boundingBox[1]
Local $boxCenterX = $boundingBox[0] + $boxWidth/2 + $centerX
Local $boxCenterY = $boundingBox[1] + $boxHeight/2 + $centerY
Local $loopStartTime = __TimerInit()
Do
Local $angle = Random() * 2 *$PI
Local $xR = Random()
If $xR = 0 Then $xR = 0.000001
Local $distance = $scale *(($xR ^(-1.0/$density)) - 1)
Local $offsetX = $distance * Sin($angle)
Local $offsetY = $distance * Cos($angle)
$x = $boxCenterX + $boxWidth * $offsetX/4
$y = $boxCenterY + $boxHeight * $offsetY/4
If __TimerDiff($loopStartTime)>5000 Then
$x = $boxCenterX
$y = $boxCenterY
ExitLoop
EndIf
Until $x >= $boundingBox[0] And $x <= $boundingBox[2] And $y >= $boundingBox[1] And $y <= $boundingBox[3]
If $y > $OutScreen Then
$y = $OutScreen
Else
$y = $y
EndIf
$x = Round($x, 3)
$y = Round($y, 3)
If $times <> 1 Then
For $i = 0 To($times - 1)
If $g_bDebugClick Then SetLog("PureClick " & "X=" & $x & " Y=" & $y & " ,t" & $times & ",s" & $speed & $AncVal, $COLOR_ACTION, "Verdana", "7.5", 0)
PureClick($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
If $g_bDebugClick Then SetLog("PureClick " & "X=" & $x & " Y=" & $y & $AncVal, $COLOR_ACTION, "Verdana", "7.5", 0)
PureClick($x, $y)
EndIf
EndFunc
Func GemClickR($boundingBox,$x, $y, $times = 1, $speed = 0, $debugtxt = "", $OutScreen =(680 + $g_iBottomOffsetY), $scale = 3, $density = 1, $centerX = 0, $centerY = 0)
Local Const $PI = 3.141592653589793
Local $boxWidth = $boundingBox[2] - $boundingBox[0]
Local $boxHeight = $boundingBox[3] - $boundingBox[1]
Local $boxCenterX = $boundingBox[0] + $boxWidth/2 + $centerX
Local $boxCenterY = $boundingBox[1] + $boxHeight/2 + $centerY
Local $loopStartTime = __TimerInit()
Do
Local $angle = Random() * 2 *$PI
Local $xR = Random()
If $xR = 0 Then $xR = 0.000001
Local $distance = $scale *(($xR ^(-1.0/$density)) - 1)
Local $offsetX = $distance * Sin($angle)
Local $offsetY = $distance * Cos($angle)
$x = $boxCenterX + $boxWidth * $offsetX/4
$y = $boxCenterY + $boxHeight * $offsetY/4
If __TimerDiff($loopStartTime)>5000 Then
$x = $boxCenterX
$y = $boxCenterY
ExitLoop
EndIf
Until $x >= $boundingBox[0] And $x <= $boundingBox[2] And $y >= $boundingBox[1] And $y <= $boundingBox[3]
If $y > $OutScreen Then
$y = $OutScreen
Else
$y = $y
EndIf
$x = Round($x, 3)
$y = Round($y, 3)
If $g_bDebugClick Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("GemClickR " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ACTION, "Verdana", "7.5", 0)
EndIf
If $g_bAndroidAdbClick = True Then
If isGemOpen(True) Then
Return False
EndIf
AndroidClick($x, $y, $times, $speed)
EndIf
If $g_bAndroidAdbClick = True Then
Return
EndIf
Local $SuspendMode = ResumeAndroid()
Local $i
If $times <> 1 Then
For $i = 0 To($times - 1)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If isProblemAffectBeforeClick($i) Then
If $g_bDebugClick Then SetLog("VOIDED GemClickR " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If _Sleep($speed, False) Then ExitLoop
Next
Else
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If isProblemAffectBeforeClick() Then
If $g_bDebugClick Then SetLog("VOIDED GemClickR " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func CheckNeedOpenTrain($TimeBeforeTrain)
Local $bToReturn = False
Local $QuickArmyCamps = 100
If $g_abSearchCampsEnable[$DB] Then
If $g_aiSearchCampsPct[$DB] < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$DB]
If $g_aiSearchCampsPct[$DB] - Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100) < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$DB] - Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100)
EndIf
If $g_abSearchCampsEnable[$LB] Then
If $g_aiSearchCampsPct[$LB] < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$LB]
If $g_aiSearchCampsPct[$LB] - Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100) < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$LB] - Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100)
EndIf
If $g_abSearchCampsEnable[$TS] Then
If $g_aiSearchCampsPct[$TS] < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$TS]
If $g_aiSearchCampsPct[$TS] - Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100) < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$TS] - Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100)
EndIf
If $g_aiTimeTrain[0] = 0 Then $bToReturn = True
Local $sNowTime = ""
Local $iTimeBeforeTrain1, $iTimeBeforeTrain2
$sNowTime = _NowCalc()
If $TimeBeforeTrain = "" Then $TimeBeforeTrain = $sNowTime
$iTimeBeforeTrain1 = _DateAdd("s", Int(($g_aiTimeTrain[0] * 60) *($QuickArmyCamps / 100)), $TimeBeforeTrain)
$iTimeBeforeTrain2 = _DateDiff("s", $sNowTime, $iTimeBeforeTrain1)
If $g_bDebugSetlogTrain Then
SetLog("Start Train: " & $TimeBeforeTrain)
SetLog("Now: " & $sNowTime)
SetLog("Train end time: " & $iTimeBeforeTrain1)
SetLog("Next Train in S: " & $iTimeBeforeTrain2)
EndIf
If $iTimeBeforeTrain2 <= 0 Then $bToReturn = True
If($g_iActiveDonate Or $g_bDonationEnabled) And $g_bChkDonate Then $bToReturn = True
If Not $bToReturn Then SetLog("Train end time: " & $iTimeBeforeTrain1, $COLOR_DEBUG)
If Not $bToReturn Then ClickP($aAway, 1, 0, "#0332")
Return $bToReturn
EndFunc
Func SwitchBetweenBases($bCheckMainScreen = True)
Local $sSwitchFrom, $sSwitchTo, $bIsOnBuilderBase = False, $aButtonCoords
Local $sTile, $sTileDir, $sRegionToSearch
If Not $g_bRunState Then Return
If isOnBuilderBase(True) Then
$sSwitchFrom = "Builder Base"
$sSwitchTo = "Normal Village"
$bIsOnBuilderBase = True
$sTile = "BoatBuilderBase"
$sTileDir = $g_sImgBoatBB
$sRegionToSearch = "487,44,708,242"
Else
$sSwitchFrom = "Normal Village"
$sSwitchTo = "Builder Base"
$bIsOnBuilderBase = False
$sTile = "BoatNormalVillage"
$sTileDir = $g_sImgBoat
$sRegionToSearch = "66,432,388,627"
EndIf
ZoomOut()
$aButtonCoords = decodeSingleCoord(findImageInPlace($sTile, $sTileDir, $sRegionToSearch))
If UBound($aButtonCoords) > 1 Then
SetLog("Going to " & $sSwitchTo, $COLOR_INFO)
ClickP($aButtonCoords)
If _Sleep($DELAYSWITCHBASES1) Then Return
Local $hTimerHandle = __TimerInit()
Local $bSwitched = False
While __TimerDiff($hTimerHandle) < 3000 And Not $bSwitched
_Sleep(250)
ForceCaptureRegion()
$bSwitched = isOnBuilderBase(True) <> $bIsOnBuilderBase
WEnd
If $bSwitched Then
If $bCheckMainScreen Then checkMainScreen(True, Not $bIsOnBuilderBase)
Return True
Else
SetLog("Failed to go to the " & $sSwitchTo, $COLOR_ERROR)
EndIf
Else
If $bIsOnBuilderBase Then
SetLog("Cannot find the Boat on the Coast", $COLOR_ERROR)
Else
SetLog("Cannot find the Boat on the Coast. Maybe it is still broken or not visible", $COLOR_ERROR)
EndIf
EndIf
Return False
EndFunc
Func ProfileSwitchAccountEnabled()
If Not $g_bChkSwitchAcc Or Not aquireSwitchAccountMutex() Then Return False
Return SetError(0, 0, _ArraySearch($g_asProfileName, $g_sProfileCurrentName) >= 0)
EndFunc
Func SwitchAccountEnabled($IdxOrProfilename = $g_sProfileCurrentName)
Local $sProfile
Local $iIdx
If IsInt($IdxOrProfilename) Then
$iIdx = $IdxOrProfilename
$sProfile = $g_asProfileName[$iIdx]
Else
$sProfile = $IdxOrProfilename
$iIdx = _ArraySearch($g_asProfileName, $sProfile)
EndIf
If Not $sProfile Or $iIdx < 0 Or Not $g_abAccountNo[$iIdx] Then
Return False
EndIf
Return aquireProfileMutex($sProfile) <> 0
EndFunc
Func AccountNoActive()
Local $a[UBound($g_abAccountNo)]
For $i = 0 To UBound($g_abAccountNo) - 1
$a[$i] = SwitchAccountEnabled($i)
Next
Return $a
EndFunc
Func InitiateSwitchAcc()
If Not ProfileSwitchAccountEnabled() Or Not $g_bInitiateSwitchAcc Then Return
UpdateMultiStats()
$g_iNextAccount = -1
SetLog("Switch Account enable for " & $g_iTotalAcc + 1 & " accounts")
SetSwitchAccLog("Initiating: " & $g_iTotalAcc + 1 & " acc", $COLOR_SUCCESS)
For $i = 0 To $g_iTotalAcc
Local $sBotType = "Idle"
If $g_abAccountNo[$i] = True Then
If SwitchAccountEnabled($i) Then
$sBotType = "Active"
If $g_abDonateOnly[$i] = True Then $sBotType = "Donate"
If $g_iNextAccount = -1 Then $g_iNextAccount = $i
If $g_asProfileName[$i] = $g_sProfileCurrentName Then $g_iNextAccount = $i
Else
$sBotType = "Other bot"
EndIf
EndIf
SetLog("  - Account [" & $i + 1 & "]: " & $g_asProfileName[$i] & " - " & $sBotType)
SetSwitchAccLog("  - Acc. " & $i + 1 & ": " & $sBotType)
$g_aiTimerStart[$i] = 0
$g_aiRemainTrainTime[$i] = 0
$g_abPBActive[$i] = False
Next
$g_iCurAccount = $g_iNextAccount
SetLog("Let's start with Account [" & $g_iNextAccount + 1 & "]")
SwitchCOCAcc($g_iNextAccount)
EndFunc
Func CheckSwitchAcc()
Local $abAccountNo = AccountNoActive()
Local $aActiveAccount = _ArrayFindAll($abAccountNo, True)
If UBound($aActiveAccount) <= 1 Then Return
Local $aDonateAccount = _ArrayFindAll($g_abDonateOnly, True)
Local $bReachAttackLimit =($g_aiAttackedCountSwitch[$g_iCurAccount] <= $g_aiAttackedCountAcc[$g_iCurAccount] - 2)
Local $bForceSwitch = False
Local $nMinRemainTrain, $iWaitTime
Local $aActibePBTaccounts = _ArrayFindAll($g_abPBActive, True)
SetLog("Start Switch Account...!", $COLOR_INFO)
If $g_abPBActive[$g_iCurAccount] = True Then $bForceSwitch = True
If $g_iCommandStop = 0 Then
SetLog("This account is in halt attack mode, switching to another account", $COLOR_ACTION)
SetSwitchAccLog(" - HaltAttack, Force switch")
$bForceSwitch = True
ElseIf $g_bWaitForCCTroopSpell Then
SetLog("Still waiting for CC Troops/Spells, switching to another Account", $COLOR_ACTION)
SetSwitchAccLog(" - Waiting for CC")
$bForceSwitch = True
Else
getArmyTroopTime(True, False)
$g_aiTimeTrain[1] = 0
If IsWaitforSpellsActive() Then getArmySpellTime()
$g_aiTimeTrain[2] = 0
If IsWaitforHeroesActive() Then CheckWaitHero()
ClickP($aAway, 1, 0, "#0000")
$iWaitTime = _ArrayMax($g_aiTimeTrain)
If $bReachAttackLimit And $iWaitTime <= 0 Then
SetLog("This account has attacked twice in a row, switching to another account", $COLOR_INFO)
SetSwitchAccLog(" - Reach attack limit: " & $g_aiAttackedCountAcc[$g_iCurAccount] - $g_aiAttackedCountSwitch[$g_iCurAccount])
$bForceSwitch = True
EndIf
EndIf
Local $sLogSkip = ""
If Not $g_abDonateOnly[$g_iCurAccount] And $iWaitTime <= $g_iTrainTimeToSkip And Not $bForceSwitch Then
If $iWaitTime > 0 Then $sLogSkip = " in " & Round($iWaitTime, 1) & " mins"
SetLog("Army is ready" & $sLogSkip & ", skip switching account", $COLOR_INFO)
SetSwitchAccLog(" - Army is ready" & $sLogSkip)
SetSwitchAccLog("Stay at [" & $g_iCurAccount + 1 & "]", $COLOR_SUCCESS)
If _Sleep(500) Then Return
Else
$nMinRemainTrain = CheckTroopTimeAllAccount($bForceSwitch)
If $g_bChkSmartSwitch = 1 Then
If $nMinRemainTrain <= 1 And Not $bForceSwitch And Not $g_bDonateLikeCrazy Then
If $g_bDebugSetlog Then SetDebugLog("Switch to or Stay at Active Account: " & $g_iNextAccount + 1, $COLOR_DEBUG)
$g_iDonateSwitchCounter = 0
Else
If $g_iDonateSwitchCounter < UBound($aDonateAccount) Then
$g_iNextAccount = $aDonateAccount[$g_iDonateSwitchCounter]
$g_iDonateSwitchCounter += 1
If $g_bDebugSetlog Then SetDebugLog("Switch to Donate Account " & $g_iNextAccount + 1 & ". $g_iDonateSwitchCounter = " & $g_iDonateSwitchCounter, $COLOR_DEBUG)
SetSwitchAccLog(" - Donate Acc [" & $g_iNextAccount + 1 & "]")
Else
$g_iDonateSwitchCounter = 0
EndIf
EndIf
Else
$g_iNextAccount = $g_iCurAccount + 1
If $g_iNextAccount > $g_iTotalAcc Then $g_iNextAccount = 0
While $abAccountNo[$g_iNextAccount] = False
$g_iNextAccount += 1
If $g_iNextAccount > $g_iTotalAcc Then $g_iNextAccount = 0
WEnd
EndIf
For $i = 0 To $g_iTotalAcc
If $g_abPBActive[$g_iNextAccount] And $g_aiRemainTrainTime[$g_iNextAccount] > 2 Then
SetLog("Account " & $g_iNextAccount + 1 & " is in a Personal Break Time!", $COLOR_INFO)
SetSwitchAccLog(" - Account " & $g_iNextAccount + 1 & " is in PTB")
$g_iNextAccount = $g_iNextAccount + 1
If $g_iNextAccount > $g_iTotalAcc Then $g_iNextAccount = 0
Else
ExitLoop
EndIf
Next
If UBound($aActibePBTaccounts) + UBound($aDonateAccount) = UBound($aActiveAccount) Then
SetLog("All accounts set to Donate and/or are in PBT!", $COLOR_INFO)
SetSwitchAccLog("All accounts in PBT/Donate:")
For $i = 0 To $g_iTotalAcc
If $g_abDonateOnly[$i] Then SetSwitchAccLog(" - Donate Acc [" & $i + 1 & "]")
If $g_abPBActive[$i] Then SetSwitchAccLog(" - PBT Acc [" & $i + 1 & "]")
NExt
EndIf
If $g_iNextAccount <> $g_iCurAccount Then
If $g_bRequestTroopsEnable And $g_bCanRequestCC Then
SetLog("Try Request troops before switching account", $COLOR_INFO)
RequestCC(True)
EndIf
If Not IsMainPage() Then checkMainScreen()
SwitchCOCAcc($g_iNextAccount)
Else
SetLog("Staying in this account")
SetSwitchAccLog("Stay at [" & $g_iCurAccount + 1 & "]", $COLOR_SUCCESS)
EndIf
EndIf
EndFunc
Func SwitchCOCAcc($NextAccount)
Local $abAccountNo = AccountNoActive()
If $NextAccount < 0 And $NextAccount > $g_iTotalAcc Then $NextAccount = _ArraySearch(True, $abAccountNo)
Static $iRetry = 0
Static $StartOnlineTime = 0
Local $bResult
SetLog("Switching to Account [" & $NextAccount + 1 & "]")
If $g_bInitiateSwitchAcc Then
$StartOnlineTime = 0
$g_bInitiateSwitchAcc = False
EndIf
If $StartOnlineTime <> 0 And Not $g_bReMatchAcc Then SetSwitchAccLog(" - Acc " & $g_iCurAccount + 1 & ", online: " & Round(TimerDiff($StartOnlineTime) / 1000 / 60, 1) & "m")
Local $bSharedPrefs = $g_bChkSharedPrefs And HaveSharedPrefs($g_asProfileName[$g_iNextAccount])
If $bSharedPrefs And $g_PushedSharedPrefsProfile = $g_asProfileName[$g_iNextAccount] Then
$bResult = True
$bSharedPrefs = False
SetLog("Profile shared_prefs already pushed")
Else
If IsMainPage() Then Click($aButtonSetting[0], $aButtonSetting[1], 1, 0, "Click Setting")
If _Sleep(500) Then Return
If $g_bChkGooglePlay Or $g_bChkSharedPrefs Then
While 1
Switch SwitchCOCAcc_DisconnectConnect($bResult, $bSharedPrefs)
Case "OK"
Case "Error"
ExitLoop
Case "Exit"
Return
EndSwitch
Switch SwitchCOCAcc_ClickAccount($bResult, $NextAccount, $bSharedPrefs)
Case "OK"
If $g_bChkSharedPrefs Then
If $bSharedPrefs Then
CloseCoC(False)
$bResult = True
ExitLoop
Else
SetLog($g_asProfileName[$g_iNextAccount] & " missing shared_prefs, using normal switch account", $COLOR_WARNING)
EndIf
EndIf
Case "Error"
ExitLoop
Case "Exit"
Return
EndSwitch
Switch SwitchCOCAcc_ConfirmAccount($bResult)
Case "OK"
Case "Error"
ExitLoop
Case "Exit"
Return
EndSwitch
ExitLoop
WEnd
ElseIf $g_bChkSuperCellID Then
While 1
Switch SwitchCOCAcc_ConnectedSCID($bResult)
Case "OK"
Case "Error"
ExitLoop
Case "Exit"
Return
EndSwitch
Switch SwitchCOCAcc_ConfirmSCID($bResult)
Case "OK"
Case "Error"
ExitLoop
Case "Exit"
Return
EndSwitch
Switch SwitchCOCAcc_ClickAccountSCID($bResult, $NextAccount)
Case "OK"
Case "Error"
ExitLoop
Case "Exit"
Return
EndSwitch
ExitLoop
WEnd
EndIf
If _Sleep(500) Then Return
EndIf
If $bResult = True Then
$iRetry = 0
$g_bReMatchAcc = False
$g_abNotNeedAllTime[0] = 1
$g_abNotNeedAllTime[1] = 1
$g_aiAttackedCountSwitch[$g_iCurAccount] = $g_aiAttackedCountAcc[$g_iCurAccount]
$g_iCurAccount = $NextAccount
If $g_sProfileCurrentName <> $g_asProfileName[$g_iNextAccount] Then
If $g_iGuiMode = 1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbProfile, _GUICtrlComboBox_FindStringExact($g_hCmbProfile, $g_asProfileName[$g_iNextAccount]))
cmbProfile()
DisableGUI_AfterLoadNewProfile()
Else
saveConfig()
$g_sProfileCurrentName = $g_asProfileName[$g_iNextAccount]
LoadProfile(False)
EndIf
EndIf
If $bSharedPrefs Then
SetLog("Please wait for loading CoC...!")
PushSharedPrefs()
OpenCoC()
EndIf
$StartOnlineTime = TimerInit()
SetSwitchAccLog("Switched to Acc [" & $NextAccount + 1 & "]", $COLOR_SUCCESS)
If $g_bChkSharedPrefs Then
waitMainScreen()
If IsMainPage() Then
Click($aButtonSetting[0], $aButtonSetting[1], 1, 0, "Click Setting")
If _Sleep(500) Then Return
Switch SwitchCOCAcc_DisconnectConnect($bResult, $g_bChkSharedPrefs)
Case "OK"
Case "Error"
Case "Exit"
Return
EndSwitch
Switch SwitchCOCAcc_ClickAccount($bResult, $NextAccount, $g_bChkSharedPrefs, False)
Case "OK"
PullSharedPrefs()
EndSwitch
EndIf
EndIf
Else
$iRetry += 1
$g_bReMatchAcc = True
SetLog("Switching account failed!", $COLOR_ERROR)
SetSwitchAccLog("Switching to Acc " & $NextAccount + 1 & " Failed!", $COLOR_ERROR)
If $iRetry <= 3 Then
ClickP($aAway, 3, 500)
checkMainScreen()
Else
$iRetry = 0
UniversalCloseWaitOpenCoC()
EndIf
EndIf
waitMainScreen()
If $g_bForceSinglePBLogoff Then $g_bGForcePBTUpdate = True
runBot()
EndFunc
Func SwitchCOCAcc_DisconnectConnect(ByRef $bResult, $bDisconnectOnly = $g_bChkSharedPrefs)
For $i = 0 To 20
If _ColorCheck(_GetPixelColor($aButtonConnected[0], $aButtonConnected[1], True), Hex($aButtonConnected[2], 6), $aButtonConnected[3]) Then
If $bDisconnectOnly = False Then
SetLog("   1. Click Connect & Disconnect")
Click($aButtonConnected[0], $aButtonConnected[1], 2, 1000)
If _Sleep(200) Then Return "Exit"
Else
SetLog("   1. Click Connected")
Click($aButtonConnected[0], $aButtonConnected[1], 1, 1000)
If _Sleep(200) Then Return "Exit"
EndIf
Return "OK"
ElseIf _ColorCheck(_GetPixelColor($aButtonDisconnected[0], $aButtonDisconnected[1], True), Hex($aButtonDisconnected[2], 6), $aButtonDisconnected[3]) Then
If $bDisconnectOnly = False Then
SetLog("   1. Click Disconnect")
Click($aButtonDisconnected[0], $aButtonDisconnected[1])
If _Sleep(200) Then Return "Exit"
Else
SetLog("Account already disconnected")
EndIf
Return "OK"
ElseIf _ColorCheck(_GetPixelColor($aButtonConnectedSCID[0], $aButtonConnectedSCID[1], True), Hex($aButtonConnectedSCID[2], 6), $aButtonConnectedSCID[3]) Then
SetLog("Account connected to SuperCell ID")
Return "OK"
EndIf
If $i = 20 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
Return ""
EndFunc
Func SwitchCOCAcc_ClickAccount(ByRef $bResult, $NextAccount, $bStayDisconnected = $g_bChkSharedPrefs, $bLateDisconnectButtonCheck = True)
FuncEnter(SwitchCOCAcc_ClickAccount)
Local $YCoord = Int(373.5 - $g_iTotalAcc * 36.5 + 73 * $NextAccount)
For $i = 0 To 20
If _ColorCheck(_GetPixelColor($aListAccount[0], $aListAccount[1], True), Hex($aListAccount[2], 6), $aListAccount[3]) Then
If $bStayDisconnected Then
ClickP($aAway, 1, 0, "#0000")
Return FuncReturn("OK")
EndIf
If _Sleep(600) Then Return FuncReturn("Exit")
SetLog("   2. Click Account [" & $NextAccount + 1 & "]")
Click(383, $YCoord)
If _Sleep(600) Then Return FuncReturn("Exit")
Return FuncReturn("OK")
ElseIf(Not $bLateDisconnectButtonCheck Or $i = 6) And _ColorCheck(_GetPixelColor($aButtonDisconnected[0], $aButtonDisconnected[1], True), Hex($aButtonDisconnected[2], 6), $aButtonDisconnected[3]) Then
If $bStayDisconnected Then
ClickP($aAway, 1, 0, "#0000")
Return FuncReturn("OK")
EndIf
If _Sleep(250) Then Return FuncReturn("Exit")
SetLog("   1.1. Click Disconnect again")
Click($aButtonDisconnected[0], $aButtonDisconnected[1])
If _Sleep(600) Then Return FuncReturn("Exit")
ElseIf _ColorCheck(_GetPixelColor($aButtonConnectedSCID[0], $aButtonConnectedSCID[1], True), Hex($aButtonConnectedSCID[2], 6), $aButtonConnectedSCID[3]) Then
If $bStayDisconnected Then
ClickP($aAway, 1, 0, "#0000")
Return FuncReturn("OK")
EndIf
EndIf
If $i = 20 Then
$bResult = False
Return FuncReturn("Error")
EndIf
If _Sleep(900) Then Return FuncReturn("Exit")
Next
Return FuncReturn("")
EndFunc
Func SwitchCOCAcc_ConfirmAccount(ByRef $bResult, $iStep = 3, $bDisconnectAfterSwitch = $g_bChkSharedPrefs)
For $i = 0 To 30
If _ColorCheck(_GetPixelColor($aButtonConnected[0], $aButtonConnected[1], True), Hex($aButtonConnected[2], 6), $aButtonConnected[3]) Then
SetLog("Already in current account")
If $bDisconnectAfterSwitch Then
Switch SwitchCOCAcc_DisconnectConnect($bResult)
Case "OK"
Case "Error"
Return "Error"
Case "Exit"
Return "Exit"
EndSwitch
EndIf
ClickP($aAway, 2, 0, "#0167")
If _Sleep(500) Then Return "Exit"
$bResult = True
Return "OK"
ElseIf _ColorCheck(_GetPixelColor($aButtonVillageLoad[0], $aButtonVillageLoad[1], True), Hex($aButtonVillageLoad[2], 6), $aButtonVillageLoad[3]) Then
If _Sleep(250) Then Return "Exit"
SetLog("   " & $iStep & ". Click Load button")
Click($aButtonVillageLoad[0], $aButtonVillageLoad[1], 1, 0, "Click Load")
For $j = 0 To 25
If _ColorCheck(_GetPixelColor($aButtonVillageOkay[0], $aButtonVillageOkay[1], True), Hex($aButtonVillageOkay[2], 6), $aButtonVillageOkay[3]) Then
If _Sleep(250) Then Return "Exit"
SetLog("   " &($iStep + 1) & ". Click OKAY")
Click($aButtonVillageOkay[0], $aButtonVillageOkay[1], 1, 0, "Click OKAY")
SetLog("Please wait for loading CoC...!")
$bResult = True
Return "OK"
ElseIf _ColorCheck(_GetPixelColor($aTextBox[0], $aTextBox[1], True), Hex($aTextBox[2], 6), $aTextBox[3]) Then
If _Sleep(250) Then Return "Exit"
SetLog("   " &($iStep + 1) & ". Click text box & type CONFIRM")
Click($aTextBox[0], $aTextBox[1], 1, 0, "Click Text box")
If _Sleep(500) Then Return "Exit"
AndroidSendText("CONFIRM")
ExitLoop
EndIf
If $j = 25 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
For $k = 0 To 10
If _ColorCheck(_GetPixelColor($aButtonVillageOkay[0], $aButtonVillageOkay[1], True), Hex($aButtonVillageOkay[2], 6), $aButtonVillageOkay[3]) Then
If _Sleep(250) Then Return "Exit"
SetLog("   " &($iStep + 2) & ". Click OKAY")
Click($aButtonVillageOkay[0], $aButtonVillageOkay[1], 1, 0, "Click OKAY")
SetLog("Please wait for loading CoC...!")
$bResult = True
If $bDisconnectAfterSwitch Then
If Not checkMainScreen() Then
SetLog("Cannot Disconnect account", $COLOR_ERROR)
Return "Error"
EndIf
Click($aButtonSetting[0], $aButtonSetting[1], 1, 0, "Click Setting")
If _Sleep(500) Then Return
Switch SwitchCOCAcc_DisconnectConnect($bResult)
Case "OK"
Case "Error"
Return "Error"
Case "Exit"
Return "Exit"
EndSwitch
EndIf
Return "OK"
EndIf
If $k = 10 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
EndIf
If $i = 30 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
Return ""
EndFunc
Func SwitchCOCAcc_ConnectedSCID(ByRef $bResult)
For $i = 0 To 20
If _ColorCheck(_GetPixelColor($aButtonConnectedSCID[0], $aButtonConnectedSCID[1], True), Hex($aButtonConnectedSCID[2], 6), $aButtonConnectedSCID[3]) Then
Click($aButtonConnectedSCID[0], $aButtonConnectedSCID[1], 1, 0, "Click Connected SC_ID")
Setlog("   1. Click Connected Supercell ID")
If _Sleep(2500) Then Return "Exit"
Return "OK"
EndIf
SetDebugLog("Checking Green Connected button x:" & $aButtonConnectedSCID[0] & " y:" & $aButtonConnectedSCID[1] & " : " & _GetPixelColor($aButtonConnectedSCID[0], $aButtonConnectedSCID[1], True))
If $i = 20 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
Return ""
EndFunc
Func SwitchCOCAcc_ConfirmSCID(ByRef $bResult)
For $i = 0 To 20
If _ColorCheck(_GetPixelColor($aButtonLogOutSCID[0], $aButtonLogOutSCID[1], True), Hex($aButtonLogOutSCID[2], 6), $aButtonLogOutSCID[3]) Then
SetLog("   2. Click Log Out Supercell ID")
Click($aButtonLogOutSCID[0], $aButtonLogOutSCID[1], 2, 500, "Click Log Out SC_ID")
If _Sleep(500) Then Return "Exit"
For $j = 0 To 10
If _ColorCheck(_GetPixelColor($aButtonConfirmSCID[0], $aButtonConfirmSCID[1], True), Hex($aButtonConfirmSCID[2], 6), $aButtonConfirmSCID[3]) Then
SetLog("   3. Click Confirm Supercell ID")
Click($aButtonConfirmSCID[0], $aButtonConfirmSCID[1], 1, 0, "Click Confirm SC_ID")
If _Sleep(500) Then Return "Exit"
Return "OK"
EndIf
If $j = 10 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
EndIf
SetDebugLog("Checking LogOut & Confirm button x:" & $aButtonLogOutSCID[0] & " y:" & $aButtonLogOutSCID[1] & " : " & _GetPixelColor($aButtonLogOutSCID[0], $aButtonLogOutSCID[1], True))
If $i = 20 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
Return ""
EndFunc
Func SwitchCOCAcc_ClickAccountSCID(ByRef $bResult, $NextAccount, $iStep = 4)
Local $YCoord = Int(336 + 73.5 * $NextAccount)
Local $iRetryCloseSCIDTab = 0
For $i = 0 To 30
If _ColorCheck(_GetPixelColor($aLoginWithSupercellID[0], $aLoginWithSupercellID[1], True), Hex($aLoginWithSupercellID[2], 6), $aLoginWithSupercellID[3]) And  _ColorCheck(_GetPixelColor($aLoginWithSupercellID2[0], $aLoginWithSupercellID2[1], True), Hex($aLoginWithSupercellID2[2], 6), $aLoginWithSupercellID2[3]) Then
SetLog("   " & $iStep & ". Click Log in with Supercell ID")
Click($aLoginWithSupercellID[0], $aLoginWithSupercellID[1], 1, 0, "Click Log in with SC_ID")
If _Sleep(3000) Then Return "Exit"
For $j = 0 To 20
If _ColorCheck(_GetPixelColor($aListAccountSCID[0], $aListAccountSCID[1], True), Hex($aListAccountSCID[2], 6), $aListAccountSCID[3]) Then
If $NextAccount >= 4 Then
$YCoord = Int(408 - 73.5 *($g_iTotalAcc - $NextAccount))
ClickDrag(700, 590, 700, 172, 2000)
If _Sleep(500) Then Return "Exit"
EndIf
Click(270, $YCoord)
SetLog("   " &($iStep + 1) & ". Click Account [" & $NextAccount + 1 & "] Supercell ID")
If _Sleep(500) Then Return "Exit"
SetLog("Please wait for loading CoC...!")
$bResult = True
Return "OK"
ElseIf $j = 10 Then
$iRetryCloseSCIDTab += 1
If $iRetryCloseSCIDTab <= 3 Then
SetLog("   " & $iStep & ".5 Click Close Tab Supercell ID")
Click($aCloseTabSCID[0], $aCloseTabSCID[1], 1, 0, "Click Close Tab SC_ID")
If _Sleep(500) Then Return "Exit"
$i = 0
ExitLoop
Else
$iRetryCloseSCIDTab = 0
$bResult = False
Return "Error"
EndIf
EndIf
SetDebugLog("Checking Account List x:" & $aListAccountSCID[0] & " y:" & $aListAccountSCID[1] & " : " & _GetPixelColor($aListAccountSCID[0], $aListAccountSCID[1], True))
If $j = 20 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
EndIf
SetDebugLog("Checking 'Log in with SuperCell ID' buttonn' x:" & $aLoginWithSupercellID[0] & " y:" & $aLoginWithSupercellID[1] & " : " & _GetPixelColor($aLoginWithSupercellID[0], $aLoginWithSupercellID[1], True))
If $i = 30 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
Return ""
EndFunc
Func CheckWaitHero()
Local $iActiveHero
Local $aHeroResult[3]
$g_aiTimeTrain[2] = 0
$aHeroResult = getArmyHeroTime("all")
If @error Then
SetLog("getArmyHeroTime return error, exit Check Hero's wait time!", $COLOR_ERROR)
Return
EndIf
If $aHeroResult = "" Then
SetLog("You have no hero or bad TH level detection Pls manually locate TH", $COLOR_ERROR)
Return
EndIf
If _Sleep($DELAYRESPOND) Then Return
If $aHeroResult[0] > 0 Or $aHeroResult[1] > 0 Or $aHeroResult[2] > 0 Then
For $pTroopType = $eKing To $eWarden
For $pMatchMode = $DB To $g_iModeCount - 1
$iActiveHero = -1
If IsSpecialTroopToBeUsed($pMatchMode, $pTroopType) And BitOR($g_aiAttackUseHeroes[$pMatchMode], $g_aiSearchHeroWaitEnable[$pMatchMode]) = $g_aiAttackUseHeroes[$pMatchMode] Then
$iActiveHero = $pTroopType - $eKing
EndIf
If $iActiveHero <> -1 And $aHeroResult[$iActiveHero] > 0 Then
If $g_aiTimeTrain[2] < $aHeroResult[$iActiveHero] Then
$g_aiTimeTrain[2] = $aHeroResult[$iActiveHero]
EndIf
EndIf
Next
If _Sleep($DELAYRESPOND) Then Return
Next
EndIf
EndFunc
Func CheckTroopTimeAllAccount($bExcludeCurrent = False)
Local $abAccountNo = AccountNoActive()
Local $iMinRemainTrain
If $bExcludeCurrent = False Then
If $g_abPBActive[$g_iCurAccount] = False Then $g_aiRemainTrainTime[$g_iCurAccount] = _ArrayMax($g_aiTimeTrain)
$g_aiTimerStart[$g_iCurAccount] = TimerInit()
EndIf
SetSwitchAccLog(" - Train times: ")
For $i = 0 To $g_iTotalAcc
If $bExcludeCurrent And $i = $g_iCurAccount Then ContinueLoop
If $abAccountNo[$i] And Not $g_abDonateOnly[$i] Then
If $g_aiTimerStart[$i] <> 0 Then
$g_aiRemainTrainTime[$i] -= Round(TimerDiff($g_aiTimerStart[$i]) / 1000 / 60, 1)
$g_aiTimerStart[$i] = TimerInit()
If $g_aiRemainTrainTime[$i] >= 0 Then
SetLog("Account [" & $i + 1 & "]: " & $g_asProfileName[$i] & " will have full army in:" & $g_aiRemainTrainTime[$i] & " minutes")
Else
SetLog("Account [" & $i + 1 & "]: " & $g_asProfileName[$i] & " was ready:" & - $g_aiRemainTrainTime[$i] & " minutes ago")
EndIf
SetSwitchAccLog("    Acc " & $i + 1 & ": " & $g_aiRemainTrainTime[$i] & "m")
Else
SetLog("Account [" & $i + 1 & "]: " & $g_asProfileName[$i] & " has not been read its remain train time")
$g_aiRemainTrainTime[$i] = -999
SetSwitchAccLog("    Acc " & $i + 1 & ": Unknown")
EndIf
EndIf
Next
$iMinRemainTrain = _ArrayMax($g_aiRemainTrainTime)
For $i = 0 To $g_iTotalAcc
If $bExcludeCurrent And $i = $g_iCurAccount Then ContinueLoop
If $abAccountNo[$i] And Not $g_abDonateOnly[$i] Then
If $g_aiRemainTrainTime[$i] <= $iMinRemainTrain Then
$iMinRemainTrain = $g_aiRemainTrainTime[$i]
$g_iNextAccount = $i
EndIf
EndIf
Next
Return $iMinRemainTrain
EndFunc
Func DisableGUI_AfterLoadNewProfile()
$g_bGUIControlDisabled = True
For $i = $g_hFirstControlToHide To $g_hLastControlToHide
If IsAlwaysEnabledControl($i) Then ContinueLoop
If $g_bNotifyPBEnable And $i = $g_hBtnNotifyDeleteMessages Then ContinueLoop
If BitAND(GUICtrlGetState($i), $GUI_ENABLE) Then GUICtrlSetState($i, $GUI_DISABLE)
Next
ControlEnable("", "", $g_hCmbGUILanguage)
$g_bGUIControlDisabled = False
EndFunc
Func aquireSwitchAccountMutex($iSwitchAccountGroup = $g_iCmbSwitchAcc, $bReturnOnlyMutex = False, $bShowMsgBox = False)
Local $sMsg = GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Msg_SwitchAccounts_InUse", "My Bot with Switch Accounts Group %s is already in use or active.", $iSwitchAccountGroup)
If $iSwitchAccountGroup Then
Local $hMutex_Profile = 0
If $g_ahMutex_SwitchAccountsGroup[0] = $iSwitchAccountGroup And $g_ahMutex_SwitchAccountsGroup[1] Then
$hMutex_Profile = $g_ahMutex_SwitchAccountsGroup[1]
Else
$hMutex_Profile = CreateMutex(StringReplace($g_sProfilePath & "\SwitchAccount.0" & $iSwitchAccountGroup, "\", "-"))
$g_ahMutex_SwitchAccountsGroup[0] = $iSwitchAccountGroup
$g_ahMutex_SwitchAccountsGroup[1] = $hMutex_Profile
EndIf
If $bReturnOnlyMutex Then
Return $hMutex_Profile
EndIf
If $hMutex_Profile = 0 Then
SetLog($sMsg, $COLOR_ERROR)
If $bShowMsgBox Then
MsgBox(BitOR($MB_OK, $MB_ICONINFORMATION, $MB_TOPMOST), $g_sBotTitle, $sMsg)
EndIf
EndIf
Return $hMutex_Profile <> 0
EndIf
Return False
EndFunc
Func releaseSwitchAccountMutex()
If $g_ahMutex_SwitchAccountsGroup[1] Then
ReleaseMutex($g_ahMutex_SwitchAccountsGroup[1])
$g_ahMutex_SwitchAccountsGroup[0] = 0
$g_ahMutex_SwitchAccountsGroup[1] = 0
Return True
EndIf
Return False
EndFunc
Func CheckGoogleSelectAccount($bSelectFirst = True)
Local $bResult = False
Local $pColor = _GetPixelColor($aListAccount[0], $aListAccount[1], False)
If _ColorCheck($pColor, Hex($aListAccount[2], 6), $aListAccount[3]) Then
SetDebugLog("Found open Google Accounts list pixel")
If UBound(decodeSingleCoord(FindImageInPlace("GoogleSelectAccount", $g_sImgGoogleSelectAccount, "180,400(90,300)", False))) > 1 Then
SetLog("Found open Google Accounts list")
If $g_bChkSharedPrefs Then
SetLog("Close Google Accounts list")
Click(90, 400)
Return True
EndIf
Local $a = decodeSingleCoord(FindImageInPlace("GoogleSelectEmail", $g_sImgGoogleSelectEmail, "220,80(400,600)", False))
If UBound($a) > 1 Then
SetLog("   1. Click first Google Account")
ClickP($a)
$bResult = True
Switch SwitchCOCAcc_ConfirmAccount($bResult, 2)
Case "OK"
Case "Error"
Case "Exit"
Return
EndSwitch
Else
SetLog("Cannot find Google Account Email", $COLOR_ERROR)
$bResult = False
EndIf
Else
SetDebugLog("Open Google Accounts list not verified")
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("CheckGoogleSelectAccount pixel color: " & $pColor)
EndIf
Return $bResult
EndFunc
Func CheckLoginWithSupercellID()
Local $bResult = False
Local $pColor = _GetPixelColor($aLoginWithSupercellID[0], $aLoginWithSupercellID[1], False)
Local $pColor1 = _GetPixelColor($aLoginWithSupercellID2[0], $aLoginWithSupercellID2[1], False)
If _ColorCheck($pColor, Hex($aLoginWithSupercellID[2], 6), $aLoginWithSupercellID[3]) And _ColorCheck($pColor1, Hex($aLoginWithSupercellID2[2], 6), $aLoginWithSupercellID2[3]) then
SetDebugLog("Found Log in with Supercell ID pixel")
If UBound(decodeSingleCoord(FindImageInPlace("LoginWithSupercellID", $g_sImgLoginWithSupercellID, "318,678(125,30)", False))) > 1 Then
SetLog("Verified Log in with Supercell ID boot screen")
If HaveSharedPrefs($g_sProfileCurrentName) Then
SetLog("Close CoC and push shared_prefs for Supercell ID screen...")
PushSharedPrefs()
Return True
Else
If $g_bChkSuperCellID And ProfileSwitchAccountEnabled() Then
Local $NextAccount = 0
$bResult = True
For $i = 0 To $g_iTotalAcc
If $g_abAccountNo[$i] = True And SwitchAccountEnabled($i) And $g_asProfileName[$i] = $g_sProfileCurrentName Then $NextAccount = $i
Next
Switch SwitchCOCAcc_ClickAccountSCID($bResult, $NextAccount, 1)
Case "OK"
Case "Error"
Return
Case "Exit"
Return
EndSwitch
Else
SetLog("Cannot close Supercell ID screen, shared_prefs not pulled.", $COLOR_ERROR)
SetLog("Please resolve Supercell ID screen manually, close CoC", $COLOR_INFO)
SetLog("and then pull shared_prefs in tab Bot/Profiles.", $COLOR_INFO)
EndIf
EndIf
Else
SetDebugLog("Log in with Supercell ID boot screen not verified")
EndIf
Else
If $g_bDebugSetlog Then
SetDebugLog("LoginWithSupercellID Button pixel color: " & $pColor)
SetDebugLog("LoginWithSupercellID Font pixel color: " & $pColor1)
EndIf
EndIf
Return $bResult
EndFunc
Func SwitchAccountCheckProfileInUse($sNewProfile)
Local $sInGroups = ""
For $g = 1 To 8
If $g = $g_iCmbSwitchAcc Then ContinueLoop
Local $sSwitchAccFile = $g_sProfilePath & "\SwitchAccount.0" & $g & ".ini"
If FileExists($sSwitchAccFile) = 0 Then ContinueLoop
Local $sProfile
Local $bEnabled
For $i = 1 To Int(IniRead($sSwitchAccFile, "SwitchAccount", "TotalCocAccount", 0)) + 1
$bEnabled = IniRead($sSwitchAccFile, "SwitchAccount", "Enable", "") = "1"
If $bEnabled Then
$bEnabled = IniRead($sSwitchAccFile, "SwitchAccount", "AccountNo." & $i, "") = "1"
If $bEnabled Then
$sProfile = IniRead($sSwitchAccFile, "SwitchAccount", "ProfileName." & $i, "")
If $sProfile = $sNewProfile Then
If $sInGroups <> "" Then $sInGroups &= ", "
$sInGroups &= $g
EndIf
EndIf
EndIf
Next
Next
If $sInGroups Then
If StringLen($sInGroups) > 2 Then
$sInGroups = "used in groups " & $sInGroups
Else
$sInGroups = "used in group " & $sInGroups
EndIf
EndIf
Local $iAquired = aquireProfileMutex($sNewProfile)
If $iAquired Then
If $iAquired = 1 Then
releaseProfileMutex($sNewProfile)
EndIf
If $sInGroups Then
SetLog("Profile " & $sNewProfile & " not active, but " & $sInGroups & "!", $COLOR_ERROR)
SetSwitchAccLog($sNewProfile & " " & $sInGroups & "!", $COLOR_ERROR)
Return False
EndIf
Return True
Else
If $sInGroups Then
SetLog("Profile " & $sNewProfile & " active and " & $sInGroups & "!", $COLOR_ERROR)
SetSwitchAccLog($sNewProfile & " active & " & $sInGroups & "!", $COLOR_ERROR)
Else
SetLog("Profile " & $sNewProfile & " active in another bot instance!", $COLOR_ERROR)
SetSwitchAccLog($sNewProfile & " active!", $COLOR_ERROR)
EndIf
Return False
EndIf
EndFunc
Func _ClanGames()
If Not $g_bChkClanGamesEnabled Then Return
Local $sINIPath = StringReplace($g_sProfileConfigPath, "config.ini" , "ClanGames_config.ini")
If Not FileExists($sINIPath) then ClanGamesChallenges("" , True, $sINIPath, $g_bChkClanGamesDebug)
ClickP($aAway, 1, 0, "#0000")
SetLog("Entering Clan Games...", $COLOR_INFO)
If _Sleep(500) Then Return
Local $TabChallengesPosition[2] = [820, 130]
Local $sTimeRemain = "", $sEventName = "", $getCapture = True
Local Static $YourAccScore[8][2] = [[-1, True], [-1, True], [-1, True], [-1, True], [-1, True], [-1, True], [-1, True], [-1, True]]
If isProblemAffect(True) Then checkMainScreen(False)
If Not IsClanGamesWindow() Then Return
If $g_bChkClanGamesOnly = 1 then
If Not IsClanGamesEvent() Then Return
EndIf
Local $ScoreLimits = GetTimesAndScores()
If $ScoreLimits = -1 Or UBound($ScoreLimits) <> 2 Then Return
If _Sleep(3000) Then Return
SetLog("Your Score is: " & Int($ScoreLimits[0]), $COLOR_INFO)
If Int($ScoreLimits[0]) = Int($ScoreLimits[1]) Then
SetLog("Your Score limit was reached, Congrats...")
ClickP($aAway, 1, 0, "#0000")
Return
ElseIf Int($ScoreLimits[0]) + 200 > Int($ScoreLimits[1]) Then
SetLog("Your Score limit is almost reached...")
If $g_bChkClanGamesStopBeforeReachAndPurge Then
If CooldownTime() Then Return
If IsEventRunning() Then Return
SetLog("Stop before completing your limit and only Purge")
$sEventName = "Builder Base Challenges to Purge"
If PurgeEvent($g_sImgPurge, $sEventName, True) Then $g_iPurgeJobCount[$g_iCurAccount] += 1
ClickP($aAway, 1, 0, "#0000")
Return
EndIf
EndIf
If $YourAccScore[$g_iCurAccount][0] = -1 Then $YourAccScore[$g_iCurAccount][0] = $ScoreLimits[0]
If CooldownTime() Then Return
If $g_bRunState = False Then Return
If IsEventRunning() Then Return
If $g_bRunState = False Then Return
Local $x = 281, $y = 150, $x1 = 775, $y1 = 545
If $g_bChkClanGamesDebug Then SetLog("Your TownHall Level is " & $g_iTownHallLevel)
If isProblemAffect(True) Then checkMainScreen(False)
If $g_bChkClanGamesLoot Then
SetLog("Checking 6 Loot Challenges", $COLOR_DEBUG)
Local $LootChallenges = ClanGamesChallenges("$LootChallenges" , False, $sINIPath, $g_bChkClanGamesDebug)
_ArraySort($LootChallenges, 0, 0, 0, 3)
For $i = 0 To UBound($LootChallenges) - 1
If $g_iTownHallLevel < $LootChallenges[$i][2] Then ContinueLoop
If $LootChallenges[$i][3] = 0 then ContinueLoop
If QuickMIS("BC1", $LootChallenges[$i][0], $x, $y, $x1, $y1, $getCapture, $g_bChkClanGamesDebug) Then
SetLog("Found " & $LootChallenges[$i][1] & " Event", $COLOR_SUCCESS)
$sEventName = "Loot Event | " & $LootChallenges[$i][1]
Click($g_iQuickMISX + $x, $g_iQuickMISY + $y)
If _Sleep(1750) Then Return
If ClickOnEvent($YourAccScore, $ScoreLimits, $sEventName, $getCapture) Then Return
ClickP($TabChallengesPosition, 2, 0, "#Tab")
EndIf
If _Sleep(50) Then Return
If $g_bRunState = False Then Return
Next
EndIf
If $g_bChkClanGamesAirTroop Then
SetLog("Checking 5 Air Troops Challenges", $COLOR_DEBUG)
Local $AirTroopChallenges = ClanGamesChallenges("$AirTroopChallenges" , False, $sINIPath, $g_bChkClanGamesDebug)
For $i = 0 To UBound($AirTroopChallenges) - 1
Local $TroopIndex = Int(Eval("eTroop" & $AirTroopChallenges[$i][1]))
If $g_aiCurrentTroops[$TroopIndex] < 1 Then
If $g_bChkClanGamesDebug Then SetLog("[" & $AirTroopChallenges[$i][1] & "] No " & $g_asTroopNames[$TroopIndex] & " on your army composition.")
ContinueLoop
ElseIf $g_aiCurrentTroops[$TroopIndex] > 0 And $g_aiCurrentTroops[$TroopIndex] < $AirTroopChallenges[$i][3] Then
If $g_bChkClanGamesDebug Then SetLog("[" & $AirTroopChallenges[$i][1] & "] You need more " & $g_asTroopNames[$TroopIndex] & " [" & $g_aiCurrentTroops[$TroopIndex] & "/" & $AirTroopChallenges[$i][3] & "]")
ContinueLoop
EndIf
If QuickMIS("BC1", $AirTroopChallenges[$i][0], $x, $y, $x1, $y1, $getCapture, $g_bChkClanGamesDebug) Then
SetLog("Found " & $AirTroopChallenges[$i][1] & " Event", $COLOR_SUCCESS)
$sEventName = "Troops Event | " & $AirTroopChallenges[$i][1]
Click($g_iQuickMISX + $x, $g_iQuickMISY + $y)
If _Sleep(1750) Then Return
If ClickOnEvent($YourAccScore, $ScoreLimits, $sEventName, $getCapture) Then Return
ClickP($TabChallengesPosition, 2, 0, "#Tab")
EndIf
If _Sleep(50) Then Return
If $g_bRunState = False Then Return
Next
EndIf
If $g_bChkClanGamesGroundTroop Then
SetLog("Checking 14 Ground Troops Challenges", $COLOR_DEBUG)
Local $GroundTroopChallenges = ClanGamesChallenges("$GroundTroopChallenges" , False, $sINIPath, $g_bChkClanGamesDebug)
For $i = 0 To UBound($GroundTroopChallenges) - 1
Local $TroopIndex = Int(Eval("eTroop" & $GroundTroopChallenges[$i][1]))
If $g_aiCurrentTroops[$TroopIndex] < 1 Then
If $g_bChkClanGamesDebug Then SetLog("[" & $GroundTroopChallenges[$i][1] & "] No " & $g_asTroopNames[$TroopIndex] & " on your army composition.")
ContinueLoop
ElseIf $g_aiCurrentTroops[$TroopIndex] > 0 And $g_aiCurrentTroops[$TroopIndex] < $GroundTroopChallenges[$i][3] Then
If $g_bChkClanGamesDebug Then SetLog("[" & $GroundTroopChallenges[$i][1] & "] You need more " & $g_asTroopNames[$TroopIndex] & " [" & $g_aiCurrentTroops[$TroopIndex] & "/" & $GroundTroopChallenges[$i][3] & "]")
ContinueLoop
EndIf
If QuickMIS("BC1", $GroundTroopChallenges[$i][0], $x, $y, $x1, $y1, $getCapture, $g_bChkClanGamesDebug) Then
SetLog("Found " & $GroundTroopChallenges[$i][1] & " Event", $COLOR_SUCCESS)
$sEventName = "Troops Event | " & $GroundTroopChallenges[$i][1]
Click($g_iQuickMISX + $x, $g_iQuickMISY + $y)
If _Sleep(1750) Then Return
If ClickOnEvent($YourAccScore, $ScoreLimits, $sEventName, $getCapture) Then Return
ClickP($TabChallengesPosition, 2, 0, "#Tab")
EndIf
If _Sleep(50) Then Return
If $g_bRunState = False Then Return
Next
EndIf
If $g_bChkClanGamesBattle Then
SetLog("Checking 9 Battle Challenges", $COLOR_DEBUG)
Local $BattleChallenges = ClanGamesChallenges("$BattleChallenges" , False, $sINIPath, $g_bChkClanGamesDebug)
_ArraySort($BattleChallenges, 0, 0, 0, 3)
For $i = 0 To UBound($BattleChallenges) - 1
If $g_iTownHallLevel < $BattleChallenges[$i][2] Then ContinueLoop
If $BattleChallenges[$i][3] = 0 then ContinueLoop
If $BattleChallenges[$i][1] = "Attack Up" And $g_iTownHallLevel = 11 then ContinueLoop
If $BattleChallenges[$i][1] = "Slaying The Titans" And Int($g_aiCurrentLoot[$eLootTrophy]) < 4100 then ContinueLoop
If $BattleChallenges[$i][1] = "No-Magic Zone" And($g_bSmartZapEnable = True Or($g_iMatchMode = $DB And $g_aiAttackAlgorithm[$DB] = 1) Or($g_iMatchMode = $LB And $g_aiAttackAlgorithm[$LB] = 1)) then ContinueLoop
If $BattleChallenges[$i][1] = "No Heroics Allowed" And((Int($g_aiAttackUseHeroes[$DB]) > $eHeroNone And $g_iMatchMode = $DB) Or(Int($g_aiAttackUseHeroes[$LB]) > $eHeroNone And $g_iMatchMode = $LB)) then ContinueLoop
If QuickMIS("BC1", $BattleChallenges[$i][0], $x, $y, $x1, $y1, $getCapture, $g_bChkClanGamesDebug) Then
SetLog("Found " & $BattleChallenges[$i][1] & " Event", $COLOR_SUCCESS)
$sEventName = "Battle Event | " & $BattleChallenges[$i][1]
Click($g_iQuickMISX + $x, $g_iQuickMISY + $y)
If _Sleep(1750) Then Return
If $BattleChallenges[$i][1] = "Pile Of Victories" Then
If QuickMIS("BC1", $g_sImgWStreakC, $x, $y, $x1, $y1, $getCapture, $g_bChkClanGamesDebug) Then
SetLog("Winning Streak Detected , wrong Event.. continuing", $COLOR_WARNING)
If $g_iTownHallLevel < 9 Then
ClickP($TabChallengesPosition, 2, 0, "#Tab")
ContinueLoop
EndIf
$sEventName = "Battle Event | Winning Streak"
EndIf
EndIf
If ClickOnEvent($YourAccScore, $ScoreLimits, $sEventName, $getCapture) Then Return
ClickP($TabChallengesPosition, 2, 0, "#Tab")
EndIf
If _Sleep(50) Then Return
If $g_bRunState = False Then Return
Next
EndIf
If $g_bChkClanGamesDestruction Then
SetLog("Checking 28 Destruction Challenges", $COLOR_DEBUG)
Local $DestructionChallenges = ClanGamesChallenges("$DestructionChallenges" , False, $sINIPath, $g_bChkClanGamesDebug)
_ArraySort($DestructionChallenges, 0, 0, 0, 3)
For $i = 0 To UBound($DestructionChallenges) - 1
If $g_iTownHallLevel < $DestructionChallenges[$i][2] Then ContinueLoop
If $DestructionChallenges[$i][3] = 0 then ContinueLoop
If $DestructionChallenges[$i][1] = "Hero Level Hunter" Or $DestructionChallenges[$i][1] = "King Level Hunter" Or $DestructionChallenges[$i][1] = "Queen Level Hunter" Or $DestructionChallenges[$i][1] = "Warden Level Hunter" And((Int($g_aiAttackUseHeroes[$DB]) = $eHeroNone And $g_iMatchMode = $DB) Or(Int($g_aiAttackUseHeroes[$LB]) = $eHeroNone And $g_iMatchMode = $LB)) then ContinueLoop
If QuickMIS("BC1", $DestructionChallenges[$i][0], $x, $y, $x1, $y1, $getCapture, $g_bChkClanGamesDebug) Then
SetLog("Found " & $DestructionChallenges[$i][1] & " Event", $COLOR_SUCCESS)
$sEventName = "Destruction Event | " & $DestructionChallenges[$i][1]
Click($g_iQuickMISX + $x, $g_iQuickMISY + $y)
If _Sleep(1750) Then Return
If ClickOnEvent($YourAccScore, $ScoreLimits, $sEventName, $getCapture) Then Return
ClickP($TabChallengesPosition, 2, 0, "#Tab")
EndIf
If _Sleep(50) Then Return
If $g_bRunState = False Then Return
Next
EndIf
If $g_bChkClanGamesMiscellaneous Then
SetLog("Checking 3 Miscellaneous Challenges", $COLOR_DEBUG)
Local $MiscChallenges = ClanGamesChallenges("$MiscChallenges" , False, $sINIPath, $g_bChkClanGamesDebug)
_ArraySort($MiscChallenges, 0, 0, 0, 3)
For $i = 0 To UBound($MiscChallenges) - 1
If $MiscChallenges[$i][3] = 0 then ContinueLoop
If $MiscChallenges[$i][1] = "Gardening Exercise" And $g_iFreeBuilderCount < 1 Then ContinueLoop
If $g_iTownHallLevel < $MiscChallenges[$i][2] Then ContinueLoop
If $MiscChallenges[$i][1] = "Helping Hand" And Not $g_iActiveDonate Then ContinueLoop
If $MiscChallenges[$i][1] = "Donate Spells" And($g_aiPrepDon[2] = 0 And $g_aiPrepDon[3] = 0) Then ContinueLoop
If QuickMIS("BC1", $MiscChallenges[$i][0], $x, $y, $x1, $y1, $getCapture, $g_bChkClanGamesDebug) Then
SetLog("Found " & $MiscChallenges[$i][1] & " Event", $COLOR_SUCCESS)
$sEventName = "Miscellaneous Event | " & $MiscChallenges[$i][1]
Click($g_iQuickMISX + $x, $g_iQuickMISY + $y)
If _Sleep(1750) Then Return
If ClickOnEvent($YourAccScore, $ScoreLimits, $sEventName, $getCapture) Then Return
ClickP($TabChallengesPosition, 2, 0, "#Tab")
EndIf
If _Sleep(50) Then Return
If $g_bRunState = False Then Return
Next
EndIf
If $g_bChkClanGamesPurge Then
If $g_iPurgeJobCount[$g_iCurAccount] + 1 < $g_iPurgeMax Or $g_iPurgeMax = 0 Then
Local $Txt = $g_iPurgeMax
If $g_iPurgeMax = 0 Then $Txt = "Unlimited"
SetLog("Current Purge Jobs " & $g_iPurgeJobCount[$g_iCurAccount] + 1 & " at max of " & $Txt, $COLOR_INFO)
$sEventName = "Builder Base Challenges to Purge"
If PurgeEvent($g_sImgPurge, $sEventName, True) Then
$g_iPurgeJobCount[$g_iCurAccount] += 1
Else
SetLog("No Builder Base Event found to Purge", $COLOR_WARNING)
EndIf
EndIf
Return
EndIf
SetLog("No Event found, Check your settings", $COLOR_WARNING)
ClickP($aAway, 1, 0, "#0000")
If _Sleep(2000) Then Return
EndFunc
Func IsClanGamesWindow($getCapture = True)
If QuickMIS("BC1", $g_sImgCaravan, 200, 55, 300, 135, $getCapture, False) Then
SetLog("Caravan available... Entering Clan Games...", $COLOR_SUCCESS)
Click($g_iQuickMISX + 200, $g_iQuickMISY + 55)
If _Sleep(2500) Then Return
If QuickMIS("BC1", $g_sImgReward, 760, 480, 830, 570, $getCapture, $g_bChkClanGamesDebug) Then
SetLog("Your Reward is Ready", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0000")
If _Sleep(2000) Then Return
Return False
EndIf
If _ColorCheck(_GetPixelColor(384, 388, True), Hex(0xFFFFFF, 6), 5) Then
Local $sTimeRemain = getOcrTimeGameTime(380, 461)
SetLog("Clan Games will start in " & $sTimeRemain, $COLOR_INFO)
GUICtrlSetData($g_hLblRemainTime, $sTimeRemain)
GUICtrlSetState($g_hLblRemainTime, $GUI_ENABLE)
ClickP($aAway, 1, 0, "#0000")
If _Sleep(2000) Then Return
Return False
EndIf
Else
SetLog("Caravan not available...", $COLOR_WARNING)
ClickP($aAway, 1, 0, "#0000")
Return False
EndIf
If _Sleep(2000) Then Return
Return True
EndFunc
Func IsClanGamesEvent($getCapture = True)
If QuickMIS("BC1", $g_sImageBuilerGames, 20, 75, 110, 115, $getCapture, $g_bChkClanGamesDebug) Then
SetLog("Builder Games Event detected!", $COLOR_INFO)
If GUICtrlRead($g_hLblRemainTime) <> "BG Event" Then GUICtrlSetData($g_hLblRemainTime, "BG Event")
ClickP($aAway, 1, 0, "#0000")
If _Sleep(2000) Then Return
Return False
EndIf
Return True
EndFunc
Func GetTimesAndScores()
Local $rest = -1, $YourScore = "", $ScoreLimits, $sTimeRemain
$sTimeRemain = StringReplace(getOcrTimeGameTime(50, 479), " ", "")
If Not _IsValideOCR($sTimeRemain) Then
SetLog("Get Time Remain error!!!", $COLOR_WARNING)
Return -1
EndIf
SetLog("Clan Games Time Remaining: " & $sTimeRemain, $COLOR_INFO)
GUICtrlSetData($g_hLblRemainTime, $sTimeRemain)
GUICtrlSetState($g_hLblRemainTime, $GUI_ENABLE)
For $i = 0 To 10
$YourScore = getOcrYourScore(55, 533)
If $g_bChkClanGamesDebug Then SetLog("Your OCR score: " & $YourScore)
$YourScore = StringReplace($YourScore, "#", "/")
$ScoreLimits = StringSplit($YourScore, "/", $STR_NOCOUNT)
If UBound($ScoreLimits) > 1 Then
If $rest = Int($ScoreLimits[0]) Then ExitLoop
$rest = Int($ScoreLimits[0])
Else
Return -1
EndIf
If _Sleep(800) Then Return
If $i = 10 Then Return -1
Next
GUICtrlSetData($g_hLblYourScore, $YourScore)
GUICtrlSetState($g_hLblYourScore, $GUI_ENABLE)
Return $ScoreLimits
EndFunc
Func CooldownTime($getCapture = True)
If QuickMIS("BC1", $g_sImgCoolPurge, 480, 370, 570, 410, $getCapture, False) Then
SetLog("Cooldown Purge Detected", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0000")
Return True
EndIf
Return False
EndFunc
Func IsEventRunning()
If Not _ColorCheck(_GetPixelColor(304, 257, True), Hex(0x53E050, 6), 5) Then
SetLog("An Event is already in progress !", $COLOR_SUCCESS)
If $g_bChkClanGamesDebug then SetLog("[0]: " & _GetPixelColor(304, 257, True))
ClickP($aAway, 1, 0, "#0000")
Return True
Else
SetLog("No event under progress... Lets look for one...", $COLOR_INFO)
Return False
EndIf
EndFunc
Func ClickOnEvent(ByRef $YourAccScore, $ScoreLimits, $sEventName, $getCapture)
If $YourAccScore[$g_iCurAccount][1] = False Then
Local $Text = "", $color = $COLOR_SUCCESS
If $YourAccScore[$g_iCurAccount][0] <> $ScoreLimits[0] Then
$Text = "You Won " & $ScoreLimits[0] - $YourAccScore[$g_iCurAccount][0] & "pts in last Event"
Else
$Text = "You could not complete the last event!!"
$color = $COLOR_WARNING
EndIf
SetLog($Text, $color)
_FileWriteLog($g_sProfileLogsPath & "\ClanGames.log", " [" & $g_sProfileCurrentName & "] - " & $Text)
EndIf
$YourAccScore[$g_iCurAccount][1] = False
$YourAccScore[$g_iCurAccount][0] = $ScoreLimits[0]
If $g_bChkClanGamesDebug then SetLog("ClickOnEvent $YourAccScore[" & $g_iCurAccount & "][1]: " & $YourAccScore[$g_iCurAccount][1])
If $g_bChkClanGamesDebug then SetLog("ClickOnEvent $YourAccScore[" & $g_iCurAccount & "][0]: " & $YourAccScore[$g_iCurAccount][0])
If Not StartsEvent($sEventName, False, $getCapture, $g_bChkClanGamesDebug) Then Return False
ClickP($aAway, 1, 0, "#0000")
Return True
EndFunc
Func StartsEvent($sEventName, $g_bPurgeJob = False, $getCapture = True, $g_bChkClanGamesDebug = False)
If $g_bRunState = False Then Return
If QuickMIS("BC1", $g_sImgStart, 220, 150, 830, 580, $getCapture, $g_bChkClanGamesDebug) Then
Local $Timer = GetEventTimeInMinutes($g_iQuickMISX + 220, $g_iQuickMISY + 150)
SetLog("Starting  Event" & " ["& $Timer & " min]", $COLOR_SUCCESS)
Click($g_iQuickMISX + 220, $g_iQuickMISY + 150)
GUICtrlSetData($g_hTxtClanGamesLog, @CRLF & _NowDate() & " " & _NowTime() & " [" & $g_sProfileCurrentName & "] - Starting " & $sEventName & " for " & $Timer & " min", 1)
_FileWriteLog($g_sProfileLogsPath & "\ClanGames.log", " [" & $g_sProfileCurrentName & "] - Starting " & $sEventName & " for "& $Timer & " min")
If $g_bPurgeJob Then
If _Sleep(2000) Then Return
If QuickMIS("BC1", $g_sImgTrashPurge, 220, 150, 830, 580, $getCapture, $g_bChkClanGamesDebug) Then
Click($g_iQuickMISX + 220, $g_iQuickMISY + 150)
If _Sleep(1200) Then Return
SetLog("Click Trash", $COLOR_INFO)
If QuickMIS("BC1", $g_sImgOkayPurge, 440, 400, 580, 450, $getCapture, $g_bChkClanGamesDebug) Then
SetLog("Click OK", $COLOR_INFO)
Click($g_iQuickMISX + 440, $g_iQuickMISY + 400)
SetLog("Purging a job on progress !", $COLOR_SUCCESS)
GUICtrlSetData($g_hTxtClanGamesLog, @CRLF & _NowDate() & " " & _NowTime() & " [" & $g_sProfileCurrentName & "] - [" & $g_iPurgeJobCount[$g_iCurAccount] + 1 & "] - Purging Event ", 1)
_FileWriteLog($g_sProfileLogsPath & "\ClanGames.log", " [" & $g_sProfileCurrentName & "] - [" & $g_iPurgeJobCount[$g_iCurAccount] + 1 & "] - Purging Event ")
ClickP($aAway, 1, 0, "#0000")
Else
SetLog("$g_sImgOkayPurge Issue!!!", $COLOR_WARNING)
Return False
EndIf
Else
SetLog("$g_sImgTrashPurge Issue!!!", $COLOR_WARNING)
Return False
EndIf
EndIf
Return True
Else
SetLog("Didn't Get the Green Start Button Event!!", $COLOR_WARNING)
If $g_bChkClanGamesDebug Then SetLog("[X: " & 220 & " Y:" & 150 & " X1: " & 830 & " Y1: " & 580 & "]", $COLOR_WARNING)
ClickP($aAway, 1, 0, "#0000")
Return False
EndIf
EndFunc
Func PurgeEvent($directoryImage, $sEventName, $getCapture = True)
SetLog("Checking Builder Base Challenges to Purge", $COLOR_DEBUG)
Local $x = 281, $y = 150, $x1 = 775, $y1 = 545
If QuickMIS("BC1", $directoryImage, $x, $y, $x1, $y1, $getCapture, $g_bChkClanGamesDebug) Then
Click($g_iQuickMISX + $x, $g_iQuickMISY + $y)
SetLog("Starting Impossible Job to purge...", $COLOR_INFO)
If _Sleep(1500) Then Return
If StartsEvent($sEventName, True, $getCapture, $g_bChkClanGamesDebug) Then
ClickP($aAway, 1, 0, "#0000")
Return True
EndIf
EndIf
Return False
EndFunc
Func _IsValideOCR($sString)
If StringInStr($sString, "d") > 0 Or StringInStr($sString, "h") > 0 Or StringInStr($sString, "m") > 0 Or StringInStr($sString, "s") > 0 Then Return True
Return False
EndFunc
Func Ocr2Minutes($StringOCR)
If Not _IsValideOCR($StringOCR) Then Return 0
Local $temp
If StringInStr($StringOCR, "d") > 0 then
$temp = StringSplit($StringOCR, "d" , $STR_NOCOUNT)
Local $d = Int($temp[0])
Local $h = Int(StringReplace($temp[1],"h" , ""))
Return($d * 24)* 60 +($h * 60)
ElseIf StringInStr($StringOCR, "h") > 0 then
$temp = StringSplit($StringOCR, "h" , $STR_NOCOUNT)
Local $h = Int($temp[0])
Local $m = Int(StringReplace($temp[1],"m" , ""))
Return($h * 60) + $m
ElseIf StringInStr($StringOCR, "m") > 0 Then
$temp = StringSplit($StringOCR, "m" , $STR_NOCOUNT)
Return Int($temp[0])
ElseIf StringInStr($StringOCR, "s") > 0 Then
Return 1
EndIf
Return 0
EndFunc
Func GetEventTimeInMinutes($iXStartBtn , $iYStartBtn , $bIsStartBtn = True )
Local $XAxis = $iXStartBtn - 163
Local $YAxis = $iYStartBtn + 8
If Not $bIsStartBtn then
$XAxis = $iXStartBtn - 163
$YAxis = $iYStartBtn + 8
EndIf
Local $Ocr = getOcrEventTime($XAxis, $YAxis)
Return Ocr2Minutes($Ocr)
EndFunc
Func getOcrTimeGameTime($x_start, $y_start)
Return getOcrAndCapture("coc-clangames", $x_start, $y_start, 116, 31, True)
EndFunc
Func getOcrYourScore($x_start, $y_start)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 120, 18, True)
EndFunc
Func getOcrEventTime($x_start, $y_start)
Return getOcrAndCapture("coc-events", $x_start, $y_start, 80, 20, True)
EndFunc
Func ClanGamesChallenges($sReturnArray, $makeIni = False , $sINIPath = "", $debug = False)
Local $LootChallenges[6][5] = [ [$g_sImgGold, "Gold Challenge" , 7, 5, 8], [$g_sImgElixir, "Elixir Challenge" , 7, 5, 8], [$g_sImgDark, "Dark Elixir Challenge" , 8, 5, 8], [$g_sImgGoldG, "Gold Grab" , 3, 1, 1], [$g_sImgElixirE, "Elixir Embezzlement" , 3, 1, 1], [$g_sImgDarkEH, "Dark Elixir Heist" , 9, 3, 1]]
Local $AirTroopChallenges[5][4] = [ [$g_sImgMini, "Minion" , 7, 20], [$g_sImgBall, "Balloon" , 4, 12], [$g_sImgDrag, "Dragon" , 7, 6], [$g_sImgBabyD, "BabyDragon" , 9, 4], [$g_sImgLava, "Lavahound" , 9, 3]]
Local $GroundTroopChallenges[14][4] = [ [$g_sImgArch, "Archer" , 1, 30], [$g_sImgBarb, "Barbarian" , 1, 30], [$g_sImgGiant, "Giant" , 1, 10], [$g_sImgGobl, "Goblin" , 2, 20], [$g_sImgWall, "WallBreaker" , 3, 6], [$g_sImgWiza, "Wizard" , 5, 12], [$g_sImgHeal, "Healer" , 6, 3], [$g_sImgHogs, "HogRider" , 7, 10], [$g_sImgMine, "Miner" , 10, 8], [$g_sImgPekka, "Pekka" , 8, 2], [$g_sImgWitch, "Witch" , 9, 4], [$g_sImgBowl, "Bowler" , 10, 8], [$g_sImgValk, "Valkyrie" , 8, 8], [$g_sImgGole, "Golem" , 8, 2]]
Local $BattleChallenges[9][5] = [ [$g_sImgStar, "Star Collector" , 3, 1, 8], [$g_sImgLordD, "Lord of Destruction" , 3, 1, 8], [$g_sImgPileVict, "Pile Of Victories" , 3, 1, 8], [$g_sImgHunt3, "Hunt for Three Stars" , 10,5 ,8], [$g_sImgWStreak, "Winning Streak" , 9, 5, 8], [$g_sImgSlayingT, "Slaying The Titans" , 11,2, 5], [$g_sImgNoHeroics, "No Heroics Allowed" , 3 ,5, 8], [$g_sImgNoMagicZone,"No-Magic Zone" , 3 ,5, 8], [$g_sImgAttUp, "Attack Up" , 3 ,1, 8]]
Local $DestructionChallenges[28][5] = [ [$g_sImgCannon, "Cannon Carnage" , 3, 1, 1], [$g_sImgArcherT, "Archer Tower Assault" , 3, 1, 1], [$g_sImgMortar, "Mortar Mauling" , 3, 1, 1], [$g_sImgAirDef, "Destroy Air Defenses" , 7, 2, 1], [$g_sImgWizard, "Wizard Tower Warfare" , 3, 1, 1], [$g_sImgAirS, "Destroy Air Sweepers" , 8, 4, 1], [$g_sImgTesla, "Destroy Tesla Towers" , 7, 5, 1], [$g_sImgBombT, "Destroy Bomb Towers" , 8, 2, 1], [$g_sImgXBow, "Destroy X-Bows" , 9, 5, 1], [$g_sImgInferno, "Destroy Inferno Towers" , 11,5, 1], [$g_sImgEagle, "Eagle Artillery Elimination" , 11,5, 1], [$g_sImgCCC, "Clan Castle Charge" , 5, 2, 1], [$g_sImgGoldRaid, "Gold Storage Raid" , 3, 2, 1], [$g_sImgElixirR, "Elixir Storage Raid" , 3, 1, 1], [$g_sImgDESRaid, "Dark Elixir Storage Raid" , 8, 3, 1], [$g_sImgGoldMM, "Gold Mine Mayhem" , 3, 1, 1], [$g_sImgElixirPE, "Elixir Pump Elimination" , 3, 1, 1], [$g_sImgDarkEP, "Dark Elixir Plumbers" , 3, 1, 1], [$g_sImgLab, "Laboratory Strike" , 3, 1, 1], [$g_sImgSFact, "Spell Factory Sabotage" , 3, 1, 1], [$g_sImgDSFact, "Dark Spell Factory Sabotage" , 8, 1, 1], [$g_sImgBBAltar, "Destroy Barbarian King Altars" , 9, 4, 1], [$g_sImgAQAltar, "Destroy Archer Queen Altars" , 10,5, 1], [$g_sImgGWAltar, "Destroy Grand Warden Altars" , 11,5, 1], [$g_sImgHeroHunt, "Hero Level Hunter" , 9, 5, 8], [$g_sImgKingHunt, "King Level Hunter" , 9, 5, 8], [$g_sImgQueenHunt, "Queen Level Hunter" , 10,5, 8], [$g_sImgWardenHunt, "Warden Level Hunter" , 11,5, 8]]
Local $MiscChallenges[3][5] = [ [$g_sImgGard, "Gardening Exercise", 3, 1, 8], [$g_sImgDonS, "Donate Spells" , 9, 3, 8], [$g_sImgDonH, "Helping Hand" , 6, 2, 8]]
Local $LocalINI = $sINIPath
If $LocalINI = "" Then $LocalINI = StringReplace($g_sProfileConfigPath, "config.ini" , "ClanGames_config.ini")
If $debug Then Setlog(" - Ini Path: " & $LocalINI)
Local $section[4] = ["Loot Challenges", "Battle Challenges", "Destruction Challenges" , "Misc Challenges"]
Local $array[4] = [$LootChallenges, $BattleChallenges, $DestructionChallenges, $MiscChallenges]
Local $ResultIni = "" , $TempChallenge , $tempXSector
If $makeIni = False Then
Switch $sReturnArray
Case "$AirTroopChallenges"
Return $AirTroopChallenges
Case "$GroundTroopChallenges"
Return $GroundTroopChallenges
Case "$LootChallenges"
$TempChallenge = $array[0]
$tempXSector = $section[0]
Case "$BattleChallenges"
$TempChallenge = $array[1]
$tempXSector = $section[1]
Case "$DestructionChallenges"
$TempChallenge = $array[2]
$tempXSector = $section[2]
Case "$MiscChallenges"
$TempChallenge = $array[3]
$tempXSector = $section[3]
EndSwitch
If $debug then Setlog("[" & $tempXSector & "]")
For $j = 0 to Ubound($TempChallenge) - 1
$ResultIni = Int(IniRead($LocalINI, $tempXSector, $TempChallenge[$j][1], $TempChallenge[$j][3]))
$TempChallenge[$j][3] = IsNumber($ResultIni) = 1 ? Int($ResultIni) : 0
If $TempChallenge[$j][3] > 5 Then $TempChallenge[$j][3] = 5
If $TempChallenge[$j][3] < 0 Then $TempChallenge[$j][3] = 0
If $debug Then Setlog(" - " & $TempChallenge[$j][1] & ": " & $TempChallenge[$j][3])
If $TempChallenge[$j][3] = 0 And not $debug then Setlog(" - " & $TempChallenge[$j][1] & " was disabled by INI file.")
$ResultIni = ""
Next
Return $TempChallenge
Else
Local $File = FileOpen($LocalINI, $FO_APPEND)
Local $HelpText = "; - MyBotRun 2018 - " & @CRLF & "; - 'Event name' = 'Priority' [1~5][easiest to the hardest] , '0' to disable the event" & @CRLF & "; - Remember on GUI you can enable/disable an entire Section" & @CRLF & "; - Do not change any event name" & @CRLF & "; - Deleting this file will restore the defaults values."& @CRLF & @CRLF
FileWrite($File, $HelpText)
FileClose($File)
For $i = 0 To UBound($array) -1
$TempChallenge = $array[$i]
If $debug Then Setlog("[" & $section[$i] & "]")
For $j = 0 to UBound($TempChallenge) -1
If IniWrite($LocalINI, $section[$i], $TempChallenge[$j][1], $TempChallenge[$j][3]) <> 1 Then SetLog("Error on :" & $section[$i] & "|" & $TempChallenge[$j][1], $COLOR_WARNING)
If $debug Then Setlog(" - " & $TempChallenge[$j][1] & ": " & $TempChallenge[$j][3])
If _sleep(100) Then Return
Next
$TempChallenge = Null
Next
EndIf
EndFunc
Func CollectFreeMagicItems($bTest = False)
If Not $g_bChkCollectFreeMagicItems Then Return
If Not $g_bRunState Then Return
Local Static $iLastTimeChecked = 0
If $iLastTimeChecked = @MDAY Then Return
ClickP($aAway, 1, 0, "#0332")
If Not IsMainPage() Then Return
SetLog("Collecting Free Magic Items", $COLOR_INFO)
If _Sleep($DELAYCOLLECT2) Then Return
If QuickMIS("BC1", $g_sImgTrader, 120, 160, 210, 215, True, False) Then
SetLog("Trader available, Entering Daily Discounts", $COLOR_SUCCESS)
Click($g_iQuickMISX + 120, $g_iQuickMISY + 160)
If _Sleep(1500) Then Return
Else
SetLog("Trader unvailable", $COLOR_INFO)
Return
EndIf
If Not QuickMIS("BC1", $g_sImgDailyDiscountWindow, 280, 175, 345, 210, True, False) Then
ClickP($aAway, 1, 0, "#0332")
Return
EndIf
If Not $g_bRunState Then Return
Local $aOcrPositions[3][2] = [[200, 439], [390, 439], [580, 439]]
Local $aResults[3] = ["", "", ""]
$iLastTimeChecked = @MDAY
For $i = 0 To 2
$aResults[$i] = getOcrAndCapture("coc-freemagicitems", $aOcrPositions[$i][0], $aOcrPositions[$i][1], 80, 25, True)
If $aResults[$i] <> "" Then
If Not $bTest Then
If $aResults[$i] = "FREE" Then
Click($aOcrPositions[$i][0], $aOcrPositions[$i][1], 2, 500)
SetLog("Free Magic Item detected", $COLOR_INFO)
ClickP($aAway, 2, 0, "#0332")
If _Sleep(1000) Then Return
Return
Else
If _ColorCheck(_GetPixelColor($aOcrPositions[$i][0], $aOcrPositions[$i][1] + 5, True), Hex(0x5D79C5, 6), 5) Then
$aResults[$i] = $aResults[$i] & " Gems"
Else
$aResults[$i] = Int($aResults[$i]) > 0 ? "No Space In Castle" : "Collected"
EndIf
EndIf
EndIf
EndIf
If Not $g_bRunState Then Return
Next
SetLog("Daily Discounts: " & $aResults[0] & " | " & $aResults[1] & " | " & $aResults[2])
SetLog("Nothing free to collect!", $COLOR_INFO)
ClickP($aAway, 2, 0, "#0332")
If _Sleep(1000) Then Return
EndFunc
Func CollectBuilderBase($bSwitchToBB = False, $bSwitchToNV = False)
If Not $g_bChkCollectBuilderBase Then Return
If Not $g_bRunState Then Return
If $bSwitchToBB Then
ClickP($aAway, 1, 0, "#0332")
If Not SwitchBetweenBases() Then Return
EndIf
SetLog("Collecting Resources on Builders Base", $COLOR_INFO)
If _Sleep($DELAYCOLLECT2) Then Return
Local $sFilename = ""
Local $aCollectXY, $t
Local $aResult = multiMatches($g_sImgCollectRessourcesBB, 0, "FV", "FV")
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
$sFilename = $aResult[$i][1]
$aCollectXY = $aResult[$i][5]
If IsArray($aCollectXY) Then
$t = Random(0, UBound($aCollectXY) - 1, 1)
If $g_bDebugSetlog Then SetDebugLog($sFilename & " found, random pick(" & $aCollectXY[$t][0] & "," & $aCollectXY[$t][1] & ")", $COLOR_SUCCESS)
If IsMainPageBuilderBase() Then Click($aCollectXY[$t][0], $aCollectXY[$t][1], 1, 0, "#0430")
If _Sleep($DELAYCOLLECT2) Then Return
EndIf
Next
EndIf
If _Sleep($DELAYCOLLECT3) Then Return
If $bSwitchToNV Then SwitchBetweenBases()
EndFunc
Func StartClockTowerBoost($bSwitchToBB = False, $bSwitchToNV = False)
If Not $g_bChkStartClockTowerBoost Then Return
If Not $g_bRunState Then Return
If $bSwitchToBB Then
ClickP($aAway, 1, 0, "#0332")
If Not SwitchBetweenBases() Then Return
EndIf
Local $bCTBoost = True
If $g_bChkCTBoostBlderBz Then
getBuilderCount(True, True)
If $g_iFreeBuilderCountBB = $g_iTotalBuilderCountBB Then $bCTBoost = False
EndIf
If Not $bCTBoost Then
SetLog("Skip Clock Tower Boost as no Building is currently under Upgrade!", $COLOR_INFO)
Else
SetLog("Boosting Clock Tower", $COLOR_INFO)
If _Sleep($DELAYCOLLECT2) Then Return
Local $sCTCoords, $aCTCoords, $aCTBoost
$sCTCoords = findImage("ClockTowerAvailable", $g_sImgStartCTBoost, "FV", 1, True)
If $sCTCoords <> "" Then
$aCTCoords = StringSplit($sCTCoords, ",", $STR_NOCOUNT)
ClickP($aCTCoords)
If _Sleep($DELAYCLOCKTOWER1) Then Return
$aCTBoost = findButton("BoostCT")
If IsArray($aCTBoost) Then
ClickP($aCTBoost)
If _Sleep($DELAYCLOCKTOWER1) Then Return
$aCTBoost = findButton("BOOSTBtn")
If IsArray($aCTBoost) Then
ClickP($aCTBoost)
If _Sleep($DELAYCLOCKTOWER2) Then Return
SetLog("Boosted Clock Tower successfully!", $COLOR_SUCCESS)
Else
SetLog("Failed to find the BOOST window button", $COLOR_ERROR)
EndIf
Else
SetLog("Cannot find the Boost Button of Clock Tower", $COLOR_ERROR)
EndIf
Else
SetLog("Clock Tower boost is not available!")
EndIf
EndIf
ClickP($aAway, 1, 0, "#0329")
If $bSwitchToNV Then SwitchBetweenBases()
EndFunc
Func BuilderBaseReport($bBypass = False, $bSetLog = True)
PureClickP($aAway, 1, 0, "#0319")
If _Sleep($DELAYVILLAGEREPORT1) Then Return
Switch $bBypass
Case False
If $bSetLog Then SetLog("Builder Base Report", $COLOR_INFO)
Case True
If $bSetLog Then SetLog("Updating Builder Base Resource Values", $COLOR_INFO)
Case Else
If $bSetLog Then SetLog("Village Report Error, You have been a BAD programmer!", $COLOR_ERROR)
EndSwitch
If Not $bSetLog Then SetLog("Village Report", $COLOR_INFO)
getBuilderCount($bSetLog, True)
If _Sleep($DELAYRESPOND) Then Return
$g_aiCurrentLootBB[$eLootTrophyBB] = getTrophyMainScreen(67, 84)
$g_aiCurrentLootBB[$eLootGoldBB] = getResourcesMainScreen(705, 23)
$g_aiCurrentLootBB[$eLootElixirBB] = getResourcesMainScreen(705, 72)
If $bSetLog Then SetLog(" [G]: " & _NumberFormat($g_aiCurrentLootBB[$eLootGoldBB]) & " [E]: " & _NumberFormat($g_aiCurrentLootBB[$eLootElixirBB]) & "[T]: " & _NumberFormat($g_aiCurrentLootBB[$eLootTrophyBB]), $COLOR_SUCCESS)
If Not $bBypass Then
UpdateStats()
EndIf
EndFunc
Func chkActivateBBSuggestedUpgrades()
If GUICtrlRead($g_hChkBBSuggestedUpgrades) = $GUI_CHECKED Then
$g_iChkBBSuggestedUpgrades = 1
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreGold, $GUI_ENABLE)
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreElixir, $GUI_ENABLE)
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreHall, $GUI_ENABLE)
GUICtrlSetState($g_hChkPlacingNewBuildings, $GUI_ENABLE)
Else
$g_iChkBBSuggestedUpgrades = 0
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreGold, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreElixir, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreHall, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
GUICtrlSetState($g_hChkPlacingNewBuildings, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
EndIf
EndFunc
Func chkActivateBBSuggestedUpgradesGold()
If $g_iChkBBSuggestedUpgrades = 0 Then Return
$g_iChkBBSuggestedUpgradesIgnoreGold =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreGold) = $GUI_CHECKED) ? 1 : 0
If $g_iChkBBSuggestedUpgradesIgnoreGold = 0 Then
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreElixir, $GUI_ENABLE)
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreHall, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreElixir, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreHall, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
EndIf
$g_iChkBBSuggestedUpgradesIgnoreHall =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreHall) = $GUI_CHECKED) ? 1 : 0
$g_iChkBBSuggestedUpgradesIgnoreElixir =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreElixir) = $GUI_CHECKED) ? 1 : 0
EndFunc
Func chkActivateBBSuggestedUpgradesElixir()
If $g_iChkBBSuggestedUpgrades = 0 Then Return
$g_iChkBBSuggestedUpgradesIgnoreElixir =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreElixir) = $GUI_CHECKED) ? 1 : 0
If $g_iChkBBSuggestedUpgradesIgnoreElixir = 0 Then
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreGold, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreGold, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
EndIf
$g_iChkBBSuggestedUpgradesIgnoreGold =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreGold) = $GUI_CHECKED) ? 1 : 0
EndFunc
Func chkPlacingNewBuildings()
$g_iChkPlacingNewBuildings =(GUICtrlRead($g_hChkPlacingNewBuildings) = $GUI_CHECKED) ? 1 : 0
EndFunc
Func MainSuggestedUpgradeCode()
If $g_iChkBBSuggestedUpgrades = 0 Then Return
Local $bDebug = False
Local $bScreencap = True
If isOnBuilderBase(True) Then
If ClickOnBuilder() Then
SetLog(" - Upg Window Opened successfully", $COLOR_INFO)
Local $y = 102, $y1 = 132, $step = 30, $x = 400, $x1 = 540
For $i = 0 To 2
Local $bSkipGoldCheck = False
If $g_iChkBBSuggestedUpgradesIgnoreElixir = 0 And $g_aiCurrentLootBB[$eLootElixirBB] > 250 Then
Local $aResult = GetIconPosition($x, $y, $x1, $y1, $g_sImgAutoUpgradeElixir, "Elixir", $bScreencap, $bDebug)
Switch $aResult[2]
Case "Elixir"
Click($aResult[0], $aResult[1], 1)
If _Sleep(2000) Then Return
If GetUpgradeButton($aResult[2], $bDebug) Then
ExitLoop
EndIf
$bSkipGoldCheck = True
Case "New"
If $g_iChkPlacingNewBuildings = 1 Then
SetLog("[" & $i + 1 & "]" & " New Building detected, Placing it...", $COLOR_INFO)
If NewBuildings($aResult) Then
ExitLoop
EndIf
$bSkipGoldCheck = True
EndIf
Case "NoResources"
SetLog("[" & $i + 1 & "]" & " Not enough Elixir, continuing...", $COLOR_INFO)
$bSkipGoldCheck = True
Case Else
EndSwitch
EndIf
If $g_iChkBBSuggestedUpgradesIgnoreGold = 0 And $g_aiCurrentLootBB[$eLootGoldBB] > 250 And Not $bSkipGoldCheck Then
Local $aResult = GetIconPosition($x, $y, $x1, $y1, $g_sImgAutoUpgradeGold, "Gold", $bScreencap, $bDebug)
Switch $aResult[2]
Case "Gold"
Click($aResult[0], $aResult[1], 1)
If _Sleep(2000) Then Return
If GetUpgradeButton($aResult[2], $bDebug) Then
ExitLoop
EndIf
Case "New"
If $g_iChkPlacingNewBuildings = 1 Then
SetLog("[" & $i + 1 & "]" & " New Building detected, Placing it...", $COLOR_INFO)
If NewBuildings($aResult) Then
ExitLoop
EndIf
EndIf
Case "NoResources"
SetLog("[" & $i + 1 & "]" & " Not enough Gold, continuing...", $COLOR_INFO)
Case Else
EndSwitch
EndIf
$y += $step
$y1 += $step
Next
EndIf
EndIf
ClickP($aAway, 1, 0, "#0121")
EndFunc
Func ClickOnBuilder()
Local Const $aMasterBuilder[4] = [360, 11, 0x7cbdde, 10]
Local $sDebugText = ""
Local Const $Debug = False
Local Const $Screencap = True
If $g_iFreeBuilderCountBB = 0 Then SetLog("No Master Builder available! [" & $g_iFreeBuilderCountBB & "/" & $g_iTotalBuilderCountBB & "]", $COLOR_INFO)
If $g_iFreeBuilderCountBB > 0 Then
If _CheckPixel($aMasterBuilder, True) Then
Click($aMasterBuilder[0], $aMasterBuilder[1], 1)
If _Sleep(2000) Then Return
If QuickMIS("BC1", $g_sImgAutoUpgradeWindow, 330, 85, 550, 145, $Screencap, $Debug) Then
Return True
Else
$sDebugText = "Window didn't opened"
EndIf
Else
$sDebugText = "BB Pixel problem"
EndIf
EndIf
If $sDebugText <> "" Then SetLog("Problem on Suggested Upg Window: [" & $sDebugText & "]", $COLOR_ERROR)
Return False
EndFunc
Func GetIconPosition($x, $y, $x1, $y1, $directory, $Name = "Elixir", $Screencap = True, $Debug = False)
Local $aResult[3] = [-1, -1, ""]
If QuickMIS("BC1", $directory, $x, $y, $x1, $y1, $Screencap, $Debug) Then
Local $iYoffset = $y + $g_iQuickMISY - 15, $iY1offset = $y + $g_iQuickMISY + 7
Local $iX = 300, $iX1 = $g_iQuickMISX + $x
$aResult[0] = $g_iQuickMISX + $x
$aResult[1] = $g_iQuickMISY + $y
$aResult[2] = $Name
If QuickMIS("BC1", $g_sImgAutoUpgradeNoRes, $aResult[0], $iYoffset, $aResult[0] + 100, $iY1offset, True, $Debug) Then
$aResult[2] = "NoResources"
Return $aResult
EndIf
If QuickMIS("BC1", $g_sImgAutoUpgradeNew, $iX, $iYoffset, $iX1, $iY1offset, True, $Debug) Then
$aResult[0] = $g_iQuickMISX + $iX + 35
$aResult[1] = $g_iQuickMISY + $iYoffset
$aResult[2] = "New"
EndIf
EndIf
Return $aResult
EndFunc
Func GetUpgradeButton($sUpgButtom = "", $Debug = False)
Local $aBtnPos = [360, 460, 380, 120]
If $sUpgButtom = "" Then Return
If $sUpgButtom = "Elixir" Then $sUpgButtom = $g_sImgAutoUpgradeBtnElixir
If $sUpgButtom = "Gold" Then $sUpgButtom = $g_sImgAutoUpgradeBtnGold
If QuickMIS("BC1", $g_sImgAutoUpgradeBtnDir, 300, 650, 600, 720, True, $Debug) Then
Local $sBuildingName = getNameBuilding(242, 584)
If _Sleep(500) Then Return
SetLog("Building: " & $sBuildingName, $COLOR_INFO)
If StringInStr($sBuildingName, "Hall") > 0 And $g_iChkBBSuggestedUpgradesIgnoreHall Then
SetLog("Ups! Builder Hall is not to Upgrade!", $COLOR_ERROR)
Return False
EndIf
Click($g_iQuickMISX + 300, $g_iQuickMISY + 650, 1)
If _Sleep(1500) Then Return
If QuickMIS("BC1", $sUpgButtom, $aBtnPos[0], $aBtnPos[1], $aBtnPos[0] + $aBtnPos[2], $aBtnPos[1] + $aBtnPos[3], True, $Debug) Then
Click($g_iQuickMISX + $aBtnPos[0], $g_iQuickMISY + $aBtnPos[1], 1)
SetLog($sBuildingName & " Upgrading!", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0121")
Return True
Else
ClickP($aAway, 1, 0, "#0121")
SetLog("Not enough Resources to Upgrade " & $sBuildingName & " !", $COLOR_ERROR)
EndIf
EndIf
Return False
EndFunc
Func NewBuildings($aResult)
Local $Screencap = True, $Debug = False
If UBound($aResult) = 3 And $aResult[2] = "New" Then
Click($aResult[0], $aResult[1], 1)
If _Sleep(3000) Then Return
Local $ClocksCoordinates = QuickMIS("CX", $g_sImgAutoUpgradeClock, 20, 250, 775, 530, $Screencap, $Debug)
If UBound($ClocksCoordinates) > 0 Then
SetLog("[Clocks]: " & UBound($ClocksCoordinates), $COLOR_DEBUG)
For $i = 0 To UBound($ClocksCoordinates) - 1
Local $Coordinates = StringSplit($ClocksCoordinates[$i], ",", 2)
If UBound($Coordinates) <> 2 Then
Click(820, 38, 1)
ExitLoop
EndIf
Local $x =($Coordinates[0] + 20), $y =($Coordinates[1] + 250) - 135, $x1 =($Coordinates[0] + 20) + 220, $y1 =($Coordinates[1] + 250) + 52
If $g_bDebugSetlog Then SetDebugLog("[x]: " & $x & " [y]: " & $y & " [x1]: " & $x1 & " [y1]: " & $y1, $COLOR_DEBUG)
If QuickMIS("BC1", $g_sImgAutoUpgradeZero, $x, $y, $x1, $y1, $Screencap, $Debug) Then
If Not QuickMIS("BC1", $g_sImgAutoUpgradeInfo, $x, $y, $x1, $y1, $Screencap, $Debug) Then
Click($x + 100, $y + 50, 1)
If _Sleep(3000) Then Return
If QuickMIS("BC1", $g_sImgAutoUpgradeNewBldgYes, 150, 150, 650, 550, $Screencap, $Debug) Then
Click($g_iQuickMISX + 150, $g_iQuickMISY + 150, 1)
SetLog("Placed a new Building on Builder Island! [" & $g_iQuickMISX + 150 & "," & $g_iQuickMISY + 150 & "]", $COLOR_INFO)
If _Sleep(1000) Then Return
If QuickMIS("BC1", $g_sImgAutoUpgradeNewBldgNo, 150, 150, 650, 550, $Screencap, $Debug) Then
Click($g_iQuickMISX + 150, $g_iQuickMISY + 150, 1)
EndIf
Return True
Else
If QuickMIS("BC1", $g_sImgAutoUpgradeNewBldgNo, 150, 150, 650, 550, $Screencap, $Debug) Then
SetLog("Sorry! Wrong place to deploy a new building on BB! [" & $g_iQuickMISX + 150 & "," & $g_iQuickMISY + 150 & "]", $COLOR_ERROR)
Click($g_iQuickMISX + 150, $g_iQuickMISY + 150, 1)
Else
SetLog("Error on Undo symbol!", $COLOR_ERROR)
EndIf
EndIf
Else
If $i = UBound($ClocksCoordinates) - 1 Then
If $g_bDebugSetlog Then SetDebugLog("Slot without enough resources![1]", $COLOR_DEBUG)
Click(820, 38, 1)
ExitLoop
EndIf
ContinueLoop
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("Slot without enough resources![2]", $COLOR_DEBUG)
If $i = UBound($ClocksCoordinates) - 1 Then Click(820, 38, 1)
EndIf
Next
Else
SetLog("Slot without enough resources![3]", $COLOR_INFO)
Click(820, 38, 1)
EndIf
EndIf
Return False
EndFunc
Global $tagSTRUCT_BOT_STATE = "struct" & ";hwnd BotHWnd" & ";hwnd AndroidHWnd" & ";boolean RunState" & ";boolean Paused" & ";boolean Launched" & ";uint64 g_hTimerSinceStarted" & ";uint g_iTimePassed" & ";char Profile[64]" & ";char AndroidEmulator[32]" & ";char AndroidInstance[32]" & ";int StructType" & ";ptr StructPtr" & ";boolean RegisterInHost" & ";endstruct"
Global Enum $g_eSTRUCT_NONE = 0, $g_eSTRUCT_STATUS_BAR, $g_eSTRUCT_UPDATE_STATS
Global $tagSTRUCT_STATUS_BAR = "struct;char Text[255];endstruct"
Global $tagSTRUCT_UPDATE_STATS = "struct" & ";long g_aiCurrentLoot[" & UBound($g_aiCurrentLoot) & "]" & ";long g_iFreeBuilderCount" & ";long g_iTotalBuilderCount" & ";long g_iGemAmount" & ";long g_iStatsTotalGain[" & UBound($g_iStatsTotalGain) & "]" & ";long g_iStatsLastAttack[" & UBound($g_iStatsLastAttack) & "]" & ";long g_iStatsBonusLast[" & UBound($g_iStatsBonusLast) & "]" & ";int g_iFirstAttack" & ";int g_aiAttackedCount" & ";int g_iSkippedVillageCount" & ";endstruct"
Global $tBotState = DllStructCreate($tagSTRUCT_BOT_STATE)
Global $tStatusBar = DllStructCreate($tagSTRUCT_STATUS_BAR)
Global $tUpdateStats = DllStructCreate($tagSTRUCT_UPDATE_STATS)
Global $API_VERSION = "1.1"
Global $sWatchdogMutex = "MyBot.run/ManageFarm/" & $API_VERSION
Global $WM_MYBOTRUN_API = _WinAPI_RegisterWindowMessage("MyBot.run/API/" & $API_VERSION)
SetDebugLog("MyBot.run/API/1.1 Message ID = " & $WM_MYBOTRUN_API)
Global $WM_MYBOTRUN_STATE = _WinAPI_RegisterWindowMessage("MyBot.run/STATE/" & $API_VERSION)
SetDebugLog("MyBot.run/STATE/1.1 Message ID = " & $WM_MYBOTRUN_STATE)
Func _DllStructSetData(ByRef $Struct, $Element, $value, $index = Default)
If IsArray($value) Then
Local $Result[UBound($value)]
For $i = 0 To UBound($value) - 1
$Result[$i] = DllStructSetData($Struct, $Element, $value[$i], $i + 1)
Next
Return $Result
Else
Return DllStructSetData($Struct, $Element, $value, $index)
EndIf
EndFunc
Global $g_ahManagedMyBotHosts[0]
GUIRegisterMsg($WM_MYBOTRUN_API, "WM_MYBOTRUN_API_CLIENT")
Func WM_MYBOTRUN_API_CLIENT($hWind, $iMsg, $wParam, $lParam)
If $hWind <> $g_hFrmBot Then Return 0
If $g_iDebugWindowMessages Then SetDebugLog("API-CLIENT: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam)
$hWind = HWnd($lParam)
Local $wParamHi = 0
If $g_bRunState = True Then $wParamHi += 1
If $g_bBotPaused = True Then $wParamHi += 2
If IsBotLaunched() Then $wParamHi += 4
Local $wParamLo = BitAND($wParam, 0xFFFF)
Local $bRegisterHost = True
Switch $wParamLo
Case 0x0000 To 0x00FF
$lParam = $g_hFrmBot
Local $iActiveBots = BitAND($wParam, 0xFF)
If $iActiveBots < 255 Then
If $g_BotInstanceCount <> $iActiveBots Then SetDebugLog($iActiveBots & " running bot instances detected")
$g_BotInstanceCount = $iActiveBots
Else
$bRegisterHost = False
EndIf
$wParam = 1
$wParamHi = 0
If $g_bRunState = True Then $wParamHi += 1
If $g_bBotPaused = True Then $wParamHi += 2
If IsBotLaunched() Then $wParamHi += 4
$wParam += BitShift($wParamHi, -16)
Case 0x0100 To 0x01FF
Local $iActiveBots = BitAND($wParam, 0xFF)
If $iActiveBots < 255 Then
If $g_BotInstanceCount <> $iActiveBots Then SetDebugLog($iActiveBots & " running bot instances detected")
$g_BotInstanceCount = $iActiveBots
EndIf
$iMsg = $WM_MYBOTRUN_STATE
$lParam = $g_hFrmBot
$wParam = DllStructGetPtr($tBotState)
$bRegisterHost = $wParamLo < 0x01FF
PrepareStructBotState($tBotState, Default, Default, $bRegisterHost)
Case 0x0200
If $g_iFirstRun = 0 Then
PrepareUpdateStatsManagedMyBotHost($hWind, $iMsg, $wParam, $lParam)
Else
$iMsg = $WM_MYBOTRUN_STATE
$lParam = $g_hFrmBot
$wParam = DllStructGetPtr($tBotState)
PrepareStructBotState($tBotState)
EndIf
Case 0x1000
$lParam = $g_hFrmBot
$wParam = $wParamLo + 1
If $g_bRunState = False Then
$wParamHi = 1
If IsBotLaunched() Then $wParamHi += 4
btnStart()
EndIf
$wParam += BitShift($wParamHi, -16)
Case 0x1010
$lParam = $g_hFrmBot
$wParam = $wParamLo + 1
If $g_bRunState = True Then
$wParamHi = 0
If IsBotLaunched() Then $wParamHi += 4
btnStop()
EndIf
$wParam += BitShift($wParamHi, -16)
Case 0x1020
$lParam = $g_hFrmBot
$wParam = $wParamLo + 1
If $g_bBotPaused = True And $g_bRunState = True Then
$wParamHi = 0
If $g_bRunState = True Then $wParamHi += 1
If IsBotLaunched() Then $wParamHi += 4
TogglePauseImpl("ManageFarm")
EndIf
$wParam += BitShift($wParamHi, -16)
Case 0x1030
$lParam = $g_hFrmBot
$wParam = $wParamLo + 1
If $g_bBotPaused = False And $g_bRunState = True Then
$wParamHi = 2
If $g_bRunState = True Then $wParamHi += 1
If IsBotLaunched() Then $wParamHi += 4
TogglePauseImpl("ManageFarm", True)
EndIf
$wParam += BitShift($wParamHi, -16)
Case 0x1040
$lParam = $g_hFrmBot
$wParam = $wParamLo + 1
$wParamHi = 0
BotCloseRequest()
$wParam += BitShift($wParamHi, -16)
Case 0x1050
$lParam = $g_hFrmBot
$wParam = $wParamLo + 1
$wParamHi = 0
If $g_bRunState = True Then $wParamHi += 1
If $g_bBotPaused = True Then $wParamHi += 2
If IsBotLaunched() Then $wParamHi += 4
btnMakeScreenshot()
$wParam += BitShift($wParamHi, -16)
Case 0x1060
$lParam = $g_hFrmBot
$wParam = $wParamLo + 1
$wParamHi = 0
If $g_bRunState = True Then $wParamHi += 1
If $g_bBotPaused = True Then $wParamHi += 2
If IsBotLaunched() Then $wParamHi += 4
Local $pid = WinGetProcess($hWind)
If $pid <> 0 And $pid <> -1 Then
$g_iGuiPID = $pid
SetBotGuiPID($pid)
EndIf
$wParam += BitShift($wParamHi, -16)
Case Else
$hWind = 0
EndSwitch
If Not IsBotLaunched() Then
$hWind = 0
EndIf
If $hWind <> 0 Then
Local $a = GetManagedMyBotHost($hWind, True, $bRegisterHost)
_WinAPI_PostMessage($hWind, $iMsg, $wParam, $lParam)
EndIf
Return 1
EndFunc
Func GetManagedMyBotHost($hFrmHost = Default, $bUpdateTime = False, $bRegisterHost = True)
If $hFrmHost = Default Then
Return $g_ahManagedMyBotHosts
EndIf
If IsHWnd($hFrmHost) = 0 Then Return -1
For $i = 0 To UBound($g_ahManagedMyBotHosts) - 1
Local $a = $g_ahManagedMyBotHosts[$i]
If $a[0] = $hFrmHost Then
If $bUpdateTime Then
$a[1] = __TimerInit()
$g_ahManagedMyBotHosts[$i] = $a
EndIf
Return $a
EndIf
Next
Local $a[2]
$a[0] = $hFrmHost
If $bUpdateTime Then $a[1] = __TimerInit()
If $bRegisterHost Then
Local $i = UBound($g_ahManagedMyBotHosts)
ReDim $g_ahManagedMyBotHosts[$i + 1]
$g_ahManagedMyBotHosts[$i] = $a
SetDebugLog("New Bot Host Window Handle registered: " & $hFrmHost)
EndIf
Return $a
EndFunc
Func LaunchWatchdog()
Local $hMutex = CreateMutex($sWatchdogMutex)
If $hMutex = 0 Then
SetDebugLog("Watchdog already running")
Return 0
EndIf
ReleaseMutex($hMutex)
Local $cmd = """" & @ScriptDir & "\MyBot.run.Watchdog.exe"""
If @Compiled = 0 Then $cmd = """" & @AutoItExe & """ /AutoIt3ExecuteScript """ & @ScriptDir & "\MyBot.run.Watchdog.au3" & """"
If $g_iBotLaunchOption_Console Then $cmd &= " /console"
Local $pid = Run($cmd, @ScriptDir)
If $pid = 0 Then
SetLog("Cannot launch watchdog", $COLOR_RED)
Return 0
EndIf
If $g_bDebugSetlog Then
SetDebugLog("Watchdog launched, PID = " & $pid)
Else
SetLog("Watchdog launched")
EndIf
Return $pid
EndFunc
Func PrepareStructBotState(ByRef $tBotState, $eStructType = Default, $pStructPtr = Default, $bRegisterInHost = True)
If $eStructType = Default Then $eStructType = $g_eSTRUCT_NONE
If $pStructPtr = Default Then $pStructPtr = 0
DllStructSetData($tBotState, "BotHWnd", $g_hFrmBot)
DllStructSetData($tBotState, "AndroidHWnd", $g_hAndroidWindow)
DllStructSetData($tBotState, "RunState", $g_bRunState)
DllStructSetData($tBotState, "Paused", $g_bBotPaused)
DllStructSetData($tBotState, "Launched", IsBotLaunched())
DllStructSetData($tBotState, "g_hTimerSinceStarted", $g_hTimerSinceStarted)
DllStructSetData($tBotState, "g_iTimePassed", $g_iTimePassed)
DllStructSetData($tBotState, "Profile", $g_sProfileCurrentName)
DllStructSetData($tBotState, "AndroidEmulator", $g_sAndroidEmulator)
DllStructSetData($tBotState, "AndroidInstance", $g_sAndroidInstance)
DllStructSetData($tBotState, "StructType", $eStructType)
DllStructSetData($tBotState, "StructPtr", $pStructPtr)
DllStructSetData($tBotState, "RegisterInHost", $bRegisterInHost)
EndFunc
Func PrepareStatusBarManagedMyBotHost($hFrmHost, ByRef $iMsg, ByRef $wParam, ByRef $lParam, $sStatusBar)
$iMsg = $WM_MYBOTRUN_STATE
$lParam = $g_hFrmBot
$wParam = DllStructGetPtr($tBotState)
DllStructSetData($tStatusBar, "Text", $sStatusBar)
PrepareStructBotState($tBotState, $g_eSTRUCT_STATUS_BAR, DllStructGetPtr($tStatusBar))
If $g_iDebugWindowMessages Then SetDebugLog("PrepareStatusBarManagedMyBotHost: $hFrmHost=" & $hFrmHost & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam & ",$sStatusBar=" & $sStatusBar)
Return True
EndFunc
Func StatusBarManagedMyBotHost($sStatusBar)
Return ManagedMyBotHostsPostMessage("PrepareStatusBarManagedMyBotHost", $sStatusBar)
EndFunc
Func PrepareUpdateStatsManagedMyBotHost($hFrmHost, ByRef $iMsg, ByRef $wParam, ByRef $lParam)
$iMsg = $WM_MYBOTRUN_STATE
$lParam = $g_hFrmBot
$wParam = DllStructGetPtr($tBotState)
_DllStructSetData($tUpdateStats, "g_aiCurrentLoot", $g_aiCurrentLoot)
_DllStructSetData($tUpdateStats, "g_iFreeBuilderCount", $g_iFreeBuilderCount)
_DllStructSetData($tUpdateStats, "g_iTotalBuilderCount", $g_iTotalBuilderCount)
_DllStructSetData($tUpdateStats, "g_iGemAmount", $g_iGemAmount)
_DllStructSetData($tUpdateStats, "g_iStatsTotalGain", $g_iStatsTotalGain)
_DllStructSetData($tUpdateStats, "g_iStatsLastAttack", $g_iStatsLastAttack)
_DllStructSetData($tUpdateStats, "g_iStatsBonusLast", $g_iStatsBonusLast)
_DllStructSetData($tUpdateStats, "g_iFirstAttack", $g_iFirstAttack)
_DllStructSetData($tUpdateStats, "g_aiAttackedCount", $g_aiAttackedCount)
_DllStructSetData($tUpdateStats, "g_iSkippedVillageCount", $g_iSkippedVillageCount)
PrepareStructBotState($tBotState, $g_eSTRUCT_UPDATE_STATS, DllStructGetPtr($tUpdateStats))
If $g_iDebugWindowMessages Then SetDebugLog("PrepareUpdateStatsManagedMyBotHost: $hFrmHost=" & $hFrmHost & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam)
Return True
EndFunc
Func UpdateStatsManagedMyBotHost()
Return ManagedMyBotHostsPostMessage("PrepareUpdateStatsManagedMyBotHost")
EndFunc
Func PrepareUnregisterManagedMyBotHost($hFrmHost, ByRef $iMsg, ByRef $wParam, ByRef $lParam)
$wParam = 0x1040 + 2
SetDebugLog("Bot Host Window Handle un-registered: " & $hFrmHost)
Return True
EndFunc
Func UnregisterManagedMyBotHost()
Local $Result = ManagedMyBotHostsPostMessage("PrepareUnregisterManagedMyBotHost")
ReDim $g_ahManagedMyBotHosts[0]
Return $Result
EndFunc
Func ManagedMyBotHostsPostMessage($sExecutePrepare, $Value1 = Default, $Value2 = Default, $Value3 = Default)
Local $sAdditional = ""
If $Value1 <> Default Or $Value2 <> Default Or $Value3 <> Default Then
If $Value3 <> Default Then
$sAdditional = ", $Value3"
EndIf
If $Value2 <> Default Then
$sAdditional = ", $Value2" & $sAdditional
ElseIf $sAdditional <> "" Then
$sAdditional = ", Default" & $sAdditional
EndIf
If $Value1 <> Default Then
$sAdditional = ", $Value1" & $sAdditional
ElseIf $sAdditional <> "" Then
$sAdditional = ", Default" & $sAdditional
EndIf
EndIf
For $i = 0 To UBound($g_ahManagedMyBotHosts) - 1
Local $a = $g_ahManagedMyBotHosts[$i]
Local $hFrmHost = $a[0]
$g_ahManagedMyBotHosts[$i] = $a
If IsHWnd($hFrmHost) Then
Local $iMsg = $WM_MYBOTRUN_API
Local $wParam = 0x0000
Local $lParam = $g_hFrmBot
Local $sExecute = $sExecutePrepare & "($hFrmHost, $iMsg, $wParam, $lParam" & $sAdditional & ")"
Local $bPostMessage
Switch $sExecutePrepare
Case "PrepareStatusBarManagedMyBotHost"
$bPostMessage = PrepareStatusBarManagedMyBotHost($hFrmHost, $iMsg, $wParam, $lParam, $Value1)
Case "PrepareUpdateStatsManagedMyBotHost"
$bPostMessage = PrepareUpdateStatsManagedMyBotHost($hFrmHost, $iMsg, $wParam, $lParam)
Case "PrepareUnregisterManagedMyBotHost"
$bPostMessage = PrepareUnregisterManagedMyBotHost($hFrmHost, $iMsg, $wParam, $lParam)
Case Else
$bPostMessage = Execute($sExecute)
EndSwitch
If @error <> 0 And $bPostMessage = "" Then
SetDebugLog("ManagedMyBotHostsPostMessage: Error executing " & $sExecute)
ElseIf $bPostMessage = False Then
If $g_iDebugWindowMessages Then SetDebugLog("ManagedMyBotHostsPostMessage: Not posting message to " & $hFrmHost)
Else
If $g_iDebugWindowMessages Then SetDebugLog("ManagedMyBotHostsPostMessage: Posting message to " & $hFrmHost)
_WinAPI_PostMessage($hFrmHost, $iMsg, $wParam, $lParam)
EndIf
EndIf
Next
EndFunc
Func _GUICtrlStatusBar_SetTextEx($hWnd, $sText = "", $iPart = 0, $iUFlag = 0)
If $hWnd Then _GUICtrlStatusBar_SetText($hWnd, $sText, $iPart, $iUFlag)
StatusBarManagedMyBotHost($sText)
EndFunc
Func setupProfileComboBox()
Local $profileString = ""
Local $aProfiles = _FileListToArray($g_sProfilePath, "*", $FLTA_FOLDERS)
Local $aProfileList = ["<No Profiles>"]
If @error Then
$profileString = $aProfileList[0]
Else
Local $a[$aProfiles[0]]
$aProfileList = $a
For $i = 1 To $aProfiles[0]
$aProfileList[$i - 1] = $aProfiles[$i]
Next
$profileString = _ArrayToString($aProfileList, "|")
EndIf
$g_asProfiles = $aProfileList
SetDebugLog("Profiles found: " & $profileString)
GUICtrlSetData($g_hCmbProfile, "", "")
GUICtrlSetData($g_hCmbProfile, $profileString, "<No Profiles>")
For $i = 0 To 7
GUICtrlSetData($g_ahCmbProfile[$i], "")
GUICtrlSetData($g_ahCmbProfile[$i], "|" & $profileString)
_GUICtrlComboBox_SetCurSel($g_ahCmbProfile[$i], 0)
Next
EndFunc
Func renameProfile()
Local $originalPath = $g_sProfilePath & "\" & GUICtrlRead($g_hCmbProfile)
Local $newPath = $g_sProfilePath & "\" & $g_sProfileCurrentName
If FileExists($originalPath) Then
If $g_hLogFile <> 0 Then
FileClose($g_hLogFile)
$g_hLogFile = 0
EndIf
If $g_hAttackLogFile <> 0 Then
FileClose($g_hAttackLogFile)
$g_hAttackLogFile = 0
EndIf
DirMove($originalPath, $newPath, $FC_NOOVERWRITE)
$originalPath = $g_sPrivateProfilePath & "\" & GUICtrlRead($g_hCmbProfile)
$newPath = $g_sPrivateProfilePath & "\" & $g_sProfileCurrentName
If FileExists($originalPath) Then
DirMove($originalPath, $newPath, $FC_NOOVERWRITE)
EndIf
EndIf
EndFunc
Func deleteProfile()
Local $sProfile = GUICtrlRead($g_hCmbProfile)
If aquireProfileMutex($sProfile, False, True) = 0 Then
Return False
EndIf
releaseProfileMutex($sProfile)
Local $deletePath = $g_sProfilePath & "\" & $sProfile
If FileExists($deletePath) Then
If $sProfile = $g_sProfileCurrentName Then
If $g_hLogFile <> 0 Then
FileClose($g_hLogFile)
$g_hLogFile = 0
EndIf
If $g_hAttackLogFile <> 0 Then
FileClose($g_hAttackLogFile)
$g_hAttackLogFile = 0
EndIf
EndIf
DirRemove($deletePath, $DIR_REMOVE)
$deletePath = $g_sPrivateProfilePath & "\" & $sProfile
If FileExists($deletePath) Then
DirRemove($deletePath, $DIR_REMOVE)
EndIf
Return True
EndIf
Return False
EndFunc
Func createProfile($bCreateNew = False)
FuncEnter(createProfile)
If $bCreateNew = True Then
setupProfileComboBox()
setupProfile()
saveConfig()
setupProfileComboBox()
selectProfile()
Return FuncReturn()
EndIf
DirCreate($g_sProfilePath & "\" & $g_sProfileCurrentName)
DirCreate($g_sPrivateProfilePath & "\" & $g_sProfileCurrentName)
If Not FileExists($g_sProfilePath & "\profile.ini") Then
Local $hFile = FileOpen($g_sProfilePath & "\profile.ini", $FO_APPEND + $FO_CREATEPATH)
FileWriteLine($hFile, "[general]")
FileClose($hFile)
EndIf
SetupProfileFolder()
DirCreate($g_sProfileLogsPath)
DirCreate($g_sProfileLootsPath)
DirCreate($g_sProfileTempPath)
DirCreate($g_sProfileTempDebugPath)
DirCreate($g_sProfileDonateCapturePath)
DirCreate($g_sProfileDonateCaptureWhitelistPath)
DirCreate($g_sProfileDonateCaptureBlacklistPath)
If FileExists($g_sProfileConfigPath) = 0 Then SetLog("New Profile '" & $g_sProfileCurrentName & "' created")
FuncReturn()
EndFunc
Func setupProfile($sProfile = Default)
FuncEnter(setupProfile)
If IsString($sProfile) Then
ElseIf $g_iGuiMode = 1 Then
If GUICtrlRead($g_hCmbProfile) = "<No Profiles>" Then
$sProfile = StringRegExpReplace(GUICtrlRead($g_hTxtVillageName), '[/:*?"<>|]', '_')
Else
$sProfile = GUICtrlRead($g_hCmbProfile)
EndIf
Else
$sProfile = $g_sProfileCurrentName
EndIf
If aquireProfileMutex($sProfile, False, True) = 0 Then
Return FuncReturn(False)
EndIf
If $g_sProfileCurrentName And $g_sProfileCurrentName <> $sProfile Then
releaseProfileMutex($g_sProfileCurrentName)
If $g_hLogFile <> 0 Then
FileClose($g_hLogFile)
$g_hLogFile = 0
EndIf
If $g_hAttackLogFile <> 0 Then
FileClose($g_hAttackLogFile)
$g_hAttackLogFile = 0
EndIf
EndIf
$g_sProfileCurrentName = $sProfile
createProfile()
GUICtrlSetData($g_hGrpVillage, GetTranslatedFileIni("MBR Main GUI", "Tab_02", "Village") & ": " & $g_sProfileCurrentName)
GUICtrlSetData($g_hTxtNotifyOrigin, $g_sProfileCurrentName)
Return FuncReturn(True)
EndFunc
Func selectProfile($sProfile = Default)
FuncEnter(selectProfile)
If IsString($sProfile) Then
ElseIf _GUICtrlComboBox_FindStringExact($g_hCmbProfile, String($g_sProfileCurrentName)) <> -1 Then
_GUICtrlComboBox_SelectString($g_hCmbProfile, String($g_sProfileCurrentName))
Else
Local $comboBoxArray = _GUICtrlComboBox_GetListArray($g_hCmbProfile)
If UBound($comboBoxArray) > 1 Then
$sProfile = $comboBoxArray[1]
Else
$sProfile = $g_sProfileCurrentName
EndIf
EndIf
If IsString($sProfile) Then
If aquireProfileMutex($sProfile, False, True) = 0 Then
Return FuncReturn(False)
EndIf
If $g_sProfileCurrentName <> $sProfile Then
releaseProfileMutex($g_sProfileCurrentName)
EndIf
$g_sProfileCurrentName = $sProfile
createProfile()
readConfig()
applyConfig()
_GUICtrlComboBox_SetCurSel($g_hCmbProfile, 0)
EndIf
GUICtrlSetData($g_hGrpVillage, GetTranslatedFileIni("MBR Main GUI", "Tab_02", "Village") & ": " & $g_sProfileCurrentName)
GUICtrlSetData($g_hTxtNotifyOrigin, $g_sProfileCurrentName)
Return FuncReturn(True)
EndFunc
Func aquireProfileMutex($sProfile = Default, $bReturnOnlyMutex = Default, $bShowMsgBox = False)
If $sProfile = Default Then $sProfile = $g_sProfileCurrentName
If $bReturnOnlyMutex = Default Then $bReturnOnlyMutex = False
Local $iProfile = _ArraySearch($g_ahMutex_Profile, $sProfile, 0, 0, 0, 0, 1, 0)
If $iProfile >= 0 Then
If $bReturnOnlyMutex Then
Return $g_ahMutex_Profile[$iProfile][1]
EndIf
Return 2
EndIf
Local $hMutex_Profile = CreateMutex("MyBot.run-Profile-" & $sProfile)
If $bReturnOnlyMutex Then
Return $hMutex_Profile
EndIf
Local $sMsg = StringRegExpReplace(GetTranslatedFileIni("MBR GUI Design - Loading", "Msg_Android_instance_02", "My Bot with Profile %s is already in use.\r\n\r\n", $sProfile), "[\r\n]", "")
If $hMutex_Profile = 0 Then
SetLog($sMsg, $COLOR_ERROR)
If $bShowMsgBox Then
MsgBox(BitOR($MB_OK, $MB_ICONINFORMATION, $MB_TOPMOST), $g_sBotTitle, $sMsg)
EndIf
Return 0
EndIf
SetDebugLog("Aquire Mutex for Profile: " & $sProfile)
$iProfile = UBound($g_ahMutex_Profile)
ReDim $g_ahMutex_Profile[$iProfile + 1][2]
$g_ahMutex_Profile[$iProfile][0] = $sProfile
$g_ahMutex_Profile[$iProfile][1] = $hMutex_Profile
Return 1
EndFunc
Func releaseProfileMutex($sProfile = Default)
If $sProfile = Default Then $sProfile = $g_sProfileCurrentName
Local $iProfile = _ArraySearch($g_ahMutex_Profile, $sProfile, 0, 0, 0, 0, 1, 0)
If $iProfile >= 0 Then
SetDebugLog("Release Mutex for Profile: " & $sProfile)
ReleaseMutex($g_ahMutex_Profile[$iProfile][1])
_ArrayDelete($g_ahMutex_Profile, $iProfile)
Return True
EndIf
Return False
EndFunc
Func releaseProfilesMutex($bCurrentAlso = False)
If UBound($g_ahMutex_Profile) > 0 Then
Local $iReleased = 0
For $i = 0 To UBound($g_ahMutex_Profile) - 1
If $bCurrentAlso Or $g_sProfileCurrentName <> $g_ahMutex_Profile[$i - $iReleased][0] Then
If releaseProfileMutex($g_ahMutex_Profile[$i - $iReleased][0]) Then $iReleased += 1
EndIf
Next
EndIf
EndFunc
Global Const $g_iIniLinesMax = 1000
Global $g_asIniTable[$g_iIniLinesMax][2]
Global $g_iIniLineCount = 0
Func _Ini_Save($filename)
ReDim $g_asIniTable[$g_iIniLineCount][3]
_ArraySort($g_asIniTable)
FileCopy($filename, $filename & ".bak", $FC_OVERWRITE)
Local $hFile = FileOpen($filename, $FO_OVERWRITE + $FO_UTF16_LE)
Local $sCurrentSection = ""
For $i = 0 To $g_iIniLineCount - 1
Local $asParts = StringSplit($g_asIniTable[$i][0], "|")
If $asParts[1] <> $sCurrentSection Then
$sCurrentSection = $asParts[1]
FileWriteLine($hFile, "[" & $sCurrentSection & "]")
If $g_sProfileSecondaryOutputFileName <> "" Then
If $sCurrentSection = "search" Or $sCurrentSection = "attack" Or $sCurrentSection = "troop" Or $sCurrentSection = "spells" Or $sCurrentSection = "milkingattack" Or $sCurrentSection = "endbattle" Or $sCurrentSection = "collectors" Or $sCurrentSection = "DropOrder" Or $sCurrentSection = "SmartZap" Or $sCurrentSection = "planned" Then
FileWriteLine($g_sProfileSecondaryOutputFileName, "[" & $sCurrentSection & "]")
EndIf
EndIf
EndIf
FileWriteLine($hFile, $asParts[2] & "=" & $g_asIniTable[$i][1])
If $g_sProfileSecondaryOutputFileName <> "" Then
If $sCurrentSection = "search" Or $sCurrentSection = "attack" Or $sCurrentSection = "troop" Or $sCurrentSection = "spells" Or $sCurrentSection = "milkingattack" Or $sCurrentSection = "endbattle" Or $sCurrentSection = "collectors" Or $sCurrentSection = "DropOrder" Or $sCurrentSection = "SmartZap" Or $sCurrentSection = "planned" Then
FileWriteLine($g_sProfileSecondaryOutputFileName, $asParts[2] & "=" & $g_asIniTable[$i][1])
EndIf
EndIf
Next
FileClose($hFile)
FileDelete($filename & ".bak")
EndFunc
Func _Ini_Clear()
$g_asIniTable = 0
Dim $g_asIniTable[$g_iIniLinesMax][3]
$g_iIniLineCount = 0
EndFunc
Func _Ini_Add($section, $key, $value)
_Ini_AddNewKeyValue($section, $key, $value)
EndFunc
Func _Ini_AddNewKeyValue($section, $key, $value)
If UBound($g_asIniTable) < $g_iIniLineCount + 1 Or UBound($g_asIniTable, 2) < 2 Then
SetDebugLog("_Ini_AddNewKeyValue: Incorrect Array size on section '" & $section & "' for key '" & $key & "' value '" & $value & "'")
Return
EndIf
$g_asIniTable[$g_iIniLineCount][0] = $section & "|" & $key
$g_asIniTable[$g_iIniLineCount][1] = $value
$g_iIniLineCount += 1
EndFunc
Func applyConfig($bRedrawAtExit = True, $TypeReadSave = "Read")
Static $iApplyConfigCount = 0
$iApplyConfigCount += 1
If $g_bApplyConfigIsActive Then
SetDebugLog("applyConfig(), already running, exit")
Return
EndIf
$g_bApplyConfigIsActive = True
SetDebugLog("applyConfig(), call number " & $iApplyConfigCount)
setMaxDegreeOfParallelism($g_iThreads)
setProcessingPoolSize($g_iGlobalThreads)
If $g_bAndroidEmbedded = False Then
If $g_iFrmBotPosX > -30000 And $g_iFrmBotPosY > -30000 And $g_bFrmBotMinimized = False And $g_iFrmBotPosX <> $g_WIN_POS_DEFAULT And $g_iFrmBotPosY <> $g_WIN_POS_DEFAULT Then WinMove($g_hFrmBot, "", $g_iFrmBotPosX, $g_iFrmBotPosY)
If $g_iAndroidPosX > -30000 And $g_iAndroidPosY > -30000 And $g_bIsHidden = False And $g_iAndroidPosX <> $g_WIN_POS_DEFAULT And $g_iAndroidPosY <> $g_WIN_POS_DEFAULT Then HideAndroidWindow(False, False, Default, "applyConfig", 0)
Else
If $g_iFrmBotDockedPosX > -30000 And $g_iFrmBotDockedPosY > -30000 And $g_bFrmBotMinimized = False And $g_iFrmBotDockedPosX <> $g_WIN_POS_DEFAULT And $g_iFrmBotDockedPosY <> $g_WIN_POS_DEFAULT Then WinMove($g_hFrmBot, "", $g_iFrmBotDockedPosX, $g_iFrmBotDockedPosY)
EndIf
If $g_iGuiMode <> 1 Then
If $g_iGuiMode = 2 Then
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkBackgroundMode, $g_bChkBackgroundMode = True ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_bChkBackgroundMode =(GUICtrlRead($g_hChkBackgroundMode) = $GUI_CHECKED)
EndSwitch
EndIf
UpdateBotTitle()
$g_bApplyConfigIsActive = False
Return
EndIf
Local $bWasRdraw = SetRedrawBotWindow(False, Default, Default, Default, "applyConfig")
ApplyConfig_Profile($TypeReadSave)
ApplyConfig_Android($TypeReadSave)
ApplyConfig_600_1($TypeReadSave)
ApplyConfig_600_6($TypeReadSave)
ApplyConfig_600_9($TypeReadSave)
ApplyConfig_600_11($TypeReadSave)
ApplyConfig_600_12($TypeReadSave)
ApplyConfig_600_13($TypeReadSave)
ApplyConfig_600_14($TypeReadSave)
ApplyConfig_600_15($TypeReadSave)
ApplyConfig_600_16($TypeReadSave)
ApplyConfig_auto($TypeReadSave)
ApplyConfig_600_17($TypeReadSave)
ApplyConfig_600_18($TypeReadSave)
ApplyConfig_600_19($TypeReadSave)
ApplyConfig_600_22($TypeReadSave)
ApplyConfig_600_26($TypeReadSave)
ApplyConfig_600_28($TypeReadSave)
ApplyConfig_600_28_DB($TypeReadSave)
ApplyConfig_600_28_LB($TypeReadSave)
ApplyConfig_600_28_TS($TypeReadSave)
ApplyConfig_600_29($TypeReadSave)
ApplyConfig_600_29_DB($TypeReadSave)
ApplyConfig_600_29_LB($TypeReadSave)
ApplyConfig_600_29_TS($TypeReadSave)
ApplyConfig_600_30($TypeReadSave)
ApplyConfig_600_30_DB($TypeReadSave)
ApplyConfig_600_30_LB($TypeReadSave)
ApplyConfig_600_30_TS($TypeReadSave)
ApplyConfig_600_31($TypeReadSave)
ApplyConfig_600_32($TypeReadSave)
ApplyConfig_600_33($TypeReadSave)
ApplyConfig_600_35_1($TypeReadSave)
ApplyConfig_600_35_2($TypeReadSave)
ApplyConfig_600_52_1($TypeReadSave)
ApplyConfig_600_52_2($TypeReadSave)
ApplyConfig_600_54($TypeReadSave)
ApplyConfig_600_56($TypeReadSave)
ApplyConfig_641_1($TypeReadSave)
PopulatePresetComboBox()
MakeSavePresetMessage()
GUICtrlSetState($g_hLblLoadPresetMessage, $GUI_SHOW)
GUICtrlSetState($g_hTxtPresetMessage, $GUI_HIDE)
GUICtrlSetState($g_hBtnGUIPresetLoadConf, $GUI_HIDE)
GUICtrlSetState($g_hBtnGUIPresetDeleteConf, $GUI_HIDE + $GUI_DISABLE)
GUICtrlSetState($g_hChkDeleteConf, $GUI_HIDE + $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDeleteConf, $GUI_HIDE)
ApplyConfig_Debug($TypeReadSave)
If $bRedrawAtExit Then SetRedrawBotWindow($bWasRdraw, Default, Default, Default, "applyConfig")
$g_bApplyConfigIsActive = False
EndFunc
Func ApplyConfig_Profile($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetData($g_hTxtGlobalActiveBotsAllowed, $g_iGlobalActiveBotsAllowed)
GUICtrlSetData($g_hTxtGlobalThreads, $g_iGlobalThreads)
Case "Save"
$g_iGlobalActiveBotsAllowed = Int(GUICtrlRead($g_hTxtGlobalActiveBotsAllowed))
If $g_iGlobalActiveBotsAllowed < 1 Then
$g_iGlobalActiveBotsAllowed = 1
EndIf
$g_iGlobalThreads = Int(GUICtrlRead($g_hTxtGlobalThreads))
EndSwitch
EndFunc
Func ApplyConfig_Android($TypeReadSave)
Switch $TypeReadSave
Case "Read"
SetCurSelCmbCOCDistributors()
UpdateBotTitle()
_GUICtrlComboBox_SetCurSel($g_hCmbAndroidBackgroundMode, $g_iAndroidBackgroundMode)
GUICtrlSetState($g_hChkAndroidAdbClickDragScript, $g_bAndroidAdbClickDragScript ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAndroidCloseWithBot, $g_bAndroidCloseWithBot ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtAndroidRebootHours, $g_iAndroidRebootHours)
_GUICtrlComboBox_SetCurSel($g_hCmbSuspendAndroid, AndroidSuspendFlagsToIndex($g_iAndroidSuspendModeFlags))
Case "Save"
cmbCOCDistributors()
cmbAndroidBackgroundMode()
$g_bAndroidAdbClickDragScript =(GUICtrlRead($g_hChkAndroidAdbClickDragScript) = $GUI_CHECKED ? True : False)
$g_bAndroidCloseWithBot =(GUICtrlRead($g_hChkAndroidCloseWithBot) = $GUI_CHECKED ? True : False)
$g_iAndroidRebootHours = Int(GUICtrlRead($g_hTxtAndroidRebootHours))
cmbSuspendAndroid()
EndSwitch
EndFunc
Func ApplyConfig_Debug($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkDebugSetlog, $g_bDebugSetlog ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugAndroid, $g_bDebugAndroid ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugClick, $g_bDebugClick ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugFunc,($g_bDebugFuncTime And $g_bDebugFuncCall) ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugDisableZoomout, $g_bDebugDisableZoomout ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugDisableVillageCentering, $g_bDebugDisableVillageCentering ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugDeadbaseImage, $g_bDebugDeadBaseImage ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugOCR, $g_bDebugOcr ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugImageSave, $g_bDebugImageSave ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkdebugBuildingPos, $g_bDebugBuildingPos ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkdebugTrain, $g_bDebugSetlogTrain ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugOCRDonate, $g_bDebugOCRdonate ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkdebugAttackCSV, $g_bDebugAttackCSV ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkMakeIMGCSV, $g_bDebugMakeIMGCSV ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugSmartZap, $g_bDebugSmartZap ? $GUI_CHECKED : $GUI_UNCHECKED)
If $g_bDevMode Then
GUICtrlSetState($g_hChkDebugFunc, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugDisableZoomout, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugDisableVillageCentering, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugDeadbaseImage, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugOCR, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugImageSave, $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugBuildingPos, $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugTrain, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugOCRDonate, $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugAttackCSV, $GUI_ENABLE)
GUICtrlSetState($g_hChkMakeIMGCSV, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugSmartZap, $GUI_ENABLE)
EndIf
Case "Save"
$g_bDebugSetlog =(GUICtrlRead($g_hChkDebugSetlog) = $GUI_CHECKED)
$g_bDebugAndroid =(GUICtrlRead($g_hChkDebugAndroid) = $GUI_CHECKED)
$g_bDebugClick =(GUICtrlRead($g_hChkDebugClick) = $GUI_CHECKED)
If $g_bDevMode Then
Local $bDebugFunc =(GUICtrlRead($g_hChkDebugFunc) = $GUI_CHECKED)
$g_bDebugFuncTime = $bDebugFunc
$g_bDebugFuncCall = $bDebugFunc
$g_bDebugDisableZoomout =(GUICtrlRead($g_hChkDebugDisableZoomout) = $GUI_CHECKED)
$g_bDebugDisableVillageCentering =(GUICtrlRead($g_hChkDebugDisableVillageCentering) = $GUI_CHECKED)
$g_bDebugDeadBaseImage =(GUICtrlRead($g_hChkDebugDeadbaseImage) = $GUI_CHECKED)
$g_bDebugOcr =(GUICtrlRead($g_hChkDebugOCR) = $GUI_CHECKED)
$g_bDebugImageSave =(GUICtrlRead($g_hChkDebugImageSave) = $GUI_CHECKED)
$g_bDebugBuildingPos =(GUICtrlRead($g_hChkdebugBuildingPos) = $GUI_CHECKED)
$g_bDebugSetlogTrain =(GUICtrlRead($g_hChkdebugTrain) = $GUI_CHECKED)
$g_bDebugOCRdonate =(GUICtrlRead($g_hChkDebugOCRDonate) = $GUI_CHECKED)
$g_bDebugAttackCSV =(GUICtrlRead($g_hChkdebugAttackCSV) = $GUI_CHECKED)
$g_bDebugMakeIMGCSV =(GUICtrlRead($g_hChkMakeIMGCSV) = $GUI_CHECKED)
$g_bDebugSmartZap =(GUICtrlRead($g_hChkDebugSmartZap) = $GUI_CHECKED)
EndIf
EndSwitch
EndFunc
Func ApplyConfig_600_1($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbLogDividerOption, $g_iCmbLogDividerOption)
cmbLog()
GUICtrlSetState($g_hChkBackgroundMode, $g_bChkBackgroundMode = True ? $GUI_CHECKED : $GUI_UNCHECKED)
UpdateChkBackground()
Case "Save"
$g_iCmbLogDividerOption = _GUICtrlComboBox_GetCurSel($g_hCmbLogDividerOption)
$g_bChkBackgroundMode =(GUICtrlRead($g_hChkBackgroundMode) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_6($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkBotStop, $g_bChkBotStop ? $GUI_CHECKED : $GUI_UNCHECKED)
chkBotStop()
_GUICtrlComboBox_SetCurSel($g_hCmbBotCommand, $g_iCmbBotCommand)
_GUICtrlComboBox_SetCurSel($g_hCmbBotCond, $g_iCmbBotCond)
_GUICtrlComboBox_SetCurSel($g_hCmbHoursStop, $g_iCmbHoursStop)
cmbBotCond()
GUICtrlSetData($g_hTxtRestartGold, $g_iTxtRestartGold)
GUICtrlSetData($g_hTxtRestartElixir, $g_iTxtRestartElixir)
GUICtrlSetData($g_hTxtRestartDark, $g_iTxtRestartDark)
GUICtrlSetState($g_hChkTrap, $g_bChkTrap ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkCollect, $g_bChkCollect ? $GUI_CHECKED : $GUI_UNCHECKED)
ChkCollect()
GUICtrlSetState($g_hChkTombstones, $g_bChkTombstones ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkCleanYard, $g_bChkCleanYard ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkGemsBox, $g_bChkGemsBox ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTreasuryCollect, $g_bChkTreasuryCollect ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkFreeMagicItems, $g_bChkCollectFreeMagicItems ? $GUI_CHECKED : $GUI_UNCHECKED)
ChkTreasuryCollect()
GUICtrlSetData($g_hTxtTreasuryGold, $g_iTxtTreasuryGold)
GUICtrlSetData($g_hTxtTreasuryElixir, $g_iTxtTreasuryElixir)
GUICtrlSetData($g_hTxtTreasuryDark, $g_iTxtTreasuryDark)
GUICtrlSetState($g_hChkCollectBuilderBase, $g_bChkCollectBuilderBase ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkStartClockTowerBoost, $g_bChkStartClockTowerBoost ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkCTBoostBlderBz, $g_bChkCTBoostBlderBz ? $GUI_CHECKED : $GUI_UNCHECKED)
chkStartClockTowerBoost()
GUICtrlSetState($g_hChkBBSuggestedUpgrades, $g_iChkBBSuggestedUpgrades = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreGold, $g_iChkBBSuggestedUpgradesIgnoreGold = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreElixir, $g_iChkBBSuggestedUpgradesIgnoreElixir = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreHall, $g_iChkBBSuggestedUpgradesIgnoreHall = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkPlacingNewBuildings, $g_iChkPlacingNewBuildings = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
chkActivateBBSuggestedUpgrades()
chkActivateBBSuggestedUpgradesGold()
chkActivateBBSuggestedUpgradesElixir()
chkPlacingNewBuildings()
GUICtrlSetState($g_hChkClanGamesAir, $g_bChkClanGamesAir ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesGround, $g_bChkClanGamesGround ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesMisc, $g_bChkClanGamesMisc ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesEnabled, $g_bChkClanGamesEnabled ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesOnly, $g_bChkClanGamesOnly ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesPurge, $g_bChkClanGamesPurge ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesStopBeforeReachAndPurge, $g_bChkClanGamesStopBeforeReachAndPurge ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesDebug, $g_bChkClanGamesDebug ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesLoot, $g_bChkClanGamesLoot ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesBattle, $g_bChkClanGamesBattle ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesDestruction, $g_bChkClanGamesDestruction ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesAirTroop, $g_bChkClanGamesAirTroop ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesGroundTroop, $g_bChkClanGamesGroundTroop ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesMiscellaneous, $g_bChkClanGamesMiscellaneous ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hcmbPurgeLimit, $g_iPurgeMax)
chkActivateClangames()
chkPurgeLimits()
Case "Save"
$g_bChkBotStop =(GUICtrlRead($g_hChkBotStop) = $GUI_CHECKED)
$g_iCmbBotCommand = _GUICtrlComboBox_GetCurSel($g_hCmbBotCommand)
$g_iCmbBotCond = _GUICtrlComboBox_GetCurSel($g_hCmbBotCond)
$g_iCmbHoursStop = _GUICtrlComboBox_GetCurSel($g_hCmbHoursStop)
$g_iTxtRestartGold = GUICtrlRead($g_hTxtRestartGold)
$g_iTxtRestartElixir = GUICtrlRead($g_hTxtRestartElixir)
$g_iTxtRestartDark = GUICtrlRead($g_hTxtRestartDark)
$g_bChkTrap =(GUICtrlRead($g_hchkTrap) = $GUI_CHECKED)
$g_bChkCollect =(GUICtrlRead($g_hChkCollect) = $GUI_CHECKED)
$g_bChkTombstones =(GUICtrlRead($g_hChkTombstones) = $GUI_CHECKED)
$g_bChkCleanYard =(GUICtrlRead($g_hChkCleanYard) = $GUI_CHECKED)
$g_bChkCollectFreeMagicItems =(GUICtrlRead($g_hChkFreeMagicItems) = $GUI_CHECKED)
$g_bChkGemsBox =(GUICtrlRead($g_hChkGemsBox) = $GUI_CHECKED)
$g_bChkTreasuryCollect =(GUICtrlRead($g_hChkTreasuryCollect) = $GUI_CHECKED)
$g_iTxtTreasuryGold = GUICtrlRead($g_hTxtTreasuryGold)
$g_iTxtTreasuryElixir = GUICtrlRead($g_hTxtTreasuryElixir)
$g_iTxtTreasuryDark = GUICtrlRead($g_hTxtTreasuryDark)
$g_bChkCollectBuilderBase =(GUICtrlRead($g_hChkCollectBuilderBase) = $GUI_CHECKED)
$g_bChkStartClockTowerBoost =(GUICtrlRead($g_hChkStartClockTowerBoost) = $GUI_CHECKED)
$g_bChkCTBoostBlderBz =(GUICtrlRead($g_hChkCTBoostBlderBz) = $GUI_CHECKED)
$g_iChkBBSuggestedUpgrades =(GUICtrlRead($g_hChkBBSuggestedUpgrades) = $GUI_CHECKED) ? 1 : 0
$g_iChkBBSuggestedUpgradesIgnoreGold =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreGold) = $GUI_CHECKED) ? 1 : 0
$g_iChkBBSuggestedUpgradesIgnoreElixir =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreElixir) = $GUI_CHECKED) ? 1 : 0
$g_iChkBBSuggestedUpgradesIgnoreHall =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreHall) = $GUI_CHECKED) ? 1 : 0
$g_iChkPlacingNewBuildings =(GUICtrlRead($g_hChkPlacingNewBuildings) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesAir =(GUICtrlRead($g_hChkClanGamesAir) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesGround =(GUICtrlRead($g_hChkClanGamesGround) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesMisc =(GUICtrlRead($g_hChkClanGamesMisc) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesEnabled =(GUICtrlRead($g_hChkClanGamesEnabled) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesOnly =(GUICtrlRead($g_hChkClanGamesOnly) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesPurge =(GUICtrlRead($g_hChkClanGamesPurge) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesStopBeforeReachAndPurge =(GUICtrlRead($g_hChkClanGamesStopBeforeReachAndPurge) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesDebug =(GUICtrlRead($g_hChkClanGamesDebug) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesLoot =(GUICtrlRead($g_hChkClanGamesLoot) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesBattle =(GUICtrlRead($g_hChkClanGamesBattle) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesDestruction =(GUICtrlRead($g_hChkClanGamesDestruction) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesAirTroop =(GUICtrlRead($g_hChkClanGamesAirTroop) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesGroundTroop =(GUICtrlRead($g_hChkClanGamesGroundTroop) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesMiscellaneous =(GUICtrlRead($g_hChkClanGamesMiscellaneous) = $GUI_CHECKED) ? 1 : 0
$g_iPurgeMax = _GUICtrlComboBox_GetCurSel($g_hcmbPurgeLimit)
EndSwitch
EndFunc
Func ApplyConfig_600_9($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkUnbreakable, $g_iUnbrkMode = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtUnbreakable, $g_iUnbrkWait)
GUICtrlSetData($g_hTxtUnBrkMinGold, $g_iUnbrkMinGold)
GUICtrlSetData($g_hTxtUnBrkMinElixir, $g_iUnbrkMinElixir)
GUICtrlSetData($g_hTxtUnBrkMinDark, $g_iUnbrkMinDark)
GUICtrlSetData($g_hTxtUnBrkMaxGold, $g_iUnbrkMaxGold)
GUICtrlSetData($g_hTxtUnBrkMaxElixir, $g_iUnbrkMaxElixir)
GUICtrlSetData($g_hTxtUnBrkMaxDark, $g_iUnbrkMaxDark)
chkUnbreakable()
Case "Save"
$g_iUnbrkMode = GUICtrlRead($g_hChkUnbreakable) = $GUI_CHECKED ? 1 : 0
$g_iUnbrkWait = GUICtrlRead($g_hTxtUnbreakable)
$g_iUnbrkMinGold = GUICtrlRead($g_hTxtUnBrkMinGold)
$g_iUnbrkMinElixir = GUICtrlRead($g_hTxtUnBrkMinElixir)
$g_iUnbrkMinDark = GUICtrlRead($g_hTxtUnBrkMinDark)
$g_iUnbrkMaxGold = GUICtrlRead($g_hTxtUnBrkMaxGold)
$g_iUnbrkMaxElixir = GUICtrlRead($g_hTxtUnBrkMaxElixir)
$g_iUnbrkMaxDark = GUICtrlRead($g_hTxtUnBrkMaxDark)
EndSwitch
EndFunc
Func ApplyConfig_600_11($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkRequestTroopsEnable, $g_bRequestTroopsEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkRequestCCHours()
GUICtrlSetData($g_hTxtRequestCC, $g_sRequestTroopsText)
For $i = 0 To 23
GUICtrlSetState($g_ahChkRequestCCHours[$i], $g_abRequestCCHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
Case "Save"
$g_bRequestTroopsEnable =(GUICtrlRead($g_hChkRequestTroopsEnable) = $GUI_CHECKED)
$g_sRequestTroopsText = GUICtrlRead($g_hTxtRequestCC)
For $i = 0 To 23
$g_abRequestCCHours[$i] =(GUICtrlRead($g_ahChkRequestCCHours[$i]) = $GUI_CHECKED)
Next
EndSwitch
EndFunc
Func ApplyConfig_600_12($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkDonate, $g_bChkDonate ? $GUI_CHECKED : $GUI_UNCHECKED)
Doncheck()
For $i = 0 To $eTroopCount - 1 + $g_iCustomDonateConfigs
GUICtrlSetState($g_ahChkDonateTroop[$i], $g_abChkDonateTroop[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
If $g_abChkDonateTroop[$i] Then
_DonateControls($i)
Else
GUICtrlSetBkColor($g_ahLblDonateTroop[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
If $g_abChkDonateAllTroop[$i] Then
GUICtrlSetState($g_ahChkDonateAllTroop[$i], $GUI_CHECKED)
_DonateAllControls($i, True)
Else
GUICtrlSetState($g_ahChkDonateAllTroop[$i], $GUI_UNCHECKED)
EndIf
GUICtrlSetData($g_ahTxtDonateTroop[$i], $g_asTxtDonateTroop[$i])
GUICtrlSetData($g_ahTxtBlacklistTroop[$i], $g_asTxtBlacklistTroop[$i])
Next
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
GUICtrlSetState($g_ahChkDonateSpell[$i], $g_abChkDonateSpell[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
If $g_abChkDonateSpell[$i] Then
_DonateControlsSpell($i)
Else
GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
If $g_abChkDonateAllSpell[$i] Then
GUICtrlSetState($g_ahChkDonateAllSpell[$i], $GUI_CHECKED)
_DonateAllControlsSpell($i, True)
Else
GUICtrlSetState($g_ahChkDonateAllSpell[$i], $GUI_UNCHECKED)
EndIf
EndIf
If $i <> $eSpellClone Then
GUICtrlSetData($g_ahTxtDonateSpell[$i], $g_asTxtDonateSpell[$i])
GUICtrlSetData($g_ahTxtBlacklistSpell[$i], $g_asTxtBlacklistSpell[$i])
EndIf
Next
For $i = 0 To 2
_GUICtrlComboBox_SetCurSel($g_ahCmbDonateCustomA[$i], $g_aiDonateCustomTrpNumA[$i][0])
GUICtrlSetData($g_ahTxtDonateCustomA[$i], $g_aiDonateCustomTrpNumA[$i][1])
Next
cmbDonateCustomA()
For $i = 0 To 2
_GUICtrlComboBox_SetCurSel($g_ahCmbDonateCustomB[$i], $g_aiDonateCustomTrpNumB[$i][0])
GUICtrlSetData($g_ahTxtDonateCustomB[$i], $g_aiDonateCustomTrpNumB[$i][1])
Next
cmbDonateCustomB()
For $i = 0 To 2
_GUICtrlComboBox_SetCurSel($g_ahCmbDonateCustomC[$i], $g_aiDonateCustomTrpNumC[$i][0])
GUICtrlSetData($g_ahTxtDonateCustomC[$i], $g_aiDonateCustomTrpNumC[$i][1])
Next
cmbDonateCustomC()
For $i = 0 To 2
_GUICtrlComboBox_SetCurSel($g_ahCmbDonateCustomD[$i], $g_aiDonateCustomTrpNumD[$i][0])
GUICtrlSetData($g_ahTxtDonateCustomD[$i], $g_aiDonateCustomTrpNumD[$i][1])
Next
cmbDonateCustomD()
GUICtrlSetState($g_hChkExtraAlphabets, $g_bChkExtraAlphabets ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkExtraChinese, $g_bChkExtraChinese ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkExtraKorean, $g_bChkExtraKorean ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkExtraPersian, $g_bChkExtraPersian ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtGeneralBlacklist, $g_sTxtGeneralBlacklist)
Case "Save"
$g_bChkDonate =(GUICtrlRead($g_hChkDonate) = $GUI_CHECKED)
For $i = 0 To $eTroopCount - 1 + $g_iCustomDonateConfigs
$g_abChkDonateTroop[$i] =(GUICtrlRead($g_ahChkDonateTroop[$i]) = $GUI_CHECKED)
$g_abChkDonateAllTroop[$i] =(GUICtrlRead($g_ahChkDonateAllTroop[$i]) = $GUI_CHECKED)
$g_asTxtDonateTroop[$i] = GUICtrlRead($g_ahTxtDonateTroop[$i])
$g_asTxtBlacklistTroop[$i] = GUICtrlRead($g_ahTxtBlacklistTroop[$i])
Next
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
$g_abChkDonateSpell[$i] =(GUICtrlRead($g_ahChkDonateSpell[$i]) = $GUI_CHECKED)
$g_abChkDonateAllSpell[$i] =(GUICtrlRead($g_ahChkDonateAllSpell[$i]) = $GUI_CHECKED)
$g_asTxtDonateSpell[$i] = GUICtrlRead($g_ahTxtDonateSpell[$i])
$g_asTxtBlacklistSpell[$i] = GUICtrlRead($g_ahTxtBlacklistSpell[$i])
EndIf
Next
For $i = 0 To 2
$g_aiDonateCustomTrpNumA[$i][0] = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomA[$i])
$g_aiDonateCustomTrpNumA[$i][1] = GUICtrlRead($g_ahTxtDonateCustomA[$i])
$g_aiDonateCustomTrpNumB[$i][0] = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomB[$i])
$g_aiDonateCustomTrpNumB[$i][1] = GUICtrlRead($g_ahTxtDonateCustomB[$i])
$g_aiDonateCustomTrpNumC[$i][0] = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomC[$i])
$g_aiDonateCustomTrpNumC[$i][1] = GUICtrlRead($g_ahTxtDonateCustomC[$i])
$g_aiDonateCustomTrpNumD[$i][0] = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomD[$i])
$g_aiDonateCustomTrpNumD[$i][1] = GUICtrlRead($g_ahTxtDonateCustomD[$i])
Next
$g_bChkExtraAlphabets =(GUICtrlRead($g_hChkExtraAlphabets) = $GUI_CHECKED)
$g_bChkExtraChinese =(GUICtrlRead($g_hChkExtraChinese) = $GUI_CHECKED)
$g_bChkExtraKorean =(GUICtrlRead($g_hChkExtraKorean) = $GUI_CHECKED)
$g_bChkExtraPersian =(GUICtrlRead($g_hChkExtraPersian) = $GUI_CHECKED)
$g_sTxtGeneralBlacklist = GUICtrlRead($g_hTxtGeneralBlacklist)
EndSwitch
EndFunc
Func ApplyConfig_600_13($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkDonateHoursEnable, $g_bDonateHoursEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDonateHours()
For $i = 0 To 23
GUICtrlSetState($g_ahChkDonateHours[$i], $g_abDonateHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
_GUICtrlComboBox_SetCurSel($g_hCmbFilterDonationsCC, $g_iCmbDonateFilter)
GUICtrlSetState($g_hChkSkipDonateNearFullTroopsEnable, $g_bDonateSkipNearFullEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtSkipDonateNearFullTroopsPercentage, $g_iDonateSkipNearFullPercent)
chkskipDonateNearFulLTroopsEnable()
GUICtrlSetState($g_hChkUseCCBalanced, $g_bUseCCBalanced = True ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbCCDonated, $g_iCCDonated - 1)
_GUICtrlComboBox_SetCurSel($g_hCmbCCReceived, $g_iCCReceived - 1)
chkBalanceDR()
Case "Save"
$g_bDonateHoursEnable =(GUICtrlRead($g_hChkDonateHoursEnable) = $GUI_CHECKED)
For $i = 0 To 23
$g_abDonateHours[$i] =(GUICtrlRead($g_ahChkDonateHours[$i]) = $GUI_CHECKED)
Next
$g_iCmbDonateFilter = _GUICtrlComboBox_GetCurSel($g_hCmbFilterDonationsCC)
$g_bDonateSkipNearFullEnable =(GUICtrlRead($g_hChkSkipDonateNearFullTroopsEnable) = $GUI_CHECKED)
$g_iDonateSkipNearFullPercent = Number(GUICtrlRead($g_hTxtSkipDonateNearFullTroopsPercentage))
$g_bUseCCBalanced =(GUICtrlRead($g_hChkUseCCBalanced) = $GUI_CHECKED)
$g_iCCDonated = _GUICtrlComboBox_GetCurSel($g_hCmbCCDonated) + 1
$g_iCCReceived = _GUICtrlComboBox_GetCurSel($g_hCmbCCReceived) + 1
EndSwitch
EndFunc
Func ApplyConfig_600_14($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkAutoLabUpgrades, $g_bAutoLabUpgradeEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbLaboratory, $g_iCmbLaboratory)
_GUICtrlSetImage($g_hPicLabUpgrade, $g_sLibIconPath, $g_avLabTroops[$g_iCmbLaboratory][4])
chkLab()
Case "Save"
$g_bAutoLabUpgradeEnable =(GUICtrlRead($g_hChkAutoLabUpgrades) = $GUI_CHECKED)
$g_iCmbLaboratory = _GUICtrlComboBox_GetCurSel($g_hCmbLaboratory)
EndSwitch
EndFunc
Func ApplyConfig_600_15($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkUpgradeKing, $g_bUpgradeKingEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkUpgradeKing()
chkDBKingWait()
chkABKingWait()
GUICtrlSetState($g_hChkUpgradeQueen, $g_bUpgradeQueenEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkUpgradeQueen()
chkDBQueenWait()
chkABQueenWait()
GUICtrlSetState($g_hChkUpgradeWarden, $g_bUpgradeWardenEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkUpgradeWarden()
chkDBWardenWait()
chkABWardenWait()
Case "Save"
$g_bUpgradeKingEnable =(GUICtrlRead($g_hChkUpgradeKing) = $GUI_CHECKED)
$g_bUpgradeQueenEnable =(GUICtrlRead($g_hChkUpgradeQueen) = $GUI_CHECKED)
$g_bUpgradeWardenEnable =(GUICtrlRead($g_hChkUpgradeWarden) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_16($TypeReadSave)
Switch $TypeReadSave
Case "Read"
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
_GUICtrlSetImage($g_hPicUpgradeStatus[$iz], $g_sLibIconPath, $g_aiPicUpgradeStatus[$iz])
If $g_avBuildingUpgrades[$iz][2] > 0 Then
GUICtrlSetData($g_hTxtUpgradeValue[$iz], _NumberFormat($g_avBuildingUpgrades[$iz][2]))
Else
GUICtrlSetData($g_hTxtUpgradeValue[$iz], "")
EndIf
GUICtrlSetData($g_hTxtUpgradeName[$iz], $g_avBuildingUpgrades[$iz][4])
GUICtrlSetData($g_hTxtUpgradeLevel[$iz], $g_avBuildingUpgrades[$iz][5])
GUICtrlSetData($g_hTxtUpgradeTime[$iz], StringStripWS($g_avBuildingUpgrades[$iz][6], $STR_STRIPALL))
Switch $g_avBuildingUpgrades[$iz][3]
Case "Gold"
_GUICtrlSetImage($g_hPicUpgradeType[$iz], $g_sLibIconPath, $eIcnGold)
Case "Elixir"
_GUICtrlSetImage($g_hPicUpgradeType[$iz], $g_sLibIconPath, $eIcnElixir)
Case "Dark"
_GUICtrlSetImage($g_hPicUpgradeType[$iz], $g_sLibIconPath, $eIcnDark)
Case Else
_GUICtrlSetImage($g_hPicUpgradeType[$iz], $g_sLibIconPath, $eIcnBlank)
EndSwitch
GUICtrlSetState($g_hChkUpgrade[$iz], $g_abBuildingUpgradeEnable[$iz] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkUpgradeRepeat[$iz], $g_abUpgradeRepeatEnable[$iz] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtUpgradeEndTime[$iz], $g_avBuildingUpgrades[$iz][7])
Next
GUICtrlSetData($g_hTxtUpgrMinGold, $g_iUpgradeMinGold)
GUICtrlSetData($g_hTxtUpgrMinElixir, $g_iUpgradeMinElixir)
GUICtrlSetData($g_hTxtUpgrMinDark, $g_iUpgradeMinDark)
Case "Save"
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
$g_abBuildingUpgradeEnable[$iz] =(GUICtrlRead($g_hChkUpgrade[$iz]) = $GUI_CHECKED)
$g_abUpgradeRepeatEnable[$iz] =(GUICtrlRead($g_hChkUpgradeRepeat[$iz]) = $GUI_CHECKED)
Next
$g_iUpgradeMinGold = Number(GUICtrlRead($g_hTxtUpgrMinGold))
$g_iUpgradeMinElixir = Number(GUICtrlRead($g_hTxtUpgrMinElixir))
$g_iUpgradeMinDark = Number(GUICtrlRead($g_hTxtUpgrMinDark))
EndSwitch
EndFunc
Func ApplyConfig_auto($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkAutoUpgrade, $g_iChkAutoUpgrade = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
For $i = 0 To 12
GUICtrlSetState($g_hChkUpgradesToIgnore[$i], $g_iChkUpgradesToIgnore[$i] = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
For $i = 0 To 2
GUICtrlSetState($g_hChkResourcesToIgnore[$i], $g_iChkResourcesToIgnore[$i] = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
GUICtrlSetData($g_hTxtSmartMinGold, $g_iTxtSmartMinGold)
GUICtrlSetData($g_hTxtSmartMinElixir, $g_iTxtSmartMinElixir)
GUICtrlSetData($g_hTxtSmartMinDark, $g_iTxtSmartMinDark)
chkAutoUpgrade()
Case "Save"
$g_iChkAutoUpgrade = GUICtrlRead($g_hChkAutoUpgrade) = $GUI_CHECKED ? 1 : 0
For $i = 0 To 12
$g_iChkUpgradesToIgnore[$i] = GUICtrlRead($g_hChkUpgradesToIgnore[$i]) = $GUI_CHECKED ? 1 : 0
Next
For $i = 0 To 2
$g_iChkResourcesToIgnore[$i] = GUICtrlRead($g_hChkResourcesToIgnore[$i]) = $GUI_CHECKED ? 1 : 0
Next
$g_iTxtSmartMinGold = GUICtrlRead($g_hTxtSmartMinGold)
$g_iTxtSmartMinElixir = GUICtrlRead($g_hTxtSmartMinElixir)
$g_iTxtSmartMinDark = GUICtrlRead($g_hTxtSmartMinDark)
EndSwitch
EndFunc
Func ApplyConfig_600_17($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkWalls, $g_bAutoUpgradeWallsEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtWallMinGold, $g_iUpgradeWallMinGold)
GUICtrlSetData($g_hTxtWallMinElixir, $g_iUpgradeWallMinElixir)
Switch $g_iUpgradeWallLootType
Case 0
GUICtrlSetState($g_hRdoUseGold, $GUI_CHECKED)
Case 1
GUICtrlSetState($g_hRdoUseElixir, $GUI_CHECKED)
Case 2
GUICtrlSetState($g_hRdoUseElixirGold, $GUI_CHECKED)
EndSwitch
GUICtrlSetState($g_hChkSaveWallBldr, $g_bUpgradeWallSaveBuilder ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbWalls, $g_iCmbUpgradeWallsLevel)
For $i = 4 To 13
GUICtrlSetData($g_ahWallsCurrentCount[$i], $g_aiWallsCurrentCount[$i])
Next
cmbWalls()
chkWalls()
Case "Save"
$g_bAutoUpgradeWallsEnable =(GUICtrlRead($g_hChkWalls) = $GUI_CHECKED)
$g_iUpgradeWallMinGold = Number(GUICtrlRead($g_hTxtWallMinGold))
$g_iUpgradeWallMinElixir = Number(GUICtrlRead($g_hTxtWallMinElixir))
If GUICtrlRead($g_hRdoUseGold) = $GUI_CHECKED Then
$g_iUpgradeWallLootType = 0
ElseIf GUICtrlRead($g_hRdoUseElixir) = $GUI_CHECKED Then
$g_iUpgradeWallLootType = 1
ElseIf GUICtrlRead($g_hRdoUseElixirGold) = $GUI_CHECKED Then
$g_iUpgradeWallLootType = 2
EndIf
$g_bUpgradeWallSaveBuilder =(GUICtrlRead($g_hChkSaveWallBldr) = $GUI_CHECKED)
$g_iCmbUpgradeWallsLevel = _GUICtrlComboBox_GetCurSel($g_hCmbWalls)
For $i = 4 To 13
$g_aiWallsCurrentCount[$i] = Number(GUICtrlRead($g_ahWallsCurrentCount[$i]))
Next
EndSwitch
EndFunc
Func ApplyConfig_600_18($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkNotifyPBEnable, $g_bNotifyPBEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyTGEnable, $g_bNotifyTGEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkPBTGenabled()
GUICtrlSetData($g_hTxtNotifyPBToken, $g_sNotifyPBToken)
GUICtrlSetData($g_hTxtNotifyTGToken, $g_sNotifyTGToken)
GUICtrlSetState($g_hChkNotifyRemote, $g_bNotifyRemoteEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyDeleteAllPBPushes, $g_bNotifyDeleteAllPushesOnStart ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyDeleteOldPBPushes, $g_bNotifyDeletePushesOlderThan ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbNotifyPushHours, $g_iNotifyDeletePushesOlderThanHours)
chkDeleteOldPBPushes()
GUICtrlSetData($g_hTxtNotifyOrigin, $g_sNotifyOrigin)
GUICtrlSetState($g_hChkNotifyAlertMatchFound, $g_bNotifyAlertMatchFound ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertLastRaidIMG, $g_bNotifyAlerLastRaidIMG ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertUpgradeWall, $g_bNotifyAlertUpgradeWalls ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertOutOfSync, $g_bNotifyAlertOutOfSync ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertTakeBreak, $g_bNotifyAlertTakeBreak ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertAnotherDevice, $g_bNotifyAlertAnotherDevice ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertLastRaidTXT, $g_bNotifyAlerLastRaidTXT ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertCampFull, $g_bNotifyAlertCampFull ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertVillageStats, $g_bNotifyAlertVillageReport ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertLastAttack, $g_bNotifyAlertLastAttack ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertBuilderIdle, $g_bNotifyAlertBulderIdle ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertMaintenance, $g_bNotifyAlertMaintenance ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertBAN, $g_bNotifyAlertBAN ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyBOTUpdate, $g_bNotifyAlertBOTUpdate ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertSmartWaitTime, $g_bNotifyAlertSmartWaitTime ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_bNotifyPBEnable =(GUICtrlRead($g_hChkNotifyPBEnable) = $GUI_CHECKED)
$g_bNotifyTGEnable =(GUICtrlRead($g_hChkNotifyTGEnable) = $GUI_CHECKED)
$g_sNotifyPBToken = GUICtrlRead($g_hTxtNotifyPBToken)
$g_sNotifyTGToken = GUICtrlRead($g_hTxtNotifyTGToken)
$g_bNotifyRemoteEnable =(GUICtrlRead($g_hChkNotifyRemote) = $GUI_CHECKED)
$g_bNotifyDeleteAllPushesOnStart =(GUICtrlRead($g_hChkNotifyDeleteAllPBPushes) = $GUI_CHECKED)
$g_bNotifyDeletePushesOlderThan =(GUICtrlRead($g_hChkNotifyDeleteOldPBPushes) = $GUI_CHECKED)
$g_iNotifyDeletePushesOlderThanHours = _GUICtrlComboBox_GetCurSel($g_hCmbNotifyPushHours)
$g_sNotifyOrigin = GUICtrlRead($g_hTxtNotifyOrigin)
$g_bNotifyAlertMatchFound =(GUICtrlRead($g_hChkNotifyAlertMatchFound) = $GUI_CHECKED)
$g_bNotifyAlerLastRaidIMG =(GUICtrlRead($g_hChkNotifyAlertLastRaidIMG) = $GUI_CHECKED)
$g_bNotifyAlertUpgradeWalls =(GUICtrlRead($g_hChkNotifyAlertUpgradeWall) = $GUI_CHECKED)
$g_bNotifyAlertOutOfSync =(GUICtrlRead($g_hChkNotifyAlertOutOfSync) = $GUI_CHECKED)
$g_bNotifyAlertTakeBreak =(GUICtrlRead($g_hChkNotifyAlertTakeBreak) = $GUI_CHECKED)
$g_bNotifyAlertAnotherDevice =(GUICtrlRead($g_hChkNotifyAlertAnotherDevice) = $GUI_CHECKED)
$g_bNotifyAlerLastRaidTXT =(GUICtrlRead($g_hChkNotifyAlertLastRaidTXT) = $GUI_CHECKED)
$g_bNotifyAlertCampFull =(GUICtrlRead($g_hChkNotifyAlertCampFull) = $GUI_CHECKED)
$g_bNotifyAlertVillageReport =(GUICtrlRead($g_hChkNotifyAlertVillageStats) = $GUI_CHECKED)
$g_bNotifyAlertLastAttack =(GUICtrlRead($g_hChkNotifyAlertLastAttack) = $GUI_CHECKED)
$g_bNotifyAlertBulderIdle =(GUICtrlRead($g_hChkNotifyAlertBuilderIdle) = $GUI_CHECKED)
$g_bNotifyAlertMaintenance =(GUICtrlRead($g_hChkNotifyAlertMaintenance) = $GUI_CHECKED)
$g_bNotifyAlertBAN =(GUICtrlRead($g_hChkNotifyAlertBAN) = $GUI_CHECKED)
$g_bNotifyAlertBOTUpdate =(GUICtrlRead($g_hChkNotifyBOTUpdate) = $GUI_CHECKED)
$g_bNotifyAlertSmartWaitTime =(GUICtrlRead($g_hChkNotifyAlertSmartWaitTime) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_19($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkNotifyOnlyHours, $g_bNotifyScheduleHoursEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkNotifyHours()
For $i = 0 To 23
GUICtrlSetState($g_hChkNotifyhours[$i], $g_abNotifyScheduleHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
GUICtrlSetState($g_hChkNotifyOnlyWeekDays, $g_bNotifyScheduleWeekDaysEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkNotifyWeekDays()
For $i = 0 To 6
GUICtrlSetState($g_hChkNotifyWeekdays[$i], $g_abNotifyScheduleWeekDays[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
Case "Save"
$g_bNotifyScheduleHoursEnable =(GUICtrlRead($g_hChkNotifyOnlyHours) = $GUI_CHECKED)
For $i = 0 To 23
$g_abNotifyScheduleHours[$i] =(GUICtrlRead($g_hChkNotifyhours[$i]) = $GUI_CHECKED)
Next
$g_bNotifyScheduleWeekDaysEnable =(GUICtrlRead($g_hChkNotifyOnlyWeekDays) = $GUI_CHECKED)
For $i = 0 To 6
$g_abNotifyScheduleWeekDays[$i] =(GUICtrlRead($g_hChkNotifyWeekdays[$i]) = $GUI_CHECKED)
Next
EndSwitch
EndFunc
Func ApplyConfig_600_22($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbBoostBarracks, $g_iCmbBoostBarracks)
_GUICtrlComboBox_SetCurSel($g_hCmbBoostSpellFactory, $g_iCmbBoostSpellFactory)
_GUICtrlComboBox_SetCurSel($g_hCmbBoostBarbarianKing, $g_iCmbBoostBarbarianKing)
_GUICtrlComboBox_SetCurSel($g_hCmbBoostArcherQueen, $g_iCmbBoostArcherQueen)
_GUICtrlComboBox_SetCurSel($g_hCmbBoostWarden, $g_iCmbBoostWarden)
For $i = 0 To 23
GUICtrlSetState($g_hChkBoostBarracksHours[$i], $g_abBoostBarracksHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
Case "Save"
$g_iCmbBoostBarracks = _GUICtrlComboBox_GetCurSel($g_hCmbBoostBarracks)
$g_iCmbBoostSpellFactory = _GUICtrlComboBox_GetCurSel($g_hCmbBoostSpellFactory)
$g_iCmbBoostBarbarianKing = _GUICtrlComboBox_GetCurSel($g_hCmbBoostBarbarianKing)
$g_iCmbBoostArcherQueen = _GUICtrlComboBox_GetCurSel($g_hCmbBoostArcherQueen)
$g_iCmbBoostWarden = _GUICtrlComboBox_GetCurSel($g_hCmbBoostWarden)
For $i = 0 To 23
$g_abBoostBarracksHours[$i] =(GUICtrlRead($g_hChkBoostBarracksHours[$i]) = $GUI_CHECKED)
Next
EndSwitch
EndFunc
Func ApplyConfig_600_26($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkBully, $g_abAttackTypeEnable[$TB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtATBullyMode, $g_iAtkTBEnableCount)
_GUICtrlComboBox_SetCurSel($g_hCmbBullyMaxTH, $g_iAtkTBMaxTHLevel)
CmbBullyMaxTH()
GUICtrlSetState($g_hRadBullyUseDBAttack, $g_iAtkTBMode = 0 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRadBullyUseLBAttack, $g_iAtkTBMode = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_abAttackTypeEnable[$TB] =(GUICtrlRead($g_hChkBully) = $GUI_CHECKED)
$g_iAtkTBEnableCount = GUICtrlRead($g_hTxtATBullyMode)
$g_iAtkTBMaxTHLevel = _GUICtrlComboBox_GetCurSel($g_hCmbBullyMaxTH)
$g_iAtkTBMode =(GUICtrlRead($g_hRadBullyUseDBAttack) = $GUI_CHECKED ? 0 : 1)
EndSwitch
EndFunc
Func ApplyConfig_600_28($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkSearchReduction, $g_bSearchReductionEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkSearchReduction()
GUICtrlSetData($g_hTxtSearchReduceCount, $g_iSearchReductionCount)
GUICtrlSetData($g_hTxtSearchReduceGold, $g_iSearchReductionGold)
GUICtrlSetData($g_hTxtSearchReduceElixir, $g_iSearchReductionElixir)
GUICtrlSetData($g_hTxtSearchReduceGoldPlusElixir, $g_iSearchReductionGoldPlusElixir)
GUICtrlSetData($g_hTxtSearchReduceDark, $g_iSearchReductionDark)
GUICtrlSetData($g_hTxtSearchReduceTrophy, $g_iSearchReductionTrophy)
If $g_iSearchDelayMin > $g_iSearchDelayMax Then $g_iSearchDelayMax = $g_iSearchDelayMin
GUICtrlSetData($g_hSldVSDelay, $g_iSearchDelayMin)
GUICtrlSetData($g_hLblVSDelay, $g_iSearchDelayMin)
GUICtrlSetData($g_hSldMaxVSDelay, $g_iSearchDelayMax)
GUICtrlSetData($g_hLblMaxVSDelay, $g_iSearchDelayMax)
GUICtrlSetState($g_hChkAttackNow, $g_bSearchAttackNowEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkAttackNow()
_GUICtrlComboBox_SetCurSel($g_hCmbAttackNowDelay, $g_iSearchAttackNowDelay)
GUICtrlSetState($g_hChkRestartSearchLimit, $g_bSearchRestartEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtRestartSearchlimit, $g_iSearchRestartLimit)
ChkRestartSearchLimit()
GUICtrlSetState($g_hChkAlertSearch, $g_bSearchAlertMe ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_bSearchReductionEnable =(GUICtrlRead($g_hChkSearchReduction) = $GUI_CHECKED)
$g_iSearchReductionCount = GUICtrlRead($g_hTxtSearchReduceCount)
$g_iSearchReductionGold = GUICtrlRead($g_hTxtSearchReduceGold)
$g_iSearchReductionElixir = GUICtrlRead($g_hTxtSearchReduceElixir)
$g_iSearchReductionGoldPlusElixir = GUICtrlRead($g_hTxtSearchReduceGoldPlusElixir)
$g_iSearchReductionDark = GUICtrlRead($g_hTxtSearchReduceDark)
$g_iSearchReductionTrophy = GUICtrlRead($g_hTxtSearchReduceTrophy)
$g_iSearchDelayMin = GUICtrlRead($g_hSldVSDelay)
$g_iSearchDelayMax = GUICtrlRead($g_hSldMaxVSDelay)
$g_bSearchAttackNowEnable =(GUICtrlRead($g_hChkAttackNow) = $GUI_CHECKED)
$g_iSearchAttackNowDelay = _GUICtrlComboBox_GetCurSel($g_hCmbAttackNowDelay)
$g_bSearchRestartEnable =(GUICtrlRead($g_hChkRestartSearchLimit) = $GUI_CHECKED)
$g_iSearchRestartLimit = GUICtrlRead($g_hTxtRestartSearchlimit)
$g_bSearchAlertMe =(GUICtrlRead($g_hChkAlertSearch) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_28_DB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkDBActivateSearches, $g_abSearchSearchesEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDBSearchesMin, $g_aiSearchSearchesMin[$DB])
GUICtrlSetData($g_hTxtDBSearchesMax, $g_aiSearchSearchesMax[$DB])
GUICtrlSetState($g_hChkDBActivateTropies, $g_abSearchTropiesEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDBActivateTropies()
GUICtrlSetData($g_hTxtDBTropiesMin, $g_aiSearchTrophiesMin[$DB])
GUICtrlSetData($g_hTxtDBTropiesMax, $g_aiSearchTrophiesMax[$DB])
GUICtrlSetState($g_hChkDBActivateCamps, $g_abSearchCampsEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDBActivateCamps()
GUICtrlSetData($g_hTxtDBArmyCamps, $g_aiSearchCampsPct[$DB])
chkDBActivateSearches()
GUICtrlSetState($g_hChkDeadbase, $g_abAttackTypeEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBKingWait, BitAND($g_aiSearchHeroWaitEnable[$DB], $eHeroKing) = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBQueenWait, BitAND($g_aiSearchHeroWaitEnable[$DB], $eHeroQueen) = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBWardenWait, BitAND($g_aiSearchHeroWaitEnable[$DB], $eHeroWarden) = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBNotWaitHeroes, $g_aiSearchNotWaitHeroesEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
$g_iHeroWaitAttackNoBit[$DB][0] = GUICtrlRead($g_hChkDBKingWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$DB][1] = GUICtrlRead($g_hChkDBQueenWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$DB][2] = GUICtrlRead($g_hChkDBWardenWait) = $GUI_CHECKED ? 1 : 0
GUICtrlSetState($g_hChkDBSpellsWait, $g_abSearchSpellsWaitEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDBSpellsWait()
GUICtrlSetState($g_hChkDBWaitForCastleSpell, $g_abSearchCastleSpellsWaitEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbDBWaitForCastleSpell, $g_aiSearchCastleSpellsWaitRegular[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbDBWaitForCastleSpell2, $g_aiSearchCastleSpellsWaitDark[$DB])
cmbDBWaitForCCSpell()
chkDBWaitForCCSpell()
GUICtrlSetState($g_hChkDBWaitForCastleTroops, $g_abSearchCastleTroopsWaitEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbDBMeetGE, $g_aiFilterMeetGE[$DB])
GUICtrlSetData($g_hTxtDBMinGold, $g_aiFilterMinGold[$DB])
GUICtrlSetData($g_hTxtDBMinElixir, $g_aiFilterMinElixir[$DB])
GUICtrlSetData($g_hTxtDBMinGoldPlusElixir, $g_aiFilterMinGoldPlusElixir[$DB])
cmbDBGoldElixir()
GUICtrlSetState($g_hChkDBMeetDE, $g_abFilterMeetDEEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDBMinDarkElixir, $g_aiFilterMeetDEMin[$DB])
chkDBMeetDE()
GUICtrlSetState($g_hChkDBMeetTrophy, $g_abFilterMeetTrophyEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDBMinTrophy, $g_aiFilterMeetTrophyMin[$DB])
GUICtrlSetData($g_hTxtDBMaxTrophy, $g_aiFilterMeetTrophyMax[$DB])
chkDBMeetTrophy()
GUICtrlSetState($g_hChkDBMeetTH, $g_abFilterMeetTH[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbDBTH, $g_aiFilterMeetTHMin[$DB])
$g_aiMaxTH[$DB] = $g_asTHText[$g_aiFilterMeetTHMin[$DB]]
chkDBMeetTH()
CmbDBTH()
GUICtrlSetState($g_hChkDBMeetTHO, $g_abFilterMeetTHOutsideEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxMortar[$DB], $g_abFilterMaxMortarEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxWizTower[$DB], $g_abFilterMaxWizTowerEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxAirDefense[$DB], $g_abFilterMaxAirDefenseEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxXBow[$DB], $g_abFilterMaxXBowEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxInferno[$DB], $g_abFilterMaxInfernoEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxEagle[$DB], $g_abFilterMaxEagleEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakMortar[$DB], $g_aiFilterMaxMortarLevel[$DB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakWizTower[$DB], $g_aiFilterMaxWizTowerLevel[$DB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakAirDefense[$DB], $g_aiFilterMaxAirDefenseLevel[$DB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakXBow[$DB], $g_aiFilterMaxXBowLevel[$DB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakInferno[$DB], $g_aiFilterMaxInfernoLevel[$DB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakEagle[$DB], $g_aiFilterMaxEagleLevel[$DB])
chkDBWeakBase()
GUICtrlSetState($g_ahChkMeetOne[$DB], $g_abFilterMeetOneConditionEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_abAttackTypeEnable[$DB] =(GUICtrlRead($g_hChkDeadbase) = $GUI_CHECKED)
$g_abSearchSearchesEnable[$DB] =(GUICtrlRead($g_hChkDBActivateSearches) = $GUI_CHECKED)
$g_aiSearchSearchesMin[$DB] = GUICtrlRead($g_hTxtDBSearchesMin)
$g_aiSearchSearchesMax[$DB] = GUICtrlRead($g_hTxtDBSearchesMax)
$g_abSearchTropiesEnable[$DB] =(GUICtrlRead($g_hChkDBActivateTropies) = $GUI_CHECKED)
$g_aiSearchTrophiesMin[$DB] = GUICtrlRead($g_hTxtDBTropiesMin)
$g_aiSearchTrophiesMax[$DB] = GUICtrlRead($g_hTxtDBTropiesMax)
$g_abSearchCampsEnable[$DB] =(GUICtrlRead($g_hChkDBActivateCamps) = $GUI_CHECKED)
$g_aiSearchCampsPct[$DB] = Int(GUICtrlRead($g_hTxtDBArmyCamps))
$g_iHeroWaitAttackNoBit[$DB][0] = GUICtrlRead($g_hChkDBKingWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$DB][1] = GUICtrlRead($g_hChkDBQueenWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$DB][2] = GUICtrlRead($g_hChkDBWardenWait) = $GUI_CHECKED ? 1 : 0
$g_aiSearchNotWaitHeroesEnable[$DB] = GUICtrlRead($g_hChkDBNotWaitHeroes) = $GUI_CHECKED ? 1 : 0
chkNotWaitHeroes()
$g_abSearchSpellsWaitEnable[$DB] =(GUICtrlRead($g_hChkDBSpellsWait) = $GUI_CHECKED)
$g_abSearchCastleSpellsWaitEnable[$DB] =(GUICtrlRead($g_hChkDBWaitForCastleSpell) = $GUI_CHECKED)
$g_aiSearchCastleSpellsWaitRegular[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBWaitForCastleSpell)
$g_aiSearchCastleSpellsWaitDark[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBWaitForCastleSpell2)
$g_abSearchCastleTroopsWaitEnable[$DB] =(GUICtrlRead($g_hChkDBWaitForCastleTroops) = $GUI_CHECKED)
$g_aiFilterMeetGE[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBMeetGE)
$g_aiFilterMinGold[$DB] = GUICtrlRead($g_hTxtDBMinGold)
$g_aiFilterMinElixir[$DB] = GUICtrlRead($g_hTxtDBMinElixir)
$g_aiFilterMinGoldPlusElixir[$DB] = GUICtrlRead($g_hTxtDBMinGoldPlusElixir)
$g_abFilterMeetDEEnable[$DB] =(GUICtrlRead($g_hChkDBMeetDE) = $GUI_CHECKED)
$g_aiFilterMeetDEMin[$DB] = GUICtrlRead($g_hTxtDBMinDarkElixir)
$g_abFilterMeetTrophyEnable[$DB] =(GUICtrlRead($g_hChkDBMeetTrophy) = $GUI_CHECKED)
$g_aiFilterMeetTrophyMin[$DB] = GUICtrlRead($g_hTxtDBMinTrophy)
$g_aiFilterMeetTrophyMax[$DB] = GUICtrlRead($g_hTxtDBMaxTrophy)
$g_abFilterMeetTH[$DB] =(GUICtrlRead($g_hChkDBMeetTH) = $GUI_CHECKED)
$g_aiFilterMeetTHMin[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBTH)
$g_aiMaxTH[$DB] = $g_asTHText[$g_aiFilterMeetTHMin[$DB]]
$g_abFilterMeetTHOutsideEnable[$DB] =(GUICtrlRead($g_hChkDBMeetTHO) = $GUI_CHECKED)
$g_abFilterMaxMortarEnable[$DB] =(GUICtrlRead($g_ahChkMaxMortar[$DB]) = $GUI_CHECKED)
$g_abFilterMaxWizTowerEnable[$DB] =(GUICtrlRead($g_ahChkMaxWizTower[$DB]) = $GUI_CHECKED)
$g_abFilterMaxAirDefenseEnable[$DB] =(GUICtrlRead($g_ahChkMaxAirDefense[$DB]) = $GUI_CHECKED)
$g_abFilterMaxXBowEnable[$DB] =(GUICtrlRead($g_ahChkMaxXBow[$DB]) = $GUI_CHECKED)
$g_abFilterMaxInfernoEnable[$DB] =(GUICtrlRead($g_ahChkMaxInferno[$DB]) = $GUI_CHECKED)
$g_abFilterMaxEagleEnable[$DB] =(GUICtrlRead($g_ahChkMaxEagle[$DB]) = $GUI_CHECKED)
$g_aiFilterMaxMortarLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakMortar[$DB])
$g_aiFilterMaxWizTowerLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakWizTower[$DB])
$g_aiFilterMaxAirDefenseLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakAirDefense[$DB])
$g_aiFilterMaxXBowLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakXBow[$DB])
$g_aiFilterMaxInfernoLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakInferno[$DB])
$g_aiFilterMaxEagleLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakEagle[$DB])
$g_abFilterMeetOneConditionEnable[$DB] =(GUICtrlRead($g_ahChkMeetOne[$DB]) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_28_LB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkABActivateSearches, $g_abSearchSearchesEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtABSearchesMin, $g_aiSearchSearchesMin[$LB])
GUICtrlSetData($g_hTxtABSearchesMax, $g_aiSearchSearchesMax[$LB])
GUICtrlSetState($g_hChkABActivateTropies, $g_abSearchTropiesEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkABActivateTropies()
GUICtrlSetData($g_hTxtABTropiesMin, $g_aiSearchTrophiesMin[$LB])
GUICtrlSetData($g_hTxtABTropiesMax, $g_aiSearchTrophiesMax[$LB])
GUICtrlSetState($g_hChkABActivateCamps, $g_abSearchCampsEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkABActivateCamps()
GUICtrlSetData($g_hTxtABArmyCamps, $g_aiSearchCampsPct[$LB])
chkABActivateSearches()
GUICtrlSetState($g_hChkActivebase, $g_abAttackTypeEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABKingWait, BitAND($g_aiSearchHeroWaitEnable[$LB], $eHeroKing) = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABQueenWait, BitAND($g_aiSearchHeroWaitEnable[$LB], $eHeroQueen) = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABWardenWait, BitAND($g_aiSearchHeroWaitEnable[$LB], $eHeroWarden) = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABNotWaitHeroes, $g_aiSearchNotWaitHeroesEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
$g_iHeroWaitAttackNoBit[$LB][0] = GUICtrlRead($g_hChkABKingWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$LB][1] = GUICtrlRead($g_hChkABQueenWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$LB][2] = GUICtrlRead($g_hChkABWardenWait) = $GUI_CHECKED ? 1 : 0
GUICtrlSetState($g_hChkABSpellsWait, $g_abSearchSpellsWaitEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkABSpellsWait()
GUICtrlSetState($g_hChkABWaitForCastleSpell, $g_abSearchCastleSpellsWaitEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbABWaitForCastleSpell, $g_aiSearchCastleSpellsWaitRegular[$LB])
_GUICtrlComboBox_SetCurSel($g_hCmbABWaitForCastleSpell2, $g_aiSearchCastleSpellsWaitDark[$LB])
cmbABWaitForCCSpell()
chkABWaitForCCSpell()
GUICtrlSetState($g_hChkABWaitForCastleTroops, $g_abSearchCastleTroopsWaitEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbABMeetGE, $g_aiFilterMeetGE[$LB])
GUICtrlSetData($g_hTxtABMinGold, $g_aiFilterMinGold[$LB])
GUICtrlSetData($g_hTxtABMinElixir, $g_aiFilterMinElixir[$LB])
GUICtrlSetData($g_hTxtABMinGoldPlusElixir, $g_aiFilterMinGoldPlusElixir[$LB])
cmbABGoldElixir()
GUICtrlSetState($g_hChkABMeetDE, $g_abFilterMeetDEEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtABMinDarkElixir, $g_aiFilterMeetDEMin[$LB])
chkABMeetDE()
GUICtrlSetState($g_hChkABMeetTrophy, $g_abFilterMeetTrophyEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtABMinTrophy, $g_aiFilterMeetTrophyMin[$LB])
GUICtrlSetData($g_hTxtABMaxTrophy, $g_aiFilterMeetTrophyMax[$LB])
chkABMeetTrophy()
GUICtrlSetState($g_hChkABMeetTH, $g_abFilterMeetTH[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbABTH, $g_aiFilterMeetTHMin[$LB])
$g_aiMaxTH[$LB] = $g_asTHText[$g_aiFilterMeetTHMin[$LB]]
chkABMeetTH()
CmbABTH()
GUICtrlSetState($g_hChkABMeetTHO, $g_abFilterMeetTHOutsideEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxMortar[$LB], $g_abFilterMaxMortarEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxWizTower[$LB], $g_abFilterMaxWizTowerEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxAirDefense[$LB], $g_abFilterMaxAirDefenseEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxXBow[$LB], $g_abFilterMaxXBowEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxInferno[$LB], $g_abFilterMaxInfernoEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxEagle[$LB], $g_abFilterMaxEagleEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakMortar[$LB], $g_aiFilterMaxMortarLevel[$LB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakWizTower[$LB], $g_aiFilterMaxWizTowerLevel[$LB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakAirDefense[$LB], $g_aiFilterMaxAirDefenseLevel[$LB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakXBow[$LB], $g_aiFilterMaxXBowLevel[$LB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakInferno[$LB], $g_aiFilterMaxInfernoLevel[$LB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakEagle[$LB], $g_aiFilterMaxEagleLevel[$LB])
chkABWeakBase()
GUICtrlSetState($g_ahChkMeetOne[$LB], $g_abFilterMeetOneConditionEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_abAttackTypeEnable[$LB] =(GUICtrlRead($g_hChkActivebase) = $GUI_CHECKED)
$g_abSearchSearchesEnable[$LB] =(GUICtrlRead($g_hChkABActivateSearches) = $GUI_CHECKED)
$g_aiSearchSearchesMin[$LB] = GUICtrlRead($g_hTxtABSearchesMin)
$g_aiSearchSearchesMax[$LB] = GUICtrlRead($g_hTxtABSearchesMax)
$g_abSearchTropiesEnable[$LB] =(GUICtrlRead($g_hChkABActivateTropies) = $GUI_CHECKED)
$g_aiSearchTrophiesMin[$LB] = GUICtrlRead($g_hTxtABTropiesMin)
$g_aiSearchTrophiesMax[$LB] = GUICtrlRead($g_hTxtABTropiesMax)
$g_abSearchCampsEnable[$LB] =(GUICtrlRead($g_hChkABActivateCamps) = $GUI_CHECKED)
$g_aiSearchCampsPct[$LB] = Int(GUICtrlRead($g_hTxtABArmyCamps))
$g_iHeroWaitAttackNoBit[$LB][0] = GUICtrlRead($g_hChkABKingWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$LB][1] = GUICtrlRead($g_hChkABQueenWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$LB][2] = GUICtrlRead($g_hChkABWardenWait) = $GUI_CHECKED ? 1 : 0
$g_aiSearchNotWaitHeroesEnable[$LB] = GUICtrlRead($g_hChkABNotWaitHeroes) = $GUI_CHECKED ? 1 : 0
ChkNotWaitHeroes()
$g_abSearchSpellsWaitEnable[$LB] =(GUICtrlRead($g_hChkABSpellsWait) = $GUI_CHECKED)
$g_abSearchCastleSpellsWaitEnable[$LB] =(GUICtrlRead($g_hChkABWaitForCastleSpell) = $GUI_CHECKED)
$g_aiSearchCastleSpellsWaitRegular[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABWaitForCastleSpell)
$g_aiSearchCastleSpellsWaitDark[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABWaitForCastleSpell2)
$g_abSearchCastleTroopsWaitEnable[$LB] =(GUICtrlRead($g_hChkABWaitForCastleTroops) = $GUI_CHECKED)
$g_aiFilterMeetGE[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABMeetGE)
$g_aiFilterMinGold[$LB] = GUICtrlRead($g_hTxtABMinGold)
$g_aiFilterMinElixir[$LB] = GUICtrlRead($g_hTxtABMinElixir)
$g_aiFilterMinGoldPlusElixir[$LB] = GUICtrlRead($g_hTxtABMinGoldPlusElixir)
$g_abFilterMeetDEEnable[$LB] =(GUICtrlRead($g_hChkABMeetDE) = $GUI_CHECKED)
$g_aiFilterMeetDEMin[$LB] = GUICtrlRead($g_hTxtABMinDarkElixir)
$g_abFilterMeetTrophyEnable[$LB] =(GUICtrlRead($g_hChkABMeetTrophy) = $GUI_CHECKED)
$g_aiFilterMeetTrophyMin[$LB] = GUICtrlRead($g_hTxtABMinTrophy)
$g_aiFilterMeetTrophyMax[$LB] = GUICtrlRead($g_hTxtABMaxTrophy)
$g_abFilterMeetTH[$LB] =(GUICtrlRead($g_hChkABMeetTH) = $GUI_CHECKED)
$g_aiFilterMeetTHMin[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABTH)
$g_aiMaxTH[$LB] = $g_asTHText[$g_aiFilterMeetTHMin[$LB]]
$g_abFilterMeetTHOutsideEnable[$LB] =(GUICtrlRead($g_hChkABMeetTHO) = $GUI_CHECKED)
$g_abFilterMaxMortarEnable[$LB] =(GUICtrlRead($g_ahChkMaxMortar[$LB]) = $GUI_CHECKED)
$g_abFilterMaxWizTowerEnable[$LB] =(GUICtrlRead($g_ahChkMaxWizTower[$LB]) = $GUI_CHECKED)
$g_abFilterMaxAirDefenseEnable[$LB] =(GUICtrlRead($g_ahChkMaxAirDefense[$LB]) = $GUI_CHECKED)
$g_abFilterMaxXBowEnable[$LB] =(GUICtrlRead($g_ahChkMaxXBow[$LB]) = $GUI_CHECKED)
$g_abFilterMaxInfernoEnable[$LB] =(GUICtrlRead($g_ahChkMaxInferno[$LB]) = $GUI_CHECKED)
$g_abFilterMaxEagleEnable[$LB] =(GUICtrlRead($g_ahChkMaxEagle[$LB]) = $GUI_CHECKED)
$g_aiFilterMaxMortarLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakMortar[$LB])
$g_aiFilterMaxWizTowerLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakWizTower[$LB])
$g_aiFilterMaxAirDefenseLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakAirDefense[$LB])
$g_aiFilterMaxXBowLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakXBow[$LB])
$g_aiFilterMaxInfernoLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakInferno[$LB])
$g_aiFilterMaxEagleLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakEagle[$LB])
$g_abFilterMeetOneConditionEnable[$LB] =(GUICtrlRead($g_ahChkMeetOne[$LB]) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_28_TS($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkTSActivateSearches, $g_abSearchSearchesEnable[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtTSSearchesMin, $g_aiSearchSearchesMin[$TS])
GUICtrlSetData($g_hTxtTSSearchesMax, $g_aiSearchSearchesMax[$TS])
GUICtrlSetState($g_hChkTSActivateTropies, $g_abSearchTropiesEnable[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTSActivateTropies()
GUICtrlSetData($g_hTxtTSTropiesMin, $g_aiSearchTrophiesMin[$TS])
GUICtrlSetData($g_hTxtTSTropiesMax, $g_aiSearchTrophiesMax[$TS])
GUICtrlSetState($g_hChkTSActivateCamps, $g_abSearchCampsEnable[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTSActivateCamps()
GUICtrlSetData($g_hTxtTSArmyCamps, $g_aiSearchCampsPct[$TS])
chkTSActivateSearches()
GUICtrlSetState($g_hChkTHSnipe, $g_abAttackTypeEnable[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbTSMeetGE, $g_aiFilterMeetGE[$TS])
GUICtrlSetData($g_hTxtTSMinGold, $g_aiFilterMinGold[$TS])
GUICtrlSetData($g_hTxtTSMinElixir, $g_aiFilterMinElixir[$TS])
GUICtrlSetData($g_hTxtTSMinGoldPlusElixir, $g_aiFilterMinGoldPlusElixir[$TS])
cmbTSGoldElixir()
GUICtrlSetState($g_hChkTSMeetDE, $g_abFilterMeetDEEnable[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtTSMinDarkElixir, $g_aiFilterMeetDEMin[$TS])
chkTSMeetDE()
GUICtrlSetData($g_hTxtSWTTiles, $g_iAtkTSAddTilesWhileTrain)
GUICtrlSetData($g_hTxtTHaddTiles, $g_iAtkTSAddTilesFullTroops)
Case "Save"
$g_abAttackTypeEnable[$TS] =(GUICtrlRead($g_hChkTHSnipe) = $GUI_CHECKED)
$g_abSearchSearchesEnable[$TS] =(GUICtrlRead($g_hChkTSActivateSearches) = $GUI_CHECKED)
$g_aiSearchSearchesMin[$TS] = GUICtrlRead($g_hTxtTSSearchesMin)
$g_aiSearchSearchesMax[$TS] = GUICtrlRead($g_hTxtTSSearchesMax)
$g_abSearchTropiesEnable[$TS] =(GUICtrlRead($g_hChkTSActivateTropies) = $GUI_CHECKED)
$g_aiSearchTrophiesMin[$TS] = GUICtrlRead($g_hTxtTSTropiesMin)
$g_aiSearchTrophiesMax[$TS] = GUICtrlRead($g_hTxtTSTropiesMax)
$g_abSearchCampsEnable[$TS] =(GUICtrlRead($g_hChkTSActivateCamps) = $GUI_CHECKED)
$g_aiSearchCampsPct[$TS] = Int(GUICtrlRead($g_hTxtTSArmyCamps))
$g_aiFilterMeetGE[$TS] = _GUICtrlComboBox_GetCurSel($g_hCmbTSMeetGE)
$g_aiFilterMinGold[$TS] = GUICtrlRead($g_hTxtTSMinGold)
$g_aiFilterMinElixir[$TS] = GUICtrlRead($g_hTxtTSMinElixir)
$g_aiFilterMinGoldPlusElixir[$TS] = GUICtrlRead($g_hTxtTSMinGoldPlusElixir)
$g_abFilterMeetDEEnable[$TS] =(GUICtrlRead($g_hChkTSMeetDE) = $GUI_CHECKED)
$g_aiFilterMeetDEMin[$TS] = GUICtrlRead($g_hTxtTSMinDarkElixir)
$g_iAtkTSAddTilesWhileTrain = GUICtrlRead($g_hTxtSWTTiles)
$g_iAtkTSAddTilesFullTroops = GUICtrlRead($g_hTxtTHaddTiles)
EndSwitch
EndFunc
Func ApplyConfig_600_29($TypeReadSave)
Switch $TypeReadSave
Case "Read"
radHerosApply()
GUICtrlSetState($g_hChkAttackPlannerEnable, $g_bAttackPlannerEnable = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, $g_bAttackPlannerCloseCoC = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackPlannerCloseAll, $g_bAttackPlannerCloseAll = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackPlannerSuspendComputer, $g_bAttackPlannerSuspendComputer = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackPlannerRandom, $g_bAttackPlannerRandomEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbAttackPlannerRandom,($g_iAttackPlannerRandomTime - 1))
GUICtrlSetState($g_hChkAttackPlannerDayLimit, $g_bAttackPlannerDayLimit = True ? $GUI_CHECKED : $GUI_UNCHECKED)
chkAttackPlannerEnable()
GUICtrlSetData($g_hCmbAttackPlannerDayMin, $g_iAttackPlannerDayMin)
GUICtrlSetData($g_hCmbAttackPlannerDayMax, $g_iAttackPlannerDayMax)
_cmbAttackPlannerDayLimit()
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $g_abPlannedAttackWeekDays[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
For $i = 0 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $g_abPlannedattackHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
GUICtrlSetState($g_hChkDropCCHoursEnable, $g_bPlannedDropCCHoursEnable = True ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDropCCHoursEnable()
For $i = 0 To 23
GUICtrlSetState($g_ahChkDropCCHours[$i], $g_abPlannedDropCCHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
Case "Save"
If GUICtrlRead($g_hRadAutoQueenAbility) = $GUI_CHECKED Then
$g_iActivateQueen = 0
ElseIf GUICtrlRead($g_hRadManQueenAbility) = $GUI_CHECKED Then
$g_iActivateQueen = 1
ElseIf GUICtrlRead($g_hRadBothQueenAbility) = $GUI_CHECKED Then
$g_iActivateQueen = 2
EndIf
$g_iDelayActivateQueen = Int(GUICtrlRead($g_hTxtManQueenAbility) * 1000)
If GUICtrlRead($g_hRadAutoKingAbility) = $GUI_CHECKED Then
$g_iActivateKing = 0
ElseIf GUICtrlRead($g_hRadManKingAbility) = $GUI_CHECKED Then
$g_iActivateKing = 1
ElseIf GUICtrlRead($g_hRadBothKingAbility) = $GUI_CHECKED Then
$g_iActivateKing = 2
EndIf
$g_iDelayActivateKing = Int(GUICtrlRead($g_hTxtManKingAbility) * 1000)
If GUICtrlRead($g_hRadAutoWardenAbility) = $GUI_CHECKED Then
$g_iActivateWarden = 0
ElseIf GUICtrlRead($g_hRadManWardenAbility) = $GUI_CHECKED Then
$g_iActivateWarden = 1
ElseIf GUICtrlRead($g_hRadBothWardenAbility) = $GUI_CHECKED Then
$g_iActivateWarden = 2
EndIf
$g_iDelayActivateWarden = Int(GUICtrlRead($g_hTxtManWardenAbility) * 1000)
$g_bAttackPlannerEnable =(GUICtrlRead($g_hChkAttackPlannerEnable) = $GUI_CHECKED)
$g_bAttackPlannerCloseCoC =(GUICtrlRead($g_hChkAttackPlannerCloseCoC) = $GUI_CHECKED)
$g_bAttackPlannerCloseAll =(GUICtrlRead($g_hChkAttackPlannerCloseAll) = $GUI_CHECKED)
$g_bAttackPlannerSuspendComputer =(GUICtrlRead($g_hChkAttackPlannerSuspendComputer) = $GUI_CHECKED)
$g_bAttackPlannerRandomEnable =(GUICtrlRead($g_hChkAttackPlannerRandom) = $GUI_CHECKED)
$g_iAttackPlannerRandomTime =(_GUICtrlComboBox_GetCurSel($g_hCmbAttackPlannerRandom) + 1)
$g_bAttackPlannerDayLimit =(GUICtrlRead($g_hChkAttackPlannerDayLimit) = $GUI_CHECKED)
$g_iAttackPlannerDayMin = GUICtrlRead($g_hCmbAttackPlannerDayMin)
$g_iAttackPlannerDayMax = GUICtrlRead($g_hCmbAttackPlannerDayMax)
Local $string = ""
For $i = 0 To 6
$g_abPlannedAttackWeekDays[$i] =(GUICtrlRead($g_ahChkAttackWeekdays[$i]) = $GUI_CHECKED)
Next
Local $string = ""
For $i = 0 To 23
$g_abPlannedattackHours[$i] =(GUICtrlRead($g_ahChkAttackHours[$i]) = $GUI_CHECKED)
Next
$g_bPlannedDropCCHoursEnable =(GUICtrlRead($g_hChkDropCCHoursEnable) = $GUI_CHECKED)
Local $string = ""
For $i = 0 To 23
$g_abPlannedDropCCHours[$i] = GUICtrlRead($g_ahChkDropCCHours[$i]) = $GUI_CHECKED ? 1 : 0
Next
EndSwitch
EndFunc
Func ApplyConfig_600_29_DB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbDBAlgorithm, $g_aiAttackAlgorithm[$DB])
cmbDBAlgorithm()
_GUICtrlComboBox_SetCurSel($g_hCmbDBSelectTroop, $g_aiAttackTroopSelection[$DB])
GUICtrlSetState($g_hChkDBKingAttack, BitAND($g_aiAttackUseHeroes[$DB], $eHeroKing) = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBQueenAttack, BitAND($g_aiAttackUseHeroes[$DB], $eHeroQueen) = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBWardenAttack, BitAND($g_aiAttackUseHeroes[$DB], $eHeroWarden) = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkDBKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkDBQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkDBWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$DB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
GUICtrlSetState($g_hChkDBDropCC, $g_abAttackDropCC[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBLightSpell, $g_abAttackUseLightSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBHealSpell, $g_abAttackUseHealSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBRageSpell, $g_abAttackUseRageSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBJumpSpell, $g_abAttackUseJumpSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBFreezeSpell, $g_abAttackUseFreezeSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBCloneSpell, $g_abAttackUseCloneSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBPoisonSpell, $g_abAttackUsePoisonSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBEarthquakeSpell, $g_abAttackUseEarthquakeSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBHasteSpell, $g_abAttackUseHasteSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBSkeletonSpell, $g_abAttackUseSkeletonSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTHSnipeBeforeDBEnable, $g_bTHSnipeBeforeEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTHSnipeBeforeDBEnable()
GUICtrlSetData($g_hTxtTHSnipeBeforeDBTiles, $g_iTHSnipeBeforeTiles[$DB])
LoadDBSnipeAttacks()
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeDBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeDBScript, $g_iTHSnipeBeforeScript[$DB]))
Case "Save"
$g_aiAttackAlgorithm[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBAlgorithm)
$g_aiAttackTroopSelection[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBSelectTroop)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkDBKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkDBQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkDBWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$DB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
$g_abAttackDropCC[$DB] =(GUICtrlRead($g_hChkDBDropCC) = $GUI_CHECKED)
$g_abAttackUseLightSpell[$DB] =(GUICtrlRead($g_hChkDBLightSpell) = $GUI_CHECKED)
$g_abAttackUseHealSpell[$DB] =(GUICtrlRead($g_hChkDBHealSpell) = $GUI_CHECKED)
$g_abAttackUseRageSpell[$DB] =(GUICtrlRead($g_hChkDBRageSpell) = $GUI_CHECKED)
$g_abAttackUseJumpSpell[$DB] =(GUICtrlRead($g_hChkDBJumpSpell) = $GUI_CHECKED)
$g_abAttackUseFreezeSpell[$DB] =(GUICtrlRead($g_hChkDBFreezeSpell) = $GUI_CHECKED)
$g_abAttackUsePoisonSpell[$DB] =(GUICtrlRead($g_hChkDBPoisonSpell) = $GUI_CHECKED)
$g_abAttackUseEarthquakeSpell[$DB] =(GUICtrlRead($g_hChkDBEarthquakeSpell) = $GUI_CHECKED)
$g_abAttackUseHasteSpell[$DB] =(GUICtrlRead($g_hChkDBHasteSpell) = $GUI_CHECKED)
$g_abAttackUseCloneSpell[$DB] =(GUICtrlRead($g_hChkDBCloneSpell) = $GUI_CHECKED)
$g_abAttackUseSkeletonSpell[$DB] =(GUICtrlRead($g_hChkDBSkeletonSpell) = $GUI_CHECKED)
$g_bTHSnipeBeforeEnable[$DB] =(GUICtrlRead($g_hChkTHSnipeBeforeDBEnable) = $GUI_CHECKED)
$g_iTHSnipeBeforeTiles[$DB] = GUICtrlRead($g_hTxtTHSnipeBeforeDBTiles)
$g_iTHSnipeBeforeScript[$DB] = GUICtrlRead($g_hCmbTHSnipeBeforeDBScript)
EndSwitch
ApplyConfig_600_29_DB_Standard($TypeReadSave)
ApplyConfig_600_29_DB_Scripted($TypeReadSave)
ApplyConfig_600_29_DB_Milking($TypeReadSave)
EndFunc
Func ApplyConfig_600_29_DB_Standard($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbStandardDropOrderDB, $g_aiAttackStdDropOrder[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardDropSidesDB, $g_aiAttackStdDropSides[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardUnitDelayDB, $g_aiAttackStdUnitDelay[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardWaveDelayDB, $g_aiAttackStdWaveDelay[$DB])
GUICtrlSetState($g_hChkRandomSpeedAtkDB, $g_abAttackStdRandomizeDelay[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkRandomSpeedAtkDB()
GUICtrlSetState($g_hChkSmartAttackRedAreaDB, $g_abAttackStdSmartAttack[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkSmartAttackRedAreaDB()
_GUICtrlComboBox_SetCurSel($g_hCmbSmartDeployDB, $g_aiAttackStdSmartDeploy[$DB])
GUICtrlSetState($g_hChkAttackNearGoldMineDB, $g_abAttackStdSmartNearCollectors[$DB][0] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackNearElixirCollectorDB, $g_abAttackStdSmartNearCollectors[$DB][1] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackNearDarkElixirDrillDB, $g_abAttackStdSmartNearCollectors[$DB][2] ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_aiAttackStdDropOrder[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropOrderDB)
$g_aiAttackStdDropSides[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropSidesDB)
$g_aiAttackStdUnitDelay[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardUnitDelayDB)
$g_aiAttackStdWaveDelay[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardWaveDelayDB)
$g_abAttackStdRandomizeDelay[$DB] =(GUICtrlRead($g_hChkRandomSpeedAtkDB) = $GUI_CHECKED)
$g_abAttackStdSmartAttack[$DB] =(GUICtrlRead($g_hChkSmartAttackRedAreaDB) = $GUI_CHECKED)
$g_aiAttackStdSmartDeploy[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbSmartDeployDB)
$g_abAttackStdSmartNearCollectors[$DB][0] =(GUICtrlRead($g_hChkAttackNearGoldMineDB) = $GUI_CHECKED)
$g_abAttackStdSmartNearCollectors[$DB][1] =(GUICtrlRead($g_hChkAttackNearElixirCollectorDB) = $GUI_CHECKED)
$g_abAttackStdSmartNearCollectors[$DB][2] =(GUICtrlRead($g_hChkAttackNearDarkElixirDrillDB) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_29_DB_Scripted($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbScriptRedlineImplDB, $g_aiAttackScrRedlineRoutine[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbScriptDroplineDB, $g_aiAttackScrDroplineEdge[$DB])
PopulateComboScriptsFilesDB()
Local $tempindex = _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameDB, $g_sAttackScrScriptName[$DB])
If $tempindex = -1 Then
$tempindex = 0
SetLog("Previous saved Scripted Attack not found (deleted, renamed?)", $COLOR_ERROR)
SetLog("Automatically setted a default script, please check your config", $COLOR_ERROR)
EndIf
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameDB, $tempindex)
cmbScriptNameDB()
cmbScriptRedlineImplDB()
Case "Save"
$g_aiAttackScrRedlineRoutine[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptRedlineImplDB)
$g_aiAttackScrDroplineEdge[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptDroplineDB)
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameDB, $indexofscript, $scriptname)
$g_sAttackScrScriptName[$DB] = $scriptname
IniWriteS($g_sProfileConfigPath, "attack", "ScriptDB", $g_sAttackScrScriptName[$DB])
EndSwitch
EndFunc
Func ApplyConfig_600_29_DB_Milking($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbMilkAttackType, $g_iMilkAttackType = 1 ? 1 : 0)
For $i = 0 To 8
_GUICtrlComboBox_SetCurSel($g_hCmbMilkLvl[$i + 4], $g_aiMilkFarmElixirParam[$i] + 1)
Next
GUICtrlSetState($g_hChkAtkElixirExtractors, $g_bMilkFarmLocateElixir ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAtkGoldMines, $g_bMilkFarmLocateMine ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbAtkGoldMinesLevel, $g_iMilkFarmMineParam - 1)
GUICtrlSetState($g_hChkAtkDarkDrills, $g_bMilkFarmLocateDrill ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbAtkDarkDrillsLevel, $g_iMilkFarmDrillParam - 1)
_GUICtrlComboBox_SetCurSel($g_hCmbRedlineResDistance, $g_iMilkFarmResMaxTilesFromBorder)
GUICtrlSetState($g_hChkAttackMinesIfGold, $g_bMilkFarmAttackGoldMines ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackMinesIfElixir, $g_bMilkFarmAttackElixirExtractors ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackMinesIfDarkElixir, $g_bMilkFarmAttackDarkDrills ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtAttackMinesIfGold, $g_iMilkFarmLimitGold)
GUICtrlSetData($g_hTxtAttackMinesIfElixir, $g_iMilkFarmLimitElixir)
GUICtrlSetData($g_hTxtAttackMinesIfDarkElixir, $g_iMilkFarmLimitDark)
chkAttackMinesifGold()
chkAttackMinesifelixir()
chkAttackMinesifdarkElixir()
GUICtrlSetData($g_hTxtLowerXWave, $g_iMilkFarmTroopForWaveMin)
GUICtrlSetData($g_hTxtUpperXWave, $g_iMilkFarmTroopForWaveMax)
GUICtrlSetData($g_hTxtMaxWaves, $g_iMilkFarmTroopMaxWaves)
GUICtrlSetData($g_hTxtLowerDelayWaves, $g_iMilkFarmDelayFromWavesMin)
GUICtrlSetData($g_hTxtUpperDelayWaves, $g_iMilkFarmDelayFromWavesMax)
_GUICtrlComboBox_SetCurSel($g_hCmbMilkingAttackDropGoblinAlgorithm, $g_iMilkingAttackDropGoblinAlgorithm = 1 ? 1 : 0)
_GUICtrlComboBox_SetCurSel($g_hCmbStructureOrder, $g_iMilkingAttackStructureOrder)
GUICtrlSetState($g_hChkStructureDestroyedBeforeAttack, $g_bMilkingAttackCheckStructureDestroyedBeforeAttack ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkStructureDestroyedAfterAttack, $g_bMilkingAttackCheckStructureDestroyedAfterAttack ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkMilkAfterAttackTHSnipe, $g_bMilkAttackAfterTHSnipeEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkMilkAfterAttackTHSnipe()
GUICtrlSetData($g_hTxtMaxTilesMilk, $g_iMilkFarmTHMaxTilesFromBorder)
Local $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sTHSnipeAttacksPath & "\*.csv")
Local $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
GUICtrlSetData($g_hCmbMilkSnipeAlgorithm, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbMilkSnipeAlgorithm, _GUICtrlComboBox_FindStringExact($g_hCmbMilkSnipeAlgorithm, $g_sMilkFarmAlgorithmTh))
GUICtrlSetState($g_hChkSnipeIfNoElixir, $g_bMilkFarmSnipeEvenIfNoExtractorsFound ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkMilkAfterAttackScripted, $g_bMilkAttackAfterScriptedAtkEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
PopulateComboMilkingCSVScriptsFiles()
Local $tempindex = _GUICtrlComboBox_FindStringExact($g_hCmbMilkingCSVScriptName, $g_sMilkAttackCSVscript)
If $tempindex = -1 Then
$tempindex = 0
SetLog("Previous saved Milking Scripted Attack not found (deleted, renamed?)", $COLOR_ERROR)
SetLog("Automatically setted a default script, please check your config", $COLOR_ERROR)
EndIf
_GUICtrlComboBox_SetCurSel($g_hCmbMilkingCSVScriptName, $tempindex)
GUICtrlSetState($g_hChkMilkFarmForceTolerance, $g_bMilkFarmForceToleranceEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkMilkFarmForcetolerance()
GUICtrlSetData($g_hTxtMilkFarmForceToleranceNormal, $g_iMilkFarmForceToleranceNormal)
GUICtrlSetData($g_hTxtMilkFarmForceToleranceBoosted, $g_iMilkFarmForceToleranceBoosted)
GUICtrlSetData($g_hTxtMilkFarmForceToleranceDestroyed, $g_iMilkFarmForceToleranceDestroyed)
If $g_bDevMode = True Then
GUICtrlSetState($g_hGrpMilkingDebug, $GUI_SHOW)
GUICtrlSetState($g_hChkMilkingDebugIMG, $GUI_SHOW)
GUICtrlSetState($g_hChkMilkingDebugVillage, $GUI_SHOW)
GUICtrlSetState($g_hChkMilkingDebugFullSearch, $GUI_SHOW)
GUICtrlSetState($g_hChkMilkingDebugIMG, $g_bDebugResourcesOffset ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkMilkingDebugVillage, $g_bDebugMilkingIMGmake ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkMilkingDebugFullSearch, $g_bDebugContinueSearchElixir ? $GUI_CHECKED : $GUI_UNCHECKED)
EndIf
Case "Save"
$g_iMilkAttackType = _GUICtrlComboBox_GetCurSel($g_hCmbMilkAttackType)
For $i = 0 To 8
$g_aiMilkFarmElixirParam[$i] = _GUICtrlComboBox_GetCurSel($g_hCmbMilkLvl[$i + 4]) - 1
Next
$g_bMilkFarmLocateElixir =(GUICtrlRead($g_hChkAtkElixirExtractors) = $GUI_CHECKED)
$g_bMilkFarmLocateMine =(GUICtrlRead($g_hChkAtkGoldMines) = $GUI_CHECKED)
$g_iMilkFarmMineParam = _GUICtrlComboBox_GetCurSel($g_hCmbAtkGoldMinesLevel) + 1
$g_bMilkFarmLocateDrill =(GUICtrlRead($g_hChkAtkDarkDrills) = $GUI_CHECKED)
$g_iMilkFarmDrillParam = _GUICtrlComboBox_GetCurSel($g_hCmbAtkDarkDrillsLevel) + 1
$g_iMilkFarmResMaxTilesFromBorder = _GUICtrlComboBox_GetCurSel($g_hCmbRedlineResDistance)
$g_bMilkFarmAttackGoldMines =(GUICtrlRead($g_hChkAttackMinesIfGold) = $GUI_CHECKED)
$g_bMilkFarmAttackElixirExtractors =(GUICtrlRead($g_hChkAttackMinesIfElixir) = $GUI_CHECKED)
$g_bMilkFarmAttackDarkDrills =(GUICtrlRead($g_hChkAttackMinesIfDarkElixir) = $GUI_CHECKED)
$g_iMilkFarmLimitGold = GUICtrlRead($g_hTxtAttackMinesIfGold)
$g_iMilkFarmLimitElixir = GUICtrlRead($g_hTxtAttackMinesIfElixir)
$g_iMilkFarmLimitDark = GUICtrlRead($g_hTxtAttackMinesIfDarkElixir)
$g_iMilkFarmTroopForWaveMin = GUICtrlRead($g_hTxtLowerXWave)
$g_iMilkFarmTroopForWaveMax = GUICtrlRead($g_hTxtUpperXWave)
$g_iMilkFarmTroopMaxWaves = GUICtrlRead($g_hTxtMaxWaves)
$g_iMilkFarmDelayFromWavesMin = GUICtrlRead($g_hTxtLowerDelayWaves)
$g_iMilkFarmDelayFromWavesMax = GUICtrlRead($g_hTxtUpperDelayWaves)
$g_iMilkingAttackDropGoblinAlgorithm = _GUICtrlComboBox_GetCurSel($g_hCmbMilkingAttackDropGoblinAlgorithm)
$g_iMilkingAttackStructureOrder = _GUICtrlComboBox_GetCurSel($g_hCmbStructureOrder)
$g_bMilkingAttackCheckStructureDestroyedBeforeAttack =(GUICtrlRead($g_hChkStructureDestroyedBeforeAttack) = $GUI_CHECKED)
$g_bMilkingAttackCheckStructureDestroyedAfterAttack =(GUICtrlRead($g_hChkStructureDestroyedAfterAttack) = $GUI_CHECKED)
$g_bMilkAttackAfterTHSnipeEnable =(GUICtrlRead($g_hChkMilkAfterAttackTHSnipe) = $GUI_CHECKED)
$g_iMilkFarmTHMaxTilesFromBorder = GUICtrlRead($g_hTxtMaxTilesMilk)
$g_sMilkFarmAlgorithmTh = GUICtrlRead($g_hCmbMilkSnipeAlgorithm)
$g_bMilkFarmSnipeEvenIfNoExtractorsFound =(GUICtrlRead($g_hChkSnipeIfNoElixir) = $GUI_CHECKED)
$g_bMilkAttackAfterScriptedAtkEnable =(GUICtrlRead($g_hChkMilkAfterAttackScripted) = $GUI_CHECKED)
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbMilkingCSVScriptName)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbMilkingCSVScriptName, $indexofscript, $scriptname)
$g_sMilkAttackCSVscript = $scriptname
$g_bMilkFarmForceToleranceEnable =(GUICtrlRead($g_hChkMilkFarmForceTolerance) = $GUI_CHECKED)
$g_iMilkFarmForceToleranceNormal = GUICtrlRead($g_hTxtMilkFarmForceToleranceNormal)
$g_iMilkFarmForceToleranceBoosted = GUICtrlRead($g_hTxtMilkFarmForceToleranceBoosted)
$g_iMilkFarmForceToleranceDestroyed = GUICtrlRead($g_hTxtMilkFarmForceToleranceDestroyed)
If $g_bDevMode Then
$g_bDebugResourcesOffset =(GUICtrlRead($g_hChkMilkingDebugIMG) = $GUI_CHECKED)
$g_bDebugMilkingIMGmake =(GUICtrlRead($g_hChkMilkingDebugVillage) = $GUI_CHECKED)
$g_bDebugContinueSearchElixir =(GUICtrlRead($g_hChkMilkingDebugFullSearch) = $GUI_CHECKED)
EndIf
EndSwitch
EndFunc
Func ApplyConfig_600_29_LB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbABAlgorithm, $g_aiAttackAlgorithm[$LB])
cmbABAlgorithm()
_GUICtrlComboBox_SetCurSel($g_hCmbABSelectTroop, $g_aiAttackTroopSelection[$LB])
GUICtrlSetState($g_hChkABKingAttack, BitAND($g_aiAttackUseHeroes[$LB], $eHeroKing) = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABQueenAttack, BitAND($g_aiAttackUseHeroes[$LB], $eHeroQueen) = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABWardenAttack, BitAND($g_aiAttackUseHeroes[$LB], $eHeroWarden) = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkABKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkABQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkABWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$LB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
GUICtrlSetState($g_hChkABDropCC, $g_abAttackDropCC[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABLightSpell, $g_abAttackUseLightSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABHealSpell, $g_abAttackUseHealSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABRageSpell, $g_abAttackUseRageSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABJumpSpell, $g_abAttackUseJumpSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABFreezeSpell, $g_abAttackUseFreezeSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABCloneSpell, $g_abAttackUseCloneSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABPoisonSpell, $g_abAttackUsePoisonSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABEarthquakeSpell, $g_abAttackUseEarthquakeSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABHasteSpell, $g_abAttackUseHasteSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABSkeletonSpell, $g_abAttackUseSkeletonSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTHSnipeBeforeLBEnable, $g_bTHSnipeBeforeEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTHSnipeBeforeLBEnable()
GUICtrlSetData($g_hTxtTHSnipeBeforeLBTiles, $g_iTHSnipeBeforeTiles[$LB])
LoadABSnipeAttacks()
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeLBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeLBScript, $g_iTHSnipeBeforeScript[$LB]))
Case "Save"
$g_aiAttackAlgorithm[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABAlgorithm)
$g_aiAttackTroopSelection[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABSelectTroop)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkABKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkABQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkABWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$LB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
$g_abAttackDropCC[$LB] =(GUICtrlRead($g_hChkABDropCC) = $GUI_CHECKED)
$g_abAttackUseLightSpell[$LB] =(GUICtrlRead($g_hChkABLightSpell) = $GUI_CHECKED)
$g_abAttackUseHealSpell[$LB] =(GUICtrlRead($g_hChkABHealSpell) = $GUI_CHECKED)
$g_abAttackUseRageSpell[$LB] =(GUICtrlRead($g_hChkABRageSpell) = $GUI_CHECKED)
$g_abAttackUseJumpSpell[$LB] =(GUICtrlRead($g_hChkABJumpSpell) = $GUI_CHECKED)
$g_abAttackUseFreezeSpell[$LB] =(GUICtrlRead($g_hChkABFreezeSpell) = $GUI_CHECKED)
$g_abAttackUseCloneSpell[$LB] =(GUICtrlRead($g_hChkABCloneSpell) = $GUI_CHECKED)
$g_abAttackUsePoisonSpell[$LB] =(GUICtrlRead($g_hChkABPoisonSpell) = $GUI_CHECKED)
$g_abAttackUseEarthquakeSpell[$LB] =(GUICtrlRead($g_hChkABEarthquakeSpell) = $GUI_CHECKED)
$g_abAttackUseHasteSpell[$LB] =(GUICtrlRead($g_hChkABHasteSpell) = $GUI_CHECKED)
$g_abAttackUseSkeletonSpell[$LB] =(GUICtrlRead($g_hChkABSkeletonSpell) = $GUI_CHECKED)
$g_bTHSnipeBeforeEnable[$LB] =(GUICtrlRead($g_hChkTHSnipeBeforeLBEnable) = $GUI_CHECKED)
$g_iTHSnipeBeforeTiles[$LB] = GUICtrlRead($g_hTxtTHSnipeBeforeLBTiles)
$g_iTHSnipeBeforeScript[$LB] = GUICtrlRead($g_hCmbTHSnipeBeforeLBScript)
EndSwitch
ApplyConfig_600_29_LB_Standard($TypeReadSave)
ApplyConfig_600_29_LB_Scripted($TypeReadSave)
EndFunc
Func ApplyConfig_600_29_LB_Standard($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbStandardDropOrderAB, $g_aiAttackStdDropOrder[$LB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardDropSidesAB, $g_aiAttackStdDropSides[$LB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardUnitDelayAB, $g_aiAttackStdUnitDelay[$LB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardWaveDelayAB, $g_aiAttackStdWaveDelay[$LB])
GUICtrlSetState($g_hChkRandomSpeedAtkAB, $g_abAttackStdRandomizeDelay[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkRandomSpeedAtkAB()
GUICtrlSetState($g_hChkSmartAttackRedAreaAB, $g_abAttackStdSmartAttack[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkSmartAttackRedAreaAB()
_GUICtrlComboBox_SetCurSel($g_hCmbSmartDeployAB, $g_aiAttackStdSmartDeploy[$LB])
GUICtrlSetState($g_hChkAttackNearGoldMineAB, $g_abAttackStdSmartNearCollectors[$LB][0] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackNearElixirCollectorAB, $g_abAttackStdSmartNearCollectors[$LB][1] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackNearDarkElixirDrillAB, $g_abAttackStdSmartNearCollectors[$LB][2] ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_aiAttackStdDropOrder[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropOrderAB)
$g_aiAttackStdDropSides[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropSidesAB)
$g_aiAttackStdUnitDelay[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardUnitDelayAB)
$g_aiAttackStdWaveDelay[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardWaveDelayAB)
$g_abAttackStdRandomizeDelay[$LB] =(GUICtrlRead($g_hChkRandomSpeedAtkAB) = $GUI_CHECKED)
$g_abAttackStdSmartAttack[$LB] =(GUICtrlRead($g_hChkSmartAttackRedAreaAB) = $GUI_CHECKED)
$g_aiAttackStdSmartDeploy[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbSmartDeployAB)
$g_abAttackStdSmartNearCollectors[$LB][0] =(GUICtrlRead($g_hChkAttackNearGoldMineAB) = $GUI_CHECKED)
$g_abAttackStdSmartNearCollectors[$LB][1] =(GUICtrlRead($g_hChkAttackNearElixirCollectorAB) = $GUI_CHECKED)
$g_abAttackStdSmartNearCollectors[$LB][2] =(GUICtrlRead($g_hChkAttackNearDarkElixirDrillAB) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_29_LB_Scripted($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbScriptRedlineImplAB, $g_aiAttackScrRedlineRoutine[$LB])
_GUICtrlComboBox_SetCurSel($g_hCmbScriptDroplineAB, $g_aiAttackScrDroplineEdge[$LB])
PopulateComboScriptsFilesAB()
Local $tempindex = _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameAB, $g_sAttackScrScriptName[$LB])
If $tempindex = -1 Then
$tempindex = 0
SetLog("Previous saved Scripted Attack not found (deleted, renamed?)", $COLOR_ERROR)
SetLog("Automatically setted a default script, please check your config", $COLOR_ERROR)
EndIf
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameAB, $tempindex)
cmbScriptNameAB()
cmbScriptRedlineImplAB()
Case "Save"
$g_aiAttackScrRedlineRoutine[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptRedlineImplAB)
$g_aiAttackScrDroplineEdge[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptDroplineAB)
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameAB, $indexofscript, $scriptname)
$g_sAttackScrScriptName[$LB] = $scriptname
IniWriteS($g_sProfileConfigPath, "attack", "ScriptAB", $g_sAttackScrScriptName[$LB])
EndSwitch
EndFunc
Func ApplyConfig_600_29_TS($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbTSSelectTroop, $g_aiAttackTroopSelection[$TS])
GUICtrlSetState($g_hChkTSKingAttack, BitAND($g_aiAttackUseHeroes[$TS], $eHeroKing) = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSQueenAttack, BitAND($g_aiAttackUseHeroes[$TS], $eHeroQueen) = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSWardenAttack, BitAND($g_aiAttackUseHeroes[$TS], $eHeroWarden) = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkTSKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkTSQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkTSWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$TS] = BitOR(Int($temp1), Int($temp2), Int($temp3))
GUICtrlSetState($g_hChkTSDropCC, $g_abAttackDropCC[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSLightSpell, $g_abAttackUseLightSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSHealSpell, $g_abAttackUseHealSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSRageSpell, $g_abAttackUseRageSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSJumpSpell, $g_abAttackUseJumpSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSFreezeSpell, $g_abAttackUseFreezeSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSPoisonSpell, $g_abAttackUsePoisonSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSEarthquakeSpell, $g_abAttackUseEarthquakeSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSHasteSpell, $g_abAttackUseHasteSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
LoadThSnipeAttacks()
_GUICtrlComboBox_SetCurSel($g_hCmbAttackTHType, _GUICtrlComboBox_FindStringExact($g_hCmbAttackTHType, $g_sAtkTSType))
Case "Save"
$g_aiAttackTroopSelection[$TS] = _GUICtrlComboBox_GetCurSel($g_hCmbTSSelectTroop)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkTSKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkTSQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkTSWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$TS] = BitOR(Int($temp1), Int($temp2), Int($temp3))
$g_abAttackDropCC[$TS] =(GUICtrlRead($g_hChkTSDropCC) = $GUI_CHECKED)
$g_abAttackUseLightSpell[$TS] =(GUICtrlRead($g_hChkTSLightSpell) = $GUI_CHECKED)
$g_abAttackUseHealSpell[$TS] =(GUICtrlRead($g_hChkTSHealSpell) = $GUI_CHECKED)
$g_abAttackUseRageSpell[$TS] =(GUICtrlRead($g_hChkTSRageSpell) = $GUI_CHECKED)
$g_abAttackUseJumpSpell[$TS] =(GUICtrlRead($g_hChkTSJumpSpell) = $GUI_CHECKED)
$g_abAttackUseFreezeSpell[$TS] =(GUICtrlRead($g_hChkTSFreezeSpell) = $GUI_CHECKED)
$g_abAttackUsePoisonSpell[$TS] =(GUICtrlRead($g_hChkTSPoisonSpell) = $GUI_CHECKED)
$g_abAttackUseEarthquakeSpell[$TS] =(GUICtrlRead($g_hChkTSEarthquakeSpell) = $GUI_CHECKED)
$g_abAttackUseHasteSpell[$TS] =(GUICtrlRead($g_hChkTSHasteSpell) = $GUI_CHECKED)
$g_sAtkTSType = GUICtrlRead($g_hCmbAttackTHType)
EndSwitch
EndFunc
Func ApplyConfig_600_30($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkShareAttack, $g_bShareAttackEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtShareMinGold, $g_iShareMinGold)
GUICtrlSetData($g_hTxtShareMinElixir, $g_iShareMinElixir)
GUICtrlSetData($g_hTxtShareMinDark, $g_iShareMinDark)
GUICtrlSetData($g_hTxtShareMessage, StringReplace($g_sShareMessage, "|", @CRLF))
chkShareAttack()
GUICtrlSetState($g_hChkTakeLootSS, $g_bTakeLootSnapShot ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkScreenshotLootInfo, $g_bScreenshotLootInfo ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTakeLootSS()
Case "Save"
$g_bShareAttackEnable =(GUICtrlRead($g_hChkShareAttack) = $GUI_CHECKED)
$g_iShareMinGold = GUICtrlRead($g_hTxtShareMinGold)
$g_iShareMinElixir = GUICtrlRead($g_hTxtShareMinElixir)
$g_iShareMinDark = GUICtrlRead($g_hTxtShareMinDark)
$g_sShareMessage = StringReplace(GUICtrlRead($g_hTxtShareMessage), @CRLF, "|")
$g_bTakeLootSnapShot =(GUICtrlRead($g_hChkTakeLootSS) = $GUI_CHECKED)
$g_bScreenshotLootInfo =(GUICtrlRead($g_hChkScreenshotLootInfo) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_30_DB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkStopAtkDBNoLoot1, $g_abStopAtkNoLoot1Enable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtStopAtkDBNoLoot1, $g_aiStopAtkNoLoot1Time[$DB])
chkStopAtkDBNoLoot1()
GUICtrlSetState($g_hChkStopAtkDBNoLoot2, $g_abStopAtkNoLoot2Enable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtStopAtkDBNoLoot2, $g_aiStopAtkNoLoot2Time[$DB])
chkStopAtkDBNoLoot2()
GUICtrlSetData($g_hTxtDBMinGoldStopAtk2, $g_aiStopAtkNoLoot2MinGold[$DB])
GUICtrlSetData($g_hTxtDBMinElixirStopAtk2, $g_aiStopAtkNoLoot2MinElixir[$DB])
GUICtrlSetData($g_hTxtDBMinDarkElixirStopAtk2, $g_aiStopAtkNoLoot2MinDark[$DB])
GUICtrlSetState($g_hChkDBEndNoResources, $g_abStopAtkNoResources[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBEndOneStar, $g_abStopAtkOneStar[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBEndTwoStars, $g_abStopAtkTwoStars[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBEndPercentHigher, $g_abStopAtkPctHigherEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDBPercentHigher, $g_aiStopAtkPctHigherAmt[$DB])
chkDBEndPercentHigher()
GUICtrlSetState($g_hChkDBEndPercentChange, $g_abStopAtkPctNoChangeEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDBPercentChange, $g_aiStopAtkPctNoChangeTime[$DB])
chkDBEndPercentChange()
Case "Save"
$g_abStopAtkNoLoot1Enable[$DB] =(GUICtrlRead($g_hChkStopAtkDBNoLoot1) = $GUI_CHECKED)
$g_aiStopAtkNoLoot1Time[$DB] = Int(GUICtrlRead($g_hTxtStopAtkDBNoLoot1))
$g_abStopAtkNoLoot2Enable[$DB] =(GUICtrlRead($g_hChkStopAtkDBNoLoot2) = $GUI_CHECKED)
$g_aiStopAtkNoLoot2Time[$DB] = Int(GUICtrlRead($g_hTxtStopAtkDBNoLoot2))
$g_aiStopAtkNoLoot2MinGold[$DB] = Int(GUICtrlRead($g_hTxtDBMinGoldStopAtk2))
$g_aiStopAtkNoLoot2MinElixir[$DB] = Int(GUICtrlRead($g_hTxtDBMinElixirStopAtk2))
$g_aiStopAtkNoLoot2MinDark[$DB] = Int(GUICtrlRead($g_hTxtDBMinDarkElixirStopAtk2))
$g_abStopAtkNoResources[$DB] =(GUICtrlRead($g_hChkDBEndNoResources) = $GUI_CHECKED)
$g_abStopAtkOneStar[$DB] =(GUICtrlRead($g_hChkDBEndOneStar) = $GUI_CHECKED)
$g_abStopAtkTwoStars[$DB] =(GUICtrlRead($g_hChkDBEndTwoStars) = $GUI_CHECKED)
$g_abStopAtkPctHigherEnable[$DB] =(GUICtrlRead($g_hChkDBEndPercentHigher) = $GUI_CHECKED)
$g_aiStopAtkPctHigherAmt[$DB] = GUICtrlRead($g_hTxtDBPercentHigher)
$g_abStopAtkPctNoChangeEnable[$DB] =(GUICtrlRead($g_hChkDBEndPercentChange) = $GUI_CHECKED)
$g_aiStopAtkPctNoChangeTime[$DB] = GUICtrlRead($g_hTxtDBPercentChange)
EndSwitch
EndFunc
Func ApplyConfig_600_30_LB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkStopAtkABNoLoot1, $g_abStopAtkNoLoot1Enable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtStopAtkABNoLoot1, $g_aiStopAtkNoLoot1Time[$LB])
chkStopAtkABNoLoot1()
GUICtrlSetState($g_hChkStopAtkABNoLoot2, $g_abStopAtkNoLoot2Enable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtStopAtkABNoLoot2, $g_aiStopAtkNoLoot2Time[$LB])
chkStopAtkABNoLoot2()
GUICtrlSetData($g_hTxtABMinGoldStopAtk2, $g_aiStopAtkNoLoot2MinGold[$LB])
GUICtrlSetData($g_hTxtABMinElixirStopAtk2, $g_aiStopAtkNoLoot2MinElixir[$LB])
GUICtrlSetData($g_hTxtABMinDarkElixirStopAtk2, $g_aiStopAtkNoLoot2MinDark[$LB])
GUICtrlSetState($g_hChkABEndNoResources, $g_abStopAtkNoResources[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABEndOneStar, $g_abStopAtkOneStar[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABEndTwoStars, $g_abStopAtkTwoStars[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDESideEB, $g_bDESideEndEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDESideEB()
GUICtrlSetData($g_hTxtDELowEndMin, $g_iDESideEndMin)
GUICtrlSetState($g_hChkDisableOtherEBO, $g_bDESideDisableOther ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDEEndBk, $g_bDESideEndBKWeak ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDEEndAq, $g_bDESideEndAQWeak ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDEEndOneStar, $g_bDESideEndOneStar ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABEndPercentHigher, $g_abStopAtkPctHigherEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtABPercentHigher, $g_aiStopAtkPctHigherAmt[$LB])
chkABEndPercentHigher()
GUICtrlSetState($g_hChkABEndPercentChange, $g_abStopAtkPctNoChangeEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtABPercentChange, $g_aiStopAtkPctNoChangeTime[$LB])
chkABEndPercentChange()
Case "Save"
$g_abStopAtkNoLoot1Enable[$LB] =(GUICtrlRead($g_hChkStopAtkABNoLoot1) = $GUI_CHECKED)
$g_aiStopAtkNoLoot1Time[$LB] = Int(GUICtrlRead($g_hTxtStopAtkABNoLoot1))
$g_abStopAtkNoLoot2Enable[$LB] =(GUICtrlRead($g_hChkStopAtkABNoLoot2) = $GUI_CHECKED)
$g_aiStopAtkNoLoot2Time[$LB] =(GUICtrlRead($g_hTxtStopAtkABNoLoot2))
$g_aiStopAtkNoLoot2MinGold[$LB] = Int(GUICtrlRead($g_hTxtABMinGoldStopAtk2))
$g_aiStopAtkNoLoot2MinElixir[$LB] = Int(GUICtrlRead($g_hTxtABMinElixirStopAtk2))
$g_aiStopAtkNoLoot2MinDark[$LB] = Int(GUICtrlRead($g_hTxtABMinDarkElixirStopAtk2))
$g_abStopAtkNoResources[$LB] =(GUICtrlRead($g_hChkABEndNoResources) = $GUI_CHECKED)
$g_abStopAtkOneStar[$LB] =(GUICtrlRead($g_hChkABEndOneStar) = $GUI_CHECKED)
$g_abStopAtkTwoStars[$LB] =(GUICtrlRead($g_hChkABEndTwoStars) = $GUI_CHECKED)
$g_bDESideEndEnable =(GUICtrlRead($g_hChkDESideEB) = $GUI_CHECKED)
$g_iDESideEndMin = GUICtrlRead($g_hTxtDELowEndMin)
$g_bDESideDisableOther =(GUICtrlRead($g_hChkDisableOtherEBO) = $GUI_CHECKED)
$g_bDESideEndAQWeak =(GUICtrlRead($g_hChkDEEndAq) = $GUI_CHECKED)
$g_bDESideEndBKWeak =(GUICtrlRead($g_hChkDEEndBk) = $GUI_CHECKED)
$g_bDESideEndOneStar =(GUICtrlRead($g_hChkDEEndOneStar) = $GUI_CHECKED)
$g_abStopAtkPctHigherEnable[$LB] =(GUICtrlRead($g_hChkABEndPercentHigher) = $GUI_CHECKED)
$g_aiStopAtkPctHigherAmt[$LB] = GUICtrlRead($g_hTxtABPercentHigher)
$g_abStopAtkPctNoChangeEnable[$LB] =(GUICtrlRead($g_hChkABEndPercentChange) = $GUI_CHECKED)
$g_aiStopAtkPctNoChangeTime[$LB] = GUICtrlRead($g_hTxtABPercentChange)
EndSwitch
EndFunc
Func ApplyConfig_600_30_TS($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkTSActivateCamps2, $g_bEndTSCampsEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTSActivateCamps2()
GUICtrlSetData($g_hTxtTSArmyCamps2, $g_iEndTSCampsPct)
Case "Save"
$g_bEndTSCampsEnable =(GUICtrlRead($g_hChkTSActivateCamps2) = $GUI_CHECKED)
$g_iEndTSCampsPct = GUICtrlRead($g_hTxtTSArmyCamps2)
EndSwitch
EndFunc
Func ApplyConfig_600_31($TypeReadSave)
Switch $TypeReadSave
Case "Read"
For $i = 6 To 12
GUICtrlSetState($g_ahChkDBCollectorLevel[$i], $g_abCollectorLevelEnabled[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahCmbDBCollectorLevel[$i], $g_abCollectorLevelEnabled[$i] ? $GUI_ENABLE : $GUI_DISABLE)
_GUICtrlComboBox_SetCurSel($g_ahCmbDBCollectorLevel[$i], $g_aiCollectorLevelFill[$i])
Next
GUICtrlSetState($g_hChkDBDisableCollectorsFilter, $g_bCollectorFilterDisable ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbMinCollectorMatches, $g_iCollectorMatchesMin - 1)
GUICtrlSetData($g_hSldCollectorTolerance, $g_iCollectorToleranceOffset)
checkCollectors()
Case "Save"
For $i = 6 To 12
$g_abCollectorLevelEnabled[$i] =(GUICtrlRead($g_ahChkDBCollectorLevel[$i]) = $GUI_CHECKED)
$g_aiCollectorLevelFill[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbDBCollectorLevel[$i])
Next
$g_bCollectorFilterDisable =(GUICtrlRead($g_hChkDBDisableCollectorsFilter) = $GUI_CHECKED)
$g_iCollectorMatchesMin = _GUICtrlComboBox_GetCurSel($g_hCmbMinCollectorMatches) + 1
$g_iCollectorToleranceOffset = GUICtrlRead($g_hSldCollectorTolerance)
EndSwitch
EndFunc
Func ApplyConfig_600_32($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkTrophyRange, $g_bDropTrophyEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtMaxTrophy, $g_iDropTrophyMax)
GUICtrlSetData($g_hTxtDropTrophy, $g_iDropTrophyMin)
GUICtrlSetState($g_hChkTrophyHeroes, $g_bDropTrophyUseHeroes ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTrophyHeroes()
_GUICtrlComboBox_SetCurSel($g_hCmbTrophyHeroesPriority, $g_iDropTrophyHeroesPriority)
GUICtrlSetState($g_hChkTrophyAtkDead, $g_bDropTrophyAtkDead ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDropTrophyArmyMin, $g_iDropTrophyArmyMinPct)
chkTrophyRange()
TxtDropTrophy()
TxtMaxTrophy()
Case "Save"
$g_bDropTrophyEnable =(GUICtrlRead($g_hChkTrophyRange) = $GUI_CHECKED)
$g_iDropTrophyMax = GUICtrlRead($g_hTxtMaxTrophy)
$g_iDropTrophyMin = GUICtrlRead($g_hTxtDropTrophy)
$g_bDropTrophyUseHeroes =(GUICtrlRead($g_hChkTrophyHeroes) = $GUI_CHECKED)
$g_iDropTrophyHeroesPriority = _GUICtrlComboBox_GetCurSel($g_hCmbTrophyHeroesPriority)
$g_bDropTrophyAtkDead =(GUICtrlRead($g_hChkTrophyAtkDead) = $GUI_CHECKED)
$g_iDropTrophyArmyMinPct = GUICtrlRead($g_hTxtDropTrophyArmyMin)
EndSwitch
EndFunc
Func ApplyConfig_600_33($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkCustomDropOrderEnable, $g_bCustomDropOrderEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDropOrder()
For $p = 0 To UBound($g_ahCmbDropOrder) - 1
_GUICtrlComboBox_SetCurSel($g_ahCmbDropOrder[$p], $g_aiCmbCustomDropOrder[$p])
_GUICtrlSetImage($g_ahImgDropOrder[$p], $g_sLibIconPath, $g_aiDropOrderIcon[$g_aiCmbCustomDropOrder[$p] + 1])
Next
If $g_bCustomDropOrderEnable Then
If Not ChangeDropOrder() Then
SetDefaultDropOrderGroup()
GUICtrlSetState($g_hChkCustomDropOrderEnable, $GUI_UNCHECKED)
$g_bCustomDropOrderEnable = False
GUICtrlSetState($g_hBtnDropOrderSet, $GUI_DISABLE)
GUICtrlSetState($g_hBtnRemoveDropOrder, $GUI_DISABLE)
For $i = 0 To UBound($g_ahCmbDropOrder) - 1
GUICtrlSetState($g_ahCmbDropOrder[$i], $GUI_DISABLE)
Next
EndIf
EndIf
Case "Save"
$g_bCustomDropOrderEnable =(GUICtrlRead($g_hChkCustomDropOrderEnable) = $GUI_CHECKED)
For $p = 0 To UBound($g_ahCmbDropOrder) - 1
$g_aiCmbCustomDropOrder[$p] = _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$p])
Next
EndSwitch
EndFunc
Func ApplyConfig_600_35_1($TypeReadSave)
Switch $TypeReadSave
Case "Read"
LoadLanguagesComboBox()
GUICtrlSetState($g_hChkDisableSplash, $g_bDisableSplash ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkForMBRUpdates, $g_bCheckVersion ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDeleteLogs, $g_bDeleteLogs ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDeleteLogsDays, $g_iDeleteLogsDays)
chkDeleteLogs()
GUICtrlSetState($g_hChkDeleteTemp, $g_bDeleteTemp ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDeleteTempDays, $g_iDeleteTempDays)
chkDeleteTemp()
GUICtrlSetState($g_hChkDeleteLoots, $g_bDeleteLoots ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDeleteLootsDays, $g_iDeleteLootsDays)
chkDeleteLoots()
GUICtrlSetState($g_hChkAutostart, $g_bAutoStart ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtAutostartDelay, $g_iAutoStartDelay)
chkAutoStart()
GUICtrlSetState($g_hChkCheckGameLanguage, $g_bCheckGameLanguage ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAutoAlign, $g_bAutoAlignEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDisposeWindows()
_GUICtrlComboBox_SetCurSel($g_hCmbAlignmentOptions, $g_iAutoAlignPosition)
GUICtrlSetData($g_hTxtAlignOffsetX, $g_iAutoAlignOffsetX)
GUICtrlSetData($g_hTxtAlignOffsetY, $g_iAutoAlignOffsetY)
GUICtrlSetState($g_hChkBotCustomTitleBarClick,((BitAND($g_iBotDesignFlags, 1)) ?($GUI_CHECKED) :($GUI_UNCHECKED)))
GUICtrlSetState($g_hChkBotAutoSlideClick,((BitAND($g_iBotDesignFlags, 2)) ?($GUI_CHECKED) :($GUI_UNCHECKED)))
GUICtrlSetState($g_hChkHideWhenMinimized, $g_bHideWhenMinimized ? $GUI_CHECKED : $GUI_UNCHECKED)
TrayItemSetState($g_hTiHide, $g_bHideWhenMinimized ? $TRAY_CHECKED : $TRAY_UNCHECKED)
GUICtrlSetState($g_hChkUseRandomClick, $g_bUseRandomClick ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkScreenshotType, $g_bScreenshotPNGFormat ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkScreenshotHideName, $g_bScreenshotHideName ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtTimeAnotherDevice, Int(Int($g_iAnotherDeviceWaitTime) / 60))
GUICtrlSetState($g_hChkSinglePBTForced, $g_bForceSinglePBLogoff ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtSinglePBTimeForced, $g_iSinglePBForcedLogoffTime)
GUICtrlSetData($g_hTxtPBTimeForcedExit, $g_iSinglePBForcedEarlyExitTime)
chkSinglePBTForced()
GUICtrlSetState($g_hChkAutoResume, $g_bAutoResumeEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtAutoResumeTime, $g_iAutoResumeTime)
chkAutoResume()
GUICtrlSetState($g_hChkDisableNotifications, $g_bDisableNotifications ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkFixClanCastle, $g_bForceClanCastleDetection ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_bDisableSplash =(GUICtrlRead($g_hChkDisableSplash) = $GUI_CHECKED)
$g_bCheckVersion =(GUICtrlRead($g_hChkForMBRUpdates) = $GUI_CHECKED)
$g_bDeleteLogs =(GUICtrlRead($g_hChkDeleteLogs) = $GUI_CHECKED)
$g_iDeleteLogsDays = GUICtrlRead($g_hTxtDeleteLogsDays)
$g_bDeleteTemp =(GUICtrlRead($g_hChkDeleteTemp) = $GUI_CHECKED)
$g_iDeleteTempDays = GUICtrlRead($g_hTxtDeleteTempDays)
$g_bDeleteLoots =(GUICtrlRead($g_hChkDeleteLoots) = $GUI_CHECKED)
$g_iDeleteLootsDays = GUICtrlRead($g_hTxtDeleteLootsDays)
$g_bAutoStart =(GUICtrlRead($g_hChkAutostart) = $GUI_CHECKED)
$g_iAutoStartDelay = GUICtrlRead($g_hTxtAutostartDelay)
$g_bCheckGameLanguage =(GUICtrlRead($g_hChkCheckGameLanguage) = $GUI_CHECKED)
$g_bAutoAlignEnable =(GUICtrlRead($g_hChkAutoAlign) = $GUI_CHECKED)
$g_iAutoAlignPosition = _GUICtrlComboBox_GetCurSel($g_hCmbAlignmentOptions)
$g_iAutoAlignOffsetX = GUICtrlRead($g_hTxtAlignOffsetX)
$g_iAutoAlignOffsetY = GUICtrlRead($g_hTxtAlignOffsetY)
$g_iBotDesignFlags = BitOR(BitAND($g_iBotDesignFlags, BitNOT(1)),((GUICtrlRead($g_hChkBotCustomTitleBarClick) = $GUI_CHECKED) ?(1) :(0)))
$g_iBotDesignFlags = BitOR(BitAND($g_iBotDesignFlags, BitNOT(2)),((GUICtrlRead($g_hChkBotAutoSlideClick) = $GUI_CHECKED) ?(2) :(0)))
$g_bHideWhenMinimized =(GUICtrlRead($g_hChkHideWhenMinimized) = $GUI_CHECKED)
$g_bUseRandomClick =(GUICtrlRead($g_hChkUseRandomClick) = $GUI_CHECKED)
$g_bScreenshotPNGFormat =(GUICtrlRead($g_hChkScreenshotType) = $GUI_CHECKED)
$g_bScreenshotHideName =(GUICtrlRead($g_hChkScreenshotHideName) = $GUI_CHECKED)
$g_iAnotherDeviceWaitTime = Int(GUICtrlRead($g_hTxtTimeAnotherDevice)) * 60
$g_bForceSinglePBLogoff =(GUICtrlRead($g_hChkSinglePBTForced) = $GUI_CHECKED)
$g_iSinglePBForcedLogoffTime = GUICtrlRead($g_hTxtSinglePBTimeForced)
$g_iSinglePBForcedEarlyExitTime = GUICtrlRead($g_hTxtPBTimeForcedExit)
$g_bAutoResumeEnable =(GUICtrlRead($g_hChkAutoResume) = $GUI_CHECKED)
$g_iAutoResumeTime = GUICtrlRead($g_hTxtAutoResumeTime)
$g_bDisableNotifications =(GUICtrlRead($g_hChkDisableNotifications) = $GUI_CHECKED)
$g_bForceClanCastleDetection =(GUICtrlRead($g_hChkFixClanCastle) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_35_2($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbSwitchAcc, $g_iCmbSwitchAcc)
GUICtrlSetState($g_hChkSwitchAcc, $g_bChkSwitchAcc ? $GUI_CHECKED : $GUI_UNCHECKED)
If $g_bChkGooglePlay Then
GUICtrlSetState($g_hRadSwitchGooglePlay, $GUI_CHECKED)
GUICtrlSetState($g_hRadSwitchSuperCellID, $GUI_UNCHECKED)
GUICtrlSetState($g_hRadSwitchSharedPrefs, $GUI_UNCHECKED)
EndIf
If $g_bChkSuperCellID Then
GUICtrlSetState($g_hRadSwitchGooglePlay, $GUI_UNCHECKED)
GUICtrlSetState($g_hRadSwitchSuperCellID, $GUI_CHECKED)
GUICtrlSetState($g_hRadSwitchSharedPrefs, $GUI_UNCHECKED)
EndIf
If $g_bChkSharedPrefs Then
GUICtrlSetState($g_hRadSwitchGooglePlay, $GUI_UNCHECKED)
GUICtrlSetState($g_hRadSwitchSuperCellID, $GUI_UNCHECKED)
GUICtrlSetState($g_hRadSwitchSharedPrefs, $GUI_CHECKED)
EndIf
GUICtrlSetState($g_hChkSmartSwitch, $g_bChkSmartSwitch ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDonateLikeCrazy, $g_bDonateLikeCrazy ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbTotalAccount, $g_iTotalAcc - 1)
For $i = 0 To 7
GUICtrlSetState($g_ahChkAccount[$i], $g_abAccountNo[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_ahCmbProfile[$i], _GUICtrlComboBox_FindStringExact($g_ahCmbProfile[$i], $g_asProfileName[$i]))
GUICtrlSetState($g_ahChkDonate[$i], $g_abDonateOnly[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
_GUICtrlComboBox_SetCurSel($g_hCmbTrainTimeToSkip, $g_iTrainTimeToSkip)
_cmbSwitchAcc(False)
Case "Save"
$g_iCmbSwitchAcc = _GUICtrlComboBox_GetCurSel($g_hCmbSwitchAcc)
$g_bChkSwitchAcc =(GUICtrlRead($g_hChkSwitchAcc) = $GUI_CHECKED)
$g_bChkGooglePlay =(GUICtrlRead($g_hRadSwitchGooglePlay) = $GUI_CHECKED)
$g_bChkSuperCellID =(GUICtrlRead($g_hRadSwitchSuperCellID) = $GUI_CHECKED)
$g_bChkSharedPrefs =(GUICtrlRead($g_hRadSwitchSharedPrefs) = $GUI_CHECKED)
$g_bChkSmartSwitch =(GUICtrlRead($g_hChkSmartSwitch) = $GUI_CHECKED)
$g_bDonateLikeCrazy =(GUICtrlRead($g_hChkDonateLikeCrazy) = $GUI_CHECKED)
$g_iTotalAcc = _GUICtrlComboBox_GetCurSel($g_hCmbTotalAccount) + 1
For $i = 0 To 7
$g_abAccountNo[$i] =(GUICtrlRead($g_ahChkAccount[$i]) = $GUI_CHECKED)
$g_asProfileName[$i] = GUICtrlRead($g_ahCmbProfile[$i])
$g_abDonateOnly[$i] =(GUICtrlRead($g_ahChkDonate[$i]) = $GUI_CHECKED)
Next
$g_iTrainTimeToSkip = _GUICtrlComboBox_GetCurSel($g_hCmbTrainTimeToSkip)
EndSwitch
EndFunc
Func ApplyConfig_600_52_1($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkUseQuickTrain, $g_bQuickTrainEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkArmy[0], $g_bQuickTrainArmy[0] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkArmy[1], $g_bQuickTrainArmy[1] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkArmy[2], $g_bQuickTrainArmy[2] ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_bQuickTrainEnable =(GUICtrlRead($g_hChkUseQuickTrain) = $GUI_CHECKED)
$g_bQuickTrainArmy[0] =(GUICtrlRead($g_ahChkArmy[0]) = $GUI_CHECKED)
$g_bQuickTrainArmy[1] =(GUICtrlRead($g_ahChkArmy[1]) = $GUI_CHECKED)
$g_bQuickTrainArmy[2] =(GUICtrlRead($g_ahChkArmy[2]) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_52_2($TypeReadSave)
Switch $TypeReadSave
Case "Read"
For $T = 0 To $eTroopCount - 1
Local $iCurrLevel = $g_aiTrainArmyTroopLevel[$T]
Local $iCurrCount = $g_aiArmyCompTroops[$T]
Local $iMaxLevel = $g_aiTroopCostPerLevel[$T][0]
Local $iColor =($iCurrLevel = $iMaxLevel ? $COLOR_YELLOW : $COLOR_WHITE)
GUICtrlSetData($g_ahTxtTrainArmyTroopCount[$T],($iCurrCount <> 0 And $iCurrLevel <> 0) ? $iCurrCount : 0)
GUICtrlSetState($g_ahTxtTrainArmyTroopCount[$T], $iCurrLevel <> 0 ? $GUI_SHOW : $GUI_HIDE)
GUICtrlSetData($g_ahLblTrainArmyTroopLevel[$T], $iCurrLevel)
If GUICtrlGetBkColor($g_ahLblTrainArmyTroopLevel[$T]) <> $iColor Then GUICtrlSetBkColor($g_ahLblTrainArmyTroopLevel[$T], $iColor)
Next
For $S = 0 To $eSpellCount - 1
Local $iCurrLevel = $g_aiTrainArmySpellLevel[$S]
Local $iCurrCount = $g_aiArmyCompSpells[$S]
Local $iMaxLevel = $g_aiSpellCostPerLevel[$S][0]
Local $iColor =($iCurrLevel = $iMaxLevel ? $COLOR_YELLOW : $COLOR_WHITE)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$S],($iCurrCount <> 0 And $iCurrLevel <> 0) ? $iCurrCount : 0)
GUICtrlSetState($g_ahTxtTrainArmySpellCount[$S], $iCurrLevel <> 0 ? $GUI_SHOW : $GUI_HIDE)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$S], $iCurrLevel)
If GUICtrlGetBkColor($g_ahLblTrainArmySpellLevel[$S]) <> $iColor Then GUICtrlSetBkColor($g_ahLblTrainArmySpellLevel[$S], $iColor)
Next
GUICtrlSetData($g_hTxtFullTroop, $g_iTrainArmyFullTroopPct)
GUICtrlSetState($g_hChkTotalCampForced, $g_bTotalCampForced ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtTotalCampForced, $g_iTotalCampForcedValue)
GUICtrlSetData($g_hTxtTotalCountSpell, $g_iTotalSpellValue)
GUICtrlSetState($g_hChkForceBrewBeforeAttack, $g_bForceBrewSpells ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
For $T = 0 To $eTroopCount - 1
$g_aiArmyCompTroops[$T] = GUICtrlRead($g_ahTxtTrainArmyTroopCount[$T])
$g_aiTrainArmyTroopLevel[$T] = GUICtrlRead($g_ahLblTrainArmyTroopLevel[$T])
Next
For $S = 0 To $eSpellCount - 1
$g_aiArmyCompSpells[$S] = GUICtrlRead($g_ahTxtTrainArmySpellCount[$S])
$g_aiTrainArmySpellLevel[$S] = GUICtrlRead($g_ahLblTrainArmySpellLevel[$S])
Next
$g_iTrainArmyFullTroopPct = Int(GUICtrlRead($g_hTxtFullTroop))
$g_bTotalCampForced =(GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED)
$g_iTotalCampForcedValue = Int(GUICtrlRead($g_hTxtTotalCampForced))
$g_iTotalSpellValue = GUICtrlRead($g_hTxtTotalCountSpell)
$g_bForceBrewSpells =(GUICtrlRead($g_hChkForceBrewBeforeAttack) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_54($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkCustomTrainOrderEnable, $g_bCustomTrainOrderEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTroopOrder()
For $z = 0 To UBound($g_ahCmbTroopOrder) - 1
_GUICtrlComboBox_SetCurSel($g_ahCmbTroopOrder[$z], $g_aiCmbCustomTrainOrder[$z])
_GUICtrlSetImage($g_ahImgTroopOrder[$z], $g_sLibIconPath, $g_aiTroopOrderIcon[$g_aiCmbCustomTrainOrder[$z] + 1])
Next
If $g_bCustomTrainOrderEnable Then
If Not ChangeTroopTrainOrder() Then
SetDefaultTroopGroup()
GUICtrlSetState($g_hChkCustomTrainOrderEnable, $GUI_UNCHECKED)
$g_bCustomTrainOrderEnable = False
GUICtrlSetState($g_hBtnTroopOrderSet, $GUI_DISABLE)
GUICtrlSetState($g_hBtnRemoveTroops, $GUI_DISABLE)
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
GUICtrlSetState($g_ahCmbTroopOrder[$i], $GUI_DISABLE)
Next
EndIf
EndIf
GUICtrlSetState($g_hChkCustomBrewOrderEnable, $g_bCustomBrewOrderEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkSpellsOrder()
For $z = 0 To UBound($g_ahCmbSpellsOrder) - 1
_GUICtrlComboBox_SetCurSel($g_ahCmbSpellsOrder[$z], $g_aiCmbCustomBrewOrder[$z])
_GUICtrlSetImage($g_ahImgSpellsOrder[$z], $g_sLibIconPath, $g_aiSpellsOrderIcon[$g_aiCmbCustomBrewOrder[$z] + 1])
Next
If $g_bCustomBrewOrderEnable Then
If Not ChangeSpellsBrewOrder() Then
SetDefaultSpellsGroup()
GUICtrlSetState($g_hChkCustomBrewOrderEnable, $GUI_UNCHECKED)
$g_bCustomBrewOrderEnable = False
GUICtrlSetState($g_hBtnRemoveSpells, $GUI_DISABLE)
GUICtrlSetState($g_hBtnSpellsOrderSet, $GUI_DISABLE)
For $i = 0 To UBound($g_ahCmbSpellsOrder) - 1
GUICtrlSetState($g_ahCmbSpellsOrder[$i], $GUI_DISABLE)
Next
EndIf
EndIf
chkTotalCampForced()
chkUseQTrain()
SetComboTroopComp()
Case "Save"
$g_bCustomTrainOrderEnable =(GUICtrlRead($g_hChkCustomTrainOrderEnable) = $GUI_CHECKED)
For $z = 0 To UBound($g_ahCmbTroopOrder) - 1
$g_aiCmbCustomTrainOrder[$z] = _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$z])
Next
$g_bCustomBrewOrderEnable =(GUICtrlRead($g_hChkCustomBrewOrderEnable) = $GUI_CHECKED)
For $z = 0 To UBound($g_ahCmbSpellsOrder) - 1
$g_aiCmbCustomBrewOrder[$z] = _GUICtrlComboBox_GetCurSel($g_ahCmbSpellsOrder[$z])
Next
EndSwitch
EndFunc
Func ApplyConfig_600_56($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkSmartLightSpell, $g_bSmartZapEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSmartEQSpell, $g_bEarthQuakeZap = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNoobZap, $g_bNoobZap = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSmartZapDB, $g_bSmartZapDB = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSmartZapSaveHeroes, $g_bSmartZapSaveHeroes = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSmartZapFTW, $g_bSmartZapFTW = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtSmartZapMinDE, $g_iSmartZapMinDE)
GUICtrlSetData($g_hTxtSmartExpectedDE, $g_iSmartZapExpectedDE)
chkSmartLightSpell()
Case "Save"
$g_bSmartZapEnable =(GUICtrlRead($g_hChkSmartLightSpell) = $GUI_CHECKED)
$g_bEarthQuakeZap =(GUICtrlRead($g_hChkSmartEQSpell) = $GUI_CHECKED)
$g_bNoobZap =(GUICtrlRead($g_hChkNoobZap) = $GUI_CHECKED)
$g_bSmartZapDB =(GUICtrlRead($g_hChkSmartZapDB) = $GUI_CHECKED)
$g_bSmartZapSaveHeroes =(GUICtrlRead($g_hChkSmartZapSaveHeroes) = $GUI_CHECKED)
$g_bSmartZapFTW =(GUICtrlRead($g_hChkSmartZapFTW) = $GUI_CHECKED)
$g_iSmartZapMinDE = Int(GUICtrlRead($g_hTxtSmartZapMinDE))
$g_iSmartZapExpectedDE = Int(GUICtrlRead($g_hTxtSmartExpectedDE))
EndSwitch
EndFunc
Func ApplyConfig_641_1($TypeReadSave)
Switch $TypeReadSave
Case "Read"
If $g_bCloseWhileTrainingEnable = True Then
GUICtrlSetState($g_hChkCloseWhileTraining, $GUI_CHECKED)
_GUI_Value_STATE("ENABLE", $groupCloseWhileTraining)
GUICtrlSetState($g_hLblCloseWaitingTroops, $GUI_ENABLE)
GUICtrlSetState($g_hCmbMinimumTimeClose, $GUI_ENABLE)
GUICtrlSetState($g_hLblSymbolWaiting, $GUI_ENABLE)
GUICtrlSetState($g_hLblWaitingInMinutes, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkCloseWhileTraining, $GUI_UNCHECKED)
_GUI_Value_STATE("DISABLE", $groupCloseWhileTraining)
GUICtrlSetState($g_hLblCloseWaitingTroops, $GUI_DISABLE)
GUICtrlSetState($g_hCmbMinimumTimeClose, $GUI_DISABLE)
GUICtrlSetState($g_hLblSymbolWaiting, $GUI_DISABLE)
GUICtrlSetState($g_hLblWaitingInMinutes, $GUI_DISABLE)
EndIf
GUICtrlSetState($g_hChkCloseWithoutShield, $g_bCloseWithoutShield ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkCloseEmulator, $g_bCloseEmulator ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSuspendComputer, $g_bSuspendComputer ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkRandomClose, $g_bCloseRandom ? $GUI_CHECKED : $GUI_UNCHECKED)
btnCloseWaitStopRandom()
If $g_bCloseExactTime Then
GUICtrlSetState($g_hRdoCloseWaitExact, $GUI_CHECKED)
GUICtrlSetState($g_hRdoCloseWaitRandom, $GUI_UNCHECKED)
EndIf
If $g_bCloseRandomTime Then
GUICtrlSetState($g_hRdoCloseWaitRandom, $GUI_CHECKED)
GUICtrlSetState($g_hRdoCloseWaitExact, $GUI_UNCHECKED)
EndIf
_GUICtrlComboBox_SetCurSel($g_hCmbCloseWaitRdmPercent, $g_iCloseRandomTimePercent)
btnCloseWaitRandom()
GUICtrlSetData($g_hCmbMinimumTimeClose, $g_iCloseMinimumTime)
GUICtrlSetData($g_hSldTrainITDelay, $g_iTrainClickDelay)
sldTrainITDelay()
GUICtrlSetData($g_hLblTrainITDelayTime, $g_iTrainClickDelay & " ms")
GUICtrlSetState($g_hChkTrainAddRandomDelayEnable, $g_bTrainAddRandomDelayEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtAddRandomDelayMin, $g_iTrainAddRandomDelayMin)
GUICtrlSetData($g_hTxtAddRandomDelayMax, $g_iTrainAddRandomDelayMax)
chkAddDelayIdlePhaseEnable()
Case "Save"
$g_bCloseWhileTrainingEnable =(GUICtrlRead($g_hChkCloseWhileTraining) = $GUI_CHECKED)
$g_bCloseWithoutShield =(GUICtrlRead($g_hChkCloseWithoutShield) = $GUI_CHECKED)
$g_bCloseEmulator =(GUICtrlRead($g_hChkCloseEmulator) = $GUI_CHECKED)
$g_bSuspendComputer =(GUICtrlRead($g_hChkSuspendComputer) = $GUI_CHECKED)
$g_bCloseRandom =(GUICtrlRead($g_hChkRandomClose) = $GUI_CHECKED)
$g_bCloseExactTime =(GUICtrlRead($g_hRdoCloseWaitExact) = $GUI_CHECKED)
$g_bCloseRandomTime =(GUICtrlRead($g_hRdoCloseWaitRandom) = $GUI_CHECKED)
$g_iCloseRandomTimePercent = _GUICtrlComboBox_GetCurSel($g_hCmbCloseWaitRdmPercent)
$g_iCloseMinimumTime = GUICtrlRead($g_hCmbMinimumTimeClose)
$g_iTrainClickDelay = GUICtrlRead($g_hSldTrainITDelay)
$g_bTrainAddRandomDelayEnable =(GUICtrlRead($g_hChkTrainAddRandomDelayEnable) = $GUI_CHECKED)
$g_iTrainAddRandomDelayMin = Int(GUICtrlRead($g_hTxtAddRandomDelayMin))
$g_iTrainAddRandomDelayMax = Int(GUICtrlRead($g_hTxtAddRandomDelayMax))
EndSwitch
EndFunc
Func readConfig($inputfile = $g_sProfileConfigPath)
Static $iReadConfigCount = 0
If $g_bReadConfigIsActive Then
SetDebugLog("readConfig(), already running, exit")
Return
EndIf
$g_bReadConfigIsActive = True
$iReadConfigCount += 1
SetDebugLog("readConfig(), call number " & $iReadConfigCount)
$g_aiWeakBaseStats = readWeakBaseStats()
ReadProfileConfig()
If FileExists($g_sProfileBuildingPath) Then ReadBuildingConfig()
If FileExists($g_sProfileConfigPath) Then ReadRegularConfig()
$g_bReadConfigIsActive = False
EndFunc
Func ReadProfileConfig($sIniFile = $g_sProfilePath & "\profile.ini")
If FileExists($sIniFile) = 0 Then Return False
Local $iValue, $sValue
$iValue = $g_iGlobalActiveBotsAllowed
$g_iGlobalActiveBotsAllowed = Int(IniRead($sIniFile, "general", "globalactivebotsallowed", $g_iGlobalActiveBotsAllowed))
If $g_iGlobalActiveBotsAllowed < 1 Then $g_iGlobalActiveBotsAllowed = 2
If $iValue <> $g_iGlobalActiveBotsAllowed Then
SetDebugLog("Maximum of " & $iValue & " bots running at same time changed to " & $g_iGlobalActiveBotsAllowed)
EndIf
$iValue = $g_iGlobalThreads
$g_iGlobalThreads = Int(IniRead($sIniFile, "general", "globalthreads", $g_iGlobalThreads))
If $iValue <> $g_iGlobalThreads Then
SetDebugLog("Threading: Using " & $g_iGlobalThreads & " threads shared across all bot instances changed to " & $iValue)
EndIf
$sValue = IniRead($sIniFile, "general", "adb.path", $g_sAndroidAdbPath)
If FileExists($sValue) Then $g_sAndroidAdbPath = $sValue
Return True
EndFunc
Func ReadBuildingConfig()
SetDebugLog("Read Building Config " & $g_sProfileBuildingPath)
Local $locationsInvalid = False
Local $buildingVersion = "0.0.0"
IniReadS($buildingVersion, $g_sProfileBuildingPath, "general", "version", $buildingVersion)
Local $_ver630 = GetVersionNormalized("6.3.0")
Local $_ver63u = GetVersionNormalized("6.3.u")
Local $_ver63u3 = GetVersionNormalized("6.3.u3")
If $buildingVersion < $_ver630 Or($buildingVersion >= $_ver63u And $buildingVersion <= $_ver63u3) Then
SetLog("New MyBot.run version! Re-locate all buildings!", $COLOR_WARNING)
$locationsInvalid = True
EndIf
IniReadS($g_iTownHallLevel, $g_sProfileBuildingPath, "other", "LevelTownHall", 0, "int")
If $locationsInvalid = False Then
IniReadS($g_aiTownHallPos[0], $g_sProfileBuildingPath, "other", "xTownHall", -1, "int")
IniReadS($g_aiTownHallPos[1], $g_sProfileBuildingPath, "other", "yTownHall", -1, "int")
IniReadS($g_aiClanCastlePos[0], $g_sProfileBuildingPath, "other", "xCCPos", -1, "int")
IniReadS($g_aiClanCastlePos[1], $g_sProfileBuildingPath, "other", "yCCPos", -1, "int")
IniReadS($g_aiKingAltarPos[0], $g_sProfileBuildingPath, "other", "xKingAltarPos", -1, "int")
IniReadS($g_aiKingAltarPos[1], $g_sProfileBuildingPath, "other", "yKingAltarPos", -1, "int")
IniReadS($g_aiQueenAltarPos[0], $g_sProfileBuildingPath, "other", "xQueenAltarPos", -1, "int")
IniReadS($g_aiQueenAltarPos[1], $g_sProfileBuildingPath, "other", "yQueenAltarPos", -1, "int")
IniReadS($g_aiWardenAltarPos[0], $g_sProfileBuildingPath, "other", "xWardenAltarPos", -1, "int")
IniReadS($g_aiWardenAltarPos[1], $g_sProfileBuildingPath, "other", "yWardenAltarPos", -1, "int")
IniReadS($g_aiLaboratoryPos[0], $g_sProfileBuildingPath, "upgrade", "LabPosX", -1, "int")
IniReadS($g_aiLaboratoryPos[1], $g_sProfileBuildingPath, "upgrade", "LabPosY", -1, "int")
EndIf
IniReadS($g_aiLastGoodWallPos[0], $g_sProfileBuildingPath, "upgrade", "xLastGoodWallPos", -1, "int")
IniReadS($g_aiLastGoodWallPos[1], $g_sProfileBuildingPath, "upgrade", "yLastGoodWallPos", -1, "int")
IniReadS($g_iTotalCampSpace, $g_sProfileBuildingPath, "other", "totalcamp", 0, "int")
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
$g_avBuildingUpgrades[$iz][0] = IniRead($g_sProfileBuildingPath, "upgrade", "xupgrade" & $iz, "-1")
$g_avBuildingUpgrades[$iz][1] = IniRead($g_sProfileBuildingPath, "upgrade", "yupgrade" & $iz, "-1")
$g_avBuildingUpgrades[$iz][2] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradevalue" & $iz, "-1")
$g_avBuildingUpgrades[$iz][3] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradetype" & $iz, "")
$g_avBuildingUpgrades[$iz][4] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradename" & $iz, "")
$g_avBuildingUpgrades[$iz][5] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradelevel" & $iz, "")
$g_avBuildingUpgrades[$iz][6] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradetime" & $iz, "")
$g_avBuildingUpgrades[$iz][7] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradeend" & $iz, "-1")
$g_abBuildingUpgradeEnable[$iz] =(IniRead($g_sProfileBuildingPath, "upgrade", "upgradechk" & $iz, 0) = "1")
$g_abUpgradeRepeatEnable[$iz] =(IniRead($g_sProfileBuildingPath, "upgrade", "upgraderepeat" & $iz, 0) = "1")
$g_aiPicUpgradeStatus[$iz] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradestatusicon" & $iz, $eIcnTroops)
If $locationsInvalid = True Then
$g_avBuildingUpgrades[$iz][0] = -1
$g_avBuildingUpgrades[$iz][1] = -1
$g_abBuildingUpgradeEnable[$iz] = False
$g_abUpgradeRepeatEnable[$iz] = False
EndIf
Next
EndFunc
Func ReadRegularConfig()
SetDebugLog("Read Config " & $g_sProfileConfigPath)
ReadConfig_Debug()
IniReadS($g_iThreads, $g_sProfileConfigPath, "general", "threads", $g_iThreads, "int")
If $g_iThreads < 0 Then $g_iThreads = 0
IniReadS($g_iBotDesignFlags, $g_sProfileConfigPath, "general", "botDesignFlags", 0, "int")
IniReadS($g_iFrmBotPosX, $g_sProfileConfigPath, "general", "frmBotPosX", $g_iFrmBotPosX, "int")
IniReadS($g_iFrmBotPosY, $g_sProfileConfigPath, "general", "frmBotPosY", $g_iFrmBotPosY, "int")
If $g_iFrmBotPosX < -30000 Or $g_iFrmBotPosY < -30000 Then
$g_iFrmBotPosX = $g_WIN_POS_DEFAULT
$g_iFrmBotPosY = $g_WIN_POS_DEFAULT
EndIf
IniReadS($g_iAndroidPosX, $g_sProfileConfigPath, "general", "AndroidPosX", $g_iAndroidPosX, "int")
IniReadS($g_iAndroidPosY, $g_sProfileConfigPath, "general", "AndroidPosY", $g_iAndroidPosY, "int")
If $g_iAndroidPosX < -30000 Or $g_iAndroidPosY < -30000 Then
$g_iAndroidPosX = $g_WIN_POS_DEFAULT
$g_iAndroidPosY = $g_WIN_POS_DEFAULT
EndIf
IniReadS($g_iFrmBotDockedPosX, $g_sProfileConfigPath, "general", "frmBotDockedPosX", $g_iFrmBotDockedPosX, "int")
IniReadS($g_iFrmBotDockedPosY, $g_sProfileConfigPath, "general", "frmBotDockedPosY", $g_iFrmBotDockedPosY, "int")
If $g_iFrmBotDockedPosX < -30000 Or $g_iFrmBotDockedPosY < -30000 Then
$g_iFrmBotDockedPosX = $g_WIN_POS_DEFAULT
$g_iFrmBotDockedPosY = $g_WIN_POS_DEFAULT
EndIf
IniReadS($g_iRedrawBotWindowMode, $g_sProfileConfigPath, "general", "RedrawBotWindowMode", 2, "int")
ReadConfig_Android()
ReadConfig_600_1()
ReadConfig_600_6()
ReadConfig_600_9()
ReadConfig_600_11()
ReadConfig_600_12()
ReadConfig_600_13()
ReadConfig_600_14()
ReadConfig_600_15()
ReadConfig_600_16()
ReadConfig_auto()
ReadConfig_600_17()
ReadConfig_600_18()
ReadConfig_600_19()
ReadConfig_600_22()
ReadConfig_600_26()
ReadConfig_600_28()
ReadConfig_600_28_DB()
ReadConfig_600_28_LB()
ReadConfig_600_28_TS()
ReadConfig_600_29()
ReadConfig_600_29_DB()
ReadConfig_600_29_LB()
ReadConfig_600_29_TS()
ReadConfig_600_30()
ReadConfig_600_30_DB()
ReadConfig_600_30_LB()
ReadConfig_600_30_TS()
ReadConfig_600_31()
ReadConfig_600_32()
ReadConfig_600_33()
ReadConfig_600_35_1()
ReadConfig_600_35_2()
ReadConfig_600_52_1()
ReadConfig_600_52_2()
ReadConfig_600_54()
ReadConfig_600_56()
ReadConfig_641_1()
EndFunc
Func ReadConfig_Debug()
$g_bDebugSetlog = IniRead($g_sProfileConfigPath, "debug", "debugsetlog", 0) = 1 ? True : False
$g_bDebugAndroid = IniRead($g_sProfileConfigPath, "debug", "debugAndroid", 0) = 1 ? True : False
$g_bDebugClick = IniRead($g_sProfileConfigPath, "debug", "debugsetclick", 0) = 1 ? True : False
If $g_bDevMode Then
Local $bDebugFunc = IniRead($g_sProfileConfigPath, "debug", "debugFunc", 0) = 1 ? True : False
$g_bDebugFuncTime = $bDebugFunc
$g_bDebugFuncCall = $bDebugFunc
$g_bDebugDisableZoomout = IniRead($g_sProfileConfigPath, "debug", "disablezoomout", 0) = 1 ? True : False
$g_bDebugDisableVillageCentering = IniRead($g_sProfileConfigPath, "debug", "disablevillagecentering", 0) = 1 ? True : False
$g_bDebugDeadBaseImage = IniRead($g_sProfileConfigPath, "debug", "debugdeadbaseimage", 0) = 1 ? True : False
$g_bDebugOcr = IniRead($g_sProfileConfigPath, "debug", "debugocr", 0) = 1 ? True : False
$g_bDebugImageSave = IniRead($g_sProfileConfigPath, "debug", "debugimagesave", 0) = 1 ? True : False
$g_bDebugBuildingPos = IniRead($g_sProfileConfigPath, "debug", "debugbuildingpos", 0) = 1 ? True : False
$g_bDebugSetlogTrain = IniRead($g_sProfileConfigPath, "debug", "debugtrain", 0) = 1 ? True : False
$g_bDebugResourcesOffset = IniRead($g_sProfileConfigPath, "debug", "debugresourcesoffset", 0) = 1 ? True : False
$g_bDebugContinueSearchElixir = IniRead($g_sProfileConfigPath, "debug", "continuesearchelixirdebug", 0) = 1 ? True : False
$g_bDebugMilkingIMGmake = IniRead($g_sProfileConfigPath, "debug", "debugMilkingIMGmake", 0) = 1 ? True : False
$g_bDebugOCRdonate = IniRead($g_sProfileConfigPath, "debug", "debugOCRDonate", 0) = 1 ? True : False
$g_bDebugAttackCSV = IniRead($g_sProfileConfigPath, "debug", "debugAttackCSV", 0) = 1 ? True : False
$g_bDebugMakeIMGCSV = IniRead($g_sProfileConfigPath, "debug", "debugmakeimgcsv", 0) = 1 ? True : False
$g_bDebugSmartZap = BitOR($g_bDebugSmartZap, Int(IniRead($g_sProfileConfigPath, "debug", "DebugSmartZap", 0)))
EndIf
EndFunc
Func ReadConfig_Android()
$g_sAndroidGameDistributor = IniRead($g_sProfileConfigPath, "android", "game.distributor", $g_sAndroidGameDistributor)
$g_sAndroidGamePackage = IniRead($g_sProfileConfigPath, "android", "game.package", $g_sAndroidGamePackage)
$g_sAndroidGameClass = IniRead($g_sProfileConfigPath, "android", "game.class", $g_sAndroidGameClass)
$g_sUserGameDistributor = IniRead($g_sProfileConfigPath, "android", "user.distributor", $g_sUserGameDistributor)
$g_sUserGamePackage = IniRead($g_sProfileConfigPath, "android", "user.package", $g_sUserGamePackage)
$g_sUserGameClass = IniRead($g_sProfileConfigPath, "android", "user.class", $g_sUserGameClass)
$g_iAndroidBackgroundMode = Int(IniRead($g_sProfileConfigPath, "android", "backgroundmode", $g_iAndroidBackgroundMode))
$g_bAndroidCheckTimeLagEnabled = Int(IniRead($g_sProfileConfigPath, "android", "check.time.lag.enabled",($g_bAndroidCheckTimeLagEnabled ? 1 : 0))) = 1
$g_iAndroidAdbScreencapTimeoutMin = Int(IniRead($g_sProfileConfigPath, "android", "adb.screencap.timeout.min", $g_iAndroidAdbScreencapTimeoutMin))
$g_iAndroidAdbScreencapTimeoutMax = Int(IniRead($g_sProfileConfigPath, "android", "adb.screencap.timeout.max", $g_iAndroidAdbScreencapTimeoutMax))
$g_iAndroidAdbScreencapTimeoutDynamic = Int(IniRead($g_sProfileConfigPath, "android", "adb.screencap.timeout.dynamic", $g_iAndroidAdbScreencapTimeoutDynamic))
$g_bAndroidAdbInputEnabled = Int(IniRead($g_sProfileConfigPath, "android", "adb.input.enabled",($g_bAndroidAdbInputEnabled ? 1 : 0))) = 1
$g_bAndroidAdbClickEnabled = Int(IniRead($g_sProfileConfigPath, "android", "adb.click.enabled",($g_bAndroidAdbClickEnabled ? 1 : 0))) = 1
$g_bAndroidAdbClickDragScript = Int(IniRead($g_sProfileConfigPath, "android", "adb.click.drag.script",(BitAND($g_iAndroidSupportFeature, 128) ? 0 : 1))) = 1
$g_iAndroidAdbClickGroup = Int(IniRead($g_sProfileConfigPath, "android", "adb.click.group", $g_iAndroidAdbClickGroup))
$g_bAndroidAdbClicksEnabled = Int(IniRead($g_sProfileConfigPath, "android", "adb.clicks.enabled",($g_bAndroidAdbClicksEnabled ? 1 : 0))) = 1
$g_iAndroidAdbClicksTroopDeploySize = Int(IniRead($g_sProfileConfigPath, "android", "adb.clicks.troop.deploy.size", $g_iAndroidAdbClicksTroopDeploySize))
$g_bNoFocusTampering = Int(IniRead($g_sProfileConfigPath, "android", "no.focus.tampering",($g_bNoFocusTampering ? 1 : 0))) = 1
$g_iAndroidShieldColor = Dec(IniRead($g_sProfileConfigPath, "android", "shield.color", Hex($g_iAndroidShieldColor, 6)))
$g_iAndroidShieldTransparency = Int(IniRead($g_sProfileConfigPath, "android", "shield.transparency", $g_iAndroidShieldTransparency))
$g_iAndroidActiveColor = Dec(IniRead($g_sProfileConfigPath, "android", "active.color", Hex($g_iAndroidActiveColor, 6)))
$g_iAndroidActiveTransparency = Int(IniRead($g_sProfileConfigPath, "android", "active.transparency", $g_iAndroidActiveTransparency))
$g_iAndroidInactiveColor = Dec(IniRead($g_sProfileConfigPath, "android", "inactive.color", Hex($g_iAndroidInactiveColor, 6)))
$g_iAndroidInactiveTransparency = Int(IniRead($g_sProfileConfigPath, "android", "inactive.transparency", $g_iAndroidInactiveTransparency))
$g_iAndroidSuspendModeFlags = Int(IniRead($g_sProfileConfigPath, "android", "suspend.mode", $g_iAndroidSuspendModeFlags))
$g_iAndroidRebootHours = Int(IniRead($g_sProfileConfigPath, "android", "reboot.hours", $g_iAndroidRebootHours))
$g_bAndroidCloseWithBot = Int(IniRead($g_sProfileConfigPath, "android", "close", $g_bAndroidCloseWithBot ? 1 : 0)) = 1
$g_iAndroidProcessAffinityMask = Int(IniRead($g_sProfileConfigPath, "android", "process.affinity.mask", $g_iAndroidProcessAffinityMask))
If $g_bBotLaunchOption_Restart = True Or $g_asCmdLine[0] < 2 Then
Local $sAndroidEmulator = IniRead($g_sProfileConfigPath, "android", "emulator", "")
Local $sAndroidInstance = IniRead($g_sProfileConfigPath, "android", "instance", "")
If $sAndroidEmulator <> "" Then
If $sAndroidEmulator <> $g_sAndroidEmulator Or $sAndroidInstance <> $g_sAndroidInstance Then
UpdateHWnD(0)
UpdateAndroidConfig($sAndroidInstance, $sAndroidEmulator)
EndIf
Else
$g_bBotLaunchOption_Restart = False
EndIf
EndIf
EndFunc
Func ReadConfig_600_1()
IniReadS($g_iCmbLogDividerOption, $g_sProfileConfigPath, "general", "logstyle", 0, "int")
IniReadS($g_iLogDividerY, $g_sProfileConfigPath, "general", "LogDividerY", 243, "int")
IniReadS($g_bChkBackgroundMode, $g_sProfileConfigPath, "general", "Background", True, "Bool")
EndFunc
Func ReadConfig_600_6()
IniReadS($g_bChkBotStop, $g_sProfileConfigPath, "general", "BotStop", False, "Bool")
IniReadS($g_iCmbBotCommand, $g_sProfileConfigPath, "general", "Command", 0, "int")
IniReadS($g_iCmbBotCond, $g_sProfileConfigPath, "general", "Cond", 0, "int")
IniReadS($g_iCmbHoursStop, $g_sProfileConfigPath, "general", "Hour", 0, "int")
IniReadS($g_iTxtRestartGold, $g_sProfileConfigPath, "other", "minrestartgold", 50000, "int")
IniReadS($g_iTxtRestartElixir, $g_sProfileConfigPath, "other", "minrestartelixir", 50000, "int")
IniReadS($g_iTxtRestartDark, $g_sProfileConfigPath, "other", "minrestartdark", 500, "int")
IniReadS($g_bChkTrap, $g_sProfileConfigPath, "other", "chkTrap", True, "Bool")
IniReadS($g_bChkCollect, $g_sProfileConfigPath, "other", "chkCollect", True, "Bool")
IniReadS($g_bChkTombstones, $g_sProfileConfigPath, "other", "chkTombstones", True, "Bool")
IniReadS($g_bChkCleanYard, $g_sProfileConfigPath, "other", "chkCleanYard", False, "Bool")
IniReadS($g_bChkGemsBox, $g_sProfileConfigPath, "other", "chkGemsBox", False, "Bool")
IniReadS($g_bChkCollectFreeMagicItems, $g_sProfileConfigPath, "other", "ChkCollectFreeMagicItems", False, "Bool")
IniReadS($g_bChkTreasuryCollect, $g_sProfileConfigPath, "other", "ChkTreasuryCollect", False, "Bool")
IniReadS($g_iTxtTreasuryGold, $g_sProfileConfigPath, "other", "minTreasurygold", 0, "int")
IniReadS($g_iTxtTreasuryElixir, $g_sProfileConfigPath, "other", "minTreasuryelixir", 0, "int")
IniReadS($g_iTxtTreasuryDark, $g_sProfileConfigPath, "other", "minTreasurydark", 0, "int")
IniReadS($g_bChkCollectBuilderBase, $g_sProfileConfigPath, "other", "ChkCollectBuildersBase", False, "Bool")
IniReadS($g_bChkStartClockTowerBoost, $g_sProfileConfigPath, "other", "ChkStartClockTowerBoost", False, "Bool")
IniReadS($g_bChkCTBoostBlderBz, $g_sProfileConfigPath, "other", "ChkCTBoostBlderBz", False, "Bool")
IniReadS($g_iChkBBSuggestedUpgrades, $g_sProfileConfigPath, "other", "ChkBBSuggestedUpgrades", $g_iChkBBSuggestedUpgrades, "Int")
IniReadS($g_iChkBBSuggestedUpgradesIgnoreGold, $g_sProfileConfigPath, "other", "ChkBBSuggestedUpgradesIgnoreGold", $g_iChkBBSuggestedUpgradesIgnoreGold, "Int")
IniReadS($g_iChkBBSuggestedUpgradesIgnoreElixir, $g_sProfileConfigPath, "other", "ChkBBSuggestedUpgradesIgnoreElixir", $g_iChkBBSuggestedUpgradesIgnoreElixir, "Int")
IniReadS($g_iChkBBSuggestedUpgradesIgnoreHall, $g_sProfileConfigPath, "other", "ChkBBSuggestedUpgradesIgnoreHall", $g_iChkBBSuggestedUpgradesIgnoreHall, "Int")
IniReadS($g_iChkPlacingNewBuildings, $g_sProfileConfigPath, "other", "ChkPlacingNewBuildings", $g_iChkPlacingNewBuildings, "Int")
IniReadS($g_bChkClanGamesAir, $g_sProfileConfigPath, "other", "ChkClanGamesAir", False, "Bool")
IniReadS($g_bChkClanGamesGround, $g_sProfileConfigPath, "other", "ChkClanGamesGround", False, "Bool")
IniReadS($g_bChkClanGamesMisc, $g_sProfileConfigPath, "other", "ChkClanGamesMisc", False, "Bool")
IniReadS($g_bChkClanGamesEnabled, $g_sProfileConfigPath, "other", "ChkClanGamesEnabled", False, "Bool")
IniReadS($g_bChkClanGamesOnly, $g_sProfileConfigPath, "other", "ChkClanGamesOnly", False, "Bool")
IniReadS($g_bChkClanGamesPurge, $g_sProfileConfigPath, "other", "ChkClanGamesPurge", False, "Bool")
IniReadS($g_bChkClanGamesStopBeforeReachAndPurge, $g_sProfileConfigPath, "other", "ChkClanGamesStopBeforeReachAndPurge", False, "Bool")
IniReadS($g_bChkClanGamesDebug, $g_sProfileConfigPath, "other", "ChkClanGamesDebug", False, "Bool")
IniReadS($g_bChkClanGamesLoot, $g_sProfileConfigPath, "other", "ChkClanGamesLoot", False, "Bool")
IniReadS($g_bChkClanGamesBattle, $g_sProfileConfigPath, "other", "ChkClanGamesBattle", False, "Bool")
IniReadS($g_bChkClanGamesDestruction, $g_sProfileConfigPath, "other", "ChkClanGamesDestruction", False, "Bool")
IniReadS($g_bChkClanGamesAirTroop, $g_sProfileConfigPath, "other", "ChkClanGamesAirTroop", False, "Bool")
IniReadS($g_bChkClanGamesGroundTroop, $g_sProfileConfigPath, "other", "ChkClanGamesGroundTroop", False, "Bool")
IniReadS($g_bChkClanGamesMiscellaneous, $g_sProfileConfigPath, "other", "ChkClanGamesMiscellaneous", False, "Bool")
IniReadS($g_iPurgeMax, $g_sProfileConfigPath, "other", "PurgeMax", 5, "int")
EndFunc
Func ReadConfig_600_9()
IniReadS($g_iUnbrkMode, $g_sProfileConfigPath, "Unbreakable", "chkUnbreakable", 0, "int")
IniReadS($g_iUnbrkWait, $g_sProfileConfigPath, "Unbreakable", "UnbreakableWait", 5, "int")
IniReadS($g_iUnbrkMinGold, $g_sProfileConfigPath, "Unbreakable", "minUnBrkgold", 50000, "int")
IniReadS($g_iUnbrkMaxGold, $g_sProfileConfigPath, "Unbreakable", "maxUnBrkgold", 600000, "int")
IniReadS($g_iUnbrkMinElixir, $g_sProfileConfigPath, "Unbreakable", "minUnBrkelixir", 50000, "int")
IniReadS($g_iUnbrkMaxElixir, $g_sProfileConfigPath, "Unbreakable", "maxUnBrkelixir", 600000, "int")
IniReadS($g_iUnbrkMinDark, $g_sProfileConfigPath, "Unbreakable", "minUnBrkdark", 5000, "int")
IniReadS($g_iUnbrkMaxDark, $g_sProfileConfigPath, "Unbreakable", "maxUnBrkdark", 10000, "int")
EndFunc
Func ReadConfig_600_11()
$g_bRequestTroopsEnable =(IniRead($g_sProfileConfigPath, "planned", "RequestHoursEnable", "0") = "1")
$g_sRequestTroopsText = IniRead($g_sProfileConfigPath, "donate", "txtRequest", "")
$g_abRequestCCHours = StringSplit(IniRead($g_sProfileConfigPath, "planned", "RequestHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abRequestCCHours[$i] =($g_abRequestCCHours[$i] = "1")
Next
EndFunc
Func ReadConfig_600_12()
IniReadS($g_bChkDonate, $g_sProfileConfigPath, "donate", "Doncheck", True, "Bool")
For $i = 0 To $eTroopCount - 1 + $g_iCustomDonateConfigs
Local $sIniName = ""
If $i >= $eTroopBarbarian And $i <= $eTroopBowler Then
$sIniName = StringReplace($g_asTroopNamesPlural[$i], " ", "")
ElseIf $i = $eCustomA Then
$sIniName = "CustomA"
ElseIf $i = $eCustomB Then
$sIniName = "CustomB"
ElseIf $i = $eCustomC Then
$sIniName = "CustomC"
ElseIf $i = $eCustomD Then
$sIniName = "CustomD"
EndIf
$g_abChkDonateTroop[$i] =(IniRead($g_sProfileConfigPath, "donate", "chkDonate" & $sIniName, "0") = "1")
$g_abChkDonateAllTroop[$i] =(IniRead($g_sProfileConfigPath, "donate", "chkDonateAll" & $sIniName, "0") = "1")
Next
$g_asTxtDonateTroop[$eTroopBarbarian] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateBarbarians", "barbarians|barbarian|barb"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopBarbarian] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistBarbarians", "no barbarians|no barb|barbarian no|barb no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopArcher] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateArchers", "archers|archer|arch"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopArcher] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistArchers", "no archers|no arch|archer no|arch no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopGiant] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateGiants", "giants|giant|any"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopGiant] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistGiants", "no giants|giants no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopGoblin] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateGoblins", "goblins|goblin"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopGoblin] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistGoblins", "no goblins|goblins no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopWallBreaker] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateWallBreakers", "wall breakers|wb"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopWallBreaker] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistWallBreakers", "no wallbreakers|wb no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopBalloon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateBalloons", "balloons|balloon"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopBalloon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistBalloons", "no balloon|balloons no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopWizard] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateWizards", "wizards|wizard|wiz"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopWizard] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistWizards", "no wizards|wizards no|no wizard|wizard no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopHealer] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateHealers", "healer"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopHealer] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistHealers", "no healer|healer no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateDragons", "dragon"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistDragons", "no dragon|dragon no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopPekka] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonatePekkas", "PEKKA|pekka"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopPekka] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistPekkas", "no PEKKA|pekka no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopBabyDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateBabyDragons", "baby dragon|baby"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopBabyDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistBabyDragons", "no baby dragon|baby dragon no|no baby|baby no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopMiner] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateMiners", "miner|mine"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopMiner] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistMiners", "no miner|miner no|no mine|mine no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopElectroDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateElectroDragons", "electro dragon|electrodrag|edrag"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopElectroDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistElectroDragons", "no electro dragon|electrodrag no|edrag no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopMinion] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateMinions", "minions|minion"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopMinion] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistMinions", "no minion|minions no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopHogRider] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateHogRiders", "hogriders|hogs|hog"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopHogRider] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistHogRiders", "no hogriders|hogriders no|no hog|hogs no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopValkyrie] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateValkyries", "valkyries|valkyrie|valk"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopValkyrie] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistValkyries", "no valkyrie|valkyries no|no valk|valk no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopGolem] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateGolems", "golem"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopGolem] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistGolems", "no golem|golem no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopWitch] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateWitches", "witches|witch"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopWitch] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistWitches", "no witches|witches no|no witch|witch no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopLavaHound] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateLavaHounds", "lavahounds|lava|hound"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopLavaHound] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistLavaHounds", "no lavahound|lavahound no|no lava|lava no|nohound|hound no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopBowler] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateBowlers", "bowler|bowl"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopBowler] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistBowlers", "no bowler|bowl no"), "|", @CRLF)
$g_asTxtDonateTroop[$eCustomA] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomA", "ground support|ground"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eCustomA] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistCustomA", "no ground|ground no|nonly"), "|", @CRLF)
$g_asTxtDonateTroop[$eCustomB] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomB", "air support|any air"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eCustomB] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistCustomB", "no air|air no|only|just"), "|", @CRLF)
$g_asTxtDonateTroop[$eCustomC] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomC", "ground support|ground"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eCustomC] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistCustomC", "no ground|ground no|nonly"), "|", @CRLF)
$g_asTxtDonateTroop[$eCustomD] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomD", "air support|any air"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eCustomD] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistCustomD", "no air|air no|only|just"), "|", @CRLF)
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
Local $sIniName = $g_asSpellNames[$i] & "Spells"
$g_abChkDonateSpell[$i] =(IniRead($g_sProfileConfigPath, "donate", "chkDonate" & $sIniName, "0") = "1")
$g_abChkDonateAllSpell[$i] =(IniRead($g_sProfileConfigPath, "donate", "chkDonateAll" & $sIniName, "0") = "1")
EndIf
Next
$g_asTxtDonateSpell[$eSpellLightning] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateLightningSpells", "lightning"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellLightning] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistLightningSpells", "no lightning|lightning no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellHeal] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateHealSpells", "heal"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellHeal] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistHealSpells", "no heal|heal no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellRage] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateRageSpells", "rage"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellRage] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistRageSpells", "no rage|rage no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellJump] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateJumpSpells", "jump"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellJump] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistJumpSpells", "no jump|jump no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellFreeze] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateFreezeSpells", "freeze"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellFreeze] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistFreezeSpells", "no freeze|freeze no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellPoison] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonatePoisonSpells", "poison"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellPoison] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistPoisonSpells", "no poison|poison no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellEarthquake] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateEarthQuakeSpells", "earthquake|quake"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellEarthquake] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistEarthQuakeSpells", "no earthquake|quake no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellHaste] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateHasteSpells", "haste"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellHaste] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistHasteSpells", "no haste|haste no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellSkeleton] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateSkeletonSpells", "skeleton"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellSkeleton] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistSkeletonSpells", "no skeleton|skeleton no"), "|", @CRLF)
$g_aiDonateCustomTrpNumA[0][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomA1", 6))
$g_aiDonateCustomTrpNumA[1][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomA2", 1))
$g_aiDonateCustomTrpNumA[2][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomA3", 0))
$g_aiDonateCustomTrpNumA[0][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomA1", 2))
$g_aiDonateCustomTrpNumA[1][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomA2", 3))
$g_aiDonateCustomTrpNumA[2][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomA3", 1))
$g_aiDonateCustomTrpNumB[0][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomB1", 11))
$g_aiDonateCustomTrpNumB[1][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomB2", 1))
$g_aiDonateCustomTrpNumB[2][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomB3", 6))
$g_aiDonateCustomTrpNumB[0][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomB1", 3))
$g_aiDonateCustomTrpNumB[1][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomB2", 13))
$g_aiDonateCustomTrpNumB[2][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomB3", 5))
$g_aiDonateCustomTrpNumC[0][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomC1", 6))
$g_aiDonateCustomTrpNumC[1][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomC2", 1))
$g_aiDonateCustomTrpNumC[2][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomC3", 0))
$g_aiDonateCustomTrpNumC[0][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomC1", 2))
$g_aiDonateCustomTrpNumC[1][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomC2", 3))
$g_aiDonateCustomTrpNumC[2][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomC3", 1))
$g_aiDonateCustomTrpNumD[0][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomD1", 11))
$g_aiDonateCustomTrpNumD[1][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomD2", 1))
$g_aiDonateCustomTrpNumD[2][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomD3", 6))
$g_aiDonateCustomTrpNumD[0][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomD1", 3))
$g_aiDonateCustomTrpNumD[1][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomD2", 13))
$g_aiDonateCustomTrpNumD[2][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomD3", 5))
$g_bChkExtraAlphabets =(IniRead($g_sProfileConfigPath, "donate", "chkExtraAlphabets", "0") = "1")
$g_bChkExtraChinese =(IniRead($g_sProfileConfigPath, "donate", "chkExtraChinese", "0") = "1")
$g_bChkExtraKorean =(IniRead($g_sProfileConfigPath, "donate", "chkExtraKorean", "0") = "1")
$g_bChkExtraPersian =(IniRead($g_sProfileConfigPath, "donate", "chkExtraPersian", "0") = "1")
$g_sTxtGeneralBlacklist = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklist", "clan war|war|cw"), "|", @CRLF)
EndFunc
Func ReadConfig_600_13()
$g_bDonateHoursEnable =(IniRead($g_sProfileConfigPath, "planned", "DonateHoursEnable", "0") = "1")
$g_abDonateHours = StringSplit(IniRead($g_sProfileConfigPath, "planned", "DonateHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abDonateHours[$i] =($g_abDonateHours[$i] = "1")
Next
$g_iCmbDonateFilter = Int(IniRead($g_sProfileConfigPath, "donate", "cmbFilterDonationsCC", 0))
$g_iDonateSkipNearFullPercent = Int(IniRead($g_sProfileConfigPath, "donate", "SkipDonateNearFulLTroopsPercentual", 90))
$g_bDonateSkipNearFullEnable =(IniRead($g_sProfileConfigPath, "donate", "SkipDonateNearFulLTroopsEnable", "1") = "1")
EndFunc
Func ReadConfig_600_14()
IniReadS($g_bAutoLabUpgradeEnable, $g_sProfileBuildingPath, "upgrade", "upgradetroops", False, "Bool")
IniReadS($g_iCmbLaboratory, $g_sProfileBuildingPath, "upgrade", "upgradetroopname", 0, "int")
$g_sLabUpgradeTime = IniRead($g_sProfileBuildingPath, "upgrade", "upgradelabtime", "")
EndFunc
Func ReadConfig_600_15()
IniReadS($g_bUpgradeKingEnable, $g_sProfileConfigPath, "upgrade", "UpgradeKing", False, "Bool")
IniReadS($g_bUpgradeQueenEnable, $g_sProfileConfigPath, "upgrade", "UpgradeQueen", False, "Bool")
IniReadS($g_bUpgradeWardenEnable, $g_sProfileConfigPath, "upgrade", "UpgradeWarden", False, "Bool")
EndFunc
Func ReadConfig_600_16()
IniReadS($g_iUpgradeMinGold, $g_sProfileConfigPath, "upgrade", "minupgrgold", 100000, "int")
IniReadS($g_iUpgradeMinElixir, $g_sProfileConfigPath, "upgrade", "minupgrelixir", 100000, "int")
IniReadS($g_iUpgradeMinDark, $g_sProfileConfigPath, "upgrade", "minupgrdark", 2000, "int")
EndFunc
Func ReadConfig_auto()
IniReadS($g_iChkAutoUpgrade, $g_sProfileConfigPath, "Auto Upgrade", "ChkAutoUpgrade", 0, "int")
For $i = 0 To 12
IniReadS($g_iChkUpgradesToIgnore[$i], $g_sProfileConfigPath, "Auto Upgrade", "ChkUpgradesToIgnore[" & $i & "]", $g_iChkUpgradesToIgnore[$i], "int")
Next
For $i = 0 To 2
IniReadS($g_iChkResourcesToIgnore[$i], $g_sProfileConfigPath, "Auto Upgrade", "ChkResourcesToIgnore[" & $i & "]", $g_iChkResourcesToIgnore[$i], "int")
Next
IniReadS($g_iTxtSmartMinGold, $g_sProfileConfigPath, "Auto Upgrade", "SmartMinGold", 150000, "int")
IniReadS($g_iTxtSmartMinElixir, $g_sProfileConfigPath, "Auto Upgrade", "SmartMinElixir", 150000, "int")
IniReadS($g_iTxtSmartMinDark, $g_sProfileConfigPath, "Auto Upgrade", "SmartMinDark", 1500, "int")
EndFunc
Func ReadConfig_600_17()
IniReadS($g_bAutoUpgradeWallsEnable, $g_sProfileConfigPath, "upgrade", "auto-wall", False, "Bool")
IniReadS($g_iUpgradeWallMinGold, $g_sProfileConfigPath, "upgrade", "minwallgold", 0, "int")
IniReadS($g_iUpgradeWallMinElixir, $g_sProfileConfigPath, "upgrade", "minwallelixir", 0, "int")
IniReadS($g_iUpgradeWallLootType, $g_sProfileConfigPath, "upgrade", "use-storage", 0, "int")
IniReadS($g_bUpgradeWallSaveBuilder, $g_sProfileConfigPath, "upgrade", "savebldr", False, "Bool")
IniReadS($g_iCmbUpgradeWallsLevel, $g_sProfileConfigPath, "upgrade", "walllvl", 6, "int")
For $i = 4 To 13
IniReadS($g_aiWallsCurrentCount[$i], $g_sProfileConfigPath, "Walls", "Wall" & StringFormat("%02d", $i), 0, "int")
Next
IniReadS($g_iWallCost, $g_sProfileConfigPath, "upgrade", "WallCost", 0, "int")
EndFunc
Func ReadConfig_600_18()
IniReadS($g_bNotifyPBEnable, $g_sProfileConfigPath, "notify", "PBEnabled", False, "Bool")
IniReadS($g_bNotifyTGEnable, $g_sProfileConfigPath, "notify", "TGEnabled", False, "Bool")
IniReadS($g_sNotifyPBToken, $g_sProfileConfigPath, "notify", "PBToken", "")
IniReadS($g_sNotifyTGToken, $g_sProfileConfigPath, "notify", "TGToken", "")
IniReadS($g_bNotifyRemoteEnable, $g_sProfileConfigPath, "notify", "PBRemote", False, "Bool")
IniReadS($g_sNotifyOrigin, $g_sProfileConfigPath, "notify", "Origin", $g_sProfileCurrentName)
IniReadS($g_bNotifyDeleteAllPushesOnStart, $g_sProfileConfigPath, "notify", "DeleteAllPBPushes", False, "Bool")
IniReadS($g_bNotifyDeletePushesOlderThan, $g_sProfileConfigPath, "notify", "DeleteOldPBPushes", False, "Bool")
IniReadS($g_iNotifyDeletePushesOlderThanHours, $g_sProfileConfigPath, "notify", "HoursPushBullet", 4, "int")
IniReadS($g_bNotifyAlertMatchFound, $g_sProfileConfigPath, "notify", "AlertPBVMFound", False, "Bool")
IniReadS($g_bNotifyAlerLastRaidIMG, $g_sProfileConfigPath, "notify", "AlertPBLastRaid", False, "Bool")
IniReadS($g_bNotifyAlerLastRaidTXT, $g_sProfileConfigPath, "notify", "AlertPBLastRaidTxt", False, "Bool")
IniReadS($g_bNotifyAlertCampFull, $g_sProfileConfigPath, "notify", "AlertPBCampFull", False, "Bool")
IniReadS($g_bNotifyAlertUpgradeWalls, $g_sProfileConfigPath, "notify", "AlertPBWallUpgrade", False, "Bool")
IniReadS($g_bNotifyAlertOutOfSync, $g_sProfileConfigPath, "notify", "AlertPBOOS", False, "Bool")
IniReadS($g_bNotifyAlertTakeBreak, $g_sProfileConfigPath, "notify", "AlertPBVBreak", False, "Bool")
IniReadS($g_bNotifyAlertBulderIdle, $g_sProfileConfigPath, "notify", "AlertBuilderIdle", False, "Bool")
IniReadS($g_bNotifyAlertVillageReport, $g_sProfileConfigPath, "notify", "AlertPBVillage", False, "Bool")
IniReadS($g_bNotifyAlertLastAttack, $g_sProfileConfigPath, "notify", "AlertPBLastAttack", False, "Bool")
IniReadS($g_bNotifyAlertAnotherDevice, $g_sProfileConfigPath, "notify", "AlertPBOtherDevice", False, "Bool")
IniReadS($g_bNotifyAlertMaintenance, $g_sProfileConfigPath, "notify", "AlertPBMaintenance", False, "Bool")
IniReadS($g_bNotifyAlertBAN, $g_sProfileConfigPath, "notify", "AlertPBBAN", False, "Bool")
IniReadS($g_bNotifyAlertBOTUpdate, $g_sProfileConfigPath, "notify", "AlertPBUpdate", False, "Bool")
IniReadS($g_bNotifyAlertSmartWaitTime, $g_sProfileConfigPath, "notify", "AlertSmartWaitTime", False, "Bool")
EndFunc
Func ReadConfig_600_19()
$g_bNotifyScheduleHoursEnable =(IniRead($g_sProfileConfigPath, "notify", "NotifyHoursEnable", "0") = "1")
$g_abNotifyScheduleHours = StringSplit(IniRead($g_sProfileConfigPath, "notify", "NotifyHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abNotifyScheduleHours[$i] =($g_abNotifyScheduleHours[$i] = "1")
Next
$g_bNotifyScheduleWeekDaysEnable =(IniRead($g_sProfileConfigPath, "notify", "NotifyWeekDaysEnable", "0") = "1")
$g_abNotifyScheduleWeekDays = StringSplit(IniRead($g_sProfileConfigPath, "notify", "NotifyWeekDays", "1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 6
$g_abNotifyScheduleWeekDays[$i] =($g_abNotifyScheduleWeekDays[$i] = "1")
Next
EndFunc
Func ReadConfig_600_22()
$g_abBoostBarracksHours = StringSplit(IniRead($g_sProfileConfigPath, "planned", "BoostBarracksHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abBoostBarracksHours[$i] =($g_abBoostBarracksHours[$i] = "1")
Next
EndFunc
Func ReadConfig_600_26()
IniReadS($g_abAttackTypeEnable[$TB], $g_sProfileConfigPath, "search", "BullyMode", False, "Bool")
IniReadS($g_iAtkTBEnableCount, $g_sProfileConfigPath, "search", "ATBullyMode", 0, "int")
IniReadS($g_iAtkTBMaxTHLevel, $g_sProfileConfigPath, "search", "YourTH", 0, "int")
IniReadS($g_iAtkTBMode, $g_sProfileConfigPath, "search", "THBullyAttackMode", 0, "int")
EndFunc
Func ReadConfig_600_28()
IniReadS($g_bSearchReductionEnable, $g_sProfileConfigPath, "search", "reduction", False, "Bool")
IniReadS($g_iSearchReductionCount, $g_sProfileConfigPath, "search", "reduceCount", 20, "int")
IniReadS($g_iSearchReductionGold, $g_sProfileConfigPath, "search", "reduceGold", 2000, "int")
IniReadS($g_iSearchReductionElixir, $g_sProfileConfigPath, "search", "reduceElixir", 2000, "int")
IniReadS($g_iSearchReductionGoldPlusElixir, $g_sProfileConfigPath, "search", "reduceGoldPlusElixir", 4000, "int")
IniReadS($g_iSearchReductionDark, $g_sProfileConfigPath, "search", "reduceDark", 100, "int")
IniReadS($g_iSearchReductionTrophy, $g_sProfileConfigPath, "search", "reduceTrophy", 2, "int")
IniReadS($g_iSearchDelayMin, $g_sProfileConfigPath, "other", "VSDelay", 0, "Int")
IniReadS($g_iSearchDelayMax, $g_sProfileConfigPath, "other", "MaxVSDelay", 4, "Int")
IniReadS($g_bSearchAttackNowEnable, $g_sProfileConfigPath, "general", "AttackNow", False, "Bool")
IniReadS($g_iSearchAttackNowDelay, $g_sProfileConfigPath, "general", "attacknowdelay", 3, "int")
IniReadS($g_bSearchRestartEnable, $g_sProfileConfigPath, "search", "ChkRestartSearchLimit", True, "Bool")
IniReadS($g_iSearchRestartLimit, $g_sProfileConfigPath, "search", "RestartSearchLimit", 50, "int")
IniReadS($g_bSearchAlertMe, $g_sProfileConfigPath, "general", "AlertSearch", False, "Bool")
EndFunc
Func ReadConfig_600_28_DB()
IniReadS($g_abAttackTypeEnable[$DB], $g_sProfileConfigPath, "search", "DBcheck", True, "Bool")
IniReadS($g_abSearchSearchesEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBSearchSearches", True, "Bool")
IniReadS($g_aiSearchSearchesMin[$DB], $g_sProfileConfigPath, "search", "DBEnableAfterCount", 1, "int")
IniReadS($g_aiSearchSearchesMax[$DB], $g_sProfileConfigPath, "search", "DBEnableBeforeCount", 9999, "int")
IniReadS($g_abSearchTropiesEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBSearchTropies", False, "Bool")
IniReadS($g_aiSearchTrophiesMin[$DB], $g_sProfileConfigPath, "search", "DBEnableAfterTropies", 100, "int")
IniReadS($g_aiSearchTrophiesMax[$DB], $g_sProfileConfigPath, "search", "DBEnableBeforeTropies", 6000, "int")
IniReadS($g_abSearchCampsEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBSearchCamps", False, "Bool")
IniReadS($g_aiSearchCampsPct[$DB], $g_sProfileConfigPath, "search", "DBEnableAfterArmyCamps", 100, "int")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $g_sProfileConfigPath, "attack", "DBKingWait", $eHeroNone)
IniReadS($temp2, $g_sProfileConfigPath, "attack", "DBQueenWait", $eHeroNone)
IniReadS($temp3, $g_sProfileConfigPath, "attack", "DBWardenWait", $eHeroNone)
$g_aiSearchHeroWaitEnable[$DB] = BitOR(Int($temp1 > $eHeroNone ? $eHeroKing : 0), Int($temp2 > $eHeroNone ? $eHeroQueen : 0), Int($temp3 > $eHeroNone ? $eHeroWarden : 0))
IniReadS($g_aiSearchNotWaitHeroesEnable[$DB], $g_sProfileConfigPath, "attack", "DBNotWaitHeroes", 0, "int")
$g_iHeroWaitAttackNoBit[$DB][0] =($temp1 > $eHeroNone) ? 1 : 0
$g_iHeroWaitAttackNoBit[$DB][1] =($temp2 > $eHeroNone) ? 1 : 0
$g_iHeroWaitAttackNoBit[$DB][2] =($temp3 > $eHeroNone) ? 1 : 0
IniReadS($g_abSearchSpellsWaitEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBSpellsWait", False, "Bool")
IniReadS($g_abSearchCastleSpellsWaitEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBCastleSpellWait", False, "Bool")
IniReadS($g_abSearchCastleTroopsWaitEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBCastleTroopsWait", False, "Bool")
IniReadS($g_aiSearchCastleSpellsWaitRegular[$DB], $g_sProfileConfigPath, "search", "cmbDBWaitForCastleSpell", 0, "int")
IniReadS($g_aiSearchCastleSpellsWaitDark[$DB], $g_sProfileConfigPath, "search", "cmbDBWaitForCastleSpell2", 0, "int")
IniReadS($g_aiFilterMeetGE[$DB], $g_sProfileConfigPath, "search", "DBMeetGE", 1, "int")
IniReadS($g_aiFilterMinGold[$DB], $g_sProfileConfigPath, "search", "DBsearchGold", 80000, "int")
IniReadS($g_aiFilterMinElixir[$DB], $g_sProfileConfigPath, "search", "DBsearchElixir", 80000, "int")
IniReadS($g_aiFilterMinGoldPlusElixir[$DB], $g_sProfileConfigPath, "search", "DBsearchGoldPlusElixir", 160000, "int")
IniReadS($g_abFilterMeetDEEnable[$DB], $g_sProfileConfigPath, "search", "DBMeetDE", False, "Bool")
IniReadS($g_aiFilterMeetDEMin[$DB], $g_sProfileConfigPath, "search", "DBsearchDark", 0, "int")
IniReadS($g_abFilterMeetTrophyEnable[$DB], $g_sProfileConfigPath, "search", "DBMeetTrophy", False, "Bool")
IniReadS($g_aiFilterMeetTrophyMin[$DB], $g_sProfileConfigPath, "search", "DBsearchTrophy", 0, "int")
IniReadS($g_aiFilterMeetTrophyMax[$DB], $g_sProfileConfigPath, "search", "DBsearchTrophyMax", 99, "int")
IniReadS($g_abFilterMeetTH[$DB], $g_sProfileConfigPath, "search", "DBMeetTH", False, "Bool")
IniReadS($g_aiFilterMeetTHMin[$DB], $g_sProfileConfigPath, "search", "DBTHLevel", 0, "int")
IniReadS($g_abFilterMeetTHOutsideEnable[$DB], $g_sProfileConfigPath, "search", "DBMeetTHO", False, "Bool")
IniReadS($g_abFilterMaxMortarEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckMortar", False, "Bool")
IniReadS($g_abFilterMaxWizTowerEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckWizTower", False, "Bool")
IniReadS($g_abFilterMaxAirDefenseEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckAirDefense", False, "Bool")
IniReadS($g_abFilterMaxXBowEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckXBow", False, "Bool")
IniReadS($g_abFilterMaxInfernoEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckInferno", False, "Bool")
IniReadS($g_abFilterMaxEagleEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckEagle", False, "Bool")
IniReadS($g_aiFilterMaxMortarLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakMortar", 5, "int")
IniReadS($g_aiFilterMaxWizTowerLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakWizTower", 4, "int")
IniReadS($g_aiFilterMaxAirDefenseLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakAirDefense", 7, "int")
IniReadS($g_aiFilterMaxXBowLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakXBow", 4, "int")
IniReadS($g_aiFilterMaxInfernoLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakInferno", 1, "int")
IniReadS($g_aiFilterMaxEagleLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakEagle", 2, "int")
IniReadS($g_abFilterMeetOneConditionEnable[$DB], $g_sProfileConfigPath, "search", "DBMeetOne", False, "Bool")
EndFunc
Func ReadConfig_600_28_LB()
IniReadS($g_abAttackTypeEnable[$LB], $g_sProfileConfigPath, "search", "ABcheck", False, "Bool")
IniReadS($g_abSearchSearchesEnable[$LB], $g_sProfileConfigPath, "search", "ChkABSearchSearches", False, "Bool")
IniReadS($g_aiSearchSearchesMin[$LB], $g_sProfileConfigPath, "search", "ABEnableAfterCount", 1, "int")
IniReadS($g_aiSearchSearchesMax[$LB], $g_sProfileConfigPath, "search", "ABEnableBeforeCount", 9999, "int")
IniReadS($g_abSearchTropiesEnable[$LB], $g_sProfileConfigPath, "search", "ChkABSearchTropies", False, "Bool")
IniReadS($g_aiSearchTrophiesMin[$LB], $g_sProfileConfigPath, "search", "ABEnableAfterTropies", 100, "int")
IniReadS($g_aiSearchTrophiesMax[$LB], $g_sProfileConfigPath, "search", "ABEnableBeforeTropies", 6000, "int")
IniReadS($g_abSearchCampsEnable[$LB], $g_sProfileConfigPath, "search", "ChkABSearchCamps", False, "Bool")
IniReadS($g_aiSearchCampsPct[$LB], $g_sProfileConfigPath, "search", "ABEnableAfterArmyCamps", 100, "int")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $g_sProfileConfigPath, "attack", "ABKingWait", $eHeroNone)
IniReadS($temp2, $g_sProfileConfigPath, "attack", "ABQueenWait", $eHeroNone)
IniReadS($temp3, $g_sProfileConfigPath, "attack", "ABWardenWait", $eHeroNone)
$g_aiSearchHeroWaitEnable[$LB] = BitOR(Int($temp1 > $eHeroNone ? $eHeroKing : 0), Int($temp2 > $eHeroNone ? $eHeroQueen : 0), Int($temp3 > $eHeroNone ? $eHeroWarden : 0))
IniReadS($g_aiSearchNotWaitHeroesEnable[$LB], $g_sProfileConfigPath, "attack", "ABNotWaitHeroes", 0, "int")
$g_iHeroWaitAttackNoBit[$LB][0] =($temp1 > $eHeroNone) ? 1 : 0
$g_iHeroWaitAttackNoBit[$LB][1] =($temp2 > $eHeroNone) ? 1 : 0
$g_iHeroWaitAttackNoBit[$LB][2] =($temp3 > $eHeroNone) ? 1 : 0
IniReadS($g_abSearchSpellsWaitEnable[$LB], $g_sProfileConfigPath, "search", "ChkABSpellsWait", False, "Bool")
IniReadS($g_abSearchCastleSpellsWaitEnable[$LB], $g_sProfileConfigPath, "search", "ChkABCastleSpellWait", False, "Bool")
IniReadS($g_abSearchCastleTroopsWaitEnable[$LB], $g_sProfileConfigPath, "search", "ChkABCastleTroopsWait", False, "Bool")
IniReadS($g_aiSearchCastleSpellsWaitRegular[$LB], $g_sProfileConfigPath, "search", "cmbABWaitForCastleSpell", 0, "int")
IniReadS($g_aiSearchCastleSpellsWaitDark[$LB], $g_sProfileConfigPath, "search", "cmbABWaitForCastleSpell2", 0, "int")
IniReadS($g_aiFilterMeetGE[$LB], $g_sProfileConfigPath, "search", "ABMeetGE", 2, "int")
IniReadS($g_aiFilterMinGold[$LB], $g_sProfileConfigPath, "search", "ABsearchGold", 80000, "int")
IniReadS($g_aiFilterMinElixir[$LB], $g_sProfileConfigPath, "search", "ABsearchElixir", 80000, "int")
IniReadS($g_aiFilterMinGoldPlusElixir[$LB], $g_sProfileConfigPath, "search", "ABsearchGoldPlusElixir", 160000, "int")
IniReadS($g_abFilterMeetDEEnable[$LB], $g_sProfileConfigPath, "search", "ABMeetDE", False, "Bool")
IniReadS($g_aiFilterMeetDEMin[$LB], $g_sProfileConfigPath, "search", "ABsearchDark", 0, "int")
IniReadS($g_abFilterMeetTrophyEnable[$LB], $g_sProfileConfigPath, "search", "ABMeetTrophy", False, "Bool")
IniReadS($g_aiFilterMeetTrophyMin[$LB], $g_sProfileConfigPath, "search", "ABsearchTrophy", 0, "int")
IniReadS($g_aiFilterMeetTrophyMax[$LB], $g_sProfileConfigPath, "search", "ABsearchTrophyMax", 99, "int")
IniReadS($g_abFilterMeetTH[$LB], $g_sProfileConfigPath, "search", "ABMeetTH", False, "Bool")
IniReadS($g_aiFilterMeetTHMin[$LB], $g_sProfileConfigPath, "search", "ABTHLevel", 0, "int")
IniReadS($g_abFilterMeetTHOutsideEnable[$LB], $g_sProfileConfigPath, "search", "ABMeetTHO", False, "Bool")
IniReadS($g_abFilterMaxMortarEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckMortar", False, "Bool")
IniReadS($g_abFilterMaxWizTowerEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckWizTower", False, "Bool")
IniReadS($g_abFilterMaxAirDefenseEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckAirDefense", False, "Bool")
IniReadS($g_abFilterMaxXBowEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckXBow", False, "Bool")
IniReadS($g_abFilterMaxInfernoEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckInferno", False, "Bool")
IniReadS($g_abFilterMaxEagleEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckEagle", False, "Bool")
IniReadS($g_aiFilterMaxMortarLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakMortar", 5, "int")
IniReadS($g_aiFilterMaxWizTowerLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakWizTower", 4, "int")
IniReadS($g_aiFilterMaxAirDefenseLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakAirDefense", 7, "int")
IniReadS($g_aiFilterMaxXBowLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakXBow", 4, "int")
IniReadS($g_aiFilterMaxInfernoLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakInferno", 1, "int")
IniReadS($g_aiFilterMaxEagleLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakEagle", 2, "int")
IniReadS($g_abFilterMeetOneConditionEnable[$LB], $g_sProfileConfigPath, "search", "ABMeetOne", False, "Bool")
EndFunc
Func ReadConfig_600_28_TS()
IniReadS($g_abAttackTypeEnable[$TS], $g_sProfileConfigPath, "search", "TScheck", False, "Bool")
IniReadS($g_abSearchSearchesEnable[$TS], $g_sProfileConfigPath, "search", "ChkTSSearchSearches", False, "Bool")
IniReadS($g_aiSearchSearchesMin[$TS], $g_sProfileConfigPath, "search", "TSEnableAfterCount", 1, "int")
IniReadS($g_aiSearchSearchesMax[$TS], $g_sProfileConfigPath, "search", "TSEnableBeforeCount", 9999, "int")
IniReadS($g_abSearchTropiesEnable[$TS], $g_sProfileConfigPath, "search", "ChkTSSearchTropies", False, "Bool")
IniReadS($g_aiSearchTrophiesMin[$TS], $g_sProfileConfigPath, "search", "TSEnableAfterTropies", 100, "int")
IniReadS($g_aiSearchTrophiesMax[$TS], $g_sProfileConfigPath, "search", "TSEnableBeforeTropies", 6000, "int")
IniReadS($g_abSearchCampsEnable[$TS], $g_sProfileConfigPath, "search", "ChkTSSearchCamps", False, "Bool")
IniReadS($g_aiSearchCampsPct[$TS], $g_sProfileConfigPath, "search", "TSEnableAfterArmyCamps", 100, "int")
IniReadS($g_aiFilterMeetGE[$TS], $g_sProfileConfigPath, "search", "TSMeetGE", 1, "int")
IniReadS($g_aiFilterMinGold[$TS], $g_sProfileConfigPath, "search", "TSsearchGold", 80000, "int")
IniReadS($g_aiFilterMinElixir[$TS], $g_sProfileConfigPath, "search", "TSsearchElixir", 80000, "int")
IniReadS($g_aiFilterMinGoldPlusElixir[$TS], $g_sProfileConfigPath, "search", "TSsearchGoldPlusElixir", 160000, "int")
IniReadS($g_abFilterMeetDEEnable[$TS], $g_sProfileConfigPath, "search", "TSMeetDE", False, "Bool")
IniReadS($g_aiFilterMeetDEMin[$TS], $g_sProfileConfigPath, "search", "TSsearchDark", 600, "int")
IniReadS($g_iAtkTSAddTilesWhileTrain, $g_sProfileConfigPath, "search", "SWTtiles", 1, "int")
IniReadS($g_iAtkTSAddTilesFullTroops, $g_sProfileConfigPath, "search", "THaddTiles", 2, "int")
EndFunc
Func ReadConfig_600_29()
IniReadS($g_iActivateQueen, $g_sProfileConfigPath, "attack", "ActivateQueen", 0, "int")
IniReadS($g_iActivateKing, $g_sProfileConfigPath, "attack", "ActivateKing", 0, "int")
IniReadS($g_iActivateWarden, $g_sProfileConfigPath, "attack", "ActivateWarden", 0, "int")
IniReadS($g_iDelayActivateQueen, $g_sProfileConfigPath, "attack", "delayActivateQueen", 9000, "int")
IniReadS($g_iDelayActivateKing, $g_sProfileConfigPath, "attack", "delayActivateKing", 9000, "int")
IniReadS($g_iDelayActivateWarden, $g_sProfileConfigPath, "attack", "delayActivateWarden", 10000, "int")
$g_bAttackPlannerEnable =(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerEnable", "0") = "1")
$g_bAttackPlannerCloseCoC =(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerCloseCoC", "0") = "1")
$g_bAttackPlannerCloseAll =(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerCloseAll", "0") = "1")
$g_bAttackPlannerSuspendComputer =(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerSuspendComputer", "0") = "1")
$g_bAttackPlannerRandomEnable =(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerRandom", "0") = "1")
$g_iAttackPlannerRandomTime = Int(IniRead($g_sProfileConfigPath, "planned", "cmbAttackPlannerRandom", 4))
$g_bAttackPlannerDayLimit =(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerDayLimit", "0") = "1")
$g_iAttackPlannerDayMin = Int(IniRead($g_sProfileConfigPath, "planned", "cmbAttackPlannerDayMin", 12))
$g_iAttackPlannerDayMax = Int(IniRead($g_sProfileConfigPath, "planned", "cmbAttackPlannerDayMax", 15))
$g_abPlannedAttackWeekDays = StringSplit(IniRead($g_sProfileConfigPath, "planned", "attackDays", "1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 6
$g_abPlannedAttackWeekDays[$i] =($g_abPlannedAttackWeekDays[$i] = "1")
Next
$g_abPlannedattackHours = StringSplit(IniRead($g_sProfileConfigPath, "planned", "attackHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abPlannedattackHours[$i] =($g_abPlannedattackHours[$i] = "1")
Next
$g_bPlannedDropCCHoursEnable =(IniRead($g_sProfileConfigPath, "planned", "DropCCEnable", "0") = "1")
$g_abPlannedDropCCHours = StringSplit(IniRead($g_sProfileConfigPath, "planned", "DropCCHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abPlannedDropCCHours[$i] =($g_abPlannedDropCCHours[$i] = "1")
Next
IniReadS($g_bUseCCBalanced, $g_sProfileConfigPath, "ClanClastle", "BalanceCC", False, "Bool")
IniReadS($g_iCCDonated, $g_sProfileConfigPath, "ClanClastle", "BalanceCCDonated", 1, "int")
IniReadS($g_iCCReceived, $g_sProfileConfigPath, "ClanClastle", "BalanceCCReceived", 1, "int")
EndFunc
Func ReadConfig_600_29_DB()
IniReadS($g_aiAttackAlgorithm[$DB], $g_sProfileConfigPath, "attack", "DBAtkAlgorithm", 0, "int")
IniReadS($g_aiAttackTroopSelection[$DB], $g_sProfileConfigPath, "attack", "DBSelectTroop", 0, "int")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $g_sProfileConfigPath, "attack", "DBKingAtk", $eHeroNone)
IniReadS($temp2, $g_sProfileConfigPath, "attack", "DBQueenAtk", $eHeroNone)
IniReadS($temp3, $g_sProfileConfigPath, "attack", "DBWardenAtk", $eHeroNone)
$g_aiAttackUseHeroes[$DB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
IniReadS($g_abAttackDropCC[$DB], $g_sProfileConfigPath, "attack", "DBDropCC", False, "Bool")
IniReadS($g_abAttackUseLightSpell[$DB], $g_sProfileConfigPath, "attack", "DBLightSpell", False, "Bool")
IniReadS($g_abAttackUseHealSpell[$DB], $g_sProfileConfigPath, "attack", "DBHealSpell", False, "Bool")
IniReadS($g_abAttackUseRageSpell[$DB], $g_sProfileConfigPath, "attack", "DBRageSpell", False, "Bool")
IniReadS($g_abAttackUseJumpSpell[$DB], $g_sProfileConfigPath, "attack", "DBJumpSpell", False, "Bool")
IniReadS($g_abAttackUseFreezeSpell[$DB], $g_sProfileConfigPath, "attack", "DBFreezeSpell", False, "Bool")
IniReadS($g_abAttackUsePoisonSpell[$DB], $g_sProfileConfigPath, "attack", "DBPoisonSpell", False, "Bool")
IniReadS($g_abAttackUseEarthquakeSpell[$DB], $g_sProfileConfigPath, "attack", "DBEarthquakeSpell", False, "Bool")
IniReadS($g_abAttackUseHasteSpell[$DB], $g_sProfileConfigPath, "attack", "DBHasteSpell", False, "Bool")
IniReadS($g_abAttackUseCloneSpell[$DB], $g_sProfileConfigPath, "attack", "DBCloneSpell", False, "Bool")
IniReadS($g_abAttackUseSkeletonSpell[$DB], $g_sProfileConfigPath, "attack", "DBSkeletonSpell", False, "Bool")
IniReadS($g_bTHSnipeBeforeEnable[$DB], $g_sProfileConfigPath, "attack", "THSnipeBeforeDBEnable", False, "Bool")
IniReadS($g_iTHSnipeBeforeTiles[$DB], $g_sProfileConfigPath, "attack", "THSnipeBeforeDBTiles", 0, "int")
IniReadS($g_iTHSnipeBeforeScript[$DB], $g_sProfileConfigPath, "attack", "THSnipeBeforeDBScript", "bam")
IniReadS($g_aiAttackStdDropOrder[$DB], $g_sProfileConfigPath, "attack", "DBStandardAlgorithm", 0, "int")
IniReadS($g_aiAttackStdDropSides[$DB], $g_sProfileConfigPath, "attack", "DBDeploy", 3, "int")
IniReadS($g_aiAttackStdUnitDelay[$DB], $g_sProfileConfigPath, "attack", "DBUnitD", 4, "int")
IniReadS($g_aiAttackStdWaveDelay[$DB], $g_sProfileConfigPath, "attack", "DBWaveD", 4, "int")
IniReadS($g_abAttackStdRandomizeDelay[$DB], $g_sProfileConfigPath, "attack", "DBRandomSpeedAtk", True, "Bool")
IniReadS($g_abAttackStdSmartAttack[$DB], $g_sProfileConfigPath, "attack", "DBSmartAttackRedArea", True, "Bool")
IniReadS($g_aiAttackStdSmartDeploy[$DB], $g_sProfileConfigPath, "attack", "DBSmartAttackDeploy", 0, "int")
IniReadS($g_abAttackStdSmartNearCollectors[$DB][0], $g_sProfileConfigPath, "attack", "DBSmartAttackGoldMine", False, "Bool")
IniReadS($g_abAttackStdSmartNearCollectors[$DB][1], $g_sProfileConfigPath, "attack", "DBSmartAttackElixirCollector", False, "Bool")
IniReadS($g_abAttackStdSmartNearCollectors[$DB][2], $g_sProfileConfigPath, "attack", "DBSmartAttackDarkElixirDrill", False, "Bool")
IniReadS($g_aiAttackScrRedlineRoutine[$DB], $g_sProfileConfigPath, "attack", "RedlineRoutineDB", $g_aiAttackScrRedlineRoutine[$DB], "Int")
IniReadS($g_aiAttackScrDroplineEdge[$DB], $g_sProfileConfigPath, "attack", "DroplineEdgeDB", $g_aiAttackScrDroplineEdge[$DB], "Int")
IniReadS($g_sAttackScrScriptName[$DB], $g_sProfileConfigPath, "attack", "ScriptDB", "Barch four fingers")
IniReadS($g_iMilkAttackType, $g_sProfileConfigPath, "MilkingAttack", "MilkAttackType", 0, "int")
IniReadS($g_aiMilkFarmElixirParam, $g_sProfileConfigPath, "MilkingAttack", "LocateElixirLevel", "-1|-1|-1|-1|-1|-1|2|2|2")
$g_aiMilkFarmElixirParam = StringSplit($g_aiMilkFarmElixirParam, "|", 2)
IniReadS($g_bMilkFarmLocateElixir, $g_sProfileConfigPath, "MilkingAttack", "LocateElixir", True, "Bool")
IniReadS($g_bMilkFarmLocateMine, $g_sProfileConfigPath, "MilkingAttack", "LocateMine", True, "Bool")
IniReadS($g_bMilkFarmLocateDrill, $g_sProfileConfigPath, "MilkingAttack", "LocateDrill", True, "Bool")
IniReadS($g_iMilkFarmMineParam, $g_sProfileConfigPath, "MilkingAttack", "MineParam", 5, "int")
IniReadS($g_iMilkFarmDrillParam, $g_sProfileConfigPath, "MilkingAttack", "DrillParam", 1, "int")
IniReadS($g_iMilkFarmResMaxTilesFromBorder, $g_sProfileConfigPath, "MilkingAttack", "MaxTiles", 1, "int")
IniReadS($g_bMilkFarmAttackGoldMines, $g_sProfileConfigPath, "MilkingAttack", "AttackMine", True, "Bool")
IniReadS($g_bMilkFarmAttackElixirExtractors, $g_sProfileConfigPath, "MilkingAttack", "AttackElixir", True, "Bool")
IniReadS($g_bMilkFarmAttackDarkDrills, $g_sProfileConfigPath, "MilkingAttack", "AttackDrill", True, "Bool")
IniReadS($g_iMilkFarmLimitGold, $g_sProfileConfigPath, "MilkingAttack", "LimitGold", 9950000, "int")
IniReadS($g_iMilkFarmLimitElixir, $g_sProfileConfigPath, "MilkingAttack", "LimitElixir", 9950000, "int")
IniReadS($g_iMilkFarmLimitDark, $g_sProfileConfigPath, "MilkingAttack", "LimitDark", 200000, "int")
IniReadS($g_iMilkFarmTroopForWaveMin, $g_sProfileConfigPath, "MilkingAttack", "TroopForWaveMin", 4, "int")
IniReadS($g_iMilkFarmTroopForWaveMax, $g_sProfileConfigPath, "MilkingAttack", "TroopForWaveMax", 6, "int")
IniReadS($g_iMilkFarmTroopMaxWaves, $g_sProfileConfigPath, "MilkingAttack", "MaxWaves", 4, "int")
IniReadS($g_iMilkFarmDelayFromWavesMin, $g_sProfileConfigPath, "MilkingAttack", "DelayBetweenWavesMin", 3000, "int")
IniReadS($g_iMilkFarmDelayFromWavesMax, $g_sProfileConfigPath, "MilkingAttack", "DelayBetweenWavesMax", 5000, "int")
IniReadS($g_iMilkingAttackDropGoblinAlgorithm, $g_sProfileConfigPath, "MilkingAttack", "DropRandomPlace", 0, "int")
IniReadS($g_iMilkingAttackStructureOrder, $g_sProfileConfigPath, "MilkingAttack", "StructureOrder", 1, "int")
IniReadS($g_bMilkingAttackCheckStructureDestroyedBeforeAttack, $g_sProfileConfigPath, "MilkingAttack", "CheckStructureDestroyedBeforeAttack", False, "Bool")
IniReadS($g_bMilkingAttackCheckStructureDestroyedAfterAttack, $g_sProfileConfigPath, "MilkingAttack", "CheckStructureDestroyedAfterAttack", False, "Bool")
IniReadS($g_bMilkAttackAfterTHSnipeEnable, $g_sProfileConfigPath, "MilkingAttack", "MilkAttackAfterTHSnipe", False, "Bool")
IniReadS($g_iMilkFarmTHMaxTilesFromBorder, $g_sProfileConfigPath, "MilkingAttack", "TownhallTiles", 0, "int")
IniReadS($g_sMilkFarmAlgorithmTh, $g_sProfileConfigPath, "MilkingAttack", "TownHallAlgorithm", "Bam")
IniReadS($g_bMilkFarmSnipeEvenIfNoExtractorsFound, $g_sProfileConfigPath, "MilkingAttack", "TownHallHitAnyway", False, "Bool")
IniReadS($g_bMilkAttackAfterScriptedAtkEnable, $g_sProfileConfigPath, "MilkingAttack", "MilkAttackAfterScriptedAtk", False, "Bool")
IniReadS($g_sMilkAttackCSVscript, $g_sProfileConfigPath, "MilkingAttack", "MilkAttackCSVscript", "0")
IniReadS($g_bMilkFarmForceToleranceEnable, $g_sProfileConfigPath, "MilkingAttack", "MilkFarmForceTolerance", False, "Bool")
IniReadS($g_iMilkFarmForceToleranceNormal, $g_sProfileConfigPath, "MilkingAttack", "MilkFarmForcetolerancenormal", 60, "int")
IniReadS($g_iMilkFarmForceToleranceBoosted, $g_sProfileConfigPath, "MilkingAttack", "MilkFarmForcetoleranceboosted", 60, "int")
IniReadS($g_iMilkFarmForceToleranceDestroyed, $g_sProfileConfigPath, "MilkingAttack", "MilkFarmForcetolerancedestroyed", 60, "int")
EndFunc
Func ReadConfig_600_29_LB()
IniReadS($g_aiAttackAlgorithm[$LB], $g_sProfileConfigPath, "attack", "ABAtkAlgorithm", 0, "int")
IniReadS($g_aiAttackTroopSelection[$LB], $g_sProfileConfigPath, "attack", "ABSelectTroop", 0, "int")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $g_sProfileConfigPath, "attack", "ABKingAtk", $eHeroNone)
IniReadS($temp2, $g_sProfileConfigPath, "attack", "ABQueenAtk", $eHeroNone)
IniReadS($temp3, $g_sProfileConfigPath, "attack", "ABWardenAtk", $eHeroNone)
$g_aiAttackUseHeroes[$LB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
IniReadS($g_abAttackDropCC[$LB], $g_sProfileConfigPath, "attack", "ABDropCC", False, "Bool")
IniReadS($g_abAttackUseLightSpell[$LB], $g_sProfileConfigPath, "attack", "ABLightSpell", False, "Bool")
IniReadS($g_abAttackUseHealSpell[$LB], $g_sProfileConfigPath, "attack", "ABHealSpell", False, "Bool")
IniReadS($g_abAttackUseRageSpell[$LB], $g_sProfileConfigPath, "attack", "ABRageSpell", False, "Bool")
IniReadS($g_abAttackUseJumpSpell[$LB], $g_sProfileConfigPath, "attack", "ABJumpSpell", False, "Bool")
IniReadS($g_abAttackUseFreezeSpell[$LB], $g_sProfileConfigPath, "attack", "ABFreezeSpell", False, "Bool")
IniReadS($g_abAttackUsePoisonSpell[$LB], $g_sProfileConfigPath, "attack", "ABPoisonSpell", False, "Bool")
IniReadS($g_abAttackUseEarthquakeSpell[$LB], $g_sProfileConfigPath, "attack", "ABEarthquakeSpell", False, "Bool")
IniReadS($g_abAttackUseHasteSpell[$LB], $g_sProfileConfigPath, "attack", "ABHasteSpell", False, "Bool")
IniReadS($g_abAttackUseCloneSpell[$LB], $g_sProfileConfigPath, "attack", "ABCloneSpell", False, "Bool")
IniReadS($g_abAttackUseSkeletonSpell[$LB], $g_sProfileConfigPath, "attack", "ABSkeletonSpell", False, "Bool")
IniReadS($g_bTHSnipeBeforeEnable[$LB], $g_sProfileConfigPath, "attack", "THSnipeBeforeLBEnable", False, "Bool")
IniReadS($g_iTHSnipeBeforeTiles[$LB], $g_sProfileConfigPath, "attack", "THSnipeBeforeLBTiles", 0, "int")
IniReadS($g_iTHSnipeBeforeScript[$LB], $g_sProfileConfigPath, "attack", "THSnipeBeforeLBScript", "bam")
IniReadS($g_aiAttackStdDropOrder[$LB], $g_sProfileConfigPath, "attack", "LBStandardAlgorithm", 0, "int")
IniReadS($g_aiAttackStdDropSides[$LB], $g_sProfileConfigPath, "attack", "ABDeploy", 0, "int")
IniReadS($g_aiAttackStdUnitDelay[$LB], $g_sProfileConfigPath, "attack", "ABUnitD", 4, "int")
IniReadS($g_aiAttackStdWaveDelay[$LB], $g_sProfileConfigPath, "attack", "ABWaveD", 4, "int")
IniReadS($g_abAttackStdRandomizeDelay[$LB], $g_sProfileConfigPath, "attack", "ABRandomSpeedAtk", True, "Bool")
IniReadS($g_abAttackStdSmartAttack[$LB], $g_sProfileConfigPath, "attack", "ABSmartAttackRedArea", True, "Bool")
IniReadS($g_aiAttackStdSmartDeploy[$LB], $g_sProfileConfigPath, "attack", "ABSmartAttackDeploy", 1, "int")
IniReadS($g_abAttackStdSmartNearCollectors[$LB][0], $g_sProfileConfigPath, "attack", "ABSmartAttackGoldMine", False, "Bool")
IniReadS($g_abAttackStdSmartNearCollectors[$LB][1], $g_sProfileConfigPath, "attack", "ABSmartAttackElixirCollector", False, "Bool")
IniReadS($g_abAttackStdSmartNearCollectors[$LB][2], $g_sProfileConfigPath, "attack", "ABSmartAttackDarkElixirDrill", False, "Bool")
IniReadS($g_aiAttackScrRedlineRoutine[$LB], $g_sProfileConfigPath, "attack", "RedlineRoutineAB", $g_aiAttackScrRedlineRoutine[$LB], "Int")
IniReadS($g_aiAttackScrDroplineEdge[$LB], $g_sProfileConfigPath, "attack", "DroplineEdgeAB", $g_aiAttackScrDroplineEdge[$LB], "Int")
IniReadS($g_sAttackScrScriptName[$LB], $g_sProfileConfigPath, "attack", "ScriptAB", "Barch four fingers")
EndFunc
Func ReadConfig_600_29_TS()
IniReadS($g_aiAttackTroopSelection[$TS], $g_sProfileConfigPath, "attack", "TSSelectTroop", 0, "int")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $g_sProfileConfigPath, "attack", "TSKingAtk", $eHeroNone)
IniReadS($temp2, $g_sProfileConfigPath, "attack", "TSQueenAtk", $eHeroNone)
IniReadS($temp3, $g_sProfileConfigPath, "attack", "TSWardenAtk", $eHeroNone)
$g_aiAttackUseHeroes[$TS] = BitOR(Int($temp1), Int($temp2), Int($temp3))
IniReadS($g_abAttackDropCC[$TS], $g_sProfileConfigPath, "attack", "TSDropCC", False, "Bool")
IniReadS($g_abAttackUseHealSpell[$TS], $g_sProfileConfigPath, "attack", "TSHealSpell", False, "Bool")
IniReadS($g_abAttackUseLightSpell[$TS], $g_sProfileConfigPath, "attack", "TSLightSpell", False, "Bool")
IniReadS($g_abAttackUseRageSpell[$TS], $g_sProfileConfigPath, "attack", "TSRageSpell", False, "Bool")
IniReadS($g_abAttackUseJumpSpell[$TS], $g_sProfileConfigPath, "attack", "TSJumpSpell", False, "Bool")
IniReadS($g_abAttackUseFreezeSpell[$TS], $g_sProfileConfigPath, "attack", "TSFreezeSpell", False, "Bool")
IniReadS($g_abAttackUsePoisonSpell[$TS], $g_sProfileConfigPath, "attack", "TSPoisonSpell", False, "Bool")
IniReadS($g_abAttackUseEarthquakeSpell[$TS], $g_sProfileConfigPath, "attack", "TSEarthquakeSpell", False, "Bool")
IniReadS($g_abAttackUseHasteSpell[$TS], $g_sProfileConfigPath, "attack", "TSHasteSpell", False, "Bool")
IniReadS($g_sAtkTSType, $g_sProfileConfigPath, "attack", "AttackTHType", "bam")
EndFunc
Func ReadConfig_600_30()
$g_bShareAttackEnable =(IniRead($g_sProfileConfigPath, "shareattack", "ShareAttack", "0") = "1")
$g_iShareMinGold = Int(IniRead($g_sProfileConfigPath, "shareattack", "minGold", 200000))
$g_iShareMinElixir = Int(IniRead($g_sProfileConfigPath, "shareattack", "minElixir", 200000))
$g_iShareMinDark = Int(IniRead($g_sProfileConfigPath, "shareattack", "minDark", 100))
$g_sShareMessage = IniRead($g_sProfileConfigPath, "shareattack", "Message", "Nice|Good|Thanks|Wowwww")
IniReadS($g_bTakeLootSnapShot, $g_sProfileConfigPath, "attack", "TakeLootSnapShot", False, "Bool")
IniReadS($g_bScreenshotLootInfo, $g_sProfileConfigPath, "attack", "ScreenshotLootInfo", False, "Bool")
EndFunc
Func ReadConfig_600_30_DB()
IniReadS($g_abStopAtkNoLoot1Enable[$DB], $g_sProfileConfigPath, "endbattle", "chkDBTimeStopAtk", True, "Bool")
IniReadS($g_aiStopAtkNoLoot1Time[$DB], $g_sProfileConfigPath, "endbattle", "txtDBTimeStopAtk", 15, "int")
IniReadS($g_abStopAtkNoLoot2Enable[$DB], $g_sProfileConfigPath, "endbattle", "chkDBTimeStopAtk2", False, "Bool")
IniReadS($g_aiStopAtkNoLoot2Time[$DB], $g_sProfileConfigPath, "endbattle", "txtDBTimeStopAtk2", 7, "int")
IniReadS($g_aiStopAtkNoLoot2MinGold[$DB], $g_sProfileConfigPath, "endbattle", "txtDBMinGoldStopAtk2", 1000, "int")
IniReadS($g_aiStopAtkNoLoot2MinElixir[$DB], $g_sProfileConfigPath, "endbattle", "txtDBMinElixirStopAtk2", 1000, "int")
IniReadS($g_aiStopAtkNoLoot2MinDark[$DB], $g_sProfileConfigPath, "endbattle", "txtDBMinDarkElixirStopAtk2", 50, "int")
IniReadS($g_abStopAtkNoResources[$DB], $g_sProfileConfigPath, "endbattle", "chkDBEndNoResources", False, "Bool")
IniReadS($g_abStopAtkOneStar[$DB], $g_sProfileConfigPath, "endbattle", "chkDBEndOneStar", False, "Bool")
IniReadS($g_abStopAtkTwoStars[$DB], $g_sProfileConfigPath, "endbattle", "chkDBEndTwoStars", False, "Bool")
IniReadS($g_abStopAtkPctHigherEnable[$DB], $g_sProfileConfigPath, "endbattle", "chkDBPercentageHigher", False, "Bool")
IniReadS($g_aiStopAtkPctHigherAmt[$DB], $g_sProfileConfigPath, "endbattle", "txtDBPercentageHigher", 50, "int")
IniReadS($g_abStopAtkPctNoChangeEnable[$DB], $g_sProfileConfigPath, "endbattle", "chkDBPercentageChange", False, "Bool")
IniReadS($g_aiStopAtkPctNoChangeTime[$DB], $g_sProfileConfigPath, "endbattle", "txtDBPercentageChange", 15, "int")
EndFunc
Func ReadConfig_600_30_LB()
IniReadS($g_abStopAtkNoLoot1Enable[$LB], $g_sProfileConfigPath, "endbattle", "chkABTimeStopAtk", True, "Bool")
IniReadS($g_aiStopAtkNoLoot1Time[$LB], $g_sProfileConfigPath, "endbattle", "txtABTimeStopAtk", 20, "int")
IniReadS($g_abStopAtkNoLoot2Enable[$LB], $g_sProfileConfigPath, "endbattle", "chkABTimeStopAtk2", False, "Bool")
IniReadS($g_aiStopAtkNoLoot2Time[$LB], $g_sProfileConfigPath, "endbattle", "txtABTimeStopAtk2", 7, "int")
IniReadS($g_aiStopAtkNoLoot2MinGold[$LB], $g_sProfileConfigPath, "endbattle", "txtABMinGoldStopAtk2", 1000, "int")
IniReadS($g_aiStopAtkNoLoot2MinElixir[$LB], $g_sProfileConfigPath, "endbattle", "txtABMinElixirStopAtk2", 1000, "int")
IniReadS($g_aiStopAtkNoLoot2MinDark[$LB], $g_sProfileConfigPath, "endbattle", "txtABMinDarkElixirStopAtk2", 50, "int")
IniReadS($g_abStopAtkNoResources[$LB], $g_sProfileConfigPath, "endbattle", "chkABEndNoResources", False, "Bool")
IniReadS($g_abStopAtkOneStar[$LB], $g_sProfileConfigPath, "endbattle", "chkABEndOneStar", False, "Bool")
IniReadS($g_abStopAtkTwoStars[$LB], $g_sProfileConfigPath, "endbattle", "chkABEndTwoStars", False, "Bool")
IniReadS($g_bDESideEndEnable, $g_sProfileConfigPath, "endbattle", "chkDESideEB", False, "Bool")
IniReadS($g_iDESideEndMin, $g_sProfileConfigPath, "endbattle", "txtDELowEndMin", 25, "int")
IniReadS($g_bDESideDisableOther, $g_sProfileConfigPath, "endbattle", "chkDisableOtherEBO", False, "Bool")
IniReadS($g_bDESideEndBKWeak, $g_sProfileConfigPath, "endbattle", "chkDEEndBk", False, "Bool")
IniReadS($g_bDESideEndAQWeak, $g_sProfileConfigPath, "endbattle", "chkDEEndAq", False, "Bool")
IniReadS($g_bDESideEndOneStar, $g_sProfileConfigPath, "endbattle", "chkDEEndOneStar", False, "Bool")
IniReadS($g_abStopAtkPctHigherEnable[$LB], $g_sProfileConfigPath, "endbattle", "chkABPercentageHigher", False, "Bool")
IniReadS($g_aiStopAtkPctHigherAmt[$LB], $g_sProfileConfigPath, "endbattle", "txtABPercentageHigher", 50, "int")
IniReadS($g_abStopAtkPctNoChangeEnable[$LB], $g_sProfileConfigPath, "endbattle", "chkABPercentageChange", False, "Bool")
IniReadS($g_aiStopAtkPctNoChangeTime[$LB], $g_sProfileConfigPath, "endbattle", "txtABPercentageChange", 15, "int")
EndFunc
Func ReadConfig_600_30_TS()
IniReadS($g_bEndTSCampsEnable, $g_sProfileConfigPath, "search", "ChkTSSearchCamps2", False, "Bool")
IniReadS($g_iEndTSCampsPct, $g_sProfileConfigPath, "search", "TSEnableAfterArmyCamps2", 100, "int")
EndFunc
Func ReadConfig_600_31()
$g_abCollectorLevelEnabled[6] = 0
For $i = 7 To 12
IniReadS($g_abCollectorLevelEnabled[$i], $g_sProfileConfigPath, "collectors", "lvl" & $i & "Enabled", True, "Bool")
Next
For $i = 6 To 12
IniReadS($g_aiCollectorLevelFill[$i], $g_sProfileConfigPath, "collectors", "lvl" & $i & "fill", 0, "int")
If $g_aiCollectorLevelFill[$i] > 1 Then $g_aiCollectorLevelFill[$i] = 1
Next
IniReadS($g_bCollectorFilterDisable, $g_sProfileConfigPath, "search", "chkDisableCollectorsFilter", False, "Bool")
IniReadS($g_iCollectorMatchesMin, $g_sProfileConfigPath, "collectors", "minmatches", $g_iCollectorMatchesMin)
If $g_iCollectorMatchesMin < 1 Or $g_iCollectorMatchesMin > 6 Then $g_iCollectorMatchesMin = 3
IniReadS($g_iCollectorToleranceOffset, $g_sProfileConfigPath, "collectors", "tolerance", 0, "int")
EndFunc
Func ReadConfig_600_32()
IniReadS($g_bDropTrophyEnable, $g_sProfileConfigPath, "search", "TrophyRange", False, "Bool")
IniReadS($g_iDropTrophyMin, $g_sProfileConfigPath, "search", "MinTrophy", 5000, "int")
IniReadS($g_iDropTrophyMax, $g_sProfileConfigPath, "search", "MaxTrophy", 5000, "int")
IniReadS($g_bDropTrophyUseHeroes, $g_sProfileConfigPath, "search", "chkTrophyHeroes", False, "Bool")
IniReadS($g_iDropTrophyHeroesPriority, $g_sProfileConfigPath, "search", "cmbTrophyHeroesPriority", 0, "int")
IniReadS($g_bDropTrophyAtkDead, $g_sProfileConfigPath, "search", "chkTrophyAtkDead", False, "Bool")
IniReadS($g_iDropTrophyArmyMinPct, $g_sProfileConfigPath, "search", "DTArmyMin", 70, "int")
EndFunc
Func ReadConfig_600_33()
IniReadS($g_bCustomDropOrderEnable, $g_sProfileConfigPath, "DropOrder", "chkDropOrder", False, "Bool")
For $p = 0 To UBound($g_aiCmbCustomDropOrder) - 1
IniReadS($g_aiCmbCustomDropOrder[$p], $g_sProfileConfigPath, "DropOrder", "cmbDropOrder" & $p, -1)
Next
EndFunc
Func ReadConfig_600_35_1()
$g_bDisableSplash =(IniRead($g_sProfileConfigPath, "General", "ChkDisableSplash", "0") = "1")
$g_bCheckVersion =(IniRead($g_sProfileConfigPath, "General", "ChkVersion", "1") = "1")
IniReadS($g_bDeleteLogs, $g_sProfileConfigPath, "deletefiles", "DeleteLogs", True, "Bool")
IniReadS($g_iDeleteLogsDays, $g_sProfileConfigPath, "deletefiles", "DeleteLogsDays", 2, "int")
IniReadS($g_bDeleteTemp, $g_sProfileConfigPath, "deletefiles", "DeleteTemp", True, "Bool")
IniReadS($g_iDeleteTempDays, $g_sProfileConfigPath, "deletefiles", "DeleteTempDays", 5, "int")
IniReadS($g_bDeleteLoots, $g_sProfileConfigPath, "deletefiles", "DeleteLoots", True, "Bool")
IniReadS($g_iDeleteLootsDays, $g_sProfileConfigPath, "deletefiles", "DeleteLootsDays", 2, "int")
IniReadS($g_bAutoStart, $g_sProfileConfigPath, "general", "AutoStart", False, "Bool")
IniReadS($g_iAutoStartDelay, $g_sProfileConfigPath, "general", "AutoStartDelay", 10, "int")
IniReadS($g_bRestarted, $g_sProfileConfigPath, "general", "Restarted", $g_bRestarted, "int")
If $g_bBotLaunchOption_Autostart = True Then $g_bRestarted = True
$g_bCheckGameLanguage =(IniRead($g_sProfileConfigPath, "General", "ChkLanguage", "1") = "1")
IniReadS($g_bAutoAlignEnable, $g_sProfileConfigPath, "general", "DisposeWindows", False, "Bool")
IniReadS($g_iAutoAlignPosition, $g_sProfileConfigPath, "general", "DisposeWindowsPos", "EMBED")
IniReadS($g_iAutoAlignOffsetX, $g_sProfileConfigPath, "other", "WAOffsetX", "")
IniReadS($g_iAutoAlignOffsetY, $g_sProfileConfigPath, "other", "WAOffsetY", "")
IniReadS($g_bHideWhenMinimized, $g_sProfileConfigPath, "general", "HideWhenMinimized", False, "Bool")
$g_bUseRandomClick =(IniRead($g_sProfileConfigPath, "other", "UseRandomClick", "0") = "1")
$g_bScreenshotPNGFormat =(IniRead($g_sProfileConfigPath, "other", "ScreenshotType", "0") = "1")
$g_bScreenshotHideName =(IniRead($g_sProfileConfigPath, "other", "ScreenshotHideName", "1") = "1")
IniReadS($g_iAnotherDeviceWaitTime, $g_sProfileConfigPath, "other", "txtTimeWakeUp", 0, "int")
$g_bForceSinglePBLogoff =(IniRead($g_sProfileConfigPath, "other", "chkSinglePBTForced", "0") = "1")
$g_iSinglePBForcedLogoffTime = Int(IniRead($g_sProfileConfigPath, "other", "ValueSinglePBTimeForced", 18))
$g_iSinglePBForcedEarlyExitTime = Int(IniRead($g_sProfileConfigPath, "other", "ValuePBTimeForcedExit", 15))
$g_bAutoResumeEnable =(IniRead($g_sProfileConfigPath, "other", "ChkAutoResume", "0") = "1")
$g_iAutoResumeTime = Int(IniRead($g_sProfileConfigPath, "other", "AutoResumeTime", 5))
IniReadS($g_bDisableNotifications, $g_sProfileConfigPath, "other", "ChkDisableNotifications", False, "Bool")
$g_bForceClanCastleDetection =(IniRead($g_sProfileConfigPath, "other", "ChkFixClanCastle", "0") = "1")
EndFunc
Func ReadConfig_600_35_2()
Local $sSwitchAccFile
$g_iCmbSwitchAcc = 0
$g_bChkSwitchAcc = False
For $g = 1 To 8
$sSwitchAccFile = $g_sProfilePath & "\SwitchAccount.0" & $g & ".ini"
If FileExists($sSwitchAccFile) = 0 Then ContinueLoop
Local $sProfile
Local $bEnabled
For $i = 1 To Int(IniRead($sSwitchAccFile, "SwitchAccount", "TotalCocAccount", 0)) + 1
$bEnabled = IniRead($sSwitchAccFile, "SwitchAccount", "Enable", "") = "1"
If $bEnabled Then
$bEnabled = IniRead($sSwitchAccFile, "SwitchAccount", "AccountNo." & $i, "") = "1"
If $bEnabled Then
$sProfile = IniRead($sSwitchAccFile, "SwitchAccount", "ProfileName." & $i, "")
If $sProfile = $g_sProfileCurrentName Then
$g_iCmbSwitchAcc = $g
ExitLoop
EndIf
EndIf
EndIf
Next
If $g_iCmbSwitchAcc Then
ReadConfig_SwitchAccounts()
ExitLoop
EndIf
Next
EndFunc
Func ReadConfig_SwitchAccounts()
If $g_iCmbSwitchAcc Then
Local $sSwitchAccFile = $g_sProfilePath & "\SwitchAccount.0" & $g_iCmbSwitchAcc & ".ini"
$g_bChkSwitchAcc = IniRead($sSwitchAccFile, "SwitchAccount", "Enable", "0") = "1"
$g_bChkGooglePlay = IniRead($sSwitchAccFile, "SwitchAccount", "GooglePlay", "0") = "1"
$g_bChkSuperCellID = IniRead($sSwitchAccFile, "SwitchAccount", "SuperCellID", "0") = "1"
$g_bChkSharedPrefs = IniRead($sSwitchAccFile, "SwitchAccount", "SharedPrefs", "0") = "1"
$g_bChkSmartSwitch = IniRead($sSwitchAccFile, "SwitchAccount", "SmartSwitch", "0") = "1"
$g_bDonateLikeCrazy = IniRead($sSwitchAccFile, "SwitchAccount", "DonateLikeCrazy", "0") = "1"
$g_iTotalAcc = Int(IniRead($sSwitchAccFile, "SwitchAccount", "TotalCocAccount", "-1"))
$g_iTrainTimeToSkip = Int(IniRead($sSwitchAccFile, "SwitchAccount", "TrainTimeToSkip", "1"))
For $i = 1 To 8
$g_abAccountNo[$i - 1] = IniRead($sSwitchAccFile, "SwitchAccount", "AccountNo." & $i, "") = "1"
$g_asProfileName[$i - 1] = IniRead($sSwitchAccFile, "SwitchAccount", "ProfileName." & $i, "")
$g_abDonateOnly[$i - 1] = IniRead($sSwitchAccFile, "SwitchAccount", "DonateOnly." & $i, "0") = "1"
Next
EndIf
EndFunc
Func ReadConfig_600_52_1()
$g_bQuickTrainEnable =(IniRead($g_sProfileConfigPath, "other", "ChkUseQTrain", "0") = "1")
$g_bQuickTrainArmy[0] =(IniRead($g_sProfileConfigPath, "troop", "QuickTrainArmy1", "0") = "1")
$g_bQuickTrainArmy[1] =(IniRead($g_sProfileConfigPath, "troop", "QuickTrainArmy2", "0") = "1")
$g_bQuickTrainArmy[2] =(IniRead($g_sProfileConfigPath, "troop", "QuickTrainArmy3", "0") = "1")
EndFunc
Func ReadConfig_600_52_2()
For $T = 0 To $eTroopCount - 1
Local $tempTroopCount, $tempTroopLevel
Switch $T
Case $eTroopBarbarian
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 58, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 1, "int")
Case $eTroopArcher
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 115, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 1, "int")
Case $eTroopGoblin
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 19, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 1, "int")
Case $eTroopGiant
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 4, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 1, "int")
Case $eTroopWallBreaker
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 4, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 1, "int")
Case Else
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 0, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 0, "int")
EndSwitch
$g_aiArmyCompTroops[$T] = $tempTroopCount
$g_aiTrainArmyTroopLevel[$T] = $tempTroopLevel
Next
For $S = 0 To $eSpellCount - 1
IniReadS($g_aiArmyCompSpells[$S], $g_sProfileConfigPath, "Spells", $g_asSpellShortNames[$S], 0, "int")
IniReadS($g_aiTrainArmySpellLevel[$S], $g_sProfileConfigPath, "LevelSpell", $g_asSpellShortNames[$S], 0, "int")
Next
IniReadS($g_iTrainArmyFullTroopPct, $g_sProfileConfigPath, "troop", "fullTroop", 100, "int")
$g_bTotalCampForced =(IniRead($g_sProfileConfigPath, "other", "ChkTotalCampForced", "1") = "1")
$g_iTotalCampForcedValue = Int(IniRead($g_sProfileConfigPath, "other", "ValueTotalCampForced", 220))
$g_bForceBrewSpells =(IniRead($g_sProfileConfigPath, "other", "ChkForceBrewBeforeAttack", "0") = "1")
IniReadS($g_iTotalSpellValue, $g_sProfileConfigPath, "Spells", "SpellFactory", 0, "int")
$g_iTotalSpellValue = Int($g_iTotalSpellValue)
EndFunc
Func ReadConfig_600_54()
IniReadS($g_bCustomTrainOrderEnable, $g_sProfileConfigPath, "troop", "chkTroopOrder", False, "Bool")
For $z = 0 To UBound($g_aiCmbCustomTrainOrder) - 1
IniReadS($g_aiCmbCustomTrainOrder[$z], $g_sProfileConfigPath, "troop", "cmbTroopOrder" & $z, -1)
Next
IniReadS($g_bCustomBrewOrderEnable, $g_sProfileConfigPath, "Spells", "chkSpellOrder", False, "Bool")
For $z = 0 To UBound($g_aiCmbCustomBrewOrder) - 1
IniReadS($g_aiCmbCustomBrewOrder[$z], $g_sProfileConfigPath, "Spells", "cmbSpellOrder" & $z, -1)
Next
EndFunc
Func ReadConfig_600_56()
$g_bSmartZapEnable =(IniRead($g_sProfileConfigPath, "SmartZap", "UseSmartZap", "0") = "1")
$g_bEarthQuakeZap =(IniRead($g_sProfileConfigPath, "SmartZap", "UseEarthQuakeZap", "0") = "1")
$g_bNoobZap =(IniRead($g_sProfileConfigPath, "SmartZap", "UseNoobZap", "0") = "1")
$g_bSmartZapDB =(IniRead($g_sProfileConfigPath, "SmartZap", "ZapDBOnly", "1") = "1")
$g_bSmartZapSaveHeroes =(IniRead($g_sProfileConfigPath, "SmartZap", "THSnipeSaveHeroes", "1") = "1")
$g_bSmartZapFTW =(IniRead($g_sProfileConfigPath, "SmartZap", "FTW", "0") = "1")
$g_iSmartZapMinDE = Int(IniRead($g_sProfileConfigPath, "SmartZap", "MinDE", 350))
$g_iSmartZapExpectedDE = Int(IniRead($g_sProfileConfigPath, "SmartZap", "ExpectedDE", 320))
EndFunc
Func ReadConfig_641_1()
IniReadS($g_bCloseWhileTrainingEnable, $g_sProfileConfigPath, "other", "chkCloseWaitEnable", True, "Bool")
IniReadS($g_bCloseWithoutShield, $g_sProfileConfigPath, "other", "chkCloseWaitTrain", False, "Bool")
IniReadS($g_bCloseEmulator, $g_sProfileConfigPath, "other", "btnCloseWaitStop", False, "Bool")
IniReadS($g_bSuspendComputer, $g_sProfileConfigPath, "other", "btnCloseWaitSuspendComputer", False, "Bool")
IniReadS($g_bCloseRandom, $g_sProfileConfigPath, "other", "btnCloseWaitStopRandom", False, "Bool")
IniReadS($g_bCloseExactTime, $g_sProfileConfigPath, "other", "btnCloseWaitExact", False, "Bool")
IniReadS($g_bCloseRandomTime, $g_sProfileConfigPath, "other", "btnCloseWaitRandom", True, "Bool")
IniReadS($g_iCloseRandomTimePercent, $g_sProfileConfigPath, "other", "CloseWaitRdmPercent", 10, "int")
IniReadS($g_iCloseMinimumTime, $g_sProfileConfigPath, "other", "MinimumTimeToClose", 2, "int")
IniReadS($g_iTrainClickDelay, $g_sProfileConfigPath, "other", "TrainITDelay", 40, "int")
IniReadS($g_bTrainAddRandomDelayEnable, $g_sProfileConfigPath, "other", "chkAddIdleTime", $g_bTrainAddRandomDelayEnable, "Bool")
IniReadS($g_iTrainAddRandomDelayMin, $g_sProfileConfigPath, "other", "txtAddDelayIdlePhaseTimeMin", $g_iTrainAddRandomDelayMin, "Int")
IniReadS($g_iTrainAddRandomDelayMax, $g_sProfileConfigPath, "other", "txtAddDelayIdlePhaseTimeMax", $g_iTrainAddRandomDelayMax, "Int")
EndFunc
Func IniReadS(ByRef $variable, $PrimaryInputFile, $section, $key, $defaultvalue, $valueType = Default)
Local $defaultvalueTest = "?"
Local $readValue = IniRead($g_sProfileSecondaryInputFileName, $section, $key, $defaultvalueTest)
If $readValue = $defaultvalueTest Then
$readValue = IniRead($PrimaryInputFile, $section, $key, $defaultvalue)
EndIf
Switch $valueType
Case Default
$variable = $readValue
Case "Int"
$variable = Int($readValue)
Case "Bool"
If $readValue = "True" Or $readValue = "1" Then
$variable = True
Else
$variable = False
EndIf
Case Else
$variable = $readValue
EndSwitch
EndFunc
Func saveConfig()
If $g_iGuiMode = 0 Then Return
If $g_bSaveConfigIsActive Then
SetDebugLog("saveConfig(), already running, exit")
Return
EndIf
$g_bSaveConfigIsActive = True
Local $t = __TimerInit()
Static $iSaveConfigCount = 0
$iSaveConfigCount += 1
SetDebugLog("saveConfig(), call number " & $iSaveConfigCount)
SaveProfileConfig()
SaveWeakBaseStats()
SaveBuildingConfig()
SaveRegularConfig()
SetDebugLog("SaveConfig(), time = " & Round(__TimerDiff($t) / 1000, 2) & " sec")
$g_bSaveConfigIsActive = False
EndFunc
Func SaveProfileConfig($sIniFile = Default, $bForceWrite = False)
If $sIniFile = Default Then $sIniFile = $g_sProfilePath & "\profile.ini"
IniWrite($sIniFile, "general", "defaultprofile", $g_sProfileCurrentName)
If $bForceWrite Or Int(IniRead($sIniFile, "general", "globalactivebotsallowed", 0)) = 0 Then
IniWrite($sIniFile, "general", "globalactivebotsallowed", $g_iGlobalActiveBotsAllowed)
EndIf
If $bForceWrite Or IniRead($sIniFile, "general", "globalthreads", "-") = "-" Then
IniWrite($sIniFile, "general", "globalthreads", $g_iGlobalThreads)
EndIf
SaveProfileConfigAdbPath($sIniFile)
EndFunc
Func SaveProfileConfigAdbPath($sIniFile = Default, $sAdbPath = $g_sAndroidAdbPath)
If $sIniFile = Default Then $sIniFile = $g_sProfilePath & "\profile.ini"
IniWrite($sIniFile, "general", "adb.path", $sAdbPath)
EndFunc
Func SaveWeakBaseStats()
_Ini_Clear()
For $j = 0 To UBound($g_aiWeakBaseStats) - 1
_Ini_Add("WeakBase", $g_aiWeakBaseStats[$j][0], $g_aiWeakBaseStats[$j][1])
Next
_Ini_Save($g_sProfileBuildingStatsPath)
EndFunc
Func SaveBuildingConfig()
SetDebugLog("Save Building Config " & $g_sProfileBuildingPath)
_Ini_Clear()
_Ini_Add("general", "version", GetVersionNormalized($g_sBotVersion))
_Ini_Add("upgrade", "LabPosX", $g_aiLaboratoryPos[0])
_Ini_Add("upgrade", "LabPosY", $g_aiLaboratoryPos[1])
_Ini_Add("other", "xTownHall", $g_aiTownHallPos[0])
_Ini_Add("other", "yTownHall", $g_aiTownHallPos[1])
_Ini_Add("other", "LevelTownHall", $g_iTownHallLevel)
_Ini_Add("other", "xCCPos", $g_aiClanCastlePos[0])
_Ini_Add("other", "yCCPos", $g_aiClanCastlePos[1])
_Ini_Add("other", "totalcamp", $g_iTotalCampSpace)
_Ini_Add("other", "xKingAltarPos", $g_aiKingAltarPos[0])
_Ini_Add("other", "yKingAltarPos", $g_aiKingAltarPos[1])
_Ini_Add("other", "xQueenAltarPos", $g_aiQueenAltarPos[0])
_Ini_Add("other", "yQueenAltarPos", $g_aiQueenAltarPos[1])
_Ini_Add("other", "xWardenAltarPos", $g_aiWardenAltarPos[0])
_Ini_Add("other", "yWardenAltarPos", $g_aiWardenAltarPos[1])
_Ini_Add("upgrade", "xLastGoodWallPos", $g_aiLastGoodWallPos[0])
_Ini_Add("upgrade", "yLastGoodWallPos", $g_aiLastGoodWallPos[1])
ApplyConfig_600_14(GetApplyConfigSaveAction())
_Ini_Add("upgrade", "upgradetroops", $g_bAutoLabUpgradeEnable ? 1 : 0)
_Ini_Add("upgrade", "upgradetroopname", $g_iCmbLaboratory)
_Ini_Add("upgrade", "upgradelabtime", $g_sLabUpgradeTime)
ApplyConfig_600_16(GetApplyConfigSaveAction())
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
_Ini_Add("upgrade", "xupgrade" & $iz, $g_avBuildingUpgrades[$iz][0])
_Ini_Add("upgrade", "yupgrade" & $iz, $g_avBuildingUpgrades[$iz][1])
_Ini_Add("upgrade", "upgradevalue" & $iz, $g_avBuildingUpgrades[$iz][2])
_Ini_Add("upgrade", "upgradetype" & $iz, $g_avBuildingUpgrades[$iz][3])
_Ini_Add("upgrade", "upgradename" & $iz, $g_avBuildingUpgrades[$iz][4])
_Ini_Add("upgrade", "upgradelevel" & $iz, $g_avBuildingUpgrades[$iz][5])
_Ini_Add("upgrade", "upgradetime" & $iz, $g_avBuildingUpgrades[$iz][6])
_Ini_Add("upgrade", "upgradeend" & $iz, $g_avBuildingUpgrades[$iz][7])
_Ini_Add("upgrade", "upgradechk" & $iz, $g_abBuildingUpgradeEnable[$iz] ? 1 : 0)
_Ini_Add("upgrade", "upgraderepeat" & $iz, $g_abUpgradeRepeatEnable[$iz] ? 1 : 0)
_Ini_Add("upgrade", "upgradestatusicon" & $iz, $g_aiPicUpgradeStatus[$iz])
Next
_Ini_Save($g_sProfileBuildingPath)
EndFunc
Func SaveRegularConfig()
SetDebugLog("Save Config " & $g_sProfileConfigPath)
_Ini_Clear()
_Ini_Add("general", "version", GetVersionNormalized($g_sBotVersion))
_Ini_Add("general", "threads", $g_iThreads)
_Ini_add("general", "botDesignFlags", $g_iBotDesignFlags)
_Ini_Add("general", "frmBotPosX", $g_iFrmBotPosX)
_Ini_Add("general", "frmBotPosY", $g_iFrmBotPosY)
If $g_hAndroidWindow <> 0 Then WinGetAndroidHandle()
_Ini_Add("general", "AndroidPosX", $g_iAndroidPosX)
_Ini_Add("general", "AndroidPosY", $g_iAndroidPosY)
_Ini_Add("general", "frmBotDockedPosX", $g_iFrmBotDockedPosX)
_Ini_Add("general", "frmBotDockedPosY", $g_iFrmBotDockedPosY)
_Ini_Add("general", "RedrawBotWindowMode", $g_iRedrawBotWindowMode)
SaveConfig_Android()
SaveConfig_600_1()
SaveConfig_600_6()
SaveConfig_600_9()
SaveConfig_600_11()
SaveConfig_600_12()
SaveConfig_600_13()
SaveConfig_600_15()
SaveConfig_600_16()
SaveConfig_auto()
SaveConfig_600_17()
SaveConfig_600_18()
SaveConfig_600_19()
SaveConfig_600_22()
SaveConfig_600_26()
SaveConfig_600_28()
SaveConfig_600_28_DB()
SaveConfig_600_28_LB()
SaveConfig_600_28_TS()
SaveConfig_600_29()
SaveConfig_600_29_DB()
SaveConfig_600_29_LB()
SaveConfig_600_29_TS()
SaveConfig_600_30()
SaveConfig_600_30_DB()
SaveConfig_600_30_LB()
SaveConfig_600_30_TS()
SaveConfig_600_31()
SaveConfig_600_32()
SaveConfig_600_33()
SaveConfig_600_35_1()
SaveConfig_600_35_2()
SaveConfig_600_52_1()
SaveConfig_600_52_2()
SaveConfig_600_54()
SaveConfig_600_56()
SaveConfig_641_1()
SaveConfig_Debug()
_Ini_Save($g_sProfileConfigPath)
EndFunc
Func SaveConfig_Android()
ApplyConfig_Android(GetApplyConfigSaveAction())
_Ini_Add("android", "game.distributor", $g_sAndroidGameDistributor)
_Ini_Add("android", "game.package", $g_sAndroidGamePackage)
_Ini_Add("android", "game.class", $g_sAndroidGameClass)
_Ini_Add("android", "user.distributor", $g_sUserGameDistributor)
_Ini_Add("android", "user.package", $g_sUserGamePackage)
_Ini_Add("android", "user.class", $g_sUserGameClass)
_Ini_Add("android", "backgroundmode", $g_iAndroidBackgroundMode)
_Ini_Add("android", "check.time.lag.enabled",($g_bAndroidCheckTimeLagEnabled ? "1" : "0"))
_Ini_Add("android", "adb.screencap.timeout.min", $g_iAndroidAdbScreencapTimeoutMin)
_Ini_Add("android", "adb.screencap.timeout.max", $g_iAndroidAdbScreencapTimeoutMax)
_Ini_Add("android", "adb.screencap.timeout.dynamic", $g_iAndroidAdbScreencapTimeoutDynamic)
_Ini_Add("android", "adb.input.enabled",($g_bAndroidAdbInputEnabled ? "1" : "0"))
_Ini_Add("android", "adb.click.enabled",($g_bAndroidAdbClickEnabled ? "1" : "0"))
_Ini_Add("android", "adb.click.drag.script",($g_bAndroidAdbClickDragScript ? "1" : "0"))
_Ini_Add("android", "adb.click.group", $g_iAndroidAdbClickGroup)
_Ini_Add("android", "adb.clicks.enabled",($g_bAndroidAdbClicksEnabled ? "1" : "0"))
_Ini_Add("android", "adb.clicks.troop.deploy.size", $g_iAndroidAdbClicksTroopDeploySize)
_Ini_Add("android", "no.focus.tampering",($g_bNoFocusTampering ? "1" : "0"))
_Ini_Add("android", "shield.color", Hex($g_iAndroidShieldColor, 6))
_Ini_Add("android", "shield.transparency", $g_iAndroidShieldTransparency)
_Ini_Add("android", "active.color", Hex($g_iAndroidActiveColor, 6))
_Ini_Add("android", "active.transparency", $g_iAndroidActiveTransparency)
_Ini_Add("android", "inactive.color", Hex($g_iAndroidInactiveColor, 6))
_Ini_Add("android", "inactive.transparency", $g_iAndroidInactiveTransparency)
_Ini_Add("android", "suspend.mode", $g_iAndroidSuspendModeFlags)
_Ini_Add("android", "emulator", $g_sAndroidEmulator)
_Ini_Add("android", "instance", $g_sAndroidInstance)
_Ini_Add("android", "reboot.hours", $g_iAndroidRebootHours)
_Ini_Add("android", "close",($g_bAndroidCloseWithBot ? "1" : "0"))
_Ini_Add("android", "process.affinity.mask", $g_iAndroidProcessAffinityMask)
EndFunc
Func SaveConfig_Debug()
ApplyConfig_Debug(GetApplyConfigSaveAction())
_Ini_Add("debug", "debugsetlog", $g_bDebugSetlog ? 1 : 0)
_Ini_Add("debug", "debugAndroid", $g_bDebugAndroid ? 1 : 0)
_Ini_Add("debug", "debugsetclick", $g_bDebugClick ? 1 : 0)
_Ini_Add("debug", "debugFunc",($g_bDebugFuncTime And $g_bDebugFuncCall)? 1 : 0)
_Ini_Add("debug", "disablezoomout", $g_bDebugDisableZoomout ? 1 : 0)
_Ini_Add("debug", "disablevillagecentering", $g_bDebugDisableVillageCentering ? 1 : 0)
_Ini_Add("debug", "debugdeadbaseimage", $g_bDebugDeadBaseImage ? 1 : 0)
_Ini_Add("debug", "debugocr", $g_bDebugOcr ? 1 : 0)
_Ini_Add("debug", "debugimagesave", $g_bDebugImageSave ? 1 : 0)
_Ini_Add("debug", "debugbuildingpos", $g_bDebugBuildingPos ? 1 : 0)
_Ini_Add("debug", "debugtrain", $g_bDebugSetlogTrain ? 1 : 0)
_Ini_Add("debug", "debugresourcesoffset", $g_bDebugResourcesOffset ? 1 : 0)
_Ini_Add("debug", "continuesearchelixirdebug", $g_bDebugContinueSearchElixir ? 1 : 0)
_Ini_Add("debug", "debugMilkingIMGmake", $g_bDebugMilkingIMGmake ? 1 : 0)
_Ini_Add("debug", "debugOCRDonate", $g_bDebugOCRdonate ? 1 : 0)
_Ini_Add("debug", "debugAttackCSV", $g_bDebugAttackCSV ? 1 : 0)
_Ini_Add("debug", "debugmakeimgcsv", $g_bDebugMakeIMGCSV ? 1 : 0)
_Ini_Add("debug", "DebugSmartZap", $g_bDebugSmartZap)
EndFunc
Func SaveConfig_600_1()
ApplyConfig_600_1(GetApplyConfigSaveAction())
_Ini_Add("general", "logstyle", $g_iCmbLogDividerOption)
_Ini_Add("general", "LogDividerY", $g_iLogDividerY)
_Ini_Add("general", "Background", $g_bChkBackgroundMode ? 1 : 0)
EndFunc
Func SaveConfig_600_6()
ApplyConfig_600_6(GetApplyConfigSaveAction())
_Ini_Add("general", "BotStop", $g_bChkBotStop ? 1 : 0)
_Ini_Add("general", "Command", $g_iCmbBotCommand)
_Ini_Add("general", "Cond", $g_iCmbBotCond)
_Ini_Add("general", "Hour", $g_iCmbHoursStop)
_Ini_Add("other", "minrestartgold", $g_iTxtRestartGold)
_Ini_Add("other", "minrestartelixir", $g_iTxtRestartElixir)
_Ini_Add("other", "minrestartdark", $g_iTxtRestartDark)
_Ini_Add("other", "chkTrap", $g_bChkTrap ? 1 : 0)
_Ini_Add("other", "chkCollect", $g_bChkCollect ? 1 : 0)
_Ini_Add("other", "chkTombstones", $g_bChkTombstones ? 1 : 0)
_Ini_Add("other", "chkCleanYard", $g_bChkCleanYard ? 1 : 0)
_Ini_Add("other", "ChkCollectFreeMagicItems", $g_bChkCollectFreeMagicItems ? 1 : 0)
_Ini_Add("other", "chkGemsBox", $g_bChkGemsBox ? 1 : 0)
_Ini_Add("other", "ChkTreasuryCollect", $g_bChkTreasuryCollect ? 1 : 0)
_Ini_Add("other", "minTreasurygold", $g_iTxtTreasuryGold)
_Ini_Add("other", "minTreasuryelixir", $g_iTxtTreasuryElixir)
_Ini_Add("other", "minTreasurydark", $g_iTxtTreasuryDark)
_Ini_Add("other", "ChkCollectBuildersBase", $g_bChkCollectBuilderBase ? 1 : 0)
_Ini_Add("other", "ChkStartClockTowerBoost", $g_bChkStartClockTowerBoost ? 1 : 0)
_Ini_Add("other", "ChkCTBoostBlderBz", $g_bChkCTBoostBlderBz ? 1 : 0)
_Ini_Add("other", "ChkBBSuggestedUpgrades", $g_iChkBBSuggestedUpgrades)
_Ini_Add("other", "ChkBBSuggestedUpgradesIgnoreGold", $g_iChkBBSuggestedUpgradesIgnoreGold)
_Ini_Add("other", "ChkBBSuggestedUpgradesIgnoreElixir", $g_iChkBBSuggestedUpgradesIgnoreElixir)
_Ini_Add("other", "ChkBBSuggestedUpgradesIgnoreHall", $g_iChkBBSuggestedUpgradesIgnoreHall)
_Ini_Add("other", "ChkPlacingNewBuildings", $g_iChkPlacingNewBuildings)
_Ini_Add("other", "ChkClanGamesAir", $g_bChkClanGamesAir ? 1 : 0)
_Ini_Add("other", "ChkClanGamesGround", $g_bChkClanGamesGround ? 1 : 0)
_Ini_Add("other", "ChkClanGamesMisc", $g_bChkClanGamesMisc ? 1 : 0)
_Ini_Add("other", "ChkClanGamesEnabled", $g_bChkClanGamesEnabled ? 1 : 0)
_Ini_Add("other", "ChkClanGamesOnly", $g_bChkClanGamesOnly ? 1 : 0)
_Ini_Add("other", "ChkClanGamesPurge", $g_bChkClanGamesPurge ? 1 : 0)
_Ini_Add("other", "ChkClanGamesStopBeforeReachAndPurge", $g_bChkClanGamesStopBeforeReachAndPurge ? 1 : 0)
_Ini_Add("other", "ChkClanGamesDebug", $g_bChkClanGamesDebug ? 1 : 0)
_Ini_Add("other", "ChkClanGamesLoot", $g_bChkClanGamesLoot ? 1 : 0)
_Ini_Add("other", "ChkClanGamesBattle", $g_bChkClanGamesBattle ? 1 : 0)
_Ini_Add("other", "ChkClanGamesDestruction", $g_bChkClanGamesDestruction ? 1 : 0)
_Ini_Add("other", "ChkClanGamesAirTroop", $g_bChkClanGamesAirTroop ? 1 : 0)
_Ini_Add("other", "ChkClanGamesGroundTroop ", $g_bChkClanGamesGroundTroop ? 1 : 0)
_Ini_Add("other", "ChkClanGamesMiscellaneous", $g_bChkClanGamesMiscellaneous ? 1 : 0)
_Ini_Add("other", "PurgeMax", $g_iPurgeMax)
EndFunc
Func SaveConfig_600_9()
ApplyConfig_600_9(GetApplyConfigSaveAction())
_Ini_Add("Unbreakable", "chkUnbreakable", $g_iUnbrkMode)
_Ini_Add("Unbreakable", "UnbreakableWait", $g_iUnbrkWait)
_Ini_Add("Unbreakable", "minUnBrkgold", $g_iUnbrkMinGold)
_Ini_Add("Unbreakable", "minUnBrkelixir", $g_iUnbrkMinElixir)
_Ini_Add("Unbreakable", "minUnBrkdark", $g_iUnbrkMinDark)
_Ini_Add("Unbreakable", "maxUnBrkgold", $g_iUnbrkMaxGold)
_Ini_Add("Unbreakable", "maxUnBrkelixir", $g_iUnbrkMaxElixir)
_Ini_Add("Unbreakable", "maxUnBrkdark", $g_iUnbrkMaxDark)
EndFunc
Func SaveConfig_600_11()
ApplyConfig_600_11(GetApplyConfigSaveAction())
_Ini_Add("planned", "RequestHoursEnable", $g_bRequestTroopsEnable ? 1 : 0)
_Ini_Add("donate", "txtRequest", $g_sRequestTroopsText)
Local $string = ""
For $i = 0 To 23
$string &=($g_abRequestCCHours[$i] ? "1" : "0") & "|"
Next
_Ini_Add("planned", "RequestHours", $string)
EndFunc
Func SaveConfig_600_12()
Local $t = __TimerInit()
ApplyConfig_600_12(GetApplyConfigSaveAction())
_Ini_Add("donate", "Doncheck", $g_bChkDonate ? 1 : 0)
For $i = 0 To $eTroopCount - 1 + $g_iCustomDonateConfigs
Local $sIniName = ""
If $i >= $eTroopBarbarian And $i <= $eTroopBowler Then
$sIniName = StringReplace($g_asTroopNamesPlural[$i], " ", "")
ElseIf $i = $eCustomA Then
$sIniName = "CustomA"
ElseIf $i = $eCustomB Then
$sIniName = "CustomB"
ElseIf $i = $eCustomC Then
$sIniName = "CustomC"
ElseIf $i = $eCustomD Then
$sIniName = "CustomD"
EndIf
_Ini_Add("donate", "chkDonate" & $sIniName, $g_abChkDonateTroop[$i] ? 1 : 0)
_Ini_Add("donate", "chkDonateAll" & $sIniName, $g_abChkDonateAllTroop[$i] ? 1 : 0)
_Ini_Add("donate", "txtDonate" & $sIniName, StringReplace($g_asTxtDonateTroop[$i], @CRLF, "|"))
_Ini_Add("donate", "txtBlacklist" & $sIniName, StringReplace($g_asTxtBlacklistTroop[$i], @CRLF, "|"))
Next
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
Local $sIniName = $g_asSpellNames[$i] & "Spells"
_Ini_Add("donate", "chkDonate" & $sIniName, $g_abChkDonateSpell[$i] ? 1 : 0)
_Ini_Add("donate", "chkDonateAll" & $sIniName, $g_abChkDonateAllSpell[$i] ? 1 : 0)
_Ini_Add("donate", "txtDonate" & $sIniName, StringReplace($g_asTxtDonateSpell[$i], @CRLF, "|"))
_Ini_Add("donate", "txtBlacklist" & $sIniName, StringReplace($g_asTxtBlacklistSpell[$i], @CRLF, "|"))
EndIf
Next
For $i = 0 To 2
_Ini_Add("donate", "cmbDonateCustomA" & $i + 1, $g_aiDonateCustomTrpNumA[$i][0])
_Ini_Add("donate", "txtDonateCustomA" & $i + 1, $g_aiDonateCustomTrpNumA[$i][1])
_Ini_Add("donate", "cmbDonateCustomB" & $i + 1, $g_aiDonateCustomTrpNumB[$i][0])
_Ini_Add("donate", "txtDonateCustomB" & $i + 1, $g_aiDonateCustomTrpNumB[$i][1])
_Ini_Add("donate", "cmbDonateCustomC" & $i + 1, $g_aiDonateCustomTrpNumC[$i][0])
_Ini_Add("donate", "txtDonateCustomC" & $i + 1, $g_aiDonateCustomTrpNumC[$i][1])
_Ini_Add("donate", "cmbDonateCustomD" & $i + 1, $g_aiDonateCustomTrpNumD[$i][0])
_Ini_Add("donate", "txtDonateCustomD" & $i + 1, $g_aiDonateCustomTrpNumD[$i][1])
Next
_Ini_Add("donate", "chkExtraAlphabets", $g_bChkExtraAlphabets ? 1 : 0)
_Ini_Add("donate", "chkExtraChinese", $g_bChkExtraChinese ? 1 : 0)
_Ini_Add("donate", "chkExtraKorean", $g_bChkExtraKorean ? 1 : 0)
_Ini_Add("donate", "chkExtraPersian", $g_bChkExtraPersian ? 1 : 0)
_Ini_Add("donate", "txtBlacklist", StringReplace($g_sTxtGeneralBlacklist, @CRLF, "|"))
EndFunc
Func SaveConfig_600_13()
ApplyConfig_600_13(GetApplyConfigSaveAction())
_Ini_Add("planned", "DonateHoursEnable", $g_bDonateHoursEnable ? 1 : 0)
Local $string = ""
For $i = 0 To 23
$string &=($g_abDonateHours[$i] ? "1" : "0") & "|"
Next
_Ini_Add("planned", "DonateHours", $string)
_Ini_Add("donate", "cmbFilterDonationsCC", $g_iCmbDonateFilter)
_Ini_Add("donate", "SkipDonateNearFulLTroopsEnable", $g_bDonateSkipNearFullEnable ? 1 : 0)
_Ini_Add("donate", "SkipDonateNearFulLTroopsPercentual", $g_iDonateSkipNearFullPercent)
EndFunc
Func SaveConfig_600_15()
ApplyConfig_600_15(GetApplyConfigSaveAction())
_Ini_Add("upgrade", "UpgradeKing", $g_bUpgradeKingEnable ? 1 : 0)
_Ini_Add("upgrade", "UpgradeQueen", $g_bUpgradeQueenEnable ? 1 : 0)
_Ini_Add("upgrade", "UpgradeWarden", $g_bUpgradeWardenEnable ? 1 : 0)
EndFunc
Func SaveConfig_600_16()
_Ini_Add("upgrade", "minupgrgold", $g_iUpgradeMinGold)
_Ini_Add("upgrade", "minupgrelixir", $g_iUpgradeMinElixir)
_Ini_Add("upgrade", "minupgrdark", $g_iUpgradeMinDark)
EndFunc
Func SaveConfig_auto()
ApplyConfig_auto(GetApplyConfigSaveAction())
_Ini_Add("Auto Upgrade", "ChkAutoUpgrade", $g_iChkAutoUpgrade)
For $i = 0 To 12
_Ini_Add("Auto Upgrade", "ChkUpgradesToIgnore[" & $i & "]", $g_iChkUpgradesToIgnore[$i])
Next
For $i = 0 To 2
_Ini_Add("Auto Upgrade", "ChkResourcesToIgnore[" & $i & "]", $g_iChkResourcesToIgnore[$i])
Next
_Ini_Add("Auto Upgrade", "SmartMinGold", $g_iTxtSmartMinGold)
_Ini_Add("Auto Upgrade", "SmartMinElixir", $g_iTxtSmartMinElixir)
_Ini_Add("Auto Upgrade", "SmartMinDark", $g_iTxtSmartMinDark)
EndFunc
Func SaveConfig_600_17()
ApplyConfig_600_17(GetApplyConfigSaveAction())
_Ini_Add("upgrade", "auto-wall", $g_bAutoUpgradeWallsEnable ? 1 : 0)
_Ini_Add("upgrade", "minwallgold", $g_iUpgradeWallMinGold)
_Ini_Add("upgrade", "minwallelixir", $g_iUpgradeWallMinElixir)
_Ini_Add("upgrade", "use-storage", $g_iUpgradeWallLootType)
_Ini_Add("upgrade", "savebldr", $g_bUpgradeWallSaveBuilder ? 1 : 0)
_Ini_Add("upgrade", "walllvl", $g_iCmbUpgradeWallsLevel)
For $i = 4 To 13
_Ini_Add("Walls", "Wall" & StringFormat("%02d", $i), $g_aiWallsCurrentCount[$i])
Next
_Ini_Add("upgrade", "WallCost", $g_iWallCost)
EndFunc
Func SaveConfig_600_18()
ApplyConfig_600_18(GetApplyConfigSaveAction())
_Ini_Add("notify", "PBEnabled", $g_bNotifyPBEnable ? 1 : 0)
_Ini_Add("notify", "TGEnabled", $g_bNotifyTGEnable ? 1 : 0)
_Ini_Add("notify", "PBToken", $g_sNotifyPBToken)
_Ini_Add("notify", "TGToken", $g_sNotifyTGToken)
_Ini_Add("notify", "PBRemote", $g_bNotifyRemoteEnable ? 1 : 0)
_Ini_Add("notify", "DeleteAllPBPushes", $g_bNotifyDeleteAllPushesOnStart ? 1 : 0)
_Ini_Add("notify", "DeleteOldPBPushes", $g_bNotifyDeletePushesOlderThan ? 1 : 0)
_Ini_Add("notify", "HoursPushBullet", $g_iNotifyDeletePushesOlderThanHours)
_Ini_Add("notify", "Origin", $g_sNotifyOrigin)
_Ini_Add("notify", "AlertPBVMFound", $g_bNotifyAlertMatchFound ? 1 : 0)
_Ini_Add("notify", "AlertPBLastRaid", $g_bNotifyAlerLastRaidIMG ? 1 : 0)
_Ini_Add("notify", "AlertPBWallUpgrade", $g_bNotifyAlertUpgradeWalls ? 1 : 0)
_Ini_Add("notify", "AlertPBOOS", $g_bNotifyAlertOutOfSync ? 1 : 0)
_Ini_Add("notify", "AlertPBVBreak", $g_bNotifyAlertTakeBreak ? 1 : 0)
_Ini_Add("notify", "AlertPBOtherDevice", $g_bNotifyAlertAnotherDevice ? 1 : 0)
_Ini_Add("notify", "AlertPBLastRaidTxt", $g_bNotifyAlerLastRaidTXT ? 1 : 0)
_Ini_Add("notify", "AlertPBCampFull", $g_bNotifyAlertCampFull ? 1 : 0)
_Ini_Add("notify", "AlertPBVillage", $g_bNotifyAlertVillageReport ? 1 : 0)
_Ini_Add("notify", "AlertPBLastAttack", $g_bNotifyAlertLastAttack ? 1 : 0)
_Ini_Add("notify", "AlertBuilderIdle", $g_bNotifyAlertBulderIdle ? 1 : 0)
_Ini_Add("notify", "AlertPBMaintenance", $g_bNotifyAlertMaintenance ? 1 : 0)
_Ini_Add("notify", "AlertPBBAN", $g_bNotifyAlertBAN ? 1 : 0)
_Ini_Add("notify", "AlertPBUpdate", $g_bNotifyAlertBOTUpdate ? 1 : 0)
_Ini_Add("notify", "AlertSmartWaitTime", $g_bNotifyAlertSmartWaitTime ? 1 : 0)
EndFunc
Func SaveConfig_600_19()
ApplyConfig_600_19(GetApplyConfigSaveAction())
_Ini_Add("notify", "NotifyHoursEnable", $g_bNotifyScheduleHoursEnable ? 1 : 0)
Local $string = ""
For $i = 0 To 23
$string &=($g_abNotifyScheduleHours[$i] ? "1" : "0") & "|"
Next
_Ini_Add("notify", "NotifyHours", $string)
_Ini_Add("notify", "NotifyWeekDaysEnable", $g_bNotifyScheduleWeekDaysEnable ? 1 : 0)
Local $string = ""
For $i = 0 To 6
$string &=($g_abNotifyScheduleWeekDays[$i] ? "1" : "0") & "|"
Next
_Ini_Add("notify", "NotifyWeekDays", $string)
EndFunc
Func SaveConfig_600_22()
ApplyConfig_600_22(GetApplyConfigSaveAction())
Local $string = ""
For $i = 0 To 23
$string &=($g_abBoostBarracksHours[$i] ? "1" : "0") & "|"
Next
_Ini_Add("planned", "BoostBarracksHours", $string)
EndFunc
Func SaveConfig_600_26()
ApplyConfig_600_26(GetApplyConfigSaveAction())
_Ini_Add("search", "BullyMode", $g_abAttackTypeEnable[$TB] ? 1 : 0)
_Ini_Add("search", "ATBullyMode", $g_iAtkTBEnableCount)
_Ini_Add("search", "YourTH", $g_iAtkTBMaxTHLevel)
_Ini_Add("search", "THBullyAttackMode", $g_iAtkTBMode)
EndFunc
Func SaveConfig_600_28()
ApplyConfig_600_28(GetApplyConfigSaveAction())
_Ini_Add("search", "reduction", $g_bSearchReductionEnable ? 1 : 0)
_Ini_Add("search", "reduceCount", $g_iSearchReductionCount)
_Ini_Add("search", "reduceGold", $g_iSearchReductionGold)
_Ini_Add("search", "reduceElixir", $g_iSearchReductionElixir)
_Ini_Add("search", "reduceGoldPlusElixir", $g_iSearchReductionGoldPlusElixir)
_Ini_Add("search", "reduceDark", $g_iSearchReductionDark)
_Ini_Add("search", "reduceTrophy", $g_iSearchReductionTrophy)
_Ini_Add("other", "VSDelay", $g_iSearchDelayMin)
_Ini_Add("other", "MaxVSDelay", $g_iSearchDelayMax)
_Ini_Add("general", "attacknow", $g_bSearchAttackNowEnable ? 1 : 0)
_Ini_Add("general", "attacknowdelay", $g_iSearchAttackNowDelay)
_Ini_Add("search", "ChkRestartSearchLimit", $g_bSearchRestartEnable ? 1 : 0)
_Ini_Add("search", "RestartSearchLimit", $g_iSearchRestartLimit)
_Ini_Add("general", "AlertSearch", $g_bSearchAlertMe ? 1 : 0)
EndFunc
Func SaveConfig_600_28_DB()
ApplyConfig_600_28_DB(GetApplyConfigSaveAction())
_Ini_Add("search", "DBcheck", $g_abAttackTypeEnable[$DB] ? 1 : 0)
_Ini_Add("search", "ChkDBSearchSearches", $g_abSearchSearchesEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBEnableAfterCount", $g_aiSearchSearchesMin[$DB])
_Ini_Add("search", "DBEnableBeforeCount", $g_aiSearchSearchesMax[$DB])
_Ini_Add("search", "ChkDBSearchTropies", $g_abSearchTropiesEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBEnableAfterTropies", $g_aiSearchTrophiesMin[$DB])
_Ini_Add("search", "DBEnableBeforeTropies", $g_aiSearchTrophiesMax[$DB])
_Ini_Add("search", "ChkDBSearchCamps", $g_abSearchCampsEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBEnableAfterArmyCamps", $g_aiSearchCampsPct[$DB])
_Ini_Add("attack", "DBKingWait", $g_iHeroWaitAttackNoBit[$DB][0])
_Ini_Add("attack", "DBQueenWait", $g_iHeroWaitAttackNoBit[$DB][1])
_Ini_Add("attack", "DBWardenWait", $g_iHeroWaitAttackNoBit[$DB][2])
_Ini_Add("attack", "DBNotWaitHeroes", $g_aiSearchNotWaitHeroesEnable[$DB] ? 1 : 0)
_Ini_Add("search", "ChkDBSpellsWait", $g_abSearchSpellsWaitEnable[$DB] ? 1 : 0)
_Ini_Add("search", "ChkDBCastleSpellWait", $g_abSearchCastleSpellsWaitEnable[$DB] ? 1 : 0)
_Ini_Add("search", "cmbDBWaitForCastleSpell", $g_aiSearchCastleSpellsWaitRegular[$DB])
_Ini_Add("search", "cmbDBWaitForCastleSpell2", $g_aiSearchCastleSpellsWaitDark[$DB])
_Ini_Add("search", "ChkDBCastleTroopsWait", $g_abSearchCastleTroopsWaitEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBMeetGE", $g_aiFilterMeetGE[$DB])
_Ini_Add("search", "DBsearchGold", $g_aiFilterMinGold[$DB])
_Ini_Add("search", "DBsearchElixir", $g_aiFilterMinElixir[$DB])
_Ini_Add("search", "DBsearchGoldPlusElixir", $g_aiFilterMinGoldPlusElixir[$DB])
_Ini_Add("search", "DBMeetDE", $g_abFilterMeetDEEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBsearchDark", $g_aiFilterMeetDEMin[$DB])
_Ini_Add("search", "DBMeetTrophy", $g_abFilterMeetTrophyEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBsearchTrophy", $g_aiFilterMeetTrophyMin[$DB])
_Ini_Add("search", "DBsearchTrophyMax", $g_aiFilterMeetTrophyMax[$DB])
_Ini_Add("search", "DBMeetTH", $g_abFilterMeetTH[$DB] ? 1 : 0)
_Ini_Add("search", "DBTHLevel", $g_aiFilterMeetTHMin[$DB])
_Ini_Add("search", "DBMeetTHO", $g_abFilterMeetTHOutsideEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBCheckMortar", $g_abFilterMaxMortarEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBCheckWizTower", $g_abFilterMaxWizTowerEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBCheckAirDefense", $g_abFilterMaxAirDefenseEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBCheckXBow", $g_abFilterMaxXBowEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBCheckInferno", $g_abFilterMaxInfernoEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBCheckEagle", $g_abFilterMaxEagleEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBWeakMortar", $g_aiFilterMaxMortarLevel[$DB])
_Ini_Add("search", "DBWeakWizTower", $g_aiFilterMaxWizTowerLevel[$DB])
_Ini_Add("search", "DBWeakAirDefense", $g_aiFilterMaxAirDefenseLevel[$DB])
_Ini_Add("search", "DBWeakXBow", $g_aiFilterMaxXBowLevel[$DB])
_Ini_Add("search", "DBWeakInferno", $g_aiFilterMaxInfernoLevel[$DB])
_Ini_Add("search", "DBWeakEagle", $g_aiFilterMaxEagleLevel[$DB])
_Ini_Add("search", "DBMeetOne", $g_abFilterMeetOneConditionEnable[$DB] ? 1 : 0)
EndFunc
Func SaveConfig_600_28_LB()
ApplyConfig_600_28_LB(GetApplyConfigSaveAction())
_Ini_Add("search", "ABcheck", $g_abAttackTypeEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ChkABSearchSearches", $g_abSearchSearchesEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABEnableAfterCount", $g_aiSearchSearchesMin[$LB])
_Ini_Add("search", "ABEnableBeforeCount", $g_aiSearchSearchesMax[$LB])
_Ini_Add("search", "ChkABSearchTropies", $g_abSearchTropiesEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABEnableAfterTropies", $g_aiSearchTrophiesMin[$LB])
_Ini_Add("search", "ABEnableBeforeTropies", $g_aiSearchTrophiesMax[$LB])
_Ini_Add("search", "ChkABSearchCamps", $g_abSearchCampsEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABEnableAfterArmyCamps", $g_aiSearchCampsPct[$LB])
_Ini_Add("attack", "ABKingWait", $g_iHeroWaitAttackNoBit[$LB][0])
_Ini_Add("attack", "ABQueenWait", $g_iHeroWaitAttackNoBit[$LB][1])
_Ini_Add("attack", "ABWardenWait", $g_iHeroWaitAttackNoBit[$LB][2])
_Ini_Add("attack", "ABNotWaitHeroes", $g_aiSearchNotWaitHeroesEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ChkABSpellsWait", $g_abSearchSpellsWaitEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ChkABCastleSpellWait", $g_abSearchCastleSpellsWaitEnable[$LB] ? 1 : 0)
_Ini_Add("search", "cmbABWaitForCastleSpell", $g_aiSearchCastleSpellsWaitRegular[$LB])
_Ini_Add("search", "cmbABWaitForCastleSpell2", $g_aiSearchCastleSpellsWaitDark[$LB])
_Ini_Add("search", "ChkABCastleTroopsWait", $g_abSearchCastleTroopsWaitEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABMeetGE", $g_aiFilterMeetGE[$LB])
_Ini_Add("search", "ABsearchGold", $g_aiFilterMinGold[$LB])
_Ini_Add("search", "ABsearchElixir", $g_aiFilterMinElixir[$LB])
_Ini_Add("search", "ABsearchGoldPlusElixir", $g_aiFilterMinGoldPlusElixir[$LB])
_Ini_Add("search", "ABMeetDE", $g_abFilterMeetDEEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABsearchDark", $g_aiFilterMeetDEMin[$LB])
_Ini_Add("search", "ABMeetTrophy", $g_abFilterMeetTrophyEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABsearchTrophy", $g_aiFilterMeetTrophyMin[$LB])
_Ini_Add("search", "ABsearchTrophyMax", $g_aiFilterMeetTrophyMax[$LB])
_Ini_Add("search", "ABMeetTH", $g_abFilterMeetTH[$LB] ? 1 : 0)
_Ini_Add("search", "ABTHLevel", $g_aiFilterMeetTHMin[$LB])
_Ini_Add("search", "ABMeetTHO", $g_abFilterMeetTHOutsideEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABCheckMortar", $g_abFilterMaxMortarEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABCheckWizTower", $g_abFilterMaxWizTowerEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABCheckAirDefense", $g_abFilterMaxAirDefenseEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABCheckXBow", $g_abFilterMaxXBowEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABCheckInferno", $g_abFilterMaxInfernoEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABCheckEagle", $g_abFilterMaxEagleEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABWeakMortar", $g_aiFilterMaxMortarLevel[$LB])
_Ini_Add("search", "ABWeakWizTower", $g_aiFilterMaxWizTowerLevel[$LB])
_Ini_Add("search", "ABWeakAirDefense", $g_aiFilterMaxAirDefenseLevel[$LB])
_Ini_Add("search", "ABWeakXBow", $g_aiFilterMaxXBowLevel[$LB])
_Ini_Add("search", "ABWeakInferno", $g_aiFilterMaxInfernoLevel[$LB])
_Ini_Add("search", "ABWeakEagle", $g_aiFilterMaxEagleLevel[$LB])
_Ini_Add("search", "ABMeetOne", $g_abFilterMeetOneConditionEnable[$LB] ? 1 : 0)
EndFunc
Func SaveConfig_600_28_TS()
ApplyConfig_600_28_TS(GetApplyConfigSaveAction())
_Ini_Add("search", "TScheck", $g_abAttackTypeEnable[$TS] ? 1 : 0)
_Ini_Add("search", "ChkTSSearchSearches", $g_abSearchSearchesEnable[$TS] ? 1 : 0)
_Ini_Add("search", "TSEnableAfterCount", $g_aiSearchSearchesMin[$TS])
_Ini_Add("search", "TSEnableBeforeCount", $g_aiSearchSearchesMax[$TS])
_Ini_Add("search", "ChkTSSearchTropies", $g_abSearchTropiesEnable[$TS] ? 1 : 0)
_Ini_Add("search", "TSEnableAfterTropies", $g_aiSearchTrophiesMin[$TS])
_Ini_Add("search", "TSEnableBeforeTropies", $g_aiSearchTrophiesMax[$TS])
_Ini_Add("search", "ChkTSSearchCamps", $g_abSearchCampsEnable[$TS] ? 1 : 0)
_Ini_Add("search", "TSEnableAfterArmyCamps", $g_aiSearchCampsPct[$TS])
_Ini_Add("search", "TSMeetGE", $g_aiFilterMeetGE[$TS])
_Ini_Add("search", "TSsearchGold", $g_aiFilterMinGold[$TS])
_Ini_Add("search", "TSsearchElixir", $g_aiFilterMinElixir[$TS])
_Ini_Add("search", "TSsearchGoldPlusElixir", $g_aiFilterMinGoldPlusElixir[$TS])
_Ini_Add("search", "TSMeetDE", $g_abFilterMeetDEEnable[$TS] ? 1 : 0)
_Ini_Add("search", "TSsearchDark", $g_aiFilterMeetDEMin[$TS])
_Ini_Add("search", "SWTtiles", $g_iAtkTSAddTilesWhileTrain)
_Ini_Add("search", "THaddTiles", $g_iAtkTSAddTilesFullTroops)
EndFunc
Func SaveConfig_600_29()
ApplyConfig_600_29(GetApplyConfigSaveAction())
_Ini_Add("attack", "ActivateQueen", $g_iActivateQueen)
_Ini_Add("attack", "ActivateKing", $g_iActivateKing)
_Ini_Add("attack", "ActivateWarden", $g_iActivateWarden)
_Ini_Add("attack", "delayActivateQueen", $g_iDelayActivateQueen)
_Ini_Add("attack", "delayActivateKing", $g_iDelayActivateKing)
_Ini_Add("attack", "delayActivateWarden", $g_iDelayActivateWarden)
_Ini_Add("planned", "chkAttackPlannerEnable", $g_bAttackPlannerEnable ? 1 : 0)
_Ini_Add("planned", "chkAttackPlannerCloseCoC", $g_bAttackPlannerCloseCoC ? 1 : 0)
_Ini_Add("planned", "chkAttackPlannerCloseAll", $g_bAttackPlannerCloseAll ? 1 : 0)
_Ini_Add("planned", "chkAttackPlannerSuspendComputer", $g_bAttackPlannerSuspendComputer ? 1 : 0)
_Ini_Add("planned", "chkAttackPlannerRandom", $g_bAttackPlannerRandomEnable ? 1 : 0)
_Ini_Add("planned", "cmbAttackPlannerRandom", $g_iAttackPlannerRandomTime)
_Ini_Add("planned", "chkAttackPlannerDayLimit", $g_bAttackPlannerDayLimit ? 1 : 0)
_Ini_Add("planned", "cmbAttackPlannerDayMin", $g_iAttackPlannerDayMin)
_Ini_Add("planned", "cmbAttackPlannerDayMax", $g_iAttackPlannerDayMax)
Local $string = ""
For $i = 0 To 6
$string &=($g_abPlannedAttackWeekDays[$i] ? 1 : 0) & "|"
Next
_Ini_Add("planned", "attackDays", $string)
Local $string = ""
For $i = 0 To 23
$string &=($g_abPlannedattackHours[$i] ? 1 : 0) & "|"
Next
_Ini_Add("planned", "attackHours", $string)
_Ini_Add("planned", "DropCCEnable", $g_bPlannedDropCCHoursEnable ? 1 : 0)
_Ini_Add("ClanClastle", "BalanceCC", $g_bUseCCBalanced ? 1 : 0)
_Ini_Add("ClanClastle", "BalanceCCDonated", $g_iCCDonated)
_Ini_Add("ClanClastle", "BalanceCCReceived", $g_iCCReceived)
Local $string = ""
For $i = 0 To 23
$string &=($g_abPlannedDropCCHours[$i] ? 1 : 0) & "|"
Next
_Ini_Add("planned", "DropCCHours", $string)
EndFunc
Func SaveConfig_600_29_DB()
ApplyConfig_600_29_DB(GetApplyConfigSaveAction())
_Ini_Add("attack", "DBAtkAlgorithm", $g_aiAttackAlgorithm[$DB])
_Ini_Add("attack", "DBSelectTroop", $g_aiAttackTroopSelection[$DB])
_Ini_Add("attack", "DBKingAtk", BitAND($g_aiAttackUseHeroes[$DB], $eHeroKing))
_Ini_Add("attack", "DBQueenAtk", BitAND($g_aiAttackUseHeroes[$DB], $eHeroQueen))
_Ini_Add("attack", "DBWardenAtk", BitAND($g_aiAttackUseHeroes[$DB], $eHeroWarden))
_Ini_Add("attack", "DBDropCC", $g_abAttackDropCC[$DB] ? 1 : 0)
_Ini_Add("attack", "DBLightSpell", $g_abAttackUseLightSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBHealSpell", $g_abAttackUseHealSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBRageSpell", $g_abAttackUseRageSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBJumpSpell", $g_abAttackUseJumpSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBFreezeSpell", $g_abAttackUseFreezeSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBPoisonSpell", $g_abAttackUsePoisonSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBEarthquakeSpell", $g_abAttackUseEarthquakeSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBHasteSpell", $g_abAttackUseHasteSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBCloneSpell", $g_abAttackUseCloneSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBSkeletonSpell", $g_abAttackUseSkeletonSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "THSnipeBeforeDBEnable", $g_bTHSnipeBeforeEnable[$DB] ? 1 : 0)
_Ini_Add("attack", "THSnipeBeforeDBTiles", $g_iTHSnipeBeforeTiles[$DB])
_Ini_Add("attack", "THSnipeBeforeDBScript", $g_iTHSnipeBeforeScript[$DB])
SaveConfig_600_29_DB_Standard()
SaveConfig_600_29_DB_Scripted()
SaveConfig_600_29_DB_Milking()
EndFunc
Func SaveConfig_600_29_DB_Standard()
ApplyConfig_600_29_DB_Standard(GetApplyConfigSaveAction())
_Ini_Add("attack", "DBStandardAlgorithm", $g_aiAttackStdDropOrder[$DB])
_Ini_Add("attack", "DBDeploy", $g_aiAttackStdDropSides[$DB])
_Ini_Add("attack", "DBUnitD", $g_aiAttackStdUnitDelay[$DB])
_Ini_Add("attack", "DBWaveD", $g_aiAttackStdWaveDelay[$DB])
_Ini_Add("attack", "DBRandomSpeedAtk", $g_abAttackStdRandomizeDelay[$DB] ? 1 : 0)
_Ini_Add("attack", "DBSmartAttackRedArea", $g_abAttackStdSmartAttack[$DB] ? 1 : 0)
_Ini_Add("attack", "DBSmartAttackDeploy", $g_aiAttackStdSmartDeploy[$DB])
_Ini_Add("attack", "DBSmartAttackGoldMine", $g_abAttackStdSmartNearCollectors[$DB][0] ? 1 : 0)
_Ini_Add("attack", "DBSmartAttackElixirCollector", $g_abAttackStdSmartNearCollectors[$DB][1] ? 1 : 0)
_Ini_Add("attack", "DBSmartAttackDarkElixirDrill", $g_abAttackStdSmartNearCollectors[$DB][2] ? 1 : 0)
EndFunc
Func SaveConfig_600_29_DB_Scripted()
ApplyConfig_600_29_DB_Scripted(GetApplyConfigSaveAction())
_Ini_Add("attack", "RedlineRoutineDB", $g_aiAttackScrRedlineRoutine[$DB])
_Ini_Add("attack", "DroplineEdgeDB", $g_aiAttackScrDroplineEdge[$DB])
_Ini_Add("attack", "ScriptDB", $g_sAttackScrScriptName[$DB])
EndFunc
Func SaveConfig_600_29_DB_Milking()
ApplyConfig_600_29_DB_Milking(GetApplyConfigSaveAction())
_Ini_Add("MilkingAttack", "MilkAttackType", $g_iMilkAttackType)
Local $string = ""
For $i = 0 To 8
$string &= $g_aiMilkFarmElixirParam[$i] & "|"
Next
_Ini_Add("MilkingAttack", "LocateElixirLevel", $string)
_Ini_Add("MilkingAttack", "LocateElixir", $g_bMilkFarmLocateElixir ? 1 : 0)
_Ini_Add("MilkingAttack", "LocateMine", $g_bMilkFarmLocateMine ? 1 : 0)
_Ini_Add("MilkingAttack", "MineParam", $g_iMilkFarmMineParam)
_Ini_Add("MilkingAttack", "LocateDrill", $g_bMilkFarmLocateDrill ? 1 : 0)
_Ini_Add("MilkingAttack", "DrillParam", $g_iMilkFarmDrillParam)
_Ini_Add("MilkingAttack", "MaxTiles", $g_iMilkFarmResMaxTilesFromBorder)
_Ini_Add("MilkingAttack", "AttackElixir", $g_bMilkFarmAttackElixirExtractors ? 1 : 0)
_Ini_Add("MilkingAttack", "AttackMine", $g_bMilkFarmAttackGoldMines ? 1 : 0)
_Ini_Add("MilkingAttack", "AttackDrill", $g_bMilkFarmAttackDarkDrills ? 1 : 0)
_Ini_Add("MilkingAttack", "LimitGold", $g_iMilkFarmLimitGold)
_Ini_Add("MilkingAttack", "LimitElixir", $g_iMilkFarmLimitElixir)
_Ini_Add("MilkingAttack", "LimitDark", $g_iMilkFarmLimitDark)
_Ini_Add("MilkingAttack", "TroopForWaveMin", $g_iMilkFarmTroopForWaveMin)
_Ini_Add("MilkingAttack", "TroopForWaveMax", $g_iMilkFarmTroopForWaveMax)
_Ini_Add("MilkingAttack", "MaxWaves", $g_iMilkFarmTroopMaxWaves)
_Ini_Add("MilkingAttack", "DelayBetweenWavesMin", $g_iMilkFarmDelayFromWavesMin)
_Ini_Add("MilkingAttack", "DelayBetweenWavesMax", $g_iMilkFarmDelayFromWavesMax)
_Ini_Add("MilkingAttack", "DropRandomPlace", $g_iMilkingAttackDropGoblinAlgorithm)
_Ini_Add("MilkingAttack", "StructureOrder", $g_iMilkingAttackStructureOrder)
_Ini_Add("MilkingAttack", "CheckStructureDestroyedBeforeAttack", $g_bMilkingAttackCheckStructureDestroyedBeforeAttack ? 1 : 0)
_Ini_Add("MilkingAttack", "CheckStructureDestroyedAfterAttack", $g_bMilkingAttackCheckStructureDestroyedAfterAttack ? 1 : 0)
_Ini_Add("MilkingAttack", "MilkAttackAfterTHSnipe", $g_bMilkAttackAfterTHSnipeEnable ? 1 : 0)
_Ini_Add("MilkingAttack", "TownhallTiles", $g_iMilkFarmTHMaxTilesFromBorder)
_Ini_Add("MilkingAttack", "TownHallAlgorithm", $g_sMilkFarmAlgorithmTh)
_Ini_Add("MilkingAttack", "TownHallHitAnyway", $g_bMilkFarmSnipeEvenIfNoExtractorsFound ? 1 : 0)
_Ini_Add("MilkingAttack", "MilkAttackAfterScriptedAtk", $g_bMilkAttackAfterScriptedAtkEnable ? 1 : 0)
_Ini_Add("MilkingAttack", "MilkAttackCSVscript", $g_sMilkAttackCSVscript)
_Ini_Add("MilkingAttack", "MilkFarmForceTolerance", $g_bMilkFarmForceToleranceEnable ? 1 : 0)
_Ini_Add("MilkingAttack", "MilkFarmForcetolerancenormal", $g_iMilkFarmForceToleranceNormal)
_Ini_Add("MilkingAttack", "MilkFarmForcetoleranceboosted", $g_iMilkFarmForceToleranceBoosted)
_Ini_Add("MilkingAttack", "MilkFarmForcetolerancedestroyed", $g_iMilkFarmForceToleranceDestroyed)
EndFunc
Func SaveConfig_600_29_LB()
ApplyConfig_600_29_LB(GetApplyConfigSaveAction())
_Ini_Add("attack", "ABAtkAlgorithm", $g_aiAttackAlgorithm[$LB])
_Ini_Add("attack", "ABSelectTroop", $g_aiAttackTroopSelection[$LB])
_Ini_Add("attack", "ABKingAtk", BitAND($g_aiAttackUseHeroes[$LB], $eHeroKing))
_Ini_Add("attack", "ABQueenAtk", BitAND($g_aiAttackUseHeroes[$LB], $eHeroQueen))
_Ini_Add("attack", "ABWardenAtk", BitAND($g_aiAttackUseHeroes[$LB], $eHeroWarden))
_Ini_Add("attack", "ABDropCC", $g_abAttackDropCC[$LB] ? 1 : 0)
_Ini_Add("attack", "ABLightSpell", $g_abAttackUseLightSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABHealSpell", $g_abAttackUseHealSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABRageSpell", $g_abAttackUseRageSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABJumpSpell", $g_abAttackUseJumpSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABFreezeSpell", $g_abAttackUseFreezeSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABCloneSpell", $g_abAttackUseCloneSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABPoisonSpell", $g_abAttackUsePoisonSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABEarthquakeSpell", $g_abAttackUseEarthquakeSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABHasteSpell", $g_abAttackUseHasteSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABSkeletonSpell", $g_abAttackUseSkeletonSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "THSnipeBeforeLBEnable", $g_bTHSnipeBeforeEnable[$LB] ? 1 : 0)
_Ini_Add("attack", "THSnipeBeforeLBTiles", $g_iTHSnipeBeforeTiles[$LB])
_Ini_Add("attack", "THSnipeBeforeLBScript", $g_iTHSnipeBeforeScript[$LB])
SaveConfig_600_29_LB_Standard()
SaveConfig_600_29_LB_Scripted()
EndFunc
Func SaveConfig_600_29_LB_Standard()
ApplyConfig_600_29_LB_Standard(GetApplyConfigSaveAction())
_Ini_Add("attack", "LBStandardAlgorithm", $g_aiAttackStdDropOrder[$LB])
_Ini_Add("attack", "ABDeploy", $g_aiAttackStdDropSides[$LB])
_Ini_Add("attack", "ABUnitD", $g_aiAttackStdUnitDelay[$LB])
_Ini_Add("attack", "ABWaveD", $g_aiAttackStdWaveDelay[$LB])
_Ini_Add("attack", "ABRandomSpeedAtk", $g_abAttackStdRandomizeDelay[$LB] ? 1 : 0)
_Ini_Add("attack", "ABSmartAttackRedArea", $g_abAttackStdSmartAttack[$LB] ? 1 : 0)
_Ini_Add("attack", "ABSmartAttackDeploy", $g_aiAttackStdSmartDeploy[$LB])
_Ini_Add("attack", "ABSmartAttackGoldMine", $g_abAttackStdSmartNearCollectors[$LB][0] ? 1 : 0)
_Ini_Add("attack", "ABSmartAttackElixirCollector", $g_abAttackStdSmartNearCollectors[$LB][1] ? 1 : 0)
_Ini_Add("attack", "ABSmartAttackDarkElixirDrill", $g_abAttackStdSmartNearCollectors[$LB][2] ? 1 : 0)
EndFunc
Func SaveConfig_600_29_LB_Scripted()
ApplyConfig_600_29_LB_Scripted(GetApplyConfigSaveAction())
_Ini_Add("attack", "RedlineRoutineAB", $g_aiAttackScrRedlineRoutine[$LB])
_Ini_Add("attack", "DroplineEdgeAB", $g_aiAttackScrDroplineEdge[$LB])
_Ini_Add("attack", "ScriptAB", $g_sAttackScrScriptName[$LB])
EndFunc
Func SaveConfig_600_29_TS()
ApplyConfig_600_29_TS(GetApplyConfigSaveAction())
_Ini_Add("attack", "TSSelectTroop", $g_aiAttackTroopSelection[$TS])
_Ini_Add("attack", "TSKingAtk", BitAND($g_aiAttackUseHeroes[$TS], $eHeroKing))
_Ini_Add("attack", "TSQueenAtk", BitAND($g_aiAttackUseHeroes[$TS], $eHeroQueen))
_Ini_Add("attack", "TSWardenAtk", BitAND($g_aiAttackUseHeroes[$TS], $eHeroWarden))
_Ini_Add("attack", "TSDropCC", $g_abAttackDropCC[$TS] ? 1 : 0)
_Ini_Add("attack", "TSLightSpell", $g_abAttackUseLightSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "TSHealSpell", $g_abAttackUseHealSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "TSRageSpell", $g_abAttackUseRageSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "TSJumpSpell", $g_abAttackUseJumpSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "TSFreezeSpell", $g_abAttackUseFreezeSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "TSPoisonSpell", $g_abAttackUsePoisonSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "TSEarthquakeSpell", $g_abAttackUseEarthquakeSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "TSHasteSpell", $g_abAttackUseHasteSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "AttackTHType", $g_sAtkTSType)
EndFunc
Func SaveConfig_600_30()
ApplyConfig_600_30(GetApplyConfigSaveAction())
_Ini_Add("shareattack", "ShareAttack", $g_bShareAttackEnable ? 1 : 0)
_Ini_Add("shareattack", "minGold", $g_iShareMinGold)
_Ini_Add("shareattack", "minElixir", $g_iShareMinElixir)
_Ini_Add("shareattack", "minDark", $g_iShareMinDark)
_Ini_Add("shareattack", "Message", $g_sShareMessage)
_Ini_Add("attack", "TakeLootSnapShot", $g_bTakeLootSnapShot ? 1 : 0)
_Ini_Add("attack", "ScreenshotLootInfo", $g_bScreenshotLootInfo ? 1 : 0)
EndFunc
Func SaveConfig_600_30_DB()
ApplyConfig_600_30_DB(GetApplyConfigSaveAction())
_Ini_Add("endbattle", "chkDBTimeStopAtk", $g_abStopAtkNoLoot1Enable[$DB] ? 1 : 0)
_Ini_Add("endbattle", "txtDBTimeStopAtk", $g_aiStopAtkNoLoot1Time[$DB])
_Ini_Add("endbattle", "chkDBTimeStopAtk2", $g_abStopAtkNoLoot2Enable[$DB] ? 1 : 0)
_Ini_Add("endbattle", "txtDBTimeStopAtk2", $g_aiStopAtkNoLoot2Time[$DB])
_Ini_Add("endbattle", "txtDBMinGoldStopAtk2", $g_aiStopAtkNoLoot2MinGold[$DB])
_Ini_Add("endbattle", "txtDBMinElixirStopAtk2", $g_aiStopAtkNoLoot2MinElixir[$DB])
_Ini_Add("endbattle", "txtDBMinDarkElixirStopAtk2", $g_aiStopAtkNoLoot2MinDark[$DB])
_Ini_Add("endbattle", "chkDBEndNoResources", $g_abStopAtkNoResources[$DB] ? 1 : 0)
_Ini_Add("endbattle", "chkDBEndOneStar", $g_abStopAtkOneStar[$DB] ? 1 : 0)
_Ini_Add("endbattle", "chkDBEndTwoStars", $g_abStopAtkTwoStars[$DB] ? 1 : 0)
_Ini_Add("endbattle", "chkDBPercentageHigher", $g_abStopAtkPctHigherEnable[$DB] ? 1 : 0)
_Ini_Add("endbattle", "txtDBPercentageHigher", $g_aiStopAtkPctHigherAmt[$DB])
_Ini_Add("endbattle", "chkDBPercentageChange", $g_abStopAtkPctNoChangeEnable[$DB] ? 1 : 0)
_Ini_Add("endbattle", "txtDBPercentageChange", $g_aiStopAtkPctNoChangeTime[$DB])
EndFunc
Func SaveConfig_600_30_LB()
ApplyConfig_600_30_LB(GetApplyConfigSaveAction())
_Ini_Add("endbattle", "chkABTimeStopAtk", $g_abStopAtkNoLoot1Enable[$LB] ? 1 : 0)
_Ini_Add("endbattle", "txtABTimeStopAtk", $g_aiStopAtkNoLoot1Time[$LB])
_Ini_Add("endbattle", "chkABTimeStopAtk2", $g_abStopAtkNoLoot2Enable[$LB] ? 1 : 0)
_Ini_Add("endbattle", "txtABTimeStopAtk2", $g_aiStopAtkNoLoot2Time[$LB])
_Ini_Add("endbattle", "txtABMinGoldStopAtk2", $g_aiStopAtkNoLoot2MinGold[$LB])
_Ini_Add("endbattle", "txtABMinElixirStopAtk2", $g_aiStopAtkNoLoot2MinElixir[$LB])
_Ini_Add("endbattle", "txtABMinDarkElixirStopAtk2", $g_aiStopAtkNoLoot2MinDark[$LB])
_Ini_Add("endbattle", "chkABEndNoResources", $g_abStopAtkNoResources[$LB] ? 1 : 0)
_Ini_Add("endbattle", "chkABEndOneStar", $g_abStopAtkOneStar[$LB] ? 1 : 0)
_Ini_Add("endbattle", "chkABEndTwoStars", $g_abStopAtkTwoStars[$LB] ? 1 : 0)
_Ini_Add("endbattle", "chkDESideEB", $g_bDESideEndEnable ? 1 : 0)
_Ini_Add("endbattle", "txtDELowEndMin", $g_iDESideEndMin)
_Ini_Add("endbattle", "chkDisableOtherEBO", $g_bDESideDisableOther ? 1 : 0)
_Ini_Add("endbattle", "chkDEEndAq", $g_bDESideEndAQWeak ? 1 : 0)
_Ini_Add("endbattle", "chkDEEndBk", $g_bDESideEndBKWeak ? 1 : 0)
_Ini_Add("endbattle", "chkDEEndOneStar", $g_bDESideEndOneStar ? 1 : 0)
_Ini_Add("endbattle", "chkABPercentageHigher", $g_abStopAtkPctHigherEnable[$LB] ? 1 : 0)
_Ini_Add("endbattle", "txtABPercentageHigher", $g_aiStopAtkPctHigherAmt[$LB])
_Ini_Add("endbattle", "chkABPercentageChange", $g_abStopAtkPctNoChangeEnable[$LB] ? 1 : 0)
_Ini_Add("endbattle", "txtABPercentageChange", $g_aiStopAtkPctNoChangeTime[$LB])
EndFunc
Func SaveConfig_600_30_TS()
ApplyConfig_600_30_TS(GetApplyConfigSaveAction())
_Ini_Add("search", "ChkTSSearchCamps2", $g_bEndTSCampsEnable ? 1 : 0)
_Ini_Add("search", "TSEnableAfterArmyCamps2", $g_iEndTSCampsPct)
EndFunc
Func SaveConfig_600_31()
ApplyConfig_600_31(GetApplyConfigSaveAction())
For $i = 6 To 12
_Ini_Add("collectors", "lvl" & $i & "Enabled", $g_abCollectorLevelEnabled[$i] ? 1 : 0)
_Ini_Add("collectors", "lvl" & $i & "fill", $g_aiCollectorLevelFill[$i])
Next
_Ini_Add("search", "chkDisableCollectorsFilter", $g_bCollectorFilterDisable ? 1 : 0)
_Ini_Add("collectors", "minmatches", $g_iCollectorMatchesMin)
_Ini_Add("collectors", "tolerance", $g_iCollectorToleranceOffset)
EndFunc
Func SaveConfig_600_32()
ApplyConfig_600_32(GetApplyConfigSaveAction())
_Ini_Add("search", "TrophyRange", $g_bDropTrophyEnable ? 1 : 0)
_Ini_Add("search", "MaxTrophy", $g_iDropTrophyMax)
_Ini_Add("search", "MinTrophy", $g_iDropTrophyMin)
_Ini_Add("search", "chkTrophyHeroes", $g_bDropTrophyUseHeroes ? 1 : 0)
_Ini_Add("search", "cmbTrophyHeroesPriority", $g_iDropTrophyHeroesPriority)
_Ini_Add("search", "chkTrophyAtkDead", $g_bDropTrophyAtkDead ? 1 : 0)
_Ini_Add("search", "DTArmyMin", $g_iDropTrophyArmyMinPct)
EndFunc
Func SaveConfig_600_33()
_Ini_Add("DropOrder", "chkDropOrder", $g_bCustomDropOrderEnable ? 1 : 0)
For $p = 0 To UBound($g_aiCmbCustomDropOrder) - 1
_Ini_Add("DropOrder", "cmbDropOrder" & $p, $g_aiCmbCustomDropOrder[$p])
Next
EndFunc
Func SaveConfig_600_35_1()
ApplyConfig_600_35_1(GetApplyConfigSaveAction())
_Ini_Add("other", "language", $g_sLanguage)
_Ini_Add("General", "ChkDisableSplash", $g_bDisableSplash ? 1 : 0)
_Ini_Add("General", "ChkVersion", $g_bCheckVersion ? 1 : 0)
_Ini_Add("deletefiles", "DeleteLogs", $g_bDeleteLogs ? 1 : 0)
_Ini_Add("deletefiles", "DeleteLogsDays", $g_iDeleteLogsDays)
_Ini_Add("deletefiles", "DeleteTemp", $g_bDeleteTemp ? 1 : 0)
_Ini_Add("deletefiles", "DeleteTempDays", $g_iDeleteTempDays)
_Ini_Add("deletefiles", "DeleteLoots", $g_bDeleteLoots ? 1 : 0)
_Ini_Add("deletefiles", "DeleteLootsDays", $g_iDeleteLootsDays)
_Ini_Add("general", "AutoStart", $g_bAutoStart ? 1 : 0)
_Ini_Add("general", "AutoStartDelay", $g_iAutoStartDelay)
_Ini_Add("General", "ChkLanguage", $g_bCheckGameLanguage ? 1 : 0)
_Ini_Add("general", "DisposeWindows", $g_bAutoAlignEnable ? 1 : 0)
_Ini_Add("general", "DisposeWindowsPos", $g_iAutoAlignPosition)
_Ini_Add("other", "WAOffsetX", $g_iAutoAlignOffsetX)
_Ini_Add("other", "WAOffsetY", $g_iAutoAlignOffsetY)
_Ini_Add("general", "UpdatingWhenMinimized", $g_bUpdatingWhenMinimized ? 1 : 0)
_Ini_Add("general", "HideWhenMinimized", $g_bHideWhenMinimized ? 1 : 0)
_Ini_Add("other", "UseRandomClick", $g_bUseRandomClick ? 1 : 0)
_Ini_Add("other", "ScreenshotType", $g_bScreenshotPNGFormat ? 1 : 0)
_Ini_Add("other", "ScreenshotHideName", $g_bScreenshotHideName ? 1 : 0)
_Ini_Add("other", "txtTimeWakeUp", $g_iAnotherDeviceWaitTime)
_Ini_Add("other", "chkSinglePBTForced", $g_bForceSinglePBLogoff ? 1 : 0)
_Ini_Add("other", "ValueSinglePBTimeForced", $g_iSinglePBForcedLogoffTime)
_Ini_Add("other", "ValuePBTimeForcedExit", $g_iSinglePBForcedEarlyExitTime)
_Ini_Add("other", "ChkAutoResume", $g_bAutoResumeEnable ? 1 : 0)
_Ini_Add("other", "AutoResumeTime", $g_iAutoResumeTime)
_Ini_Add("other", "ChkDisableNotifications", $g_bDisableNotifications)
_Ini_Add("other", "ChkFixClanCastle", $g_bForceClanCastleDetection ? 1 : 0)
EndFunc
Func SaveConfig_600_35_2()
ApplyConfig_600_35_2(GetApplyConfigSaveAction())
Local $sSwitchAccFile
Local $iCmbSwitchAcc = $g_iCmbSwitchAcc
If $iCmbSwitchAcc = 0 Then
For $g = 1 To 8
$sSwitchAccFile = $g_sProfilePath & "\SwitchAccount.0" & $g & ".ini"
If FileExists($sSwitchAccFile) = 0 Then ContinueLoop
Local $sProfile
Local $bEnabled
For $i = 1 To 8
$bEnabled = IniRead($sSwitchAccFile, "SwitchAccount", "Enable" & $i, "") = "1"
If $bEnabled Then
$bEnabled = IniRead($sSwitchAccFile, "SwitchAccount", "AccountNo." & $i, "") = "1"
If $bEnabled Then
$sProfile = IniRead($sSwitchAccFile, "SwitchAccount", "ProfileName." & $i, "")
If $sProfile = $g_sProfileCurrentName Then
$iCmbSwitchAcc = $g
ExitLoop 2
EndIf
EndIf
EndIf
Next
Next
EndIf
If $iCmbSwitchAcc Then
$sSwitchAccFile = $g_sProfilePath & "\SwitchAccount.0" & $iCmbSwitchAcc & ".ini"
IniWrite($sSwitchAccFile, "SwitchAccount", "Enable", $g_bChkSwitchAcc ? 1 : 0)
IniWrite($sSwitchAccFile, "SwitchAccount", "GooglePlay", $g_bChkGooglePlay ? 1 : 0)
IniWrite($sSwitchAccFile, "SwitchAccount", "SuperCellID", $g_bChkSuperCellID ? 1 : 0)
IniWrite($sSwitchAccFile, "SwitchAccount", "SharedPrefs", $g_bChkSharedPrefs ? 1 : 0)
IniWrite($sSwitchAccFile, "SwitchAccount", "SmartSwitch", $g_bChkSmartSwitch ? 1 : 0)
IniWrite($sSwitchAccFile, "SwitchAccount", "DonateLikeCrazy", $g_bDonateLikeCrazy ? 1 : 0)
IniWrite($sSwitchAccFile, "SwitchAccount", "TotalCocAccount", $g_iTotalAcc)
IniWrite($sSwitchAccFile, "SwitchAccount", "TrainTimeToSkip", $g_iTrainTimeToSkip)
For $i = 1 To 8
IniWrite($sSwitchAccFile, "SwitchAccount", "AccountNo." & $i, $g_abAccountNo[$i - 1] ? 1 : 0)
IniWrite($sSwitchAccFile, "SwitchAccount", "ProfileName." & $i, $g_asProfileName[$i - 1])
IniWrite($sSwitchAccFile, "SwitchAccount", "DonateOnly." & $i, $g_abDonateOnly[$i - 1] ? 1 : 0)
Next
EndIf
EndFunc
Func SaveConfig_600_52_1()
ApplyConfig_600_52_1(GetApplyConfigSaveAction())
_Ini_Add("other", "ChkUseQTrain", $g_bQuickTrainEnable ? 1 : 0)
_Ini_Add("troop", "QuickTrainArmy1", $g_bQuickTrainArmy[0] ? 1 : 0)
_Ini_Add("troop", "QuickTrainArmy2", $g_bQuickTrainArmy[1] ? 1 : 0)
_Ini_Add("troop", "QuickTrainArmy3", $g_bQuickTrainArmy[2] ? 1 : 0)
EndFunc
Func SaveConfig_600_52_2()
ApplyConfig_600_52_2(GetApplyConfigSaveAction())
For $t = 0 To $eTroopCount - 1
_Ini_Add("troop", $g_asTroopShortNames[$t], $g_aiArmyCompTroops[$t])
_Ini_Add("LevelTroop", $g_asTroopShortNames[$t], $g_aiTrainArmyTroopLevel[$t])
Next
For $s = 0 To $eSpellCount - 1
_Ini_Add("Spells", $g_asSpellShortNames[$s], $g_aiArmyCompSpells[$s])
_Ini_Add("LevelSpell", $g_asSpellShortNames[$s], $g_aiTrainArmySpellLevel[$s])
Next
_Ini_Add("troop", "fulltroop", $g_iTrainArmyFullTroopPct)
_Ini_Add("other", "ChkTotalCampForced", $g_bTotalCampForced ? 1 : 0)
_Ini_Add("other", "ValueTotalCampForced", $g_iTotalCampForcedValue)
_Ini_Add("Spells", "SpellFactory", $g_iTotalSpellValue)
_Ini_Add("other", "ChkForceBrewBeforeAttack", $g_bForceBrewSpells ? 1 : 0)
EndFunc
Func SaveConfig_600_54()
ApplyConfig_600_54(GetApplyConfigSaveAction())
_Ini_Add("troop", "chkTroopOrder", $g_bCustomTrainOrderEnable ? 1 : 0)
For $z = 0 To UBound($g_aiCmbCustomTrainOrder) - 1
_Ini_Add("troop", "cmbTroopOrder" & $z, $g_aiCmbCustomTrainOrder[$z])
Next
_Ini_Add("Spells", "chkSpellOrder", $g_bCustomBrewOrderEnable ? 1 : 0)
For $z = 0 To UBound($g_aiCmbCustomBrewOrder) - 1
_Ini_Add("Spells", "cmbSpellOrder" & $z, $g_aiCmbCustomBrewOrder[$z])
Next
EndFunc
Func SaveConfig_600_56()
ApplyConfig_600_56(GetApplyConfigSaveAction())
_Ini_Add("SmartZap", "UseSmartZap", $g_bSmartZapEnable ? 1 : 0)
_Ini_Add("SmartZap", "UseEarthQuakeZap", $g_bEarthQuakeZap ? 1 : 0)
_Ini_Add("SmartZap", "UseNoobZap", $g_bNoobZap ? 1 : 0)
_Ini_Add("SmartZap", "ZapDBOnly", $g_bSmartZapDB ? 1 : 0)
_Ini_Add("SmartZap", "THSnipeSaveHeroes", $g_bSmartZapSaveHeroes ? 1 : 0)
_Ini_Add("SmartZap", "FTW", $g_bSmartZapFTW ? 1 : 0)
_Ini_Add("SmartZap", "MinDE", $g_iSmartZapMinDE)
_Ini_Add("SmartZap", "ExpectedDE", $g_iSmartZapExpectedDE)
EndFunc
Func SaveConfig_641_1()
ApplyConfig_641_1(GetApplyConfigSaveAction())
_Ini_Add("other", "chkCloseWaitEnable", $g_bCloseWhileTrainingEnable ? 1 : 0)
_Ini_Add("other", "chkCloseWaitTrain", $g_bCloseWithoutShield ? 1 : 0)
_Ini_Add("other", "btnCloseWaitStop", $g_bCloseEmulator ? 1 : 0)
_Ini_Add("other", "btnCloseWaitSuspendComputer", $g_bSuspendComputer ? 1 : 0)
_Ini_Add("other", "btnCloseWaitStopRandom", $g_bCloseRandom ? 1 : 0)
_Ini_Add("other", "btnCloseWaitExact", $g_bCloseExactTime ? 1 : 0)
_Ini_Add("other", "btnCloseWaitRandom", $g_bCloseRandomTime ? 1 : 0)
_Ini_Add("other", "CloseWaitRdmPercent", $g_iCloseRandomTimePercent)
_Ini_Add("other", "MinimumTimeToClose", $g_iCloseMinimumTime)
_Ini_Add("other", "TrainITDelay", $g_iTrainClickDelay)
_Ini_Add("other", "chkAddIdleTime", $g_bTrainAddRandomDelayEnable ? 1 : 0)
_Ini_Add("other", "txtAddDelayIdlePhaseTimeMin", $g_iTrainAddRandomDelayMin)
_Ini_Add("other", "txtAddDelayIdlePhaseTimeMax", $g_iTrainAddRandomDelayMax)
EndFunc
Func IniWriteS($filename, $section, $key, $value)
IniWrite($filename, $section, $key, $value)
EndFunc
Func GetApplyConfigSaveAction()
If $g_iGuiMode <> 1 Then
Return "Save(disabled)"
EndIf
Return "Save"
EndFunc
Func GetTranslatedParsedText($sText, $var1 = Default, $var2 = Default, $var3 = Default)
Local $s = StringReplace(StringReplace($sText, "\r\n", @CRLF), "\n", @CRLF)
If $var1 = Default Then Return $s
If $var2 = Default Then Return StringFormat($sText, $var1)
If $var3 = Default Then Return StringFormat($sText, $var1, $var2)
Return StringFormat($sText, $var1, $var2, $var3)
EndFunc
Func DetectLanguage()
Local $decimalCode = "", $countryCode = "", $langName = ""
$g_sLanguage = IniRead($g_sProfileConfigPath, "other", "language", "")
If Not FileExists(@ScriptDir & "\Languages\" & $g_sLanguage & ".ini") Then $g_sLanguage = ""
If $g_sLanguage = "" Then
Local $OSLang = @OSLang
If $g_bDebugSetlog Then SetDebugLog("Detected language code: " & $OSLang)
Switch $OSLang
Case Hex(0x0004, 4)
$decimalCode = '4'
$countryCode = 'zh-CHS'
$langName = 'Chinese_S'
Case Hex(0x0401, 4)
$decimalCode = '1025'
$countryCode = 'ar-SA'
$langName = 'Arabic'
Case Hex(0x0402, 4)
$decimalCode = '1026'
$countryCode = 'bg-BG'
$langName = 'Bulgarian'
Case Hex(0x0403, 4)
$decimalCode = '1027'
$countryCode = 'ca-ES'
$langName = 'Catalan'
Case Hex(0x0404, 4)
$decimalCode = '1028'
$countryCode = 'zh-TW'
$langName = 'Chinese_T'
Case Hex(0x0405, 4)
$decimalCode = '1029'
$countryCode = 'cs-CZ'
$langName = 'Czech'
Case Hex(0x0406, 4)
$decimalCode = '1030'
$countryCode = 'da-DK'
$langName = 'Danish'
Case Hex(0x0407, 4)
$decimalCode = '1031'
$countryCode = 'de-DE'
$langName = 'German'
Case Hex(0x0408, 4)
$decimalCode = '1032'
$countryCode = 'el-GR'
$langName = 'Greek'
Case Hex(0x0409, 4)
$decimalCode = '1033'
$countryCode = 'en-US'
$langName = 'English'
Case Hex(0x040A, 4)
$decimalCode = '1034'
$countryCode = 'es-ES_tradnl'
$langName = 'Spanish'
Case Hex(0x040B, 4)
$decimalCode = '1035'
$countryCode = 'fi-FI'
$langName = 'Finnish'
Case Hex(0x040C, 4)
$decimalCode = '1036'
$countryCode = 'fr-FR'
$langName = 'French'
Case Hex(0x040D, 4)
$decimalCode = '1037'
$countryCode = 'he-IL'
$langName = 'Hebrew'
Case Hex(0x040E, 4)
$decimalCode = '1038'
$countryCode = 'hu-HU'
$langName = 'Hungarian'
Case Hex(0x040F, 4)
$decimalCode = '1039'
$countryCode = 'is-IS'
$langName = 'Icelandic'
Case Hex(0x0410, 4)
$decimalCode = '1040'
$countryCode = 'it-IT'
$langName = 'Italian'
Case Hex(0x0411, 4)
$decimalCode = '1041'
$countryCode = 'ja-JP'
$langName = 'Japanese'
Case Hex(0x0412, 4)
$decimalCode = '1042'
$countryCode = 'ko-KR'
$langName = 'Korean'
Case Hex(0x0413, 4)
$decimalCode = '1043'
$countryCode = 'nl-NL'
$langName = 'Dutch'
Case Hex(0x0414, 4)
$decimalCode = '1044'
$countryCode = 'nb-NO'
$langName = 'Norwegian'
Case Hex(0x0415, 4)
$decimalCode = '1045'
$countryCode = 'pl-PL'
$langName = 'Polish'
Case Hex(0x0416, 4)
$decimalCode = '1046'
$countryCode = 'pt-BR'
$langName = 'Portuguese'
Case Hex(0x0417, 4)
$decimalCode = '1047'
$countryCode = 'rm-CH'
$langName = 'Romansh'
Case Hex(0x0418, 4)
$decimalCode = '1048'
$countryCode = 'ro-RO'
$langName = 'Romanian'
Case Hex(0x0419, 4)
$decimalCode = '1049'
$countryCode = 'ru-RU'
$langName = 'Russian'
Case Hex(0x041A, 4)
$decimalCode = '1050'
$countryCode = 'hr-HR'
$langName = 'Croatian'
Case Hex(0x041B, 4)
$decimalCode = '1051'
$countryCode = 'sk-SK'
$langName = 'Slovak'
Case Hex(0x041C, 4)
$decimalCode = '1052'
$countryCode = 'sq-AL'
$langName = 'Albanian'
Case Hex(0x041D, 4)
$decimalCode = '1053'
$countryCode = 'sv-SE'
$langName = 'Swedish'
Case Hex(0x041E, 4)
$decimalCode = '1054'
$countryCode = 'th-TH'
$langName = 'Thai'
Case Hex(0x041F, 4)
$decimalCode = '1055'
$countryCode = 'tr-TR'
$langName = 'Turkish'
Case Hex(0x0420, 4)
$decimalCode = '1056'
$countryCode = 'ur-PK'
$langName = 'Urdu'
Case Hex(0x0421, 4)
$decimalCode = '1057'
$countryCode = 'id-ID'
$langName = 'Indonesian'
Case Hex(0x0422, 4)
$decimalCode = '1058'
$countryCode = 'uk-UA'
$langName = 'Ukrainian'
Case Hex(0x0423, 4)
$decimalCode = '1059'
$countryCode = 'be-BY'
$langName = 'Belarusian'
Case Hex(0x0424, 4)
$decimalCode = '1060'
$countryCode = 'sl-SI'
$langName = 'Slovenian'
Case Hex(0x0425, 4)
$decimalCode = '1061'
$countryCode = 'et-EE'
$langName = 'Estonian'
Case Hex(0x0426, 4)
$decimalCode = '1062'
$countryCode = 'lv-LV'
$langName = 'Latvian'
Case Hex(0x0427, 4)
$decimalCode = '1063'
$countryCode = 'lt-LT'
$langName = 'Lithuanian'
Case Hex(0x0428, 4)
$decimalCode = '1064'
$countryCode = 'tg-Cyrl-TJ'
$langName = 'Tajik'
Case Hex(0x0429, 4)
$decimalCode = '1065'
$countryCode = 'fa-IR'
$langName = 'Persian'
Case Hex(0x042A, 4)
$decimalCode = '1066'
$countryCode = 'vi-VN'
$langName = 'Vietnamese'
Case Hex(0x042B, 4)
$decimalCode = '1067'
$countryCode = 'hy-AM'
$langName = 'Armenian'
Case Hex(0x042C, 4)
$decimalCode = '1068'
$countryCode = 'az-Latn-AZ'
$langName = 'Azeri'
Case Hex(0x042D, 4)
$decimalCode = '1069'
$countryCode = 'eu-ES'
$langName = 'Basque'
Case Hex(0x042E, 4)
$decimalCode = '1070'
$countryCode = 'hsb-DE'
$langName = 'Upper'
Case Hex(0x042F, 4)
$decimalCode = '1071'
$countryCode = 'mk-MK'
$langName = 'Macedonian'
Case Hex(0x0432, 4)
$decimalCode = '1074'
$countryCode = 'tn-ZA'
$langName = 'Setswana'
Case Hex(0x0434, 4)
$decimalCode = '1076'
$countryCode = 'xh-ZA'
$langName = 'isiXhosa'
Case Hex(0x0435, 4)
$decimalCode = '1077'
$countryCode = 'zu-ZA'
$langName = 'isiZulu'
Case Hex(0x0436, 4)
$decimalCode = '1078'
$countryCode = 'af-ZA'
$langName = 'Afrikaans'
Case Hex(0x0437, 4)
$decimalCode = '1079'
$countryCode = 'ka-GE'
$langName = 'Georgian'
Case Hex(0x0438, 4)
$decimalCode = '1080'
$countryCode = 'fo-FO'
$langName = 'Faroese'
Case Hex(0x0439, 4)
$decimalCode = '1081'
$countryCode = 'hi-IN'
$langName = 'Hindi'
Case Hex(0x043A, 4)
$decimalCode = '1082'
$countryCode = 'mt-MT'
$langName = 'Maltese'
Case Hex(0x043B, 4)
$decimalCode = '1083'
$countryCode = 'se-NO'
$langName = 'Sami'
Case Hex(0x043e, 4)
$decimalCode = '1086'
$countryCode = 'ms-MY'
$langName = 'Malay'
Case Hex(0x043F, 4)
$decimalCode = '1087'
$countryCode = 'kk-KZ'
$langName = 'Kazakh'
Case Hex(0x0440, 4)
$decimalCode = '1088'
$countryCode = 'ky-KG'
$langName = 'Kyrgyz'
Case Hex(0x0441, 4)
$decimalCode = '1089'
$countryCode = 'sw-KE'
$langName = 'Swahili'
Case Hex(0x0442, 4)
$decimalCode = '1090'
$countryCode = 'tk-TM'
$langName = 'Turkmen'
Case Hex(0x0443, 4)
$decimalCode = '1091'
$countryCode = 'uz-Latn-UZ'
$langName = 'Uzbek'
Case Hex(0x0444, 4)
$decimalCode = '1092'
$countryCode = 'tt-RU'
$langName = 'Tatar'
Case Hex(0x0445, 4)
$decimalCode = '1093'
$countryCode = 'bn-IN'
$langName = 'Bangla'
Case Hex(0x0446, 4)
$decimalCode = '1094'
$countryCode = 'pa-IN'
$langName = 'Punjabi'
Case Hex(0x0447, 4)
$decimalCode = '1095'
$countryCode = 'gu-IN'
$langName = 'Gujarati'
Case Hex(0x0448, 4)
$decimalCode = '1096'
$countryCode = 'or-IN'
$langName = 'Oriya'
Case Hex(0x0449, 4)
$decimalCode = '1097'
$countryCode = 'ta-IN'
$langName = 'Tamil'
Case Hex(0x044A, 4)
$decimalCode = '1098'
$countryCode = 'te-IN'
$langName = 'Telugu'
Case Hex(0x044B, 4)
$decimalCode = '1099'
$countryCode = 'kn-IN'
$langName = 'Kannada'
Case Hex(0x044C, 4)
$decimalCode = '1100'
$countryCode = 'ml-IN'
$langName = 'Malayalam'
Case Hex(0x044D, 4)
$decimalCode = '1101'
$countryCode = 'as-IN'
$langName = 'Assamese'
Case Hex(0x044E, 4)
$decimalCode = '1102'
$countryCode = 'mr-IN'
$langName = 'Marathi'
Case Hex(0x044F, 4)
$decimalCode = '1103'
$countryCode = 'sa-IN'
$langName = 'Sanskrit'
Case Hex(0x0450, 4)
$decimalCode = '1104'
$countryCode = 'mn-MN'
$langName = 'Mongolian'
Case Hex(0x0451, 4)
$decimalCode = '1105'
$countryCode = 'bo-CN'
$langName = 'Tibetan'
Case Hex(0x0452, 4)
$decimalCode = '1106'
$countryCode = 'cy-GB'
$langName = 'Welsh'
Case Hex(0x0453, 4)
$decimalCode = '1107'
$countryCode = 'km-KH'
$langName = 'Khmer'
Case Hex(0x0454, 4)
$decimalCode = '1108'
$countryCode = 'lo-LA'
$langName = 'Lao'
Case Hex(0x0456, 4)
$decimalCode = '1110'
$countryCode = 'gl-ES'
$langName = 'Galician'
Case Hex(0x0457, 4)
$decimalCode = '1111'
$countryCode = 'kok-IN'
$langName = 'Konkani'
Case Hex(0x0459, 4)
$decimalCode = '1113'
$countryCode = 'sd-Deva-IN'
$langName = '(reserved)'
Case Hex(0x045A, 4)
$decimalCode = '1114'
$countryCode = 'syr-SY'
$langName = 'Syriac'
Case Hex(0x045B, 4)
$decimalCode = '1115'
$countryCode = 'si-LK'
$langName = 'Sinhala'
Case Hex(0x045C, 4)
$decimalCode = '1116'
$countryCode = 'chr-Cher-US'
$langName = 'Cherokee'
Case Hex(0x045D, 4)
$decimalCode = '1117'
$countryCode = 'iu-Cans-CA'
$langName = 'Inuktitut'
Case Hex(0x045E, 4)
$decimalCode = '1118'
$countryCode = 'am-ET'
$langName = 'Amharic'
Case Hex(0x0461, 4)
$decimalCode = '1121'
$countryCode = 'ne-NP'
$langName = 'Nepali'
Case Hex(0x0462, 4)
$decimalCode = '1122'
$countryCode = 'fy-NL'
$langName = 'Frisian'
Case Hex(0x0463, 4)
$decimalCode = '1123'
$countryCode = 'ps-AF'
$langName = 'Pashto'
Case Hex(0x0464, 4)
$decimalCode = '1124'
$countryCode = 'fil-PH'
$langName = 'Filipino'
Case Hex(0x0465, 4)
$decimalCode = '1125'
$countryCode = 'dv-MV'
$langName = 'Divehi'
Case Hex(0x0468, 4)
$decimalCode = '1128'
$countryCode = 'ha-Latn-NG'
$langName = 'Hausa'
Case Hex(0x046A, 4)
$decimalCode = '1130'
$countryCode = 'yo-NG'
$langName = 'Yoruba'
Case Hex(0x046B, 4)
$decimalCode = '1131'
$countryCode = 'quz-BO'
$langName = 'Quechua'
Case Hex(0x046C, 4)
$decimalCode = '1132'
$countryCode = 'nso-ZA'
$langName = 'Sesotho'
Case Hex(0x046D, 4)
$decimalCode = '1133'
$countryCode = 'ba-RU'
$langName = 'Bashkir'
Case Hex(0x046E, 4)
$decimalCode = '1134'
$countryCode = 'lb-LU'
$langName = 'Luxembourgish'
Case Hex(0x046F, 4)
$decimalCode = '1135'
$countryCode = 'kl-GL'
$langName = 'Greenlandic'
Case Hex(0x0470, 4)
$decimalCode = '1136'
$countryCode = 'ig-NG'
$langName = 'Igbo'
Case Hex(0x0473, 4)
$decimalCode = '1139'
$countryCode = 'ti-ET'
$langName = 'Tigrinya'
Case Hex(0x0475, 4)
$decimalCode = '1141'
$countryCode = 'haw-US'
$langName = 'Hawiian'
Case Hex(0x0478, 4)
$decimalCode = '1144'
$countryCode = 'ii-CN'
$langName = 'Yi'
Case Hex(0x047A, 4)
$decimalCode = '1146'
$countryCode = 'arn-CL'
$langName = 'Mapudungun'
Case Hex(0x047C, 4)
$decimalCode = '1148'
$countryCode = 'moh-CA'
$langName = 'Mohawk'
Case Hex(0x047E, 4)
$decimalCode = '1150'
$countryCode = 'br-FR'
$langName = 'Breton'
Case Hex(0x0480, 4)
$decimalCode = '1152'
$countryCode = 'ug-CN'
$langName = 'Uyghur'
Case Hex(0x0481, 4)
$decimalCode = '1153'
$countryCode = 'mi-NZ'
$langName = 'Maori'
Case Hex(0x0482, 4)
$decimalCode = '1154'
$countryCode = 'oc-FR'
$langName = 'Occitan'
Case Hex(0x0483, 4)
$decimalCode = '1155'
$countryCode = 'co-FR'
$langName = 'Corsican'
Case Hex(0x0484, 4)
$decimalCode = '1156'
$countryCode = 'gsw-FR'
$langName = 'Alsatian'
Case Hex(0x0485, 4)
$decimalCode = '1157'
$countryCode = 'sah-RU'
$langName = 'Sakha'
Case Hex(0x0486, 4)
$decimalCode = '1158'
$countryCode = 'quc-Latn-GT'
$langName = "K'iche"
Case Hex(0x0487, 4)
$decimalCode = '1159'
$countryCode = 'rw-RW'
$langName = 'Kinyarwanda'
Case Hex(0x0488, 4)
$decimalCode = '1160'
$countryCode = 'wo-SN'
$langName = 'Wolof'
Case Hex(0x048C, 4)
$decimalCode = '1164'
$countryCode = 'prs-AF'
$langName = 'Dari'
Case Hex(0x0491, 4)
$decimalCode = '1169'
$countryCode = 'gd-GB'
$langName = 'Scottish'
Case Hex(0x0492, 4)
$decimalCode = '1170'
$countryCode = 'ku-Arab-IQ'
$langName = 'Central'
Case Hex(0x0801, 4)
$decimalCode = '2049'
$countryCode = 'ar-IQ'
$langName = 'Arabic'
Case Hex(0x0803, 4)
$decimalCode = '2051'
$countryCode = 'ca-ES-valencia'
$langName = 'Valencian'
Case Hex(0x0804, 4)
$decimalCode = '2052'
$countryCode = 'zh-CN'
$langName = 'Chinese_S'
Case Hex(0x0807, 4)
$decimalCode = '2055'
$countryCode = 'de-CH'
$langName = 'German'
Case Hex(0x0809, 4)
$decimalCode = '2057'
$countryCode = 'en-GB'
$langName = 'English'
Case Hex(0x080A, 4)
$decimalCode = '2058'
$countryCode = 'es-MX'
$langName = 'Spanish'
Case Hex(0x080C, 4)
$decimalCode = '2060'
$countryCode = 'fr-BE'
$langName = 'French'
Case Hex(0x0810, 4)
$decimalCode = '2064'
$countryCode = 'it-CH'
$langName = 'Italian'
Case Hex(0x0813, 4)
$decimalCode = '2067'
$countryCode = 'nl-BE'
$langName = 'Dutch'
Case Hex(0x0814, 4)
$decimalCode = '2068'
$countryCode = 'nn-NO'
$langName = 'Norwegian'
Case Hex(0x0816, 4)
$decimalCode = '2070'
$countryCode = 'pt-PT'
$langName = 'Portuguese'
Case Hex(0x081A, 4)
$decimalCode = '2074'
$countryCode = 'sr-Latn-CS'
$langName = 'Serbian'
Case Hex(0x081D, 4)
$decimalCode = '2077'
$countryCode = 'sv-FI'
$langName = 'Swedish'
Case Hex(0x0820, 4)
$decimalCode = '2080'
$countryCode = 'ur-IN'
$langName = 'Urdu'
Case Hex(0x082C, 4)
$decimalCode = '2092'
$countryCode = 'az-Cyrl-AZ'
$langName = 'Azeri'
Case Hex(0x082E, 4)
$decimalCode = '2094'
$countryCode = 'dsb-DE'
$langName = 'Lower'
Case Hex(0x0832, 4)
$decimalCode = '2098'
$countryCode = 'tn-BW'
$langName = 'Setswana'
Case Hex(0x083B, 4)
$decimalCode = '2107'
$countryCode = 'se-SE'
$langName = 'Sami'
Case Hex(0x083C, 4)
$decimalCode = '2108'
$countryCode = 'ga-IE'
$langName = 'Irish'
Case Hex(0x083E, 4)
$decimalCode = '2110'
$countryCode = 'ms-BN'
$langName = 'Malay'
Case Hex(0x0843, 4)
$decimalCode = '2115'
$countryCode = 'uz-Cyrl-UZ'
$langName = 'Uzbek'
Case Hex(0x0845, 4)
$decimalCode = '2117'
$countryCode = 'bn-BD'
$langName = 'Bangla'
Case Hex(0x0846, 4)
$decimalCode = '2118'
$countryCode = 'pa-Arab-PK'
$langName = 'Punjabi'
Case Hex(0x0849, 4)
$decimalCode = '2121'
$countryCode = 'ta-LK'
$langName = 'Tamil'
Case Hex(0x0850, 4)
$decimalCode = '2128'
$countryCode = 'mn-Mong-CN'
$langName = 'Mongolian'
Case Hex(0x0859, 4)
$decimalCode = '2137'
$countryCode = 'sd-Arab-PK'
$langName = 'Sindhi'
Case Hex(0x085D, 4)
$decimalCode = '2141'
$countryCode = 'iu-Latn-CA'
$langName = 'Inuktitut'
Case Hex(0x085F, 4)
$decimalCode = '2143'
$countryCode = 'tzm-Latn-DZ'
$langName = 'Tamazight'
Case Hex(0x0867, 4)
$decimalCode = '2151'
$countryCode = 'ff-Latn-SN'
$langName = 'Pular'
Case Hex(0x086B, 4)
$decimalCode = '2155'
$countryCode = 'quz-EC'
$langName = 'Quechua'
Case Hex(0x0873, 4)
$decimalCode = '2163'
$countryCode = 'ti-ER'
$langName = '(reserved)'
Case Hex(0x0873, 4)
$decimalCode = '2163'
$countryCode = 'ti-ER'
$langName = 'Tigrinya'
Case Hex(0x0C01, 4)
$decimalCode = '3073'
$countryCode = 'ar-EG'
$langName = 'Arabic'
Case Hex(0x0C04, 4)
$decimalCode = '3076'
$countryCode = 'zh-HK'
$langName = 'Chinese_T'
Case Hex(0x0C07, 4)
$decimalCode = '3079'
$countryCode = 'de-AT'
$langName = 'German'
Case Hex(0x0C09, 4)
$decimalCode = '3081'
$countryCode = 'en-AU'
$langName = 'English'
Case Hex(0x0C0A, 4)
$decimalCode = '3082'
$countryCode = 'es-ES'
$langName = 'Spanish'
Case Hex(0x0C0C, 4)
$decimalCode = '3084'
$countryCode = 'fr-CA'
$langName = 'French'
Case Hex(0x0C1A, 4)
$decimalCode = '3098'
$countryCode = 'sr-Cyrl-CS'
$langName = 'Serbian'
Case Hex(0x0C3B, 4)
$decimalCode = '3131'
$countryCode = 'se-FI'
$langName = 'Sami'
Case Hex(0x0C6B, 4)
$decimalCode = '3179'
$countryCode = 'quz-PE'
$langName = 'Quechua'
Case Hex(0x1001, 4)
$decimalCode = '4097'
$countryCode = 'ar-LY'
$langName = 'Arabic'
Case Hex(0x1004, 4)
$decimalCode = '4100'
$countryCode = 'zh-SG'
$langName = 'Chinese_S'
Case Hex(0x1007, 4)
$decimalCode = '4103'
$countryCode = 'de-LU'
$langName = 'German'
Case Hex(0x1009, 4)
$decimalCode = '4105'
$countryCode = 'en-CA'
$langName = 'English'
Case Hex(0x100A, 4)
$decimalCode = '4106'
$countryCode = 'es-GT'
$langName = 'Spanish'
Case Hex(0x100C, 4)
$decimalCode = '4108'
$countryCode = 'fr-CH'
$langName = 'French'
Case Hex(0x101A, 4)
$decimalCode = '4122'
$countryCode = 'hr-BA'
$langName = 'Croatian'
Case Hex(0x103B, 4)
$decimalCode = '4155'
$countryCode = 'smj-NO'
$langName = 'Sami'
Case Hex(0x105F, 4)
$decimalCode = '4191'
$countryCode = 'tzm-Tfng-MA'
$langName = 'Central'
Case Hex(0x1401, 4)
$decimalCode = '5121'
$countryCode = 'ar-DZ'
$langName = 'Arabic'
Case Hex(0x1404, 4)
$decimalCode = '5124'
$countryCode = 'zh-MO'
$langName = 'Chinese_T'
Case Hex(0x1407, 4)
$decimalCode = '5127'
$countryCode = 'de-LI'
$langName = 'German'
Case Hex(0x1409, 4)
$decimalCode = '5129'
$countryCode = 'en-NZ'
$langName = 'English'
Case Hex(0x140A, 4)
$decimalCode = '5130'
$countryCode = 'es-CR'
$langName = 'Spanish'
Case Hex(0x140C, 4)
$decimalCode = '5132'
$countryCode = 'fr-LU'
$langName = 'French'
Case Hex(0x141A, 4)
$decimalCode = '5146'
$countryCode = 'bs-Latn-BA'
$langName = 'Bosnian'
Case Hex(0x143B, 4)
$decimalCode = '5179'
$countryCode = 'smj-SE'
$langName = 'Sami'
Case Hex(0x1801, 4)
$decimalCode = '6145'
$countryCode = 'ar-MA'
$langName = 'Arabic'
Case Hex(0x1809, 4)
$decimalCode = '6153'
$countryCode = 'en-IE'
$langName = 'English'
Case Hex(0x180A, 4)
$decimalCode = '6154'
$countryCode = 'es-PA'
$langName = 'Spanish'
Case Hex(0x180C, 4)
$decimalCode = '6156'
$countryCode = 'fr-MC'
$langName = 'French'
Case Hex(0x181A, 4)
$decimalCode = '6170'
$countryCode = 'sr-Latn-BA'
$langName = 'Serbian'
Case Hex(0x183B, 4)
$decimalCode = '6203'
$countryCode = 'sma-NO'
$langName = 'Sami'
Case Hex(0x1C01, 4)
$decimalCode = '7169'
$countryCode = 'ar-TN'
$langName = 'Arabic'
Case Hex(0x1c09, 4)
$decimalCode = '7177'
$countryCode = 'en-ZA'
$langName = 'English'
Case Hex(0x1C0A, 4)
$decimalCode = '7178'
$countryCode = 'es-DO'
$langName = 'Spanish'
Case Hex(0x1C1A, 4)
$decimalCode = '7194'
$countryCode = 'sr-Cyrl-BA'
$langName = 'Serbian'
Case Hex(0x1C3B, 4)
$decimalCode = '7227'
$countryCode = 'sma-SE'
$langName = 'Sami'
Case Hex(0x2001, 4)
$decimalCode = '8193'
$countryCode = 'ar-OM'
$langName = 'Arabic'
Case Hex(0x2009, 4)
$decimalCode = '8201'
$countryCode = 'en-JM'
$langName = 'English'
Case Hex(0x200A, 4)
$decimalCode = '8202'
$countryCode = 'es-VE'
$langName = 'Spanish'
Case Hex(0x201A, 4)
$decimalCode = '8218'
$countryCode = 'bs-Cyrl-BA'
$langName = 'Bosnian'
Case Hex(0x203B, 4)
$decimalCode = '8251'
$countryCode = 'sms-FI'
$langName = 'Sami'
Case Hex(0x2401, 4)
$decimalCode = '9217'
$countryCode = 'ar-YE'
$langName = 'Arabic'
Case Hex(0x2409, 4)
$decimalCode = '9225'
$countryCode = 'en-029'
$langName = 'English'
Case Hex(0x240A, 4)
$decimalCode = '9226'
$countryCode = 'es-CO'
$langName = 'Spanish'
Case Hex(0x241A, 4)
$decimalCode = '9242'
$countryCode = 'sr-Latn-RS'
$langName = 'Serbian'
Case Hex(0x243B, 4)
$decimalCode = '9275'
$countryCode = 'smn-FI'
$langName = 'Sami'
Case Hex(0x2801, 4)
$decimalCode = '10241'
$countryCode = 'ar-SY'
$langName = 'Arabic'
Case Hex(0x2809, 4)
$decimalCode = '10249'
$countryCode = 'en-BZ'
$langName = 'English'
Case Hex(0x280A, 4)
$decimalCode = '10250'
$countryCode = 'es-PE'
$langName = 'Spanish'
Case Hex(0x281A, 4)
$decimalCode = '10266'
$countryCode = 'sr-Cyrl-RS'
$langName = 'Serbian'
Case Hex(0x2C01, 4)
$decimalCode = '11265'
$countryCode = 'ar-JO'
$langName = 'Arabic'
Case Hex(0x2C09, 4)
$decimalCode = '11273'
$countryCode = 'en-TT'
$langName = 'English'
Case Hex(0x2C0A, 4)
$decimalCode = '11274'
$countryCode = 'es-AR'
$langName = 'Spanish'
Case Hex(0x2C1A, 4)
$decimalCode = '11290'
$countryCode = 'sr-Latn-ME'
$langName = 'Serbian'
Case Hex(0x3001, 4)
$decimalCode = '12289'
$countryCode = 'ar-LB'
$langName = 'Arabic'
Case Hex(0x3009, 4)
$decimalCode = '12297'
$countryCode = 'en-ZW'
$langName = 'English'
Case Hex(0x300A, 4)
$decimalCode = '12298'
$countryCode = 'es-EC'
$langName = 'Spanish'
Case Hex(0x301A, 4)
$decimalCode = '12314'
$countryCode = 'sr-Cyrl-ME'
$langName = 'Serbian'
Case Hex(0x3401, 4)
$decimalCode = '13313'
$countryCode = 'ar-KW'
$langName = 'Arabic'
Case Hex(0x3409, 4)
$decimalCode = '13321'
$countryCode = 'en-PH'
$langName = 'English'
Case Hex(0x340A, 4)
$decimalCode = '13322'
$countryCode = 'es-CL'
$langName = 'Spanish'
Case Hex(0x3801, 4)
$decimalCode = '14337'
$countryCode = 'ar-AE'
$langName = 'Arabic'
Case Hex(0x380A, 4)
$decimalCode = '14346'
$countryCode = 'es-UY'
$langName = 'Spanish'
Case Hex(0x3C01, 4)
$decimalCode = '15361'
$countryCode = 'ar-BH'
$langName = 'Arabic'
Case Hex(0x3C0A, 4)
$decimalCode = '15370'
$countryCode = 'es-PY'
$langName = 'Spanish'
Case Hex(0x4001, 4)
$decimalCode = '16385'
$countryCode = 'ar-QA'
$langName = 'Arabic'
Case Hex(0x4009, 4)
$decimalCode = '16393'
$countryCode = 'en-IN'
$langName = 'English'
Case Hex(0x400A, 4)
$decimalCode = '16394'
$countryCode = 'es-BO'
$langName = 'Spanish'
Case Hex(0x4409, 4)
$decimalCode = '17417'
$countryCode = 'en-MY'
$langName = 'English'
Case Hex(0x440A, 4)
$decimalCode = '17418'
$countryCode = 'es-SV'
$langName = 'Spanish'
Case Hex(0x4809, 4)
$decimalCode = '18441'
$countryCode = 'en-SG'
$langName = 'English'
Case Hex(0x480A, 4)
$decimalCode = '18442'
$countryCode = 'es-HN'
$langName = 'Spanish'
Case Hex(0x4C0A, 4)
$decimalCode = '19466'
$countryCode = 'es-NI'
$langName = 'Spanish'
Case Hex(0x500A, 4)
$decimalCode = '20490'
$countryCode = 'es-PR'
$langName = 'Spanish'
Case Hex(0x540A, 4)
$decimalCode = '21514'
$countryCode = 'es-US'
$langName = 'Spanish'
Case Hex(0x7C04, 4)
$decimalCode = '31748'
$countryCode = 'zh-CHT'
$langName = 'Chinese_T'
Case Else
SetLog("Your computer's language was not recognized.")
$langName = "NONE"
EndSwitch
SetLog("Detected System Locale: " & $langName, $COLOR_INFO)
If FileExists($g_sDirLanguages & "/" & $langName & ".ini") Then
SetLog("Language file " & $langName & ".ini found in " & $g_sDirLanguages)
$g_sLanguage = $langName
If FileExists($g_sProfileConfigPath) Then IniWrite($g_sProfileConfigPath, "other", "language", $g_sLanguage)
Else
SetLog("Language file for " & $langName & " not found! Defaulting to English", $COLOR_ERROR)
$g_sLanguage = $g_sDefaultLanguage
EndIf
Else
$g_sLanguage = IniRead($g_sProfileConfigPath, "other", "language", $g_sDefaultLanguage)
EndIf
EndFunc
Func GetTranslatedFileIni($iSection = -1, $iKey = -1, $sText = "", $var1 = Default, $var2 = Default, $var3 = Default)
Static $aNewLanguage[1][2]
$sText = StringReplace($sText, @CRLF, "\r\n")
Local $sDefaultText, $g_sLanguageText
Local $SearchInLanguage = $iSection & "§" & $iKey
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
Return GetTranslatedParsedText($aNewLanguage[$result][1], $var1, $var2, $var3)
EndIf
If $g_sLanguage = $g_sDefaultLanguage Then
$sDefaultText = IniRead($g_sDirLanguages & $g_sDefaultLanguage & ".ini", $iSection, $iKey, "-3")
If $sText = "-1" Then
If $sDefaultText <> "-3" Then
$sDefaultText = GetTranslatedParsedText($sDefaultText, $var1, $var2, $var3)
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][0] = $SearchInLanguage
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][1] = $sDefaultText
ReDim $aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) + 1][2]
EndIf
Return $sDefaultText
Else
Return "-3"
EndIf
EndIf
If $sDefaultText <> $sText Then
Local $ini_file = $g_sDirLanguages & $g_sDefaultLanguage & ".ini"
Local $aSection[1][2] = [[$iKey, $sText]]
Local $Count = 1
Local $aKey = IniReadSection($ini_file, $iSection)
If IsArray($aKey) Then
For $i = 1 To $aKey[0][0]
If _ArraySearch($aSection, $aKey[$i][0], 0, 0, 0, 0, 1, 0) = -1 Then
$Count += 1
ReDim $aSection[$Count][2]
$aSection[$Count - 1][0] = $aKey[$i][0]
$aSection[$Count - 1][1] = $aKey[$i][1]
EndIf
Next
EndIf
_ArraySort($aSection, 0, 0, 0, 0)
IniWriteSection($ini_file, $iSection, $aSection, 0)
$sText = GetTranslatedParsedText($sText, $var1, $var2, $var3)
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][0] = $SearchInLanguage
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][1] = $sText
ReDim $aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) + 1][2]
Else
EndIf
Return $sText
Else
$sDefaultText = GetTranslatedParsedText($sDefaultText, $var1, $var2, $var3)
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][0] = $SearchInLanguage
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][1] = $sDefaultText
ReDim $aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) + 1][2]
Else
EndIf
Return $sDefaultText
EndIf
Else
$g_sLanguageText = IniRead($g_sDirLanguages & $g_sLanguage & ".ini", $iSection, $iKey, "-3")
If $sText = "-1" Then
If $g_sLanguageText = "-3" Then
$sDefaultText = IniRead($g_sDirLanguages & $g_sDefaultLanguage & ".ini", $iSection, $iKey, $sText)
$sDefaultText = GetTranslatedParsedText($sDefaultText, $var1, $var2, $var3)
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][0] = $SearchInLanguage
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][1] = $sDefaultText
ReDim $aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) + 1][2]
Else
EndIf
Return $sDefaultText
Else
$g_sLanguageText = GetTranslatedParsedText($g_sLanguageText, $var1, $var2, $var3)
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][0] = $SearchInLanguage
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][1] = $g_sLanguageText
ReDim $aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) + 1][2]
Else
EndIf
Return $g_sLanguageText
EndIf
EndIf
If $g_sLanguageText = "-3" Then
Local $ini_file = $g_sDirLanguages & $g_sLanguage & ".ini"
Local $aSection[1][2] = [[$iKey, $sText]]
Local $Count = 1
Local $aKey = IniReadSection($ini_file, $iSection)
If IsArray($aKey) Then
For $i = 1 To $aKey[0][0]
If _ArraySearch($aSection, $aKey[$i][0], 0, 0, 0, 0, 1, 0) = -1 Then
$Count += 1
ReDim $aSection[$Count][2]
$aSection[$Count - 1][0] = $aKey[$i][0]
$aSection[$Count - 1][1] = $aKey[$i][1]
EndIf
Next
EndIf
_ArraySort($aSection, 0, 0, 0, 0)
IniWriteSection($ini_file, $iSection, $aSection, 0)
$sText = GetTranslatedParsedText($sText, $var1, $var2, $var3)
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][0] = $SearchInLanguage
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][1] = $sText
ReDim $aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) + 1][2]
Else
EndIf
Return $sText
EndIf
$g_sLanguageText = GetTranslatedParsedText($g_sLanguageText, $var1, $var2, $var3)
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][0] = $SearchInLanguage
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][1] = $g_sLanguageText
ReDim $aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) + 1][2]
Else
EndIf
Return $g_sLanguageText
EndIf
EndFunc
Func _ReadFullIni()
Local $ini_file = $g_sDirLanguages & $g_sDefaultLanguage & ".ini"
Static $aNewLanguage[1][2]
Local $Count = 1
Local $aSection = IniReadSectionNames($ini_file)
For $i = 1 To UBound($aSection) - 1
Local $aKey = IniReadSection($ini_file, $aSection[$i])
If IsArray($aKey) Then
ReDim $aNewLanguage[$Count + UBound($aKey) - 1][2]
For $j = 1 To Ubound($aKey) - 1
If _ArraySearch($aNewLanguage, $aSection[$i] & "§" & $aKey[$j][0], 0, 0, 0, 0, 1, 0) = -1 Then
$aNewLanguage[$Count][0] = $aSection[$i] & "§" & $aKey[$j][0]
$aNewLanguage[$Count][1] = $aKey[$j][1]
$Count += 1
EndIf
Next
Else
ReDim $aNewLanguage[$Count + 1][2]
$aNewLanguage[$Count][0] = $aSection[$i]
$Count += 1
EndIf
Next
EndFunc
ReferenceFunctions()
ReferenceGlobals()
Func ReferenceFunctions()
If True Then Return
Local $a1, $a2
BotMoveRequest()
BotMinimizeRequest()
FindPreferredAdbPath()
CloseVboxAndroidSvc()
SetScreenAndroid()
WaitForRunningVMS()
WaitForAndroidBootCompleted()
RebootAndroidSetScreenDefault()
AndroidSetFontSizeNormal()
AndroidCloseSystemBar()
AndroidOpenSystemBar()
AndroidPicturePathAutoConfig()
_ShortcutAppId(0)
_GUICtrlGetControlID()
IsStopped()
GetFont()
btnConfigureCollectors()
btnConfigureReduction()
btnConfigureTHBully()
btnConfigureDBWeakBase()
btnConfigureABWeakBase()
EnableSearchPanels(0)
btnMilkingOptions()
btnDBAttackConfigure()
btnABAttackConfigure()
btnTestTHcsv()
btnConfigureReplayShare()
btnLoots()
btnLogs()
AttackCSVAssignDefaultScriptName()
GUIControl_WM_SYSCOMMAND(0, 0, 0, 0)
RedrawBotWindowNow()
_GUICtrlListView_SetItemHeightByFont(0, 0)
_GUICtrlListView_GetHeightToFitRows(0, 0)
Barch()
MilkingDebug()
CheckMilkingBaseTest()
SortRedline(0, 0, 0)
_SortRedline(0)
FindClosestToAxis(0)
GetSlotIndexFromXPos(0)
CheckFullBarrack()
GetCurTotalDarkSpell()
IsElixirTroop(0)
TestTroopsCoords()
TestSpellsCoords()
TestTrainRevamp2()
checkDeadBaseNew()
GetDeployableNextTo(0)
decodeTroopEnum(0)
decodeTroopName(0)
GUISetFont_DPI(0)
SetDPI()
_SysTrayIconTitles()
_SysTrayIconPids()
_SysTrayIconProcesses()
_SysTrayIconIndex(0)
_SysTrayIconTooltip(0)
_SysTrayIconPos(0)
_SysTrayIconVisible(0)
_SysTrayIconHide(0, 0)
_SysTrayIconMove(0, 0)
ZoomOutBlueStacks()
ZoomOutBlueStacks2()
ZoomOutMEmu()
ZoomOutDroid4X()
ZoomOutNox()
DefaultZoomOut()
ZoomOutCtrlWheelScroll()
ZoomOutCtrlClick()
OpenBS()
OpenBlueStacks()
OpenBlueStacks2()
InitBlueStacksX()
InitBlueStacks()
InitBlueStacks2()
RestartBlueStacksXCoC()
RestartBlueStacksCoC()
RestartBlueStacks2CoC()
CheckScreenBlueStacksX()
CheckScreenBlueStacks()
CheckScreenBlueStacks2()
SetScreenBlueStacks()
SetScreenBlueStacks2()
RebootBlueStacksSetScreen()
ConfigBlueStacks2WindowManager()
RebootBlueStacks2SetScreen()
GetBlueStacksRunningInstance()
GetBlueStacks2RunningInstance()
GetBlueStacksProgramParameter()
GetBlueStacks2ProgramParameter()
BlueStacksBotStartEvent()
BlueStacksBotStopEvent()
BlueStacks2BotStartEvent()
BlueStacks2BotStopEvent()
BlueStacksAdjustClickCoordinates($a1, $a2)
BlueStacks2AdjustClickCoordinates($a1, $a2)
GetBlueStacksAdbPath()
GetBlueStacks2AdbPath()
GetDroid4XAdbPath()
DisableBS(0, 0)
EnableBS(0, 0)
GetBlueStacksSvcPid()
CloseBlueStacks()
CloseBlueStacks2()
KillBSProcess()
ServiceStop(0)
CloseUnsupportedBlueStacks2()
OpenDroid4X()
GetDroid4XProgramParameter()
GetDroid4XPath()
GetDroid4XAdbPath()
InitDroid4X()
SetScreenDroid4X()
RebootDroid4XSetScreen()
CheckScreenDroid4X()
UpdateDroid4XConfig()
UpdateDroid4XWindowState()
CloseDroid4X()
OpenMEmu()
GetMEmuProgramParameter()
GetMEmuPath()
GetMEmuAdbPath()
InitMEmu()
SetScreenMEmu()
RebootMEmuSetScreen()
CloseMEmu()
CheckScreenMEmu()
UpdateMEmuConfig()
UpdateMEmuWindowState()
OpenLeapDroid()
IsLeapDroidCommandLine(0)
GetLeapDroidProgramParameter()
GetLeapDroidPath()
GetLeapDroidAdbPath()
InitLeapDroid()
UpdateLeapdroidSettings($a1, 0, 0)
SetScreenLeapDroid()
RebootLeapDroidSetScreen()
CloseLeapDroid()
CheckScreenLeapDroid()
EmbedLeapDroid()
LeapDroidBotStartEvent()
LeapDroidBotStopEvent()
OpenNox()
IsNoxCommandLine(0)
GetNoxProgramParameter()
GetNoxRtPath()
GetNoxPath()
GetNoxAdbPath()
InitNox()
SetScreenNox()
RebootNoxSetScreen()
CloseNox()
CheckScreenNox()
GetNoxRunningInstance()
RedrawNoxWindow()
HideNoxWindow()
EmbedNox()
OpenKOPLAYER()
GetKOPLAYERProgramParameter()
IsKOPLAYERCommandLine(0)
GetKOPLAYERPath()
GetKOPLAYERAdbPath()
InitKOPLAYER()
SetScreenKOPLAYER()
RebootKOPLAYERSetScreen()
CloseKOPLAYER()
CheckScreenKOPLAYER()
EmbedKOPLAYER()
OpeniTools()
IsiToolsCommandLine(0)
GetiToolsProgramParameter()
GetiToolsPath()
GetiToolsAdbPath()
InitiTools()
SetScreeniTools()
RebootiToolsSetScreen()
CloseiTools()
CheckScreeniTools()
HideiToolsWindow()
EmbediTools()
AndroidEmbedded()
_ProcessSuspendResume2(0)
__EnumDefaultProc(0, 0)
__EnumPageFilesProc(0, 0, 0)
GemClickP(0, 0)
SetGuiLog(0)
Tab(0, 0)
isNetFramework4Installed()
WinGetPos2(0)
ControlGetPos2(0, 0, 0)
WindowSystemMenu(0, 0)
IsMainChatOpenPage()
IsClanInfoPage()
IsPixelColorGray(0)
_MultiPixelSearch2(0, 0, 0, 0, 0, 0, 0, 0, 0)
getArmyTroopQuantity(0, 0)
getArmyTroopKind(0, 0)
getBarracksTroopQuantity(0, 0)
getOcrSpellDetection(0, 0)
getOcrSpellQuantity(0, 0)
getOcrClanLevel(0, 0)
getOcrDonationTroopsDetection(0, 0)
getOcrOverAllDamage(0, 0)
getHeroStatus(0, 0)
returnAllMatches(0)
returnLowestLevelSingleMatch(0)
updateGlobalVillageOffset(0, 0)
GemClickR(0, 0, 0)
GetBlueStacksBackgroundMode()
GetBlueStacks2BackgroundMode()
GetDroid4XBackgroundMode()
GetKOPLAYERBackgroundMode()
GetMEmuBackgroundMode()
GetNoxBackgroundMode()
getChatString(0, 0, 0)
getChatStringChinese(0, 0)
getChatStringKorean(0, 0)
getChatStringPersian(0, 0)
EndFunc
Func ReferenceGlobals()
If True Then Return
Local $a1
$a1 = $g_aaiTroopsToBeUsed
$a1 = $g_asMilkFarmOffsetMine
$a1 = $g_asMilkFarmOffsetElixir
$a1 = $g_asMilkFarmOffsetDark
$a1 = $aArmyCCRemainTime
$a1 = $aIsReloadError
$a1 = $g_iAndroidControlClickWindow
$a1 = $ATTACKVECTOR_A
$a1 = $ATTACKVECTOR_B
$a1 = $ATTACKVECTOR_C
$a1 = $ATTACKVECTOR_D
$a1 = $ATTACKVECTOR_E
$a1 = $ATTACKVECTOR_F
$a1 = $ATTACKVECTOR_G
$a1 = $ATTACKVECTOR_H
$a1 = $ATTACKVECTOR_I
$a1 = $ATTACKVECTOR_J
$a1 = $ATTACKVECTOR_K
$a1 = $ATTACKVECTOR_L
$a1 = $ATTACKVECTOR_M
$a1 = $ATTACKVECTOR_N
$a1 = $ATTACKVECTOR_O
$a1 = $ATTACKVECTOR_P
$a1 = $ATTACKVECTOR_Q
$a1 = $ATTACKVECTOR_R
$a1 = $ATTACKVECTOR_S
$a1 = $ATTACKVECTOR_T
$a1 = $ATTACKVECTOR_U
$a1 = $ATTACKVECTOR_V
$a1 = $ATTACKVECTOR_W
$a1 = $ATTACKVECTOR_X
$a1 = $ATTACKVECTOR_Y
$a1 = $ATTACKVECTOR_Z
$a1 = $eIcnArcher
$a1 = $eIcnDonArcher
$a1 = $eIcnBalloon
$a1 = $eIcnDonBalloon
$a1 = $eIcnBarbarian
$a1 = $eIcnDonBarbarian
$a1 = $eBtnTest
$a1 = $eIcnBuilder
$a1 = $eIcnCC
$a1 = $eIcnGUI
$a1 = $eIcnDark
$a1 = $eIcnDragon
$a1 = $eIcnDonDragon
$a1 = $eIcnDrill
$a1 = $eIcnElixir
$a1 = $eIcnCollector
$a1 = $eIcnFreezeSpell
$a1 = $eIcnGem
$a1 = $eIcnGiant
$a1 = $eIcnDonGiant
$a1 = $eIcnTrap
$a1 = $eIcnGoblin
$a1 = $eIcnDonGoblin
$a1 = $eIcnGold
$a1 = $eIcnGolem
$a1 = $eIcnDonGolem
$a1 = $eIcnHealer
$a1 = $eIcnDonHealer
$a1 = $eIcnHogRider
$a1 = $eIcnDonHogRider
$a1 = $eIcnHealSpell
$a1 = $eIcnInferno
$a1 = $eIcnJumpSpell
$a1 = $eIcnLavaHound
$a1 = $eIcnDonLavaHound
$a1 = $eIcnLightSpell
$a1 = $eIcnMinion
$a1 = $eIcnDonMinion
$a1 = $eIcnPekka
$a1 = $eIcnDonPekka
$a1 = $eIcnTreasury
$a1 = $eIcnRageSpell
$a1 = $eIcnTroops
$a1 = $eIcnHourGlass
$a1 = $eIcnTH1
$a1 = $eIcnTH10
$a1 = $eIcnTrophy
$a1 = $eIcnValkyrie
$a1 = $eIcnDonValkyrie
$a1 = $eIcnWall
$a1 = $eIcnWallBreaker
$a1 = $eIcnDonWallBreaker
$a1 = $eIcnWitch
$a1 = $eIcnDonWitch
$a1 = $eIcnWizard
$a1 = $eIcnDonWizard
$a1 = $eIcnXbow
$a1 = $eIcnBarrackBoost
$a1 = $eIcnMine
$a1 = $eIcnCamp
$a1 = $eIcnBarrack
$a1 = $eIcnSpellFactory
$a1 = $eIcnDonBlacklist
$a1 = $eIcnSpellFactoryBoost
$a1 = $eIcnMortar
$a1 = $eIcnWizTower
$a1 = $eIcnPayPal
$a1 = $eIcnNotify
$a1 = $eIcnGreenLight
$a1 = $eIcnLaboratory
$a1 = $eIcnRedLight
$a1 = $eIcnBlank
$a1 = $eIcnYellowLight
$a1 = $eIcnDonCustom
$a1 = $eIcnTombstone
$a1 = $eIcnSilverStar
$a1 = $eIcnGoldStar
$a1 = $eIcnDarkBarrack
$a1 = $eIcnCollectorLocate
$a1 = $eIcnDrillLocate
$a1 = $eIcnMineLocate
$a1 = $eIcnBarrackLocate
$a1 = $eIcnDarkBarrackLocate
$a1 = $eIcnDarkSpellFactoryLocate
$a1 = $eIcnDarkSpellFactory
$a1 = $eIcnEarthQuakeSpell
$a1 = $eIcnHasteSpell
$a1 = $eIcnPoisonSpell
$a1 = $eIcnBldgTarget
$a1 = $eIcnBldgX
$a1 = $eIcnRecycle
$a1 = $eIcnHeroes
$a1 = $eIcnBldgElixir
$a1 = $eIcnBldgGold
$a1 = $eIcnMagnifier
$a1 = $eIcnWallElixir
$a1 = $eIcnWallGold
$a1 = $eIcnKing
$a1 = $eIcnQueen
$a1 = $eIcnDarkSpellBoost
$a1 = $eIcnQueenBoostLocate
$a1 = $eIcnKingBoostLocate
$a1 = $eIcnKingUpgr
$a1 = $eIcnQueenUpgr
$a1 = $eIcnWardenUpgr
$a1 = $eIcnWarden
$a1 = $eIcnWardenBoostLocate
$a1 = $eIcnKingBoost
$a1 = $eIcnQueenBoost
$a1 = $eIcnWardenBoost
$a1 = $eEmpty3
$a1 = $eIcnReload
$a1 = $eIcnCopy
$a1 = $eIcnAddcvs
$a1 = $eIcnEdit
$a1 = $eIcnTreeSnow
$a1 = $eIcnSleepingQueen
$a1 = $eIcnSleepingKing
$a1 = $eIcnGoldElixir
$a1 = $eIcnBowler
$a1 = $eIcnDonBowler
$a1 = $eIcnCCDonate
$a1 = $eIcnEagleArt
$a1 = $eIcnGembox
$a1 = $eIcnInferno4
$a1 = $eIcnInfo
$a1 = $eIcnMain
$a1 = $eIcnTree
$a1 = $eIcnProfile
$a1 = $eIcnCCRequest
$a1 = $eIcnTelegram
$a1 = $eIcnTiles
$a1 = $eIcnXbow3
$a1 = $eIcnBark
$a1 = $eIcnDailyProgram
$a1 = $eIcnLootCart
$a1 = $eIcnSleepMode
$a1 = $eIcnTH11
$a1 = $eIcnTH12
$a1 = $eIcnTrainMode
$a1 = $eIcnSleepingWarden
$a1 = $eIcnCloneSpell
$a1 = $eIcnSkeletonSpell
$a1 = $eIcnBabyDragon
$a1 = $eIcnDonBabyDragon
$a1 = $eIcnMiner
$a1 = $eIcnDonMiner
$a1 = $eIcnNoShield
$a1 = $eIcnDonCustomB
$a1 = $eIcnAirdefense
$a1 = $eIcnDarkBarrackBoost
$a1 = $eIcnDarkElixirStorage
$a1 = $eIcnSpellsCost
$a1 = $eIcnTroopsCost
$a1 = $eIcnResetButton
$a1 = $eIcnNewSmartZap
$a1 = $eIcnTrain
$a1 = $eIcnAttack
$a1 = $eIcnDelay
$a1 = $eIcnReOrder
$a1 = $eIcn2Arrow
$a1 = $eIcnArrowLeft
$a1 = $eIcnArrowRight
$a1 = $eIcnAndroid
$a1 = $eHdV04
$a1 = $eHdV05
$a1 = $eHdV06
$a1 = $eHdV07
$a1 = $eHdV08
$a1 = $eHdV09
$a1 = $eHdV10
$a1 = $eHdV11
$a1 = $eHdV12
$a1 = $eUnranked
$a1 = $eBronze
$a1 = $eSilver
$a1 = $eGold
$a1 = $eCrystal
$a1 = $eMaster
$a1 = $eChampion
$a1 = $eTitan
$a1 = $eLegend
$a1 = $eWall04
$a1 = $eWall05
$a1 = $eWall06
$a1 = $eWall07
$a1 = $eWall08
$a1 = $eWall09
$a1 = $eWall10
$a1 = $eWall11
$a1 = $eIcnPBNotify
$a1 = $eIcnCCTroops
$a1 = $eIcnCCSpells
$a1 = $eIcnSpellsGroup
$a1 = $eBahasaIND
$a1 = $eChinese_S
$a1 = $eChinese_T
$a1 = $eEnglish
$a1 = $eFrench
$a1 = $eGerman
$a1 = $eItalian
$a1 = $ePersian
$a1 = $eRussian
$a1 = $eSpanish
$a1 = $eTurkish
$a1 = $eMissingLangIcon
$a1 = $eWall12
$a1 = $ePortuguese
$a1 = $eIcnDonPoisonSpell
$a1 = $eIcnDonEarthQuakeSpell
$a1 = $eIcnDonHasteSpell
$a1 = $eIcnDonSkeletonSpell
$a1 = $eVietnamese
$a1 = $eKorean
$a1 = $eTroopBarbarian
$a1 = $eTroopArcher
$a1 = $eTroopGiant
$a1 = $eTroopGoblin
$a1 = $eTroopWallBreaker
$a1 = $eTroopBalloon
$a1 = $eTroopWizard
$a1 = $eTroopHealer
$a1 = $eTroopDragon
$a1 = $eTroopPekka
$a1 = $eTroopBabyDragon
$a1 = $eTroopMiner
$a1 = $eTroopElectroDragon
$a1 = $eTroopMinion
$a1 = $eTroopHogRider
$a1 = $eTroopValkyrie
$a1 = $eTroopGolem
$a1 = $eTroopWitch
$a1 = $eTroopLavaHound
$a1 = $eTroopBowler
$a1 = $eTroopCount
$a1 = $eSpellLightning
$a1 = $eSpellHeal
$a1 = $eSpellRage
$a1 = $eSpellJump
$a1 = $eSpellFreeze
$a1 = $eSpellClone
$a1 = $eSpellPoison
$a1 = $eSpellEarthquake
$a1 = $eSpellHaste
$a1 = $eSpellSkeleton
$a1 = $eSpellCount
$a1 = $eBarb
$a1 = $eArch
$a1 = $eGiant
$a1 = $eGobl
$a1 = $eWall
$a1 = $eBall
$a1 = $eWiza
$a1 = $eHeal
$a1 = $eDrag
$a1 = $ePekk
$a1 = $eBabyD
$a1 = $eMine
$a1 = $eMini
$a1 = $eHogs
$a1 = $eValk
$a1 = $eGole
$a1 = $eWitc
$a1 = $eLava
$a1 = $eBowl
$a1 = $eKing
$a1 = $eQueen
$a1 = $eWarden
$a1 = $eCastle
$a1 = $eLSpell
$a1 = $eHSpell
$a1 = $eRSpell
$a1 = $eJSpell
$a1 = $eFSpell
$a1 = $eCSpell
$a1 = $ePSpell
$a1 = $eESpell
$a1 = $eHaSpell
$a1 = $eSkSpell
$a1 = $aTrainBarb
$a1 = $aTrainArch
$a1 = $aTrainGiant
$a1 = $aTrainGobl
$a1 = $aTrainWall
$a1 = $aTrainBall
$a1 = $aTrainWiza
$a1 = $aTrainHeal
$a1 = $aTrainDrag
$a1 = $aTrainPekk
$a1 = $aTrainBabyD
$a1 = $aTrainMine
$a1 = $aTrainMini
$a1 = $aTrainHogs
$a1 = $aTrainValk
$a1 = $aTrainGole
$a1 = $aTrainWitc
$a1 = $aTrainLava
$a1 = $aTrainBowl
$a1 = $aTrainLSpell
$a1 = $aTrainHSpell
$a1 = $aTrainRSpell
$a1 = $aTrainJSpell
$a1 = $aTrainFSpell
$a1 = $aTrainCSpell
$a1 = $aTrainPSpell
$a1 = $aTrainESpell
$a1 = $aTrainHaSpell
$a1 = $aTrainSkSpell
$a1 = $aTrainArmy
$a1 = $aLoginWithSupercellID
EndFunc
Opt("GUIResizeMode", $GUI_DOCKALL)
Opt("GUIEventOptions", 1)
Opt("GUICloseOnESC", 0)
Opt("WinTitleMatchMode", 3)
Opt("GUIOnEventMode", 1)
Opt("MouseClickDelay", 10)
Opt("MouseClickDownDelay", 10)
Opt("TrayMenuMode", 3)
Opt("TrayOnEventMode", 1)
InitializeBot()
MainLoop(CheckPrerequisites())
Func UpdateBotTitle()
Local $sTitle = "My Bot " & $g_sBotVersion
Local $sConsoleTitle
If $g_sBotTitle = "" Then
$g_sBotTitle = $sTitle
$sConsoleTitle = $sTitle
Else
$g_sBotTitle = $sTitle & " (" &($g_sAndroidInstance <> "" ? $g_sAndroidInstance : $g_sAndroidEmulator) & ")"
$sConsoleTitle = $sTitle & " " & $g_sAndroidEmulator & " (" &($g_sAndroidInstance <> "" ? $g_sAndroidInstance : $g_sAndroidEmulator) & ")"
EndIf
If $g_hFrmBot <> 0 Then
WinSetTitle($g_hFrmBot, "", $g_sBotTitle)
GUICtrlSetData($g_hLblBotTitle, $g_sBotTitle)
EndIf
DllCall("kernel32.dll", "bool", "SetConsoleTitle", "str", "Console " & $sConsoleTitle)
TraySetToolTip($g_sBotTitle)
SetDebugLog("Bot title updated to: " & $g_sBotTitle)
EndFunc
Func InitializeBot()
ProcessCommandLine()
If FileExists(@ScriptDir & "\EnableMBRDebug.txt") Then
$g_bDevMode = True
Local $aText = FileReadToArray(@ScriptDir & "\EnableMBRDebug.txt")
If Not @error Then
For $l = 0 To UBound($aText) - 1
If StringInStr($aText[$l], "DISABLEWATCHDOG", $STR_NOCASESENSEBASIC) <> 0 Then
$g_bBotLaunchOption_NoWatchdog = True
SetDebugLog("Watch Dog disabled by Developer Mode File Command", $COLOR_INFO)
EndIf
Next
EndIf
EndIf
SetupProfileFolder()
SetLogCentered(" BOT LOG ")
SetSwitchAccLog(_PadStringCenter(" SwitchAcc LOG ", 25, "="), $COLOR_BLACK, "Lucida Console", 8, False)
DetectLanguage()
If $g_iBotLaunchOption_Help Then
ShowCommandLineHelp()
Exit
EndIf
InitAndroidConfig()
Local $bConfigRead = FileExists($g_sProfileConfigPath)
If $bConfigRead Or FileExists($g_sProfileBuildingPath) Then
readConfig()
EndIf
Local $sAndroidInfo = ""
_Crypt_Startup()
__GDIPlus_Startup()
CreateMainGUI()
CreateSplashScreen()
If Not $g_bBotLaunchOption_NoWatchdog Then LaunchWatchdog()
InitializeMBR($sAndroidInfo, $bConfigRead)
CreateMainGUIControls()
InitializeMainGUI()
SetupFilesAndFolders()
ShowMainGUI()
If $g_iBotLaunchOption_Dock Then
If AndroidEmbed(True) And $g_iBotLaunchOption_Dock = 2 And $g_bCustomTitleBarActive Then
BotShrinkExpandToggle()
EndIf
EndIf
FinalInitialization($sAndroidInfo)
EndFunc
Func ProcessCommandLine()
If $CmdLine[0] > 0 Then
For $i = 1 To $CmdLine[0]
Local $bOptionDetected = True
Switch $CmdLine[$i]
Case "/restart", "/r", "-restart", "-r"
$g_bBotLaunchOption_Restart = True
Case "/autostart", "/a", "-autostart", "-a"
$g_bBotLaunchOption_Autostart = True
Case "/nowatchdog", "/nwd", "-nowatchdog", "-nwd"
$g_bBotLaunchOption_NoWatchdog = True
Case "/dpiaware", "/da", "-dpiaware", "-da"
$g_bBotLaunchOption_ForceDpiAware = True
Case "/dock1", "/d1", "-dock1", "-d1", "/dock", "/d", "-dock", "-d"
$g_iBotLaunchOption_Dock = 1
Case "/dock2", "/d2", "-dock2", "-d2"
$g_iBotLaunchOption_Dock = 2
Case "/nobotslot", "/nbs", "-nobotslot", "-nbs"
$g_bBotLaunchOption_NoBotSlot = True
Case "/debug", "/debugmode", "/dev", "/dm", "-debug", "-debugmode", "-dev", "-dm"
$g_bDevMode = True
Case "/minigui", "/mg", "-minigui", "-mg"
$g_iGuiMode = 2
Case "/nogui", "/ng", "-nogui", "-ng"
$g_iGuiMode = 0
Case "/hideandroid", "/ha", "-hideandroid", "-ha"
$g_bBotLaunchOption_HideAndroid = True
Case "/console", "/c", "-console", "-c"
$g_iBotLaunchOption_Console = True
ConsoleWindow()
Case "/?", "/h", "/help", "-?", "-h", "-help"
$g_iBotLaunchOption_Help = True
Case Else
If StringInStr($CmdLine[$i], "/guipid=") Then
Local $guidpid = Int(StringMid($CmdLine[$i], 9))
If ProcessExists($guidpid) Then
$g_iGuiPID = $guidpid
Else
SetDebugLog("GUI Process doesn't exist: " & $guidpid)
EndIf
ElseIf StringInStr($CmdLine[$i], "/profiles=") = 1 Then
Local $sProfilePath = StringMid($CmdLine[$i], 11)
If StringInStr(FileGetAttrib($sProfilePath), "D") Then
$g_sProfilePath = $sProfilePath
Else
SetLog("Profiles Path doesn't exist: " & $sProfilePath, $COLOR_ERROR)
EndIf
Else
$bOptionDetected = False
$g_asCmdLine[0] += 1
ReDim $g_asCmdLine[$g_asCmdLine[0] + 1]
$g_asCmdLine[$g_asCmdLine[0]] = $CmdLine[$i]
EndIf
EndSwitch
If $bOptionDetected Then SetDebugLog("Command Line Option detected: " & $CmdLine[$i])
Next
EndIf
If $g_asCmdLine[0] > 0 Then
$g_sProfileCurrentName = StringRegExpReplace($g_asCmdLine[1], '[/:*?"<>|]', '_')
If $g_asCmdLine[0] >= 2 Then
If StringInStr($g_asCmdLine[2], "BlueStacks3") Then $g_asCmdLine[2] = "BlueStacks2"
EndIf
ElseIf FileExists($g_sProfilePath & "\profile.ini") Then
$g_sProfileCurrentName = StringRegExpReplace(IniRead($g_sProfilePath & "\profile.ini", "general", "defaultprofile", ""), '[/:*?"<>|]', '_')
If $g_sProfileCurrentName = "" Or Not FileExists($g_sProfilePath & "\" & $g_sProfileCurrentName) Then $g_sProfileCurrentName = "<No Profiles>"
Else
$g_sProfileCurrentName = "<No Profiles>"
EndIf
EndFunc
Func InitializeAndroid($bConfigRead)
Local $s = GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_06", "Initializing Android...")
SplashStep($s)
If $g_bBotLaunchOption_Restart = False Then
If $g_asCmdLine[0] > 1 Then
InitAndroidConfig(True)
Local $i
For $i = 0 To UBound($g_avAndroidAppConfig) - 1
If StringCompare($g_avAndroidAppConfig[$i][0], $g_asCmdLine[2]) = 0 Then
$g_iAndroidConfig = $i
SplashStep($s & "(" & $g_avAndroidAppConfig[$i][0] & ")...", False)
If $g_avAndroidAppConfig[$i][1] <> "" And $g_asCmdLine[0] > 2 Then
UpdateAndroidConfig($g_asCmdLine[3])
Else
UpdateAndroidConfig()
EndIf
SplashStep($s & "(" & $g_avAndroidAppConfig[$i][0] & ")", False)
ExitLoop
EndIf
Next
EndIf
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_07", "Detecting Android..."))
If $g_asCmdLine[0] < 2 And Not $bConfigRead Then
DetectRunningAndroid()
If Not $g_bFoundRunningAndroid Then DetectInstalledAndroid()
EndIf
Else
SplashStep($s)
EndIf
CleanSecureFiles()
GetCOCDistributors()
EndFunc
Func SetupProfileFolder()
SetDebugLog("SetupProfileFolder: " & $g_sProfilePath & "\" & $g_sProfileCurrentName)
$g_sProfileConfigPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\config.ini"
$g_sProfileBuildingStatsPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\stats_buildings.ini"
$g_sProfileBuildingPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\building.ini"
$g_sProfileLogsPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Logs\"
$g_sProfileLootsPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Loots\"
$g_sProfileTempPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Temp\"
$g_sProfileTempDebugPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Temp\Debug\"
$g_sProfileDonateCapturePath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\'
$g_sProfileDonateCaptureWhitelistPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\White List\'
$g_sProfileDonateCaptureBlacklistPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\Black List\'
EndFunc
Func InitializeMBR(ByRef $sAI, $bConfigRead)
If Not FileExists(@ScriptDir & "\License.txt") Then
Local $hDownload = InetGet("http://www.gnu.org/licenses/gpl-3.0.txt", @ScriptDir & "\License.txt")
Local $i = 0
Do
Sleep($DELAYDOWNLOADLICENSE)
$i += 1
Until InetGetInfo($hDownload, $INET_DOWNLOADCOMPLETE) Or $i > 25
InetClose($hDownload)
EndIf
If Not FileExists(@ScriptDir & "\Languages") Then DirCreate(@ScriptDir & "\Languages")
_ReadFullIni()
TranslateTroopNames()
InitializeCOCDistributors()
Local $sMsg = GetTranslatedFileIni("MBR GUI Design - Loading", "Compile_Script", "Don't Run/Compile the Script as (x64)! Try to Run/Compile the Script as (x86) to get the bot to work.\r\n" & "If this message still appears, try to re-install AutoIt.")
If @AutoItX64 = 1 Then
DestroySplashScreen()
MsgBox(0, "", $sMsg)
__GDIPlus_Shutdown()
Exit
EndIf
InitializeAndroid($bConfigRead)
UpdateBotTitle()
UpdateSplashTitle($g_sBotTitle & GetTranslatedFileIni("MBR GUI Design - Loading", "Loading_Profile", ", Profile: %s", $g_sProfileCurrentName))
If $g_bBotLaunchOption_Restart = True Then
If CloseRunningBot($g_sBotTitle, True) Then
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "Closing_previous", "Closing previous bot..."), False)
If CloseRunningBot($g_sBotTitle) = True Then
Sleep(3000)
WinGetAndroidHandle()
EndIf
EndIf
EndIf
Local $cmdLineHelp = GetTranslatedFileIni("MBR GUI Design - Loading", "Commandline_multiple_Bots", "By using the commandline (or a shortcut) you can start multiple Bots:\r\n" & "     MyBot.run.exe [ProfileName] [EmulatorName] [InstanceName]\r\n\r\n" & "With the first command line parameter, specify the Profilename (you can create profiles on the Bot/Profiles tab, if a " & "profilename contains a {space}, then enclose the profilename in double quotes). " & "With the second, specify the name of the Emulator and with the third, an Android Instance (not for BlueStacks). \r\n" & "Supported Emulators are MEmu, Droid4X, Nox, BlueStacks2, BlueStacks, KOPlayer and LeapDroid.\r\n\r\n" & "Examples:\r\n" & "     MyBot.run.exe MyVillage BlueStacks2\r\n" & "     MyBot.run.exe ""My Second Village"" MEmu MEmu_1")
$g_hMutex_BotTitle = CreateMutex($g_sBotTitle)
$sAI = GetTranslatedFileIni("MBR GUI Design - Loading", "Android_instance_01", "%s", $g_sAndroidEmulator)
Local $sAndroidInfo2 = GetTranslatedFileIni("MBR GUI Design - Loading", "Android_instance_02", "%s (instance %s)", $g_sAndroidEmulator, $g_sAndroidInstance)
If $g_sAndroidInstance <> "" Then
$sAI = $sAndroidInfo2
EndIf
$sMsg = GetTranslatedFileIni("MBR GUI Design - Loading", "Msg_Android_instance_01", "My Bot for %s is already running.\r\n\r\n", $sAI)
If $g_hMutex_BotTitle = 0 Then
SetDebugLog($g_sBotTitle & " is already running, exit now")
DestroySplashScreen()
MsgBox(BitOR($MB_OK, $MB_ICONINFORMATION, $MB_TOPMOST), $g_sBotTitle, $sMsg & $cmdLineHelp)
__GDIPlus_Shutdown()
Exit
EndIf
$sMsg = GetTranslatedFileIni("MBR GUI Design - Loading", "Msg_Android_instance_02", "My Bot with Profile %s is already in use.\r\n\r\n", $g_sProfileCurrentName)
If aquireProfileMutex() = 0 Then
ReleaseMutex($g_hMutex_BotTitle)
releaseProfilesMutex(True)
DestroySplashScreen()
MsgBox(BitOR($MB_OK, $MB_ICONINFORMATION, $MB_TOPMOST), $g_sBotTitle, $sMsg & $cmdLineHelp)
__GDIPlus_Shutdown()
Exit
EndIf
$g_hMutex_MyBot = CreateMutex("MyBot.run")
$g_bOnlyInstance = $g_hMutex_MyBot <> 0
SetDebugLog("My Bot is " &($g_bOnlyInstance ? "" : "not ") & "the only running instance")
EndFunc
Func SetupFilesAndFolders()
DirCreate($g_sProfilePresetPath)
DirCreate($g_sPrivateProfilePath & "\" & $g_sProfileCurrentName)
DirCreate($g_sProfilePath & "\" & $g_sProfileCurrentName)
DirCreate($g_sProfileLogsPath)
DirCreate($g_sProfileLootsPath)
DirCreate($g_sProfileTempPath)
DirCreate($g_sProfileTempDebugPath)
$g_sProfileDonateCapturePath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\'
$g_sProfileDonateCaptureWhitelistPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\White List\'
$g_sProfileDonateCaptureBlacklistPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\Black List\'
DirCreate($g_sProfileDonateCapturePath)
DirCreate($g_sProfileDonateCaptureWhitelistPath)
DirCreate($g_sProfileDonateCaptureBlacklistPath)
FileMove(@ScriptDir & "\*.ini", $g_sProfilePath & "\" & $g_sProfileCurrentName, $FC_OVERWRITE + $FC_CREATEPATH)
DirCopy(@ScriptDir & "\Logs", $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Logs", $FC_OVERWRITE + $FC_CREATEPATH)
DirCopy(@ScriptDir & "\Loots", $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Loots", $FC_OVERWRITE + $FC_CREATEPATH)
DirCopy(@ScriptDir & "\Temp", $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Temp", $FC_OVERWRITE + $FC_CREATEPATH)
DirRemove(@ScriptDir & "\Logs", 1)
DirRemove(@ScriptDir & "\Loots", 1)
DirRemove(@ScriptDir & "\Temp", 1)
If FileExists($g_sProfileConfigPath) = 0 Then
createProfile(True)
applyConfig()
EndIf
If $g_bDeleteLogs Then DeleteFiles($g_sProfileLogsPath, "*.*", $g_iDeleteLogsDays, 0)
If $g_bDeleteLoots Then DeleteFiles($g_sProfileLootsPath, "*.*", $g_iDeleteLootsDays, 0)
If $g_bDeleteTemp Then
DeleteFiles($g_sProfileTempPath, "*.*", $g_iDeleteTempDays, 0)
DeleteFiles($g_sProfileTempDebugPath, "*.*", $g_iDeleteTempDays, 0, $FLTAR_RECUR)
EndIf
SetDebugLog("$g_sProfilePath = " & $g_sProfilePath)
SetDebugLog("$g_sProfileCurrentName = " & $g_sProfileCurrentName)
SetDebugLog("$g_sProfileLogsPath = " & $g_sProfileLogsPath)
EndFunc
Func FinalInitialization(Const $sAI)
If CheckPrerequisites(True) Then
MBRFunc(True)
setAndroidPID()
SetBotGuiPID()
EndIf
If $g_bFoundRunningAndroid Then
SetLog(GetTranslatedFileIni("MBR GUI Design - Loading", "Msg_Android_instance_03", "Found running %s %s", $g_sAndroidEmulator, $g_sAndroidVersion), $COLOR_SUCCESS)
EndIf
If $g_bFoundInstalledAndroid Then
SetLog("Found installed " & $g_sAndroidEmulator & " " & $g_sAndroidVersion, $COLOR_SUCCESS)
EndIf
SetLog(GetTranslatedFileIni("MBR GUI Design - Loading", "Msg_Android_instance_04", "Android Emulator Configuration: %s", $sAI), $COLOR_SUCCESS)
LoadAmountOfResourcesImages()
$g_iGuiPID = @AutoItPID
$g_iBotLaunchTime = __TimerDiff($g_hBotLaunchTime)
If $g_iGuiMode = 0 Then
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "Waiting_for_Remote_GUI", "Waiting for remote GUI..."))
SetDebugLog("Wait for GUI Process...")
Local $timer = __TimerInit()
While $g_iGuiPID = @AutoItPID And __TimerDiff($timer) < 60000
Sleep(50)
WEnd
If $g_iGuiPID = @AutoItPID Then
SetDebugLog("GUI Process not received, close bot")
BotClose()
Else
SetDebugLog("Linked to GUI Process " & $g_iGuiPID)
EndIf
EndIf
DestroySplashScreen()
CheckVersion()
UpdateMultiStats()
SetDebugLog("Maximum of " & $g_iGlobalActiveBotsAllowed & " bots running at same time configured")
SetDebugLog("MyBot.run launch time " & Round($g_iBotLaunchTime) & " ms.")
If $g_bAndroidShieldEnabled = False Then
SetLog(GetTranslatedFileIni("MBR GUI Design - Loading", "Msg_Android_instance_05", "Android Shield not available for %s", @OSVersion), $COLOR_ACTION)
EndIf
DisableProcessWindowsGhosting()
UpdateMainGUI()
EndFunc
Func MainLoop($bCheckPrerequisitesOK = True)
Local $iStartDelay = 0
If $bCheckPrerequisitesOK And($g_bAutoStart Or $g_bRestarted = True) Then
Local $iDelay = $g_iAutoStartDelay
If $g_bRestarted = True Then $iDelay = 0
$iStartDelay = $iDelay * 1000
$g_iBotAction = $eBotStart
If $g_bBotLaunchOption_HideAndroid Then $g_bIsHidden = True
EndIf
While 1
_Sleep($DELAYSLEEP, True, False)
If Not $g_bRunState And($g_bNotifyPBEnable Or $g_bNotifyTGEnable) And $g_bNotifyRemoteEnable Then
NotifyRemoteControlProcBtnStart()
EndIf
Switch $g_iBotAction
Case $eBotStart
BotStart($iStartDelay)
$iStartDelay = 0
If $g_iBotAction = $eBotStart Then $g_iBotAction = $eBotNoAction
Case $eBotStop
BotStop()
If $g_iBotAction = $eBotStop Then $g_iBotAction = $eBotNoAction
Case $eBotSearchMode
BotSearchMode()
If $g_iBotAction = $eBotSearchMode Then $g_iBotAction = $eBotNoAction
Case $eBotClose
BotClose()
EndSwitch
WEnd
EndFunc
Func runBot()
Local $iWaitTime
InitiateSwitchAcc()
If ProfileSwitchAccountEnabled() And $g_bReMatchAcc Then
SetLog("Rematching Account [" & $g_iNextAccount + 1 & "] with Profile [" & GUICtrlRead($g_ahCmbProfile[$g_iNextAccount]) & "]")
SwitchCoCAcc($g_iNextAccount)
EndIf
While 1
If FileExists(@ScriptDir & "\EnableMBRDebug.txt") Then
While(FileReadLine(@ScriptDir & "\EnableMBRDebug.txt") = "wait")
If _SleepStatus(15000) = True Then Return
WEnd
EndIf
If $b_iAutoRestartDelay > 0 And __TimerDiff($g_hBotLaunchTime) > $b_iAutoRestartDelay * 1000 Then
If RestartBot(False) = True Then Return
EndIf
PrepareDonateCC()
$g_bRestart = False
$g_bFullArmy = False
$g_iCommandStop = -1
If _Sleep($DELAYRUNBOT1) Then Return
checkMainScreen()
If $g_bRestart = True Then ContinueLoop
chkShieldStatus()
If $g_bRestart = True Then ContinueLoop
checkObstacles()
If $g_bRestart = True Then ContinueLoop
If $g_bQuicklyFirstStart = True Then
$g_bQuicklyFirstStart = False
Else
$g_bQuickAttack = QuickAttack()
EndIf
If CheckAndroidReboot() = True Then ContinueLoop
If $g_bIsClientSyncError = False And $g_bIsSearchLimit = False And($g_bQuickAttack = False) Then
If BotCommand() Then btnStop()
If _Sleep($DELAYRUNBOT2) Then Return
checkMainScreen(False)
If $g_bRestart = True Then ContinueLoop
If _Sleep($DELAYRUNBOT3) Then Return
VillageReport()
If $g_bOutOfGold = True And(Number($g_aiCurrentLoot[$eLootGold]) >= Number($g_iTxtRestartGold)) Then
$g_bOutOfGold = False
SetLog("Switching back to normal after no gold to search ...", $COLOR_SUCCESS)
ContinueLoop
EndIf
If $g_bOutOfElixir = True And(Number($g_aiCurrentLoot[$eLootElixir]) >= Number($g_iTxtRestartElixir)) And(Number($g_aiCurrentLoot[$eLootDarkElixir]) >= Number($g_iTxtRestartDark)) Then
$g_bOutOfElixir = False
SetLog("Switching back to normal setting after no elixir to train ...", $COLOR_SUCCESS)
ContinueLoop
EndIf
If _Sleep($DELAYRUNBOT5) Then Return
checkMainScreen(False)
If $g_bRestart = True Then ContinueLoop
Local $aRndFuncList = ['LabCheck','Collect', 'CheckTombs', 'ReArm', 'CleanYard']
While 1
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
Local $Index = Random(0, UBound($aRndFuncList), 1)
If $Index > UBound($aRndFuncList) - 1 Then $Index = UBound($aRndFuncList) - 1
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
If $g_bRestart = True Then ContinueLoop 2
WEnd
AddIdleTime()
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop
If IsSearchAttackEnabled() Then
Local $aRndFuncList = ['ReplayShare', 'NotifyReport', 'DonateCC,Train', 'BoostBarracks', 'BoostSpellFactory', 'BoostKing', 'BoostQueen', 'BoostWarden', 'RequestCC', 'CollectFreeMagicItems']
While 1
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
Local $Index = Random(0, UBound($aRndFuncList), 1)
If $Index > UBound($aRndFuncList) - 1 Then $Index = UBound($aRndFuncList) - 1
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
If CheckAndroidReboot() = True Then ContinueLoop 2
WEnd
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop
If $g_iUnbrkMode >= 1 Then
If Unbreakable() = True Then ContinueLoop
EndIf
EndIf
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) Then
If BalanceDonRec(True) Then DonateCC()
EndIf
Local $aRndFuncList = ['Laboratory', 'UpgradeHeroes', 'UpgradeBuilding', 'BuilderBase']
While 1
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
$Index = Random(0, UBound($aRndFuncList), 1)
If $Index > UBound($aRndFuncList) - 1 Then $Index = UBound($aRndFuncList) - 1
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
If CheckAndroidReboot() = True Then ContinueLoop 2
WEnd
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop
If IsSearchAttackEnabled() Then
$g_iNbrOfWallsUpped = 0
UpgradeWall()
If _Sleep($DELAYRUNBOT3) Then Return
If $g_bRestart = True Then ContinueLoop
If ProfileSwitchAccountEnabled() And $g_abDonateOnly[$g_iCurAccount] Then checkSwitchAcc()
Idle()
If _Sleep($DELAYRUNBOT3) Then Return
If $g_bRestart = True Then ContinueLoop
If $g_iCommandStop <> 0 And $g_iCommandStop <> 3 Then
AttackMain()
$g_bSkipFirstZoomout = False
If $g_bOutOfGold = True Then
SetLog("Switching to Halt Attack, Stay Online/Collect mode ...", $COLOR_ERROR)
$g_bFirstStart = True
ContinueLoop
EndIf
If _Sleep($DELAYRUNBOT1) Then Return
If $g_bRestart = True Then ContinueLoop
EndIf
Else
$iWaitTime = Random($DELAYWAITATTACK1, $DELAYWAITATTACK2)
SetLog("Attacking Not Planned and Skipped, Waiting random " & StringFormat("%0.1f", $iWaitTime / 1000) & " Seconds", $COLOR_WARNING)
If _SleepStatus($iWaitTime) Then Return False
EndIf
Else
If $g_bQuickAttack Then
SetLog("Quick Restart... ", $COLOR_INFO)
Else
If $g_bIsSearchLimit = True Then
SetLog("Restarted due search limit", $COLOR_INFO)
Else
SetLog("Restarted after Out of Sync Error: Attack Now", $COLOR_INFO)
EndIf
EndIf
If _Sleep($DELAYRUNBOT3) Then Return
$g_aiCurrentLoot[$eLootTrophy] = Number(getTrophyMainScreen($aTrophies[0], $aTrophies[1]))
If $g_bDebugSetlog Then SetDebugLog("Runbot Trophy Count: " & $g_aiCurrentLoot[$eLootTrophy], $COLOR_DEBUG)
AttackMain()
$g_bSkipFirstZoomout = False
If $g_bOutOfGold = True Then
SetLog("Switching to Halt Attack, Stay Online/Collect mode ...", $COLOR_ERROR)
$g_bFirstStart = True
$g_bIsClientSyncError = False
ContinueLoop
EndIf
If _Sleep($DELAYRUNBOT5) Then Return
If $g_bRestart = True Then ContinueLoop
EndIf
WEnd
EndFunc
Func Idle()
$g_bIdleState = True
Local $Result = _Idle()
$g_bIdleState = False
Return $Result
EndFunc
Func _Idle()
Static $iCollectCounter = 0
Local $TimeIdle = 0
If $g_bDebugSetlog Then SetDebugLog("Func Idle ", $COLOR_DEBUG)
While $g_bIsFullArmywithHeroesAndSpells = False
CheckAndroidReboot()
NotifyPendingActions()
If _Sleep($DELAYIDLE1) Then Return
If $g_iCommandStop = -1 Then SetLog("====== Waiting for full army ======", $COLOR_SUCCESS)
Local $hTimer = __TimerInit()
Local $iReHere = 0
If $g_iActiveDonate And $g_bChkDonate Then
Local $aHeroResult = CheckArmyCamp(True, True, True, False)
While $iReHere < 7
$iReHere += 1
If $iReHere = 1 And SkipDonateNearFullTroops(True, $aHeroResult) = False And BalanceDonRec(True) Then
DonateCC(True)
ElseIf SkipDonateNearFullTroops(False, $aHeroResult) = False And BalanceDonRec(False) Then
DonateCC(True)
EndIf
If _Sleep($DELAYIDLE2) Then ExitLoop
If $g_bRestart = True Then ExitLoop
If CheckAndroidReboot() Then ContinueLoop 2
WEnd
EndIf
If _Sleep($DELAYIDLE1) Then ExitLoop
checkObstacles()
checkMainScreen(False)
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) And $g_bTrainEnabled = True Then
CheckArmyCamp(True, True)
If _Sleep($DELAYIDLE1) Then Return
If($g_bFullArmy = False Or $g_bFullArmySpells = False) Then
SetLog("Army Camp and Barracks are not full, Training Continues...", $COLOR_ACTION)
$g_iCommandStop = 0
EndIf
EndIf
ReplayShare($g_bShareAttackEnableNow)
If _Sleep($DELAYIDLE1) Then Return
If $g_bRestart = True Then ExitLoop
If $iCollectCounter > $g_iCollectAtCount Then
Local $aRndFuncList = ['Collect', 'CheckTombs', 'DonateCC', 'CleanYard']
While 1
If $g_bRunState = False Then Return
If $g_bRestart = True Then ExitLoop
If CheckAndroidReboot() Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
Local $Index = Random(0, UBound($aRndFuncList), 1)
If $Index > UBound($aRndFuncList) - 1 Then $Index = UBound($aRndFuncList) - 1
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
WEnd
If $g_bRunState = False Then Return
If $g_bRestart = True Then ExitLoop
If _Sleep($DELAYIDLE1) Or $g_bRunState = False Then ExitLoop
$iCollectCounter = 0
EndIf
$iCollectCounter = $iCollectCounter + 1
AddIdleTime()
checkMainScreen(False)
If $g_iCommandStop = -1 Then
If $g_iActualTrainSkip < $g_iMaxTrainSkip Then
If CheckNeedOpenTrain($g_sTimeBeforeTrain) Then TrainRevamp()
If $g_bRestart = True Then ExitLoop
If _Sleep($DELAYIDLE1) Then ExitLoop
checkMainScreen(False)
Else
SetLog("Humanize bot, prevent to delete and recreate troops " & $g_iActualTrainSkip + 1 & "/" & $g_iMaxTrainSkip, $color_blue)
$g_iActualTrainSkip = $g_iActualTrainSkip + 1
If $g_iActualTrainSkip >= $g_iMaxTrainSkip Then
$g_iActualTrainSkip = 0
EndIf
CheckArmyCamp(True, True)
EndIf
EndIf
If _Sleep($DELAYIDLE1) Then Return
If $g_iCommandStop = 0 And $g_bTrainEnabled = True Then
If Not($g_bFullArmy) Then
If $g_iActualTrainSkip < $g_iMaxTrainSkip Then
If CheckNeedOpenTrain($g_sTimeBeforeTrain) Then TrainRevamp()
If $g_bRestart = True Then ExitLoop
If _Sleep($DELAYIDLE1) Then ExitLoop
checkMainScreen(False)
Else
$g_iActualTrainSkip = $g_iActualTrainSkip + 1
If $g_iActualTrainSkip >= $g_iMaxTrainSkip Then
$g_iActualTrainSkip = 0
EndIf
CheckArmyCamp(True, True)
EndIf
EndIf
If $g_bFullArmy And $g_bTrainEnabled = True Then
SetLog("Army Camp and Barracks are full, stop Training...", $COLOR_ACTION)
$g_iCommandStop = 3
EndIf
EndIf
If _Sleep($DELAYIDLE1) Then Return
If $g_iCommandStop = -1 Then
DropTrophy()
If $g_bRestart = True Then ExitLoop
If _Sleep($DELAYIDLE1) Then ExitLoop
checkMainScreen(False)
EndIf
If _Sleep($DELAYIDLE1) Then Return
If $g_bRestart = True Then ExitLoop
$TimeIdle += Round(__TimerDiff($hTimer) / 1000, 2)
If $g_bCanRequestCC = True Then RequestCC()
SetLog("Time Idle: " & StringFormat("%02i", Floor(Floor($TimeIdle / 60) / 60)) & ":" & StringFormat("%02i", Floor(Mod(Floor($TimeIdle / 60), 60))) & ":" & StringFormat("%02i", Floor(Mod($TimeIdle, 60))))
If $g_bOutOfGold = True Or $g_bOutOfElixir = True Then Return
If ProfileSwitchAccountEnabled() Then checkSwitchAcc()
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) And $g_bTrainEnabled = False Then ExitLoop
If $g_iCommandStop = -1 Then
SmartWait4Train()
If $g_bRestart = True Then ExitLoop
EndIf
WEnd
EndFunc
Func AttackMain()
If ProfileSwitchAccountEnabled() And $g_abDonateOnly[$g_iCurAccount] Then Return
getArmyTroopCapacity(True, True)
ClickP($aAway, 1, 0, "#0000")
If IsSearchAttackEnabled() Then
If(IsSearchModeActive($DB) And checkCollectors(True, False)) Or IsSearchModeActive($LB) Or IsSearchModeActive($TS) Then
If ProfileSwitchAccountEnabled() And($g_aiAttackedCountSwitch[$g_iCurAccount] <= $g_aiAttackedCountAcc[$g_iCurAccount] - 2) Then checkSwitchAcc()
If $g_bUseCCBalanced = True Then
ProfileReport()
If _Sleep($DELAYATTACKMAIN1) Then Return
checkMainScreen(False)
If $g_bRestart = True Then Return
EndIf
If $g_bDropTrophyEnable And Number($g_aiCurrentLoot[$eLootTrophy]) > Number($g_iDropTrophyMax) Then
DropTrophy()
$g_bIsClientSyncError = False
If _Sleep($DELAYATTACKMAIN1) Then Return
Return
EndIf
If $g_bDebugSetlog Then
SetDebugLog(_PadStringCenter(" Hero status check" & BitAND($g_aiAttackUseHeroes[$DB], $g_aiSearchHeroWaitEnable[$DB], $g_iHeroAvailable) & "|" & $g_aiSearchHeroWaitEnable[$DB] & "|" & $g_iHeroAvailable, 54, "="), $COLOR_DEBUG)
SetDebugLog(_PadStringCenter(" Hero status check" & BitAND($g_aiAttackUseHeroes[$LB], $g_aiSearchHeroWaitEnable[$LB], $g_iHeroAvailable) & "|" & $g_aiSearchHeroWaitEnable[$LB] & "|" & $g_iHeroAvailable, 54, "="), $COLOR_DEBUG)
EndIf
_ClanGames()
ClickP($aAway, 1, 0, "#0000")
PrepareSearch()
If $g_bOutOfGold = True Then Return
If $g_bRestart = True Then Return
VillageSearch()
If $g_bOutOfGold = True Then Return
If $g_bRestart = True Then Return
PrepareAttack($g_iMatchMode)
If $g_bRestart = True Then Return
Attack()
If $g_bRestart = True Then Return
ReturnHome($g_bTakeLootSnapShot)
If _Sleep($DELAYATTACKMAIN2) Then Return
Return True
Else
SetLog("No one of search condition match:", $COLOR_WARNING)
SetLog("Waiting on troops, heroes and/or spells according to search settings", $COLOR_WARNING)
$g_bIsSearchLimit = False
$g_bIsClientSyncError = False
$g_bQuickAttack = False
If ProfileSwitchAccountEnabled() Then checkSwitchAcc()
SmartWait4Train()
EndIf
Else
SetLog("Attacking Not Planned, Skipped..", $COLOR_WARNING)
EndIf
EndFunc
Func Attack()
$g_bAttackActive = True
SetLog(" ====== Start Attack ====== ", $COLOR_SUCCESS)
If($g_iMatchMode = $DB And $g_aiAttackAlgorithm[$DB] = 1) Or($g_iMatchMode = $LB And $g_aiAttackAlgorithm[$LB] = 1) Then
If $g_bDebugSetlog Then SetDebugLog("start scripted attack", $COLOR_ERROR)
Algorithm_AttackCSV()
ElseIf $g_iMatchMode = $DB And $g_aiAttackAlgorithm[$DB] = 2 Then
If $g_bDebugSetlog Then SetDebugLog("start milking attack", $COLOR_ERROR)
Alogrithm_MilkingAttack()
Else
If $g_bDebugSetlog Then SetDebugLog("start standard attack", $COLOR_ERROR)
algorithm_AllTroops()
EndIf
$g_bAttackActive = False
EndFunc
Func QuickAttack()
getArmyTroopCapacity(True, True)
If($g_aiAttackAlgorithm[$DB] = 2 And IsSearchModeActive($DB)) Or(IsSearchModeActive($TS)) Then
VillageReport()
EndIf
$g_aiCurrentLoot[$eLootTrophy] = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If($g_bDropTrophyEnable And Number($g_aiCurrentLoot[$eLootTrophy]) > Number($g_iDropTrophyMax)) Then
If $g_bDebugSetlog Then SetDebugLog("No quickly re-attack, need to drop tropies", $COLOR_DEBUG)
Return False
EndIf
If $g_aiAttackAlgorithm[$DB] = 2 And IsSearchModeActive($DB) Then
If Int($g_CurrentCampUtilization) >= $g_iTotalCampSpace * $g_aiSearchCampsPct[$DB] / 100 And $g_abSearchCampsEnable[$DB] Then
If $g_bDebugSetlog Then SetDebugLog("Milking: Quickly re-attack " & Int($g_CurrentCampUtilization) & " >= " & $g_iTotalCampSpace & " * " & $g_aiSearchCampsPct[$DB] & "/100 " & "= " & $g_iTotalCampSpace * $g_aiSearchCampsPct[$DB] / 100, $COLOR_DEBUG)
Return True
Else
If $g_bDebugSetlog Then SetDebugLog("Milking: No Quickly re-attack:  cur. " & Int($g_CurrentCampUtilization) & "  need " & $g_iTotalCampSpace * $g_aiSearchCampsPct[$DB] / 100 & " firststart = " &($g_bQuicklyFirstStart), $COLOR_DEBUG)
Return False
EndIf
EndIf
If IsSearchModeActive($TS) Then
If Int($g_CurrentCampUtilization) >= $g_iTotalCampSpace * $g_aiSearchCampsPct[$TS] / 100 And $g_abSearchCampsEnable[$TS] Then
If $g_bDebugSetlog Then SetDebugLog("THSnipe: Quickly re-attack " & Int($g_CurrentCampUtilization) & " >= " & $g_iTotalCampSpace & " * " & $g_aiSearchCampsPct[$TS] & "/100 " & "= " & $g_iTotalCampSpace * $g_aiSearchCampsPct[$TS] / 100, $COLOR_DEBUG)
Return True
Else
If $g_bDebugSetlog Then SetDebugLog("THSnipe: No Quickly re-attack:  cur. " & Int($g_CurrentCampUtilization) & "  need " & $g_iTotalCampSpace * $g_aiSearchCampsPct[$TS] / 100 & " firststart = " &($g_bQuicklyFirstStart), $COLOR_DEBUG)
Return False
EndIf
EndIf
EndFunc
Func _RunFunction($action)
SetDebugLog("_RunFunction: " & $action & " BEGIN", $COLOR_DEBUG2)
Switch $action
Case "Collect"
Collect()
_Sleep($DELAYRUNBOT1)
Case "CheckTombs"
CheckTombs()
_Sleep($DELAYRUNBOT3)
Case "CleanYard"
CleanYard()
Case "ReArm"
ReArm()
_Sleep($DELAYRUNBOT3)
Case "ReplayShare"
ReplayShare($g_bShareAttackEnableNow)
_Sleep($DELAYRUNBOT3)
Case "NotifyReport"
NotifyReport()
_Sleep($DELAYRUNBOT3)
Case "DonateCC"
If $g_iActiveDonate And $g_bChkDonate Then
If SkipDonateNearFullTroops(True) = False And BalanceDonRec(True) Then DonateCC()
If _Sleep($DELAYRUNBOT1) = False Then checkMainScreen(False)
EndIf
Case "DonateCC,Train"
If $g_iActiveDonate And $g_bChkDonate Then
If $g_bFirstStart Then
getArmyTroopCapacity(True, False)
getArmySpellCapacity(False, True)
EndIf
If SkipDonateNearFullTroops(True) = False And BalanceDonRec(True) Then DonateCC()
EndIf
If _Sleep($DELAYRUNBOT1) = False Then checkMainScreen(False)
If $g_bTrainEnabled Then
If $g_iActualTrainSkip < $g_iMaxTrainSkip Then
TrainRevamp()
_Sleep($DELAYRUNBOT1)
Else
SetLog("Humanize bot, prevent to delete and recreate troops " & $g_iActualTrainSkip + 1 & "/" & $g_iMaxTrainSkip, $color_blue)
$g_iActualTrainSkip = $g_iActualTrainSkip + 1
If $g_iActualTrainSkip >= $g_iMaxTrainSkip Then
$g_iActualTrainSkip = 0
EndIf
CheckOverviewFullArmy(True, False)
getArmySpells()
getArmyHeroCount(False, True)
EndIf
Else
If $g_bDebugSetlogTrain Then SetLog("Halt mode - training disabled", $COLOR_DEBUG)
EndIf
Case "BoostBarracks"
BoostBarracks()
Case "BoostSpellFactory"
BoostSpellFactory()
Case "BoostKing"
BoostKing()
Case "BoostQueen"
BoostQueen()
Case "BoostWarden"
BoostWarden()
Case "LabCheck"
Setlog("Checking Lab Status", $COLOR_INFO)
LabGuiDisplay()
_Sleep($DELAYRUNBOT3)
Case "RequestCC"
RequestCC()
If _Sleep($DELAYRUNBOT1) = False Then checkMainScreen(False)
Case "Laboratory"
Laboratory()
If _Sleep($DELAYRUNBOT3) = False Then checkMainScreen(False)
Case "UpgradeHeroes"
UpgradeHeroes()
_Sleep($DELAYRUNBOT3)
Case "UpgradeBuilding"
UpgradeBuilding()
_Sleep($DELAYRUNBOT3)
AutoUpgrade()
_Sleep($DELAYRUNBOT3)
Case "BuilderBase"
If isOnBuilderBase() Or(($g_bChkCollectBuilderBase Or $g_bChkStartClockTowerBoost Or $g_iChkBBSuggestedUpgrades) And SwitchBetweenBases()) Then
CollectBuilderBase()
BuilderBaseReport()
StartClockTowerBoost()
MainSuggestedUpgradeCode()
SwitchBetweenBases()
EndIf
_Sleep($DELAYRUNBOT3)
Case "CollectFreeMagicItems"
CollectFreeMagicItems()
Case ""
SetDebugLog("Function call doesn't support empty string, please review array size", $COLOR_ERROR)
Case Else
SetLog("Unknown function call: " & $action, $COLOR_ERROR)
EndSwitch
SetDebugLog("_RunFunction: " & $action & " END", $COLOR_DEBUG2)
EndFunc
